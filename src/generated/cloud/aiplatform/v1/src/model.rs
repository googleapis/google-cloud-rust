// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::invalid_html_tags)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Annotation {
    /// Output only. Resource name of the Annotation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Google Cloud Storage URI points to a YAML file describing
    /// [payload][google.cloud.aiplatform.v1.Annotation.payload]. The schema is
    /// defined as an [OpenAPI 3.0.2 Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// The schema files that can be used here are found in
    /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
    /// chosen schema must be consistent with the parent Dataset's
    /// [metadata][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Annotation.payload]: crate::model::Annotation::payload
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payload_schema_uri: std::string::String,

    /// Required. The schema of the payload can be found in
    /// [payload_schema][google.cloud.aiplatform.v1.Annotation.payload_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Annotation.payload_schema_uri]: crate::model::Annotation::payload_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this Annotation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Annotation was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The source of the Annotation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotation_source: std::option::Option<crate::model::UserActionReference>,

    /// Optional. The labels with user-defined metadata to organize your
    /// Annotations.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Annotation(System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for each Annotation:
    ///
    /// * "aiplatform.googleapis.com/annotation_set_name":
    ///   optional, name of the UI's annotation set this Annotation belongs to.
    ///   If not set, the Annotation is not visible in the UI.
    ///
    /// * "aiplatform.googleapis.com/payload_schema":
    ///   output only, its value is the
    ///   [payload_schema's][google.cloud.aiplatform.v1.Annotation.payload_schema_uri]
    ///   title.
    ///
    ///
    /// [google.cloud.aiplatform.v1.Annotation.payload_schema_uri]: crate::model::Annotation::payload_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl Annotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Annotation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [payload_schema_uri][crate::model::Annotation::payload_schema_uri].
    pub fn set_payload_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload_schema_uri = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::Annotation::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Annotation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Annotation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Annotation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotation_source][crate::model::Annotation::annotation_source].
    pub fn set_annotation_source<
        T: std::convert::Into<std::option::Option<crate::model::UserActionReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_source = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Annotation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for Annotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Annotation"
    }
}

/// Identifies a concept with which DataItems may be annotated with.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotationSpec {
    /// Output only. Resource name of the AnnotationSpec.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the AnnotationSpec.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp when this AnnotationSpec was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when AnnotationSpec was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl AnnotationSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnnotationSpec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AnnotationSpec::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AnnotationSpec::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AnnotationSpec::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AnnotationSpec::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for AnnotationSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AnnotationSpec"
    }
}

/// The generic reusable api auth config.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiAuth {
    /// The auth config.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub auth_config: std::option::Option<crate::model::api_auth::AuthConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ApiAuth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_config][crate::model::ApiAuth::auth_config].
    ///
    /// Note that all the setters affecting `auth_config` are mutually
    /// exclusive.
    pub fn set_auth_config<
        T: std::convert::Into<std::option::Option<crate::model::api_auth::AuthConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_config = v.into();
        self
    }

    /// The value of [auth_config][crate::model::ApiAuth::auth_config]
    /// if it holds a `ApiKeyConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn api_key_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::api_auth::ApiKeyConfig>> {
        #[allow(unreachable_patterns)]
        self.auth_config.as_ref().and_then(|v| match v {
            crate::model::api_auth::AuthConfig::ApiKeyConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [auth_config][crate::model::ApiAuth::auth_config]
    /// to hold a `ApiKeyConfig`.
    ///
    /// Note that all the setters affecting `auth_config` are
    /// mutually exclusive.
    pub fn set_api_key_config<
        T: std::convert::Into<std::boxed::Box<crate::model::api_auth::ApiKeyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_config =
            std::option::Option::Some(crate::model::api_auth::AuthConfig::ApiKeyConfig(v.into()));
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ApiAuth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ApiAuth"
    }
}

/// Defines additional types related to [ApiAuth].
#[cfg(feature = "vertex_rag_data_service")]
pub mod api_auth {
    #[allow(unused_imports)]
    use super::*;

    /// The API secret.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ApiKeyConfig {
        /// Required. The SecretManager secret version resource name storing API key.
        /// e.g. projects/{project}/secrets/{secret}/versions/{version}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub api_key_secret_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl ApiKeyConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [api_key_secret_version][crate::model::api_auth::ApiKeyConfig::api_key_secret_version].
        pub fn set_api_key_secret_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.api_key_secret_version = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for ApiKeyConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ApiAuth.ApiKeyConfig"
        }
    }

    /// The auth config.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthConfig {
        /// The API secret.
        ApiKeyConfig(std::boxed::Box<crate::model::api_auth::ApiKeyConfig>),
    }
}

/// Instance of a general artifact.
#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Artifact {
    /// Output only. The resource name of the Artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name of the Artifact.
    /// May be up to 128 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The uniform resource identifier of the artifact file.
    /// May be empty if there is no actual artifact file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// An eTag used to perform consistent read-modify-write updates. If not set, a
    /// blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Artifacts.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Artifact (System
    /// labels are excluded).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Artifact was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Artifact was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The state of this Artifact. This is a property of the Artifact, and does
    /// not imply or capture any ongoing process. This property is managed by
    /// clients (such as Vertex AI Pipelines), and the system does not prescribe
    /// or check the validity of state transitions.
    pub state: crate::model::artifact::State,

    /// The title of the schema describing the metadata.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_title: std::string::String,

    /// The version of the schema in schema_name to use.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Properties of the Artifact.
    /// Top level metadata keys' heading and trailing spaces will be trimmed.
    /// The size of this field should not exceed 200KB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Description of the Artifact
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
impl Artifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Artifact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Artifact::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Artifact::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Artifact::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Artifact::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Artifact::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Artifact::state].
    pub fn set_state<T: std::convert::Into<crate::model::artifact::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schema_title][crate::model::Artifact::schema_title].
    pub fn set_schema_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_title = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::Artifact::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Artifact::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Artifact::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Artifact::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
impl wkt::message::Message for Artifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Artifact"
    }
}

/// Defines additional types related to [Artifact].
#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
pub mod artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the state of the Artifact.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state for the Artifact.
        Unspecified,
        /// A state used by systems like Vertex AI Pipelines to indicate that the
        /// underlying data item represented by this Artifact is being created.
        Pending,
        /// A state indicating that the Artifact should exist, unless something
        /// external to the system deletes it.
        Live,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Live => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Live => std::option::Option::Some("LIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Live,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "LIVE" => Self::Live,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Live => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.Artifact.State",
            ))
        }
    }
}

/// A job that uses a
/// [Model][google.cloud.aiplatform.v1.BatchPredictionJob.model] to produce
/// predictions on multiple [input
/// instances][google.cloud.aiplatform.v1.BatchPredictionJob.input_config]. If
/// predictions for significant portion of the instances fail, the job may finish
/// without attempting predictions for all remaining instances.
///
/// [google.cloud.aiplatform.v1.BatchPredictionJob.input_config]: crate::model::BatchPredictionJob::input_config
/// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchPredictionJob {
    /// Output only. Resource name of the BatchPredictionJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of this BatchPredictionJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The name of the Model resource that produces the predictions via this job,
    /// must share the same ancestor Location.
    /// Starting this job has no impact on any existing deployments of the Model
    /// and their resources.
    /// Exactly one of model and unmanaged_container_model must be set.
    ///
    /// The model resource name may contain version id or version alias to specify
    /// the version.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// if no version is specified, the default version will be deployed.
    ///
    /// The model resource could also be a publisher model.
    /// Example: `publishers/{publisher}/models/{model}`
    /// or
    /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the Model that produces the predictions via
    /// this job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    /// Contains model information necessary to perform batch prediction without
    /// requiring uploading to model registry.
    /// Exactly one of model and unmanaged_container_model must be set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub unmanaged_container_model: std::option::Option<crate::model::UnmanagedContainerModel>,

    /// Required. Input configuration of the instances on which predictions are
    /// performed. The schema of any single instance may be specified via the
    /// [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::batch_prediction_job::InputConfig>,

    /// Configuration for how to convert batch prediction input instances to the
    /// prediction instances that are sent to the Model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_config: std::option::Option<crate::model::batch_prediction_job::InstanceConfig>,

    /// The parameters that govern the predictions. The schema of the parameters
    /// may be specified via the
    /// [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [parameters_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_parameters: std::option::Option<wkt::Value>,

    /// Required. The Configuration specifying where output predictions should
    /// be written.
    /// The schema of any single prediction may be specified as a concatenation
    /// of [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// and
    /// [prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]: crate::model::PredictSchemata::prediction_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::batch_prediction_job::OutputConfig>,

    /// The config of resources used by the Model during the batch prediction. If
    /// the Model
    /// [supports][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]
    /// DEDICATED_RESOURCES this config may be provided (and the job will use these
    /// resources), if the Model doesn't support AUTOMATIC_RESOURCES, this config
    /// must be provided.
    ///
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_resources: std::option::Option<crate::model::BatchDedicatedResources>,

    /// The service account that the DeployedModel's container runs as. If not
    /// specified, a system generated one will be used, which
    /// has minimal permissions and the custom container, if used, may not have
    /// enough permission to access other Google Cloud resources.
    ///
    /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Immutable. Parameters configuring the batch behavior. Currently only
    /// applicable when
    /// [dedicated_resources][google.cloud.aiplatform.v1.BatchPredictionJob.dedicated_resources]
    /// are used (in other cases Vertex AI does the tuning itself).
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.dedicated_resources]: crate::model::BatchPredictionJob::dedicated_resources
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub manual_batch_tuning_parameters:
        std::option::Option<crate::model::ManualBatchTuningParameters>,

    /// Generate explanation with the batch prediction results.
    ///
    /// When set to `true`, the batch prediction output changes based on the
    /// `predictions_format` field of the
    /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config]
    /// object:
    ///
    /// * `bigquery`: output includes a column named `explanation`. The value
    ///   is a struct that conforms to the
    ///   [Explanation][google.cloud.aiplatform.v1.Explanation] object.
    /// * `jsonl`: The JSON objects on each line include an additional entry
    ///   keyed `explanation`. The value of the entry is a JSON object that
    ///   conforms to the [Explanation][google.cloud.aiplatform.v1.Explanation]
    ///   object.
    /// * `csv`: Generating explanations for CSV format is not supported.
    ///
    /// If this field is set to true, either the
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// or
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// must be populated.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]: crate::model::BatchPredictionJob::explanation_spec
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    /// [google.cloud.aiplatform.v1.Explanation]: crate::model::Explanation
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub generate_explanation: bool,

    /// Explanation configuration for this BatchPredictionJob. Can be
    /// specified only if
    /// [generate_explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
    /// is set to `true`.
    ///
    /// This value overrides the value of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec].
    /// All fields of
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// are optional in the request. If a field of the
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// object is not populated, the corresponding field of the
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// object is inherited.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]: crate::model::BatchPredictionJob::explanation_spec
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]: crate::model::BatchPredictionJob::generate_explanation
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

    /// Output only. Information further describing the output of this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_info: std::option::Option<crate::model::batch_prediction_job::OutputInfo>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Only populated when the job's state is JOB_STATE_FAILED or
    /// JOB_STATE_CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Partial failures encountered.
    /// For example, single files that can't be read.
    /// This field never exceeds 20 entries.
    /// Status details fields contain standard Google Cloud error details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_failures: std::vec::Vec<rpc::model::Status>,

    /// Output only. Information about resources that had been consumed by this
    /// job. Provided in real time at best effort basis, as well as a final value
    /// once the job completes.
    ///
    /// Note: This field currently may be not populated for batch predictions that
    /// use AutoML Models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resources_consumed: std::option::Option<crate::model::ResourcesConsumed>,

    /// Output only. Statistics on completed and failed prediction instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_stats: std::option::Option<crate::model::CompletionStats>,

    /// Output only. Time when the BatchPredictionJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the BatchPredictionJob for the first time entered
    /// the `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the BatchPredictionJob entered any of the following
    /// states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the BatchPredictionJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize BatchPredictionJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a BatchPredictionJob. If this
    /// is set, then all resources created by the BatchPredictionJob will be
    /// encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// For custom-trained Models and AutoML Tabular Models, the container of the
    /// DeployedModel instances will send `stderr` and `stdout` streams to
    /// Cloud Logging by default. Please note that the logs incur cost,
    /// which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging/pricing).
    ///
    /// User can disable container logging by setting this flag to true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_container_logging: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl BatchPredictionJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchPredictionJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::BatchPredictionJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model][crate::model::BatchPredictionJob::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::BatchPredictionJob::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }

    /// Sets the value of [unmanaged_container_model][crate::model::BatchPredictionJob::unmanaged_container_model].
    pub fn set_unmanaged_container_model<
        T: std::convert::Into<std::option::Option<crate::model::UnmanagedContainerModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.unmanaged_container_model = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::BatchPredictionJob::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::InputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }

    /// Sets the value of [instance_config][crate::model::BatchPredictionJob::instance_config].
    pub fn set_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::InstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config = v.into();
        self
    }

    /// Sets the value of [model_parameters][crate::model::BatchPredictionJob::model_parameters].
    pub fn set_model_parameters<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_parameters = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::BatchPredictionJob::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }

    /// Sets the value of [dedicated_resources][crate::model::BatchPredictionJob::dedicated_resources].
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::option::Option<crate::model::BatchDedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_resources = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BatchPredictionJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [manual_batch_tuning_parameters][crate::model::BatchPredictionJob::manual_batch_tuning_parameters].
    pub fn set_manual_batch_tuning_parameters<
        T: std::convert::Into<std::option::Option<crate::model::ManualBatchTuningParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.manual_batch_tuning_parameters = v.into();
        self
    }

    /// Sets the value of [generate_explanation][crate::model::BatchPredictionJob::generate_explanation].
    pub fn set_generate_explanation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.generate_explanation = v.into();
        self
    }

    /// Sets the value of [explanation_spec][crate::model::BatchPredictionJob::explanation_spec].
    pub fn set_explanation_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec = v.into();
        self
    }

    /// Sets the value of [output_info][crate::model::BatchPredictionJob::output_info].
    pub fn set_output_info<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::OutputInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_info = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BatchPredictionJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchPredictionJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [resources_consumed][crate::model::BatchPredictionJob::resources_consumed].
    pub fn set_resources_consumed<
        T: std::convert::Into<std::option::Option<crate::model::ResourcesConsumed>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resources_consumed = v.into();
        self
    }

    /// Sets the value of [completion_stats][crate::model::BatchPredictionJob::completion_stats].
    pub fn set_completion_stats<
        T: std::convert::Into<std::option::Option<crate::model::CompletionStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_stats = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BatchPredictionJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BatchPredictionJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BatchPredictionJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BatchPredictionJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::BatchPredictionJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [disable_container_logging][crate::model::BatchPredictionJob::disable_container_logging].
    pub fn set_disable_container_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_container_logging = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::BatchPredictionJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::BatchPredictionJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [partial_failures][crate::model::BatchPredictionJob::partial_failures].
    pub fn set_partial_failures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_failures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::BatchPredictionJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for BatchPredictionJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob"
    }
}

/// Defines additional types related to [BatchPredictionJob].
#[cfg(feature = "job_service")]
pub mod batch_prediction_job {
    #[allow(unused_imports)]
    use super::*;

    /// Configures the input to
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob]. See
    /// [Model.supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats]
    /// for Model's supported input formats, and how instances should be expressed
    /// via any of them.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.Model.supported_input_storage_formats]: crate::model::Model::supported_input_storage_formats
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputConfig {
        /// Required. The format in which instances are given, must be one of the
        /// [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
        /// [supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats].
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
        /// [google.cloud.aiplatform.v1.Model.supported_input_storage_formats]: crate::model::Model::supported_input_storage_formats
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub instances_format: std::string::String,

        /// Required. The source of the input.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::batch_prediction_job::input_config::Source>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl InputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instances_format][crate::model::batch_prediction_job::InputConfig::instances_format].
        pub fn set_instances_format<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instances_format = v.into();
            self
        }

        /// Sets the value of [source][crate::model::batch_prediction_job::InputConfig::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<crate::model::batch_prediction_job::input_config::Source>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// if it holds a `GcsSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::input_config::Source::GcsSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// if it holds a `BigquerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bigquery_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::input_config::Source::BigquerySource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// to hold a `GcsSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::batch_prediction_job::input_config::Source::GcsSource(v.into()),
            );
            self
        }

        /// Sets the value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// to hold a `BigquerySource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_bigquery_source<
            T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::batch_prediction_job::input_config::Source::BigquerySource(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for InputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig"
        }
    }

    /// Defines additional types related to [InputConfig].
    #[cfg(feature = "job_service")]
    pub mod input_config {
        #[allow(unused_imports)]
        use super::*;

        /// Required. The source of the input.
        #[cfg(feature = "job_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// The Cloud Storage location for the input instances.
            GcsSource(std::boxed::Box<crate::model::GcsSource>),
            /// The BigQuery location of the input table.
            /// The schema of the table should be in the format described by the given
            /// context OpenAPI Schema, if one is provided. The table may contain
            /// additional columns that are not described by the schema, and they will
            /// be ignored.
            BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        }
    }

    /// Configuration defining how to transform batch prediction input instances to
    /// the instances that the Model accepts.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceConfig {
        /// The format of the instance that the Model accepts. Vertex AI will
        /// convert compatible
        /// [batch prediction input instance
        /// formats][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.instances_format]
        /// to the specified format.
        ///
        /// Supported values are:
        ///
        /// * `object`: Each input is converted to JSON object format.
        ///
        ///   * For `bigquery`, each row is converted to an object.
        ///   * For `jsonl`, each line of the JSONL input must be an object.
        ///   * Does not apply to `csv`, `file-list`, `tf-record`, or
        ///     `tf-record-gzip`.
        /// * `array`: Each input is converted to JSON array format.
        ///
        ///   * For `bigquery`, each row is converted to an array. The order
        ///     of columns is determined by the BigQuery column order, unless
        ///     [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///     is populated.
        ///     [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///     must be populated for specifying field orders.
        ///   * For `jsonl`, if each line of the JSONL input is an object,
        ///     [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///     must be populated for specifying field orders.
        ///   * Does not apply to `csv`, `file-list`, `tf-record`, or
        ///     `tf-record-gzip`.
        ///
        /// If not specified, Vertex AI converts the batch prediction input as
        /// follows:
        ///
        /// * For `bigquery` and `csv`, the behavior is the same as `array`. The
        ///   order of columns is the same as defined in the file or table, unless
        ///   [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///   is populated.
        /// * For `jsonl`, the prediction instance format is determined by
        ///   each line of the input.
        /// * For `tf-record`/`tf-record-gzip`, each record will be converted to
        ///   an object in the format of `{"b64": <value>}`, where `<value>` is
        ///   the Base64-encoded string of the content of the record.
        /// * For `file-list`, each file in the list will be converted to an
        ///   object in the format of `{"b64": <value>}`, where `<value>` is
        ///   the Base64-encoded string of the content of the file.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.instances_format]: crate::model::batch_prediction_job::InputConfig::instances_format
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]: crate::model::batch_prediction_job::InstanceConfig::included_fields
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub instance_type: std::string::String,

        /// The name of the field that is considered as a key.
        ///
        /// The values identified by the key field is not included in the transformed
        /// instances that is sent to the Model. This is similar to
        /// specifying this name of the field in
        /// [excluded_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields].
        /// In addition, the batch prediction output will not include the instances.
        /// Instead the output will only include the value of the key field, in a
        /// field named `key` in the output:
        ///
        /// * For `jsonl` output format, the output will have a `key` field
        ///   instead of the `instance` field.
        /// * For `csv`/`bigquery` output format, the output will have have a `key`
        ///   column instead of the instance feature columns.
        ///
        /// The input must be JSONL with objects at each line, CSV, BigQuery
        /// or TfRecord.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields]: crate::model::batch_prediction_job::InstanceConfig::excluded_fields
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key_field: std::string::String,

        /// Fields that will be included in the prediction instance that is
        /// sent to the Model.
        ///
        /// If
        /// [instance_type][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.instance_type]
        /// is `array`, the order of field names in included_fields also determines
        /// the order of the values in the array.
        ///
        /// When included_fields is populated,
        /// [excluded_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields]
        /// must be empty.
        ///
        /// The input must be JSONL with objects at each line, BigQuery
        /// or TfRecord.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields]: crate::model::batch_prediction_job::InstanceConfig::excluded_fields
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.instance_type]: crate::model::batch_prediction_job::InstanceConfig::instance_type
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub included_fields: std::vec::Vec<std::string::String>,

        /// Fields that will be excluded in the prediction instance that is
        /// sent to the Model.
        ///
        /// Excluded will be attached to the batch prediction output if
        /// [key_field][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.key_field]
        /// is not specified.
        ///
        /// When excluded_fields is populated,
        /// [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        /// must be empty.
        ///
        /// The input must be JSONL with objects at each line, BigQuery
        /// or TfRecord.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]: crate::model::batch_prediction_job::InstanceConfig::included_fields
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.key_field]: crate::model::batch_prediction_job::InstanceConfig::key_field
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub excluded_fields: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl InstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_type][crate::model::batch_prediction_job::InstanceConfig::instance_type].
        pub fn set_instance_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_type = v.into();
            self
        }

        /// Sets the value of [key_field][crate::model::batch_prediction_job::InstanceConfig::key_field].
        pub fn set_key_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key_field = v.into();
            self
        }

        /// Sets the value of [included_fields][crate::model::batch_prediction_job::InstanceConfig::included_fields].
        pub fn set_included_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.included_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_fields][crate::model::batch_prediction_job::InstanceConfig::excluded_fields].
        pub fn set_excluded_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for InstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig"
        }
    }

    /// Configures the output of
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob]. See
    /// [Model.supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats]
    /// for supported output formats, and how predictions are expressed via any of
    /// them.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.Model.supported_output_storage_formats]: crate::model::Model::supported_output_storage_formats
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputConfig {
        /// Required. The format in which Vertex AI gives the predictions, must be
        /// one of the [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
        /// [supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats].
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
        /// [google.cloud.aiplatform.v1.Model.supported_output_storage_formats]: crate::model::Model::supported_output_storage_formats
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub predictions_format: std::string::String,

        /// Required. The destination of the output.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub destination:
            std::option::Option<crate::model::batch_prediction_job::output_config::Destination>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl OutputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [predictions_format][crate::model::batch_prediction_job::OutputConfig::predictions_format].
        pub fn set_predictions_format<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.predictions_format = v.into();
            self
        }

        /// Sets the value of [destination][crate::model::batch_prediction_job::OutputConfig::destination].
        ///
        /// Note that all the setters affecting `destination` are mutually
        /// exclusive.
        pub fn set_destination<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::batch_prediction_job::output_config::Destination,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination = v.into();
            self
        }

        /// The value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// if it holds a `GcsDestination`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gcs_destination(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
            #[allow(unreachable_patterns)]
            self.destination.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_config::Destination::GcsDestination(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// if it holds a `BigqueryDestination`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bigquery_destination(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
            #[allow(unreachable_patterns)]
            self.destination.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_config::Destination::BigqueryDestination(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// to hold a `GcsDestination`.
        ///
        /// Note that all the setters affecting `destination` are
        /// mutually exclusive.
        pub fn set_gcs_destination<
            T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination = std::option::Option::Some(
                crate::model::batch_prediction_job::output_config::Destination::GcsDestination(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// to hold a `BigqueryDestination`.
        ///
        /// Note that all the setters affecting `destination` are
        /// mutually exclusive.
        pub fn set_bigquery_destination<
            T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination = std::option::Option::Some(
                crate::model::batch_prediction_job::output_config::Destination::BigqueryDestination(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for OutputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig"
        }
    }

    /// Defines additional types related to [OutputConfig].
    #[cfg(feature = "job_service")]
    pub mod output_config {
        #[allow(unused_imports)]
        use super::*;

        /// Required. The destination of the output.
        #[cfg(feature = "job_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Destination {
            /// The Cloud Storage location of the directory where the output is
            /// to be written to. In the given directory a new directory is created.
            /// Its name is `prediction-<model-display-name>-<job-create-time>`,
            /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
            /// Inside of it files `predictions_0001.<extension>`,
            /// `predictions_0002.<extension>`, ..., `predictions_N.<extension>`
            /// are created where `<extension>` depends on chosen
            /// [predictions_format][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.predictions_format],
            /// and N may equal 0001 and depends on the total number of successfully
            /// predicted instances. If the Model has both
            /// [instance][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
            /// and
            /// [prediction][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]
            /// schemata defined then each such file contains predictions as per the
            /// [predictions_format][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.predictions_format].
            /// If prediction for any instance failed (partially or completely), then
            /// an additional `errors_0001.<extension>`, `errors_0002.<extension>`,...,
            /// `errors_N.<extension>` files are created (N depends on total number
            /// of failed predictions). These files contain the failed instances,
            /// as per their schema, followed by an additional `error` field which as
            /// value has [google.rpc.Status][google.rpc.Status]
            /// containing only `code` and `message` fields.
            ///
            /// [google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.predictions_format]: crate::model::batch_prediction_job::OutputConfig::predictions_format
            /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
            /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
            /// [google.rpc.Status]: rpc::model::Status
            GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
            /// The BigQuery project or dataset location where the output is to be
            /// written to. If project is provided, a new dataset is created with name
            /// `prediction_<model-display-name>_<job-create-time>`
            /// where \<model-display-name\> is made
            /// BigQuery-dataset-name compatible (for example, most special characters
            /// become underscores), and timestamp is in
            /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset
            /// two tables will be created, `predictions`, and `errors`.
            /// If the Model has both
            /// [instance][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
            /// and
            /// [prediction][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]
            /// schemata defined then the tables have columns as follows: The
            /// `predictions` table contains instances for which the prediction
            /// succeeded, it has columns as per a concatenation of the Model's
            /// instance and prediction schemata. The `errors` table contains rows for
            /// which the prediction has failed, it has instance columns, as per the
            /// instance schema, followed by a single "errors" column, which as values
            /// has [google.rpc.Status][google.rpc.Status]
            /// represented as a STRUCT, and containing only `code` and `message`.
            ///
            /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
            /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
            /// [google.rpc.Status]: rpc::model::Status
            BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
        }
    }

    /// Further describes this job's output.
    /// Supplements
    /// [output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputInfo {
        /// Output only. The name of the BigQuery table created, in
        /// `predictions_<timestamp>`
        /// format, into which the prediction output is written.
        /// Can be used by UI to generate the BigQuery output path, for example.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub bigquery_output_table: std::string::String,

        /// The output location into which prediction output is written.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub output_location:
            std::option::Option<crate::model::batch_prediction_job::output_info::OutputLocation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl OutputInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_output_table][crate::model::batch_prediction_job::OutputInfo::bigquery_output_table].
        pub fn set_bigquery_output_table<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.bigquery_output_table = v.into();
            self
        }

        /// Sets the value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location].
        ///
        /// Note that all the setters affecting `output_location` are mutually
        /// exclusive.
        pub fn set_output_location<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::batch_prediction_job::output_info::OutputLocation,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output_location = v.into();
            self
        }

        /// The value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// if it holds a `GcsOutputDirectory`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gcs_output_directory(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output_location.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_info::OutputLocation::GcsOutputDirectory(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// if it holds a `BigqueryOutputDataset`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bigquery_output_dataset(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output_location.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_info::OutputLocation::BigqueryOutputDataset(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// to hold a `GcsOutputDirectory`.
        ///
        /// Note that all the setters affecting `output_location` are
        /// mutually exclusive.
        pub fn set_gcs_output_directory<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_location = std::option::Option::Some(
                crate::model::batch_prediction_job::output_info::OutputLocation::GcsOutputDirectory(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// to hold a `BigqueryOutputDataset`.
        ///
        /// Note that all the setters affecting `output_location` are
        /// mutually exclusive.
        pub fn set_bigquery_output_dataset<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_location = std::option::Option::Some(
                crate::model::batch_prediction_job::output_info::OutputLocation::BigqueryOutputDataset(
                    v.into()
                )
            );
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for OutputInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.OutputInfo"
        }
    }

    /// Defines additional types related to [OutputInfo].
    #[cfg(feature = "job_service")]
    pub mod output_info {
        #[allow(unused_imports)]
        use super::*;

        /// The output location into which prediction output is written.
        #[cfg(feature = "job_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum OutputLocation {
            /// Output only. The full path of the Cloud Storage directory created, into
            /// which the prediction output is written.
            GcsOutputDirectory(std::string::String),
            /// Output only. The path of the BigQuery dataset created, in
            /// `bq://projectId.bqDatasetId`
            /// format, into which the prediction output is written.
            BigqueryOutputDataset(std::string::String),
        }
    }
}

/// A resource used in LLM queries for users to explicitly specify what to cache
/// and how to cache.
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CachedContent {
    /// Immutable. Identifier. The server-generated resource name of the cached
    /// content Format:
    /// projects/{project}/locations/{location}/cachedContents/{cached_content}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Immutable. The user-generated meaningful display name of the
    /// cached content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Immutable. The name of the publisher model to use for cached content.
    /// Format:
    /// projects/{project}/locations/{location}/publishers/{publisher}/models/{model}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. Input only. Immutable. Developer set system instruction.
    /// Currently, text only
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::Content>,

    /// Optional. Input only. Immutable. The content to cache
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. Input only. Immutable. A list of `Tools` the model may use to
    /// generate the next response
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tools: std::vec::Vec<crate::model::Tool>,

    /// Optional. Input only. Immutable. Tool config. This config is shared for all
    /// tools
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tool_config: std::option::Option<crate::model::ToolConfig>,

    /// Output only. Creatation time of the cache entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. When the cache entry was last updated in UTC time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Metadata on the usage of the cached content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub usage_metadata: std::option::Option<crate::model::cached_content::UsageMetadata>,

    /// Expiration time of the cached content.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<crate::model::cached_content::Expiration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl CachedContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CachedContent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CachedContent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CachedContent::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::CachedContent::system_instruction].
    pub fn set_system_instruction<
        T: std::convert::Into<std::option::Option<crate::model::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_instruction = v.into();
        self
    }

    /// Sets the value of [tool_config][crate::model::CachedContent::tool_config].
    pub fn set_tool_config<T: std::convert::Into<std::option::Option<crate::model::ToolConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tool_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CachedContent::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CachedContent::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [usage_metadata][crate::model::CachedContent::usage_metadata].
    pub fn set_usage_metadata<
        T: std::convert::Into<std::option::Option<crate::model::cached_content::UsageMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.usage_metadata = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::CachedContent::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tools][crate::model::CachedContent::tools].
    pub fn set_tools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tool>,
    {
        use std::iter::Iterator;
        self.tools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expiration][crate::model::CachedContent::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::cached_content::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::CachedContent::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::cached_content::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [expiration][crate::model::CachedContent::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::cached_content::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::CachedContent::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::cached_content::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// Sets the value of [expiration][crate::model::CachedContent::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::cached_content::Expiration::Ttl(v.into()));
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for CachedContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CachedContent"
    }
}

/// Defines additional types related to [CachedContent].
#[cfg(feature = "gen_ai_cache_service")]
pub mod cached_content {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata on the usage of the cached content.
    #[cfg(feature = "gen_ai_cache_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UsageMetadata {
        /// Total number of tokens that the cached content consumes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub total_token_count: i32,

        /// Number of text characters.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub text_count: i32,

        /// Number of images.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub image_count: i32,

        /// Duration of video in seconds.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub video_duration_seconds: i32,

        /// Duration of audio in seconds.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub audio_duration_seconds: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "gen_ai_cache_service")]
    impl UsageMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_token_count][crate::model::cached_content::UsageMetadata::total_token_count].
        pub fn set_total_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_token_count = v.into();
            self
        }

        /// Sets the value of [text_count][crate::model::cached_content::UsageMetadata::text_count].
        pub fn set_text_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.text_count = v.into();
            self
        }

        /// Sets the value of [image_count][crate::model::cached_content::UsageMetadata::image_count].
        pub fn set_image_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.image_count = v.into();
            self
        }

        /// Sets the value of [video_duration_seconds][crate::model::cached_content::UsageMetadata::video_duration_seconds].
        pub fn set_video_duration_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.video_duration_seconds = v.into();
            self
        }

        /// Sets the value of [audio_duration_seconds][crate::model::cached_content::UsageMetadata::audio_duration_seconds].
        pub fn set_audio_duration_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.audio_duration_seconds = v.into();
            self
        }
    }

    #[cfg(feature = "gen_ai_cache_service")]
    impl wkt::message::Message for UsageMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.CachedContent.UsageMetadata"
        }
    }

    /// Expiration time of the cached content.
    #[cfg(feature = "gen_ai_cache_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Expiration {
        /// Timestamp of when this resource is considered expired.
        /// This is *always* provided on output, regardless of what was sent
        /// on input.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The TTL for this resource. The expiration time is computed:
        /// now + TTL.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// Success and error statistics of processing multiple entities
/// (for example, DataItems or structured data rows) in batch.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompletionStats {
    /// Output only. The number of entities that had been processed successfully.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub successful_count: i64,

    /// Output only. The number of entities for which any error was encountered.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_count: i64,

    /// Output only. In cases when enough errors are encountered a job, pipeline,
    /// or operation may be failed as a whole. Below is the number of entities for
    /// which the processing had not been finished (either in successful or failed
    /// state). Set to -1 if the number is unknown (for example, the operation
    /// failed before the total entity number could be collected).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub incomplete_count: i64,

    /// Output only. The number of the successful forecast points that are
    /// generated by the forecasting model. This is ONLY used by the forecasting
    /// batch prediction.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub successful_forecast_point_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CompletionStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [successful_count][crate::model::CompletionStats::successful_count].
    pub fn set_successful_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.successful_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::CompletionStats::failed_count].
    pub fn set_failed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [incomplete_count][crate::model::CompletionStats::incomplete_count].
    pub fn set_incomplete_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.incomplete_count = v.into();
        self
    }

    /// Sets the value of [successful_forecast_point_count][crate::model::CompletionStats::successful_forecast_point_count].
    pub fn set_successful_forecast_point_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.successful_forecast_point_count = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CompletionStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CompletionStats"
    }
}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the `Content`
/// and a `parts` field containing multi-part data that contains the content of
/// the message turn.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Content {
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    ///
    /// Useful to set for multi-turn conversations, otherwise can be left blank
    /// or unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// Required. Ordered `Parts` that constitute a single message. Parts may have
    /// different IANA MIME types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parts: std::vec::Vec<crate::model::Part>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl Content {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::Content::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [parts][crate::model::Content::parts].
    pub fn set_parts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Part>,
    {
        use std::iter::Iterator;
        self.parts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for Content {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Content"
    }
}

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `Part` must have a fixed IANA MIME type identifying the type and subtype
/// of the media if `inline_data` or `file_data` field is filled with raw bytes.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Part {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::part::Data>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::part::Metadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl Part {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::Part::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::part::Data>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `InlineData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::Blob>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::InlineData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `FileData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::FileData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::FileData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `FunctionCall`, `None` if the field is not set or
    /// holds a different branch.
    pub fn function_call(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionCall>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::FunctionCall(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `FunctionResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn function_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionResponse>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::FunctionResponse(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `ExecutableCode`, `None` if the field is not set or
    /// holds a different branch.
    pub fn executable_code(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExecutableCode>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::ExecutableCode(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `CodeExecutionResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn code_execution_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CodeExecutionResult>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::CodeExecutionResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::Text(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `InlineData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_inline_data<T: std::convert::Into<std::boxed::Box<crate::model::Blob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::InlineData(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `FileData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_file_data<T: std::convert::Into<std::boxed::Box<crate::model::FileData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::FileData(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `FunctionCall`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_function_call<T: std::convert::Into<std::boxed::Box<crate::model::FunctionCall>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::FunctionCall(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `FunctionResponse`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_function_response<
        T: std::convert::Into<std::boxed::Box<crate::model::FunctionResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::FunctionResponse(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `ExecutableCode`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_executable_code<
        T: std::convert::Into<std::boxed::Box<crate::model::ExecutableCode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::ExecutableCode(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `CodeExecutionResult`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_code_execution_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CodeExecutionResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::part::Data::CodeExecutionResult(v.into()));
        self
    }

    /// Sets the value of [metadata][crate::model::Part::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::part::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::Part::metadata]
    /// if it holds a `VideoMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn video_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VideoMetadata>> {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::part::Metadata::VideoMetadata(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::Part::metadata]
    /// to hold a `VideoMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_video_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::VideoMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata =
            std::option::Option::Some(crate::model::part::Metadata::VideoMetadata(v.into()));
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for Part {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Part"
    }
}

/// Defines additional types related to [Part].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
pub mod part {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// Optional. Text part (can be code).
        Text(std::string::String),
        /// Optional. Inlined bytes data.
        InlineData(std::boxed::Box<crate::model::Blob>),
        /// Optional. URI based data.
        FileData(std::boxed::Box<crate::model::FileData>),
        /// Optional. A predicted [FunctionCall] returned from the model that
        /// contains a string representing the [FunctionDeclaration.name] with the
        /// parameters and their values.
        FunctionCall(std::boxed::Box<crate::model::FunctionCall>),
        /// Optional. The result output of a [FunctionCall] that contains a string
        /// representing the [FunctionDeclaration.name] and a structured JSON object
        /// containing any output from the function call. It is used as context to
        /// the model.
        FunctionResponse(std::boxed::Box<crate::model::FunctionResponse>),
        /// Optional. Code generated by the model that is meant to be executed.
        ExecutableCode(std::boxed::Box<crate::model::ExecutableCode>),
        /// Optional. Result of executing the [ExecutableCode].
        CodeExecutionResult(std::boxed::Box<crate::model::CodeExecutionResult>),
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Metadata {
        /// Optional. Video metadata. The metadata should only be specified while the
        /// video data is presented in inline_data or file_data.
        VideoMetadata(std::boxed::Box<crate::model::VideoMetadata>),
    }
}

/// Content blob.
///
/// It's preferred to send as [text][google.cloud.aiplatform.v1.Part.text]
/// directly rather than raw bytes.
///
/// [google.cloud.aiplatform.v1.Part.text]: crate::model::Part::data
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Blob {
    /// Required. The IANA standard MIME type of the source data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Required. Raw bytes.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl Blob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::Blob::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [data][crate::model::Blob::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for Blob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Blob"
    }
}

/// URI based data.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileData {
    /// Required. The IANA standard MIME type of the source data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Required. URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl FileData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::FileData::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [file_uri][crate::model::FileData::file_uri].
    pub fn set_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_uri = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for FileData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FileData"
    }
}

/// Metadata describes the input video content.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VideoMetadata {
    /// Optional. The start offset of the video.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_offset: std::option::Option<wkt::Duration>,

    /// Optional. The end offset of the video.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_offset: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl VideoMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_offset][crate::model::VideoMetadata::start_offset].
    pub fn set_start_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_offset = v.into();
        self
    }

    /// Sets the value of [end_offset][crate::model::VideoMetadata::end_offset].
    pub fn set_end_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_offset = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for VideoMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VideoMetadata"
    }
}

/// Generation config.
#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerationConfig {
    /// Optional. Controls the randomness of predictions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub temperature: std::option::Option<f32>,

    /// Optional. If specified, nucleus sampling will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub top_p: std::option::Option<f32>,

    /// Optional. If specified, top-k sampling will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub top_k: std::option::Option<f32>,

    /// Optional. Number of candidates to generate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub candidate_count: std::option::Option<i32>,

    /// Optional. The maximum number of output tokens to generate per message.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_output_tokens: std::option::Option<i32>,

    /// Optional. Stop sequences.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stop_sequences: std::vec::Vec<std::string::String>,

    /// Optional. If true, export the logprobs results in response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_logprobs: std::option::Option<bool>,

    /// Optional. Logit probabilities.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logprobs: std::option::Option<i32>,

    /// Optional. Positive penalties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub presence_penalty: std::option::Option<f32>,

    /// Optional. Frequency penalties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub frequency_penalty: std::option::Option<f32>,

    /// Optional. Seed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub seed: std::option::Option<i32>,

    /// Optional. Output response mimetype of the generated candidate text.
    /// Supported mimetype:
    ///
    /// - `text/plain`: (default) Text output.
    /// - `application/json`: JSON response in the candidates.
    ///   The model needs to be prompted to output the appropriate response type,
    ///   otherwise the behavior is undefined.
    ///   This is a preview feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub response_mime_type: std::string::String,

    /// Optional. The `Schema` object allows the definition of input and output
    /// data types. These types can be objects, but also primitives and arrays.
    /// Represents a select subset of an [OpenAPI 3.0 schema
    /// object](https://spec.openapis.org/oas/v3.0.3#schema).
    /// If set, a compatible response_mime_type must also be set.
    /// Compatible mimetypes:
    /// `application/json`: Schema for JSON response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_schema: std::option::Option<crate::model::Schema>,

    /// Optional. Routing configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routing_config: std::option::Option<crate::model::generation_config::RoutingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl GenerationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [temperature][crate::model::GenerationConfig::temperature].
    pub fn set_temperature<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.temperature = v.into();
        self
    }

    /// Sets the value of [top_p][crate::model::GenerationConfig::top_p].
    pub fn set_top_p<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.top_p = v.into();
        self
    }

    /// Sets the value of [top_k][crate::model::GenerationConfig::top_k].
    pub fn set_top_k<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.top_k = v.into();
        self
    }

    /// Sets the value of [candidate_count][crate::model::GenerationConfig::candidate_count].
    pub fn set_candidate_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.candidate_count = v.into();
        self
    }

    /// Sets the value of [max_output_tokens][crate::model::GenerationConfig::max_output_tokens].
    pub fn set_max_output_tokens<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_output_tokens = v.into();
        self
    }

    /// Sets the value of [response_logprobs][crate::model::GenerationConfig::response_logprobs].
    pub fn set_response_logprobs<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_logprobs = v.into();
        self
    }

    /// Sets the value of [logprobs][crate::model::GenerationConfig::logprobs].
    pub fn set_logprobs<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.logprobs = v.into();
        self
    }

    /// Sets the value of [presence_penalty][crate::model::GenerationConfig::presence_penalty].
    pub fn set_presence_penalty<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.presence_penalty = v.into();
        self
    }

    /// Sets the value of [frequency_penalty][crate::model::GenerationConfig::frequency_penalty].
    pub fn set_frequency_penalty<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency_penalty = v.into();
        self
    }

    /// Sets the value of [seed][crate::model::GenerationConfig::seed].
    pub fn set_seed<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.seed = v.into();
        self
    }

    /// Sets the value of [response_mime_type][crate::model::GenerationConfig::response_mime_type].
    pub fn set_response_mime_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_mime_type = v.into();
        self
    }

    /// Sets the value of [response_schema][crate::model::GenerationConfig::response_schema].
    pub fn set_response_schema<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_schema = v.into();
        self
    }

    /// Sets the value of [routing_config][crate::model::GenerationConfig::routing_config].
    pub fn set_routing_config<
        T: std::convert::Into<std::option::Option<crate::model::generation_config::RoutingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_config = v.into();
        self
    }

    /// Sets the value of [stop_sequences][crate::model::GenerationConfig::stop_sequences].
    pub fn set_stop_sequences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stop_sequences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl wkt::message::Message for GenerationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig"
    }
}

/// Defines additional types related to [GenerationConfig].
#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
pub mod generation_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration for routing the request to a specific model.
    #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RoutingConfig {
        /// Routing mode.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub routing_config:
            std::option::Option<crate::model::generation_config::routing_config::RoutingConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
    impl RoutingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config].
        ///
        /// Note that all the setters affecting `routing_config` are mutually
        /// exclusive.
        pub fn set_routing_config<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::generation_config::routing_config::RoutingConfig,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.routing_config = v.into();
            self
        }

        /// The value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// if it holds a `AutoMode`, `None` if the field is not set or
        /// holds a different branch.
        pub fn auto_mode(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::generation_config::routing_config::AutoRoutingMode>,
        > {
            #[allow(unreachable_patterns)]
            self.routing_config.as_ref().and_then(|v| match v {
                crate::model::generation_config::routing_config::RoutingConfig::AutoMode(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// if it holds a `ManualMode`, `None` if the field is not set or
        /// holds a different branch.
        pub fn manual_mode(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::generation_config::routing_config::ManualRoutingMode>,
        > {
            #[allow(unreachable_patterns)]
            self.routing_config.as_ref().and_then(|v| match v {
                crate::model::generation_config::routing_config::RoutingConfig::ManualMode(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// to hold a `AutoMode`.
        ///
        /// Note that all the setters affecting `routing_config` are
        /// mutually exclusive.
        pub fn set_auto_mode<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::generation_config::routing_config::AutoRoutingMode,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.routing_config = std::option::Option::Some(
                crate::model::generation_config::routing_config::RoutingConfig::AutoMode(v.into()),
            );
            self
        }

        /// Sets the value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// to hold a `ManualMode`.
        ///
        /// Note that all the setters affecting `routing_config` are
        /// mutually exclusive.
        pub fn set_manual_mode<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::generation_config::routing_config::ManualRoutingMode,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.routing_config = std::option::Option::Some(
                crate::model::generation_config::routing_config::RoutingConfig::ManualMode(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
    impl wkt::message::Message for RoutingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig"
        }
    }

    /// Defines additional types related to [RoutingConfig].
    #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
    pub mod routing_config {
        #[allow(unused_imports)]
        use super::*;

        /// When automated routing is specified, the routing will be determined by
        /// the pretrained routing model and customer provided model routing
        /// preference.
        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AutoRoutingMode {

            /// The model routing preference.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_routing_preference: std::option::Option<crate::model::generation_config::routing_config::auto_routing_mode::ModelRoutingPreference>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        impl AutoRoutingMode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_routing_preference][crate::model::generation_config::routing_config::AutoRoutingMode::model_routing_preference].
            pub fn set_model_routing_preference<T: std::convert::Into<std::option::Option<crate::model::generation_config::routing_config::auto_routing_mode::ModelRoutingPreference>>>(mut self, v: T) -> Self{
                self.model_routing_preference = v.into();
                self
            }
        }

        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        impl wkt::message::Message for AutoRoutingMode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.AutoRoutingMode"
            }
        }

        /// Defines additional types related to [AutoRoutingMode].
        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        pub mod auto_routing_mode {
            #[allow(unused_imports)]
            use super::*;

            /// The model routing preference.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ModelRoutingPreference {
                /// Unspecified model routing preference.
                Unknown,
                /// Prefer higher quality over low cost.
                PrioritizeQuality,
                /// Balanced model routing preference.
                Balanced,
                /// Prefer lower cost over higher quality.
                PrioritizeCost,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ModelRoutingPreference::value] or
                /// [ModelRoutingPreference::name].
                UnknownValue(model_routing_preference::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            pub mod model_routing_preference {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl ModelRoutingPreference {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unknown => std::option::Option::Some(0),
                        Self::PrioritizeQuality => std::option::Option::Some(1),
                        Self::Balanced => std::option::Option::Some(2),
                        Self::PrioritizeCost => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unknown => std::option::Option::Some("UNKNOWN"),
                        Self::PrioritizeQuality => std::option::Option::Some("PRIORITIZE_QUALITY"),
                        Self::Balanced => std::option::Option::Some("BALANCED"),
                        Self::PrioritizeCost => std::option::Option::Some("PRIORITIZE_COST"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl std::default::Default for ModelRoutingPreference {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl std::fmt::Display for ModelRoutingPreference {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl std::convert::From<i32> for ModelRoutingPreference {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unknown,
                        1 => Self::PrioritizeQuality,
                        2 => Self::Balanced,
                        3 => Self::PrioritizeCost,
                        _ => Self::UnknownValue(model_routing_preference::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl std::convert::From<&str> for ModelRoutingPreference {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "UNKNOWN" => Self::Unknown,
                        "PRIORITIZE_QUALITY" => Self::PrioritizeQuality,
                        "BALANCED" => Self::Balanced,
                        "PRIORITIZE_COST" => Self::PrioritizeCost,
                        _ => Self::UnknownValue(model_routing_preference::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl serde::ser::Serialize for ModelRoutingPreference {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unknown => serializer.serialize_i32(0),
                        Self::PrioritizeQuality => serializer.serialize_i32(1),
                        Self::Balanced => serializer.serialize_i32(2),
                        Self::PrioritizeCost => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
            impl<'de> serde::de::Deserialize<'de> for ModelRoutingPreference {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelRoutingPreference>::new(
                        ".google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.AutoRoutingMode.ModelRoutingPreference"))
                }
            }
        }

        /// When manual routing is set, the specified model will be used directly.
        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ManualRoutingMode {
            /// The model name to use. Only the public LLM models are accepted. e.g.
            /// 'gemini-1.5-pro-001'.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_name: std::option::Option<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        impl ManualRoutingMode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_name][crate::model::generation_config::routing_config::ManualRoutingMode::model_name].
            pub fn set_model_name<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.model_name = v.into();
                self
            }
        }

        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        impl wkt::message::Message for ManualRoutingMode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.ManualRoutingMode"
            }
        }

        /// Routing mode.
        #[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum RoutingConfig {
            /// Automated routing.
            AutoMode(
                std::boxed::Box<crate::model::generation_config::routing_config::AutoRoutingMode>,
            ),
            /// Manual routing.
            ManualMode(
                std::boxed::Box<crate::model::generation_config::routing_config::ManualRoutingMode>,
            ),
        }
    }
}

/// Safety settings.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetySetting {
    /// Required. Harm category.
    pub category: crate::model::HarmCategory,

    /// Required. The harm block threshold.
    pub threshold: crate::model::safety_setting::HarmBlockThreshold,

    /// Optional. Specify if the threshold is used for probability or severity
    /// score. If not specified, the threshold is used for probability score.
    pub method: crate::model::safety_setting::HarmBlockMethod,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl SafetySetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::SafetySetting::category].
    pub fn set_category<T: std::convert::Into<crate::model::HarmCategory>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [threshold][crate::model::SafetySetting::threshold].
    pub fn set_threshold<
        T: std::convert::Into<crate::model::safety_setting::HarmBlockThreshold>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threshold = v.into();
        self
    }

    /// Sets the value of [method][crate::model::SafetySetting::method].
    pub fn set_method<T: std::convert::Into<crate::model::safety_setting::HarmBlockMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for SafetySetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetySetting"
    }
}

/// Defines additional types related to [SafetySetting].
#[cfg(feature = "prediction_service")]
pub mod safety_setting {
    #[allow(unused_imports)]
    use super::*;

    /// Probability based thresholds levels for blocking.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HarmBlockThreshold {
        /// Unspecified harm block threshold.
        Unspecified,
        /// Block low threshold and above (i.e. block more).
        BlockLowAndAbove,
        /// Block medium threshold and above.
        BlockMediumAndAbove,
        /// Block only high threshold (i.e. block less).
        BlockOnlyHigh,
        /// Block none.
        BlockNone,
        /// Turn off the safety filter.
        Off,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HarmBlockThreshold::value] or
        /// [HarmBlockThreshold::name].
        UnknownValue(harm_block_threshold::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod harm_block_threshold {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl HarmBlockThreshold {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BlockLowAndAbove => std::option::Option::Some(1),
                Self::BlockMediumAndAbove => std::option::Option::Some(2),
                Self::BlockOnlyHigh => std::option::Option::Some(3),
                Self::BlockNone => std::option::Option::Some(4),
                Self::Off => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HARM_BLOCK_THRESHOLD_UNSPECIFIED"),
                Self::BlockLowAndAbove => std::option::Option::Some("BLOCK_LOW_AND_ABOVE"),
                Self::BlockMediumAndAbove => std::option::Option::Some("BLOCK_MEDIUM_AND_ABOVE"),
                Self::BlockOnlyHigh => std::option::Option::Some("BLOCK_ONLY_HIGH"),
                Self::BlockNone => std::option::Option::Some("BLOCK_NONE"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for HarmBlockThreshold {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for HarmBlockThreshold {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for HarmBlockThreshold {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BlockLowAndAbove,
                2 => Self::BlockMediumAndAbove,
                3 => Self::BlockOnlyHigh,
                4 => Self::BlockNone,
                5 => Self::Off,
                _ => Self::UnknownValue(harm_block_threshold::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for HarmBlockThreshold {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED" => Self::Unspecified,
                "BLOCK_LOW_AND_ABOVE" => Self::BlockLowAndAbove,
                "BLOCK_MEDIUM_AND_ABOVE" => Self::BlockMediumAndAbove,
                "BLOCK_ONLY_HIGH" => Self::BlockOnlyHigh,
                "BLOCK_NONE" => Self::BlockNone,
                "OFF" => Self::Off,
                _ => Self::UnknownValue(harm_block_threshold::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for HarmBlockThreshold {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BlockLowAndAbove => serializer.serialize_i32(1),
                Self::BlockMediumAndAbove => serializer.serialize_i32(2),
                Self::BlockOnlyHigh => serializer.serialize_i32(3),
                Self::BlockNone => serializer.serialize_i32(4),
                Self::Off => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for HarmBlockThreshold {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmBlockThreshold>::new(
                ".google.cloud.aiplatform.v1.SafetySetting.HarmBlockThreshold",
            ))
        }
    }

    /// Probability vs severity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HarmBlockMethod {
        /// The harm block method is unspecified.
        Unspecified,
        /// The harm block method uses both probability and severity scores.
        Severity,
        /// The harm block method uses the probability score.
        Probability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HarmBlockMethod::value] or
        /// [HarmBlockMethod::name].
        UnknownValue(harm_block_method::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod harm_block_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl HarmBlockMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Severity => std::option::Option::Some(1),
                Self::Probability => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HARM_BLOCK_METHOD_UNSPECIFIED"),
                Self::Severity => std::option::Option::Some("SEVERITY"),
                Self::Probability => std::option::Option::Some("PROBABILITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for HarmBlockMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for HarmBlockMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for HarmBlockMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Severity,
                2 => Self::Probability,
                _ => Self::UnknownValue(harm_block_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for HarmBlockMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HARM_BLOCK_METHOD_UNSPECIFIED" => Self::Unspecified,
                "SEVERITY" => Self::Severity,
                "PROBABILITY" => Self::Probability,
                _ => Self::UnknownValue(harm_block_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for HarmBlockMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Severity => serializer.serialize_i32(1),
                Self::Probability => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for HarmBlockMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmBlockMethod>::new(
                ".google.cloud.aiplatform.v1.SafetySetting.HarmBlockMethod",
            ))
        }
    }
}

/// Safety rating corresponding to the generated content.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyRating {
    /// Output only. Harm category.
    pub category: crate::model::HarmCategory,

    /// Output only. Harm probability levels in the content.
    pub probability: crate::model::safety_rating::HarmProbability,

    /// Output only. Harm probability score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub probability_score: f32,

    /// Output only. Harm severity levels in the content.
    pub severity: crate::model::safety_rating::HarmSeverity,

    /// Output only. Harm severity score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub severity_score: f32,

    /// Output only. Indicates whether the content was filtered out because of this
    /// rating.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub blocked: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl SafetyRating {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::SafetyRating::category].
    pub fn set_category<T: std::convert::Into<crate::model::HarmCategory>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [probability][crate::model::SafetyRating::probability].
    pub fn set_probability<T: std::convert::Into<crate::model::safety_rating::HarmProbability>>(
        mut self,
        v: T,
    ) -> Self {
        self.probability = v.into();
        self
    }

    /// Sets the value of [probability_score][crate::model::SafetyRating::probability_score].
    pub fn set_probability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability_score = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::SafetyRating::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::safety_rating::HarmSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [severity_score][crate::model::SafetyRating::severity_score].
    pub fn set_severity_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity_score = v.into();
        self
    }

    /// Sets the value of [blocked][crate::model::SafetyRating::blocked].
    pub fn set_blocked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.blocked = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for SafetyRating {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyRating"
    }
}

/// Defines additional types related to [SafetyRating].
#[cfg(feature = "prediction_service")]
pub mod safety_rating {
    #[allow(unused_imports)]
    use super::*;

    /// Harm probability levels in the content.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HarmProbability {
        /// Harm probability unspecified.
        Unspecified,
        /// Negligible level of harm.
        Negligible,
        /// Low level of harm.
        Low,
        /// Medium level of harm.
        Medium,
        /// High level of harm.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HarmProbability::value] or
        /// [HarmProbability::name].
        UnknownValue(harm_probability::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod harm_probability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl HarmProbability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Negligible => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::High => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HARM_PROBABILITY_UNSPECIFIED"),
                Self::Negligible => std::option::Option::Some("NEGLIGIBLE"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for HarmProbability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for HarmProbability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for HarmProbability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Negligible,
                2 => Self::Low,
                3 => Self::Medium,
                4 => Self::High,
                _ => Self::UnknownValue(harm_probability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for HarmProbability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HARM_PROBABILITY_UNSPECIFIED" => Self::Unspecified,
                "NEGLIGIBLE" => Self::Negligible,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                _ => Self::UnknownValue(harm_probability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for HarmProbability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Negligible => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::High => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for HarmProbability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmProbability>::new(
                ".google.cloud.aiplatform.v1.SafetyRating.HarmProbability",
            ))
        }
    }

    /// Harm severity levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HarmSeverity {
        /// Harm severity unspecified.
        Unspecified,
        /// Negligible level of harm severity.
        Negligible,
        /// Low level of harm severity.
        Low,
        /// Medium level of harm severity.
        Medium,
        /// High level of harm severity.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HarmSeverity::value] or
        /// [HarmSeverity::name].
        UnknownValue(harm_severity::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod harm_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl HarmSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Negligible => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::High => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HARM_SEVERITY_UNSPECIFIED"),
                Self::Negligible => std::option::Option::Some("HARM_SEVERITY_NEGLIGIBLE"),
                Self::Low => std::option::Option::Some("HARM_SEVERITY_LOW"),
                Self::Medium => std::option::Option::Some("HARM_SEVERITY_MEDIUM"),
                Self::High => std::option::Option::Some("HARM_SEVERITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for HarmSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for HarmSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for HarmSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Negligible,
                2 => Self::Low,
                3 => Self::Medium,
                4 => Self::High,
                _ => Self::UnknownValue(harm_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for HarmSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HARM_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "HARM_SEVERITY_NEGLIGIBLE" => Self::Negligible,
                "HARM_SEVERITY_LOW" => Self::Low,
                "HARM_SEVERITY_MEDIUM" => Self::Medium,
                "HARM_SEVERITY_HIGH" => Self::High,
                _ => Self::UnknownValue(harm_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for HarmSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Negligible => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::High => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for HarmSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmSeverity>::new(
                ".google.cloud.aiplatform.v1.SafetyRating.HarmSeverity",
            ))
        }
    }
}

/// A collection of source attributions for a piece of content.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CitationMetadata {
    /// Output only. List of citations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub citations: std::vec::Vec<crate::model::Citation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl CitationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [citations][crate::model::CitationMetadata::citations].
    pub fn set_citations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Citation>,
    {
        use std::iter::Iterator;
        self.citations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for CitationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CitationMetadata"
    }
}

/// Source attributions for content.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Citation {
    /// Output only. Start index into the content.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub start_index: i32,

    /// Output only. End index into the content.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub end_index: i32,

    /// Output only. Url reference of the attribution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Output only. Title of the attribution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Output only. License of the attribution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub license: std::string::String,

    /// Output only. Publication date of the attribution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub publication_date: std::option::Option<gtype::model::Date>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl Citation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_index][crate::model::Citation::start_index].
    pub fn set_start_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.start_index = v.into();
        self
    }

    /// Sets the value of [end_index][crate::model::Citation::end_index].
    pub fn set_end_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.end_index = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Citation::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Citation::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [license][crate::model::Citation::license].
    pub fn set_license<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.license = v.into();
        self
    }

    /// Sets the value of [publication_date][crate::model::Citation::publication_date].
    pub fn set_publication_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.publication_date = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for Citation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Citation"
    }
}

/// A response candidate generated from the model.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Candidate {
    /// Output only. Index of the candidate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub index: i32,

    /// Output only. Content parts of the candidate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::Content>,

    /// Output only. Confidence score of the candidate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub score: f64,

    /// Output only. Average log probability score of the candidate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub avg_logprobs: f64,

    /// Output only. Log-likelihood scores for the response tokens and top tokens
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logprobs_result: std::option::Option<crate::model::LogprobsResult>,

    /// Output only. The reason why the model stopped generating tokens.
    /// If empty, the model has not stopped generating the tokens.
    pub finish_reason: crate::model::candidate::FinishReason,

    /// Output only. List of ratings for the safety of a response candidate.
    ///
    /// There is at most one rating per category.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub safety_ratings: std::vec::Vec<crate::model::SafetyRating>,

    /// Output only. Describes the reason the mode stopped generating tokens in
    /// more detail. This is only filled when `finish_reason` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_message: std::option::Option<std::string::String>,

    /// Output only. Source attribution of the generated content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub citation_metadata: std::option::Option<crate::model::CitationMetadata>,

    /// Output only. Metadata specifies sources used to ground generated content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub grounding_metadata: std::option::Option<crate::model::GroundingMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl Candidate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::Candidate::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Candidate::content].
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Candidate::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [avg_logprobs][crate::model::Candidate::avg_logprobs].
    pub fn set_avg_logprobs<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.avg_logprobs = v.into();
        self
    }

    /// Sets the value of [logprobs_result][crate::model::Candidate::logprobs_result].
    pub fn set_logprobs_result<
        T: std::convert::Into<std::option::Option<crate::model::LogprobsResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logprobs_result = v.into();
        self
    }

    /// Sets the value of [finish_reason][crate::model::Candidate::finish_reason].
    pub fn set_finish_reason<T: std::convert::Into<crate::model::candidate::FinishReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_reason = v.into();
        self
    }

    /// Sets the value of [finish_message][crate::model::Candidate::finish_message].
    pub fn set_finish_message<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_message = v.into();
        self
    }

    /// Sets the value of [citation_metadata][crate::model::Candidate::citation_metadata].
    pub fn set_citation_metadata<
        T: std::convert::Into<std::option::Option<crate::model::CitationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.citation_metadata = v.into();
        self
    }

    /// Sets the value of [grounding_metadata][crate::model::Candidate::grounding_metadata].
    pub fn set_grounding_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GroundingMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.grounding_metadata = v.into();
        self
    }

    /// Sets the value of [safety_ratings][crate::model::Candidate::safety_ratings].
    pub fn set_safety_ratings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SafetyRating>,
    {
        use std::iter::Iterator;
        self.safety_ratings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for Candidate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Candidate"
    }
}

/// Defines additional types related to [Candidate].
#[cfg(feature = "prediction_service")]
pub mod candidate {
    #[allow(unused_imports)]
    use super::*;

    /// The reason why the model stopped generating tokens.
    /// If empty, the model has not stopped generating the tokens.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FinishReason {
        /// The finish reason is unspecified.
        Unspecified,
        /// Token generation reached a natural stopping point or a configured stop
        /// sequence.
        Stop,
        /// Token generation reached the configured maximum output tokens.
        MaxTokens,
        /// Token generation stopped because the content potentially contains safety
        /// violations. NOTE: When streaming,
        /// [content][google.cloud.aiplatform.v1.Candidate.content] is empty if
        /// content filters blocks the output.
        ///
        /// [google.cloud.aiplatform.v1.Candidate.content]: crate::model::Candidate::content
        Safety,
        /// Token generation stopped because the content potentially contains
        /// copyright violations.
        Recitation,
        /// All other reasons that stopped the token generation.
        Other,
        /// Token generation stopped because the content contains forbidden terms.
        Blocklist,
        /// Token generation stopped for potentially containing prohibited content.
        ProhibitedContent,
        /// Token generation stopped because the content potentially contains
        /// Sensitive Personally Identifiable Information (SPII).
        Spii,
        /// The function call generated by the model is invalid.
        MalformedFunctionCall,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FinishReason::value] or
        /// [FinishReason::name].
        UnknownValue(finish_reason::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod finish_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl FinishReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Stop => std::option::Option::Some(1),
                Self::MaxTokens => std::option::Option::Some(2),
                Self::Safety => std::option::Option::Some(3),
                Self::Recitation => std::option::Option::Some(4),
                Self::Other => std::option::Option::Some(5),
                Self::Blocklist => std::option::Option::Some(6),
                Self::ProhibitedContent => std::option::Option::Some(7),
                Self::Spii => std::option::Option::Some(8),
                Self::MalformedFunctionCall => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FINISH_REASON_UNSPECIFIED"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::MaxTokens => std::option::Option::Some("MAX_TOKENS"),
                Self::Safety => std::option::Option::Some("SAFETY"),
                Self::Recitation => std::option::Option::Some("RECITATION"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::Blocklist => std::option::Option::Some("BLOCKLIST"),
                Self::ProhibitedContent => std::option::Option::Some("PROHIBITED_CONTENT"),
                Self::Spii => std::option::Option::Some("SPII"),
                Self::MalformedFunctionCall => std::option::Option::Some("MALFORMED_FUNCTION_CALL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for FinishReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for FinishReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for FinishReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Stop,
                2 => Self::MaxTokens,
                3 => Self::Safety,
                4 => Self::Recitation,
                5 => Self::Other,
                6 => Self::Blocklist,
                7 => Self::ProhibitedContent,
                8 => Self::Spii,
                9 => Self::MalformedFunctionCall,
                _ => Self::UnknownValue(finish_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for FinishReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FINISH_REASON_UNSPECIFIED" => Self::Unspecified,
                "STOP" => Self::Stop,
                "MAX_TOKENS" => Self::MaxTokens,
                "SAFETY" => Self::Safety,
                "RECITATION" => Self::Recitation,
                "OTHER" => Self::Other,
                "BLOCKLIST" => Self::Blocklist,
                "PROHIBITED_CONTENT" => Self::ProhibitedContent,
                "SPII" => Self::Spii,
                "MALFORMED_FUNCTION_CALL" => Self::MalformedFunctionCall,
                _ => Self::UnknownValue(finish_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for FinishReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Stop => serializer.serialize_i32(1),
                Self::MaxTokens => serializer.serialize_i32(2),
                Self::Safety => serializer.serialize_i32(3),
                Self::Recitation => serializer.serialize_i32(4),
                Self::Other => serializer.serialize_i32(5),
                Self::Blocklist => serializer.serialize_i32(6),
                Self::ProhibitedContent => serializer.serialize_i32(7),
                Self::Spii => serializer.serialize_i32(8),
                Self::MalformedFunctionCall => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for FinishReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FinishReason>::new(
                ".google.cloud.aiplatform.v1.Candidate.FinishReason",
            ))
        }
    }
}

/// Logprobs Result
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogprobsResult {
    /// Length = total number of decoding steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub top_candidates: std::vec::Vec<crate::model::logprobs_result::TopCandidates>,

    /// Length = total number of decoding steps.
    /// The chosen candidates may or may not be in top_candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub chosen_candidates: std::vec::Vec<crate::model::logprobs_result::Candidate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl LogprobsResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top_candidates][crate::model::LogprobsResult::top_candidates].
    pub fn set_top_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logprobs_result::TopCandidates>,
    {
        use std::iter::Iterator;
        self.top_candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [chosen_candidates][crate::model::LogprobsResult::chosen_candidates].
    pub fn set_chosen_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logprobs_result::Candidate>,
    {
        use std::iter::Iterator;
        self.chosen_candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for LogprobsResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult"
    }
}

/// Defines additional types related to [LogprobsResult].
#[cfg(feature = "prediction_service")]
pub mod logprobs_result {
    #[allow(unused_imports)]
    use super::*;

    /// Candidate for the logprobs token and score.
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Candidate {
        /// The candidates token string value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub token: std::option::Option<std::string::String>,

        /// The candidates token id value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub token_id: std::option::Option<i32>,

        /// The candidate's log probability.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub log_probability: std::option::Option<f32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl Candidate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [token][crate::model::logprobs_result::Candidate::token].
        pub fn set_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.token = v.into();
            self
        }

        /// Sets the value of [token_id][crate::model::logprobs_result::Candidate::token_id].
        pub fn set_token_id<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.token_id = v.into();
            self
        }

        /// Sets the value of [log_probability][crate::model::logprobs_result::Candidate::log_probability].
        pub fn set_log_probability<T: std::convert::Into<std::option::Option<f32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.log_probability = v.into();
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for Candidate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult.Candidate"
        }
    }

    /// Candidates with top log probabilities at each decoding step.
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TopCandidates {
        /// Sorted by log probability in descending order.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub candidates: std::vec::Vec<crate::model::logprobs_result::Candidate>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl TopCandidates {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [candidates][crate::model::logprobs_result::TopCandidates::candidates].
        pub fn set_candidates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::logprobs_result::Candidate>,
        {
            use std::iter::Iterator;
            self.candidates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for TopCandidates {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult.TopCandidates"
        }
    }
}

/// Segment of the content.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Segment {
    /// Output only. The index of a Part object within its parent Content object.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub part_index: i32,

    /// Output only. Start index in the given Part, measured in bytes. Offset from
    /// the start of the Part, inclusive, starting at zero.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub start_index: i32,

    /// Output only. End index in the given Part, measured in bytes. Offset from
    /// the start of the Part, exclusive, starting at zero.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub end_index: i32,

    /// Output only. The text corresponding to the segment from the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl Segment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [part_index][crate::model::Segment::part_index].
    pub fn set_part_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.part_index = v.into();
        self
    }

    /// Sets the value of [start_index][crate::model::Segment::start_index].
    pub fn set_start_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.start_index = v.into();
        self
    }

    /// Sets the value of [end_index][crate::model::Segment::end_index].
    pub fn set_end_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.end_index = v.into();
        self
    }

    /// Sets the value of [text][crate::model::Segment::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for Segment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Segment"
    }
}

/// Grounding chunk.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingChunk {
    /// Chunk type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub chunk_type: std::option::Option<crate::model::grounding_chunk::ChunkType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl GroundingChunk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [chunk_type][crate::model::GroundingChunk::chunk_type].
    ///
    /// Note that all the setters affecting `chunk_type` are mutually
    /// exclusive.
    pub fn set_chunk_type<
        T: std::convert::Into<std::option::Option<crate::model::grounding_chunk::ChunkType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunk_type = v.into();
        self
    }

    /// The value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// if it holds a `Web`, `None` if the field is not set or
    /// holds a different branch.
    pub fn web(&self) -> std::option::Option<&std::boxed::Box<crate::model::grounding_chunk::Web>> {
        #[allow(unreachable_patterns)]
        self.chunk_type.as_ref().and_then(|v| match v {
            crate::model::grounding_chunk::ChunkType::Web(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// if it holds a `RetrievedContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retrieved_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::grounding_chunk::RetrievedContext>>
    {
        #[allow(unreachable_patterns)]
        self.chunk_type.as_ref().and_then(|v| match v {
            crate::model::grounding_chunk::ChunkType::RetrievedContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// to hold a `Web`.
    ///
    /// Note that all the setters affecting `chunk_type` are
    /// mutually exclusive.
    pub fn set_web<T: std::convert::Into<std::boxed::Box<crate::model::grounding_chunk::Web>>>(
        mut self,
        v: T,
    ) -> Self {
        self.chunk_type =
            std::option::Option::Some(crate::model::grounding_chunk::ChunkType::Web(v.into()));
        self
    }

    /// Sets the value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// to hold a `RetrievedContext`.
    ///
    /// Note that all the setters affecting `chunk_type` are
    /// mutually exclusive.
    pub fn set_retrieved_context<
        T: std::convert::Into<std::boxed::Box<crate::model::grounding_chunk::RetrievedContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunk_type = std::option::Option::Some(
            crate::model::grounding_chunk::ChunkType::RetrievedContext(v.into()),
        );
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for GroundingChunk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk"
    }
}

/// Defines additional types related to [GroundingChunk].
#[cfg(feature = "prediction_service")]
pub mod grounding_chunk {
    #[allow(unused_imports)]
    use super::*;

    /// Chunk from the web.
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Web {
        /// URI reference of the chunk.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub uri: std::option::Option<std::string::String>,

        /// Title of the chunk.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub title: std::option::Option<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl Web {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::grounding_chunk::Web::uri].
        pub fn set_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [title][crate::model::grounding_chunk::Web::title].
        pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.title = v.into();
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for Web {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.Web"
        }
    }

    /// Chunk from context retrieved by the retrieval tools.
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RetrievedContext {
        /// URI reference of the attribution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub uri: std::option::Option<std::string::String>,

        /// Title of the attribution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub title: std::option::Option<std::string::String>,

        /// Text of the attribution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub text: std::option::Option<std::string::String>,

        /// Tool-specific details about the retrieved context.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub context_details:
            std::option::Option<crate::model::grounding_chunk::retrieved_context::ContextDetails>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl RetrievedContext {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::grounding_chunk::RetrievedContext::uri].
        pub fn set_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [title][crate::model::grounding_chunk::RetrievedContext::title].
        pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [text][crate::model::grounding_chunk::RetrievedContext::text].
        pub fn set_text<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [context_details][crate::model::grounding_chunk::RetrievedContext::context_details].
        ///
        /// Note that all the setters affecting `context_details` are mutually
        /// exclusive.
        pub fn set_context_details<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::grounding_chunk::retrieved_context::ContextDetails,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.context_details = v.into();
            self
        }

        /// The value of [context_details][crate::model::grounding_chunk::RetrievedContext::context_details]
        /// if it holds a `RagChunk`, `None` if the field is not set or
        /// holds a different branch.
        pub fn rag_chunk(&self) -> std::option::Option<&std::boxed::Box<crate::model::RagChunk>> {
            #[allow(unreachable_patterns)]
            self.context_details.as_ref().and_then(|v| match v {
                crate::model::grounding_chunk::retrieved_context::ContextDetails::RagChunk(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [context_details][crate::model::grounding_chunk::RetrievedContext::context_details]
        /// to hold a `RagChunk`.
        ///
        /// Note that all the setters affecting `context_details` are
        /// mutually exclusive.
        pub fn set_rag_chunk<T: std::convert::Into<std::boxed::Box<crate::model::RagChunk>>>(
            mut self,
            v: T,
        ) -> Self {
            self.context_details = std::option::Option::Some(
                crate::model::grounding_chunk::retrieved_context::ContextDetails::RagChunk(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for RetrievedContext {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.RetrievedContext"
        }
    }

    /// Defines additional types related to [RetrievedContext].
    #[cfg(feature = "prediction_service")]
    pub mod retrieved_context {
        #[allow(unused_imports)]
        use super::*;

        /// Tool-specific details about the retrieved context.
        #[cfg(feature = "prediction_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ContextDetails {
            /// Additional context for the RAG retrieval result. This is only populated
            /// when using the RAG retrieval tool.
            RagChunk(std::boxed::Box<crate::model::RagChunk>),
        }
    }

    /// Chunk type.
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ChunkType {
        /// Grounding chunk from the web.
        Web(std::boxed::Box<crate::model::grounding_chunk::Web>),
        /// Grounding chunk from context retrieved by the retrieval tools.
        RetrievedContext(std::boxed::Box<crate::model::grounding_chunk::RetrievedContext>),
    }
}

/// Grounding support.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingSupport {
    /// Segment of the content this support belongs to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub segment: std::option::Option<crate::model::Segment>,

    /// A list of indices (into 'grounding_chunk') specifying the
    /// citations associated with the claim. For instance [1,3,4] means
    /// that grounding_chunk[1], grounding_chunk[3],
    /// grounding_chunk[4] are the retrieved content attributed to the claim.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_chunk_indices: std::vec::Vec<i32>,

    /// Confidence score of the support references. Ranges from 0 to 1. 1 is the
    /// most confident. This list must have the same size as the
    /// grounding_chunk_indices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub confidence_scores: std::vec::Vec<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl GroundingSupport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [segment][crate::model::GroundingSupport::segment].
    pub fn set_segment<T: std::convert::Into<std::option::Option<crate::model::Segment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.segment = v.into();
        self
    }

    /// Sets the value of [grounding_chunk_indices][crate::model::GroundingSupport::grounding_chunk_indices].
    pub fn set_grounding_chunk_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.grounding_chunk_indices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [confidence_scores][crate::model::GroundingSupport::confidence_scores].
    pub fn set_confidence_scores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.confidence_scores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for GroundingSupport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingSupport"
    }
}

/// Metadata returned to client when grounding is enabled.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingMetadata {
    /// Optional. Web search queries for the following-up web search.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub web_search_queries: std::vec::Vec<std::string::String>,

    /// Optional. Google search entry for the following-up web searches.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_entry_point: std::option::Option<crate::model::SearchEntryPoint>,

    /// List of supporting references retrieved from specified grounding source.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_chunks: std::vec::Vec<crate::model::GroundingChunk>,

    /// Optional. List of grounding support.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_supports: std::vec::Vec<crate::model::GroundingSupport>,

    /// Optional. Output only. Retrieval metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retrieval_metadata: std::option::Option<crate::model::RetrievalMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl GroundingMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_entry_point][crate::model::GroundingMetadata::search_entry_point].
    pub fn set_search_entry_point<
        T: std::convert::Into<std::option::Option<crate::model::SearchEntryPoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.search_entry_point = v.into();
        self
    }

    /// Sets the value of [retrieval_metadata][crate::model::GroundingMetadata::retrieval_metadata].
    pub fn set_retrieval_metadata<
        T: std::convert::Into<std::option::Option<crate::model::RetrievalMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retrieval_metadata = v.into();
        self
    }

    /// Sets the value of [web_search_queries][crate::model::GroundingMetadata::web_search_queries].
    pub fn set_web_search_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.web_search_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_chunks][crate::model::GroundingMetadata::grounding_chunks].
    pub fn set_grounding_chunks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroundingChunk>,
    {
        use std::iter::Iterator;
        self.grounding_chunks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_supports][crate::model::GroundingMetadata::grounding_supports].
    pub fn set_grounding_supports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroundingSupport>,
    {
        use std::iter::Iterator;
        self.grounding_supports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for GroundingMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingMetadata"
    }
}

/// Google search entry point.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntryPoint {
    /// Optional. Web content snippet that can be embedded in a web page or an app
    /// webview.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rendered_content: std::string::String,

    /// Optional. Base64 encoded JSON representing array of <search term, search
    /// url> tuple.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub sdk_blob: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl SearchEntryPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rendered_content][crate::model::SearchEntryPoint::rendered_content].
    pub fn set_rendered_content<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rendered_content = v.into();
        self
    }

    /// Sets the value of [sdk_blob][crate::model::SearchEntryPoint::sdk_blob].
    pub fn set_sdk_blob<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.sdk_blob = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for SearchEntryPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchEntryPoint"
    }
}

/// Metadata related to retrieval in the grounding flow.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrievalMetadata {
    /// Optional. Score indicating how likely information from Google Search could
    /// help answer the prompt. The score is in the range `[0, 1]`, where 0 is the
    /// least likely and 1 is the most likely. This score is only populated when
    /// Google Search grounding and dynamic retrieval is enabled. It will be
    /// compared to the threshold to determine whether to trigger Google Search.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub google_search_dynamic_retrieval_score: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl RetrievalMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_search_dynamic_retrieval_score][crate::model::RetrievalMetadata::google_search_dynamic_retrieval_score].
    pub fn set_google_search_dynamic_retrieval_score<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_search_dynamic_retrieval_score = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for RetrievalMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrievalMetadata"
    }
}

/// Represents token counting info for a single modality.
#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModalityTokenCount {
    /// The modality associated with this token count.
    pub modality: crate::model::Modality,

    /// Number of tokens.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub token_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl ModalityTokenCount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [modality][crate::model::ModalityTokenCount::modality].
    pub fn set_modality<T: std::convert::Into<crate::model::Modality>>(mut self, v: T) -> Self {
        self.modality = v.into();
        self
    }

    /// Sets the value of [token_count][crate::model::ModalityTokenCount::token_count].
    pub fn set_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.token_count = v.into();
        self
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl wkt::message::Message for ModalityTokenCount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModalityTokenCount"
    }
}

/// Instance of a general context.
#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Context {
    /// Immutable. The resource name of the Context.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name of the Context.
    /// May be up to 128 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// An eTag used to perform consistent read-modify-write updates. If not set, a
    /// blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Contexts.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Context (System
    /// labels are excluded).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Context was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Context was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A list of resource names of Contexts that are parents of this
    /// Context. A Context may have at most 10 parent_contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parent_contexts: std::vec::Vec<std::string::String>,

    /// The title of the schema describing the metadata.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_title: std::string::String,

    /// The version of the schema in schema_name to use.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Properties of the Context.
    /// Top level metadata keys' heading and trailing spaces will be trimmed.
    /// The size of this field should not exceed 200KB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Description of the Context
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
impl Context {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Context::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Context::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Context::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Context::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Context::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [schema_title][crate::model::Context::schema_title].
    pub fn set_schema_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_title = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::Context::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Context::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Context::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parent_contexts][crate::model::Context::parent_contexts].
    pub fn set_parent_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parent_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Context::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
impl wkt::message::Message for Context {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Context"
    }
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package. A CustomJob can have multiple worker pools and each worker
/// pool can have its own machine and input spec. A CustomJob will be cleaned up
/// once the job enters terminal state (failed or succeeded).
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomJob {
    /// Output only. Resource name of a CustomJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the CustomJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Job spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_spec: std::option::Option<crate::model::CustomJobSpec>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the CustomJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the CustomJob for the first time entered the
    /// `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the CustomJob entered any of the following states:
    /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the CustomJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize CustomJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a CustomJob. If this is set,
    /// then all resources created by the CustomJob will be encrypted with the
    /// provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. URIs for accessing [interactive
    /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
    /// (one URI for each training node). Only available if
    /// [job_spec.enable_web_access][google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]
    /// is `true`.
    ///
    /// The keys are names of each node in the training job; for example,
    /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
    /// the second worker pool, and `workerpool1-1` for the second node in the
    /// second worker pool.
    ///
    /// The values are the URIs for each node's interactive shell.
    ///
    /// [google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]: crate::model::CustomJobSpec::enable_web_access
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub web_access_uris: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CustomJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [job_spec][crate::model::CustomJob::job_spec].
    pub fn set_job_spec<T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CustomJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CustomJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CustomJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CustomJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CustomJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::CustomJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::CustomJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::CustomJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CustomJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [web_access_uris][crate::model::CustomJob::web_access_uris].
    pub fn set_web_access_uris<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.web_access_uris = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CustomJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CustomJob"
    }
}

/// Represents the spec of a CustomJob.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomJobSpec {
    /// Optional. The ID of the PersistentResource in the same Project and Location
    /// which to run
    ///
    /// If this is specified, the job will be run on existing machines held by the
    /// PersistentResource instead of on-demand short-live machines.
    /// The network and CMEK configs on the job should be consistent with those on
    /// the PersistentResource, otherwise, the job will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub persistent_resource_id: std::string::String,

    /// Required. The spec of the worker pools including machine type and Docker
    /// image. All worker pools except the first one are optional and can be
    /// skipped by providing an empty value.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub worker_pool_specs: std::vec::Vec<crate::model::WorkerPoolSpec>,

    /// Scheduling options for a CustomJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// Specifies the service account for workload run-as account.
    /// Users submitting jobs must have act-as permission on this run-as account.
    /// If unspecified, the [Vertex AI Custom Code Service
    /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
    /// for the CustomJob's project is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. The full name of the Compute Engine
    /// [network](/compute/docs/networks-and-firewalls#networks) to which the Job
    /// should be peered. For example, `projects/12345/global/networks/myVPC`.
    /// [Format](/compute/docs/reference/rest/v1/networks/insert)
    /// is of the form `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in `12345`, and {network} is a
    /// network name.
    ///
    /// To specify this field, you must have already [configured VPC Network
    /// Peering for Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
    ///
    /// If this field is left unspecified, the job is not peered with any network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. A list of names for the reserved ip ranges under the VPC network
    /// that can be used for this job.
    ///
    /// If set, we will deploy the job within the provided ip ranges. Otherwise,
    /// the job will be deployed to any ip ranges under the provided VPC
    /// network.
    ///
    /// Example: ['vertex-ai-ip-range'].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    /// The Cloud Storage location to store the output of this CustomJob or
    /// HyperparameterTuningJob. For HyperparameterTuningJob,
    /// the baseOutputDirectory of
    /// each child CustomJob backing a Trial is set to a subdirectory of name
    /// [id][google.cloud.aiplatform.v1.Trial.id] under its parent
    /// HyperparameterTuningJob's baseOutputDirectory.
    ///
    /// The following Vertex AI environment variables will be passed to
    /// containers or python modules when this field is set:
    ///
    /// For CustomJob:
    ///
    /// * AIP_MODEL_DIR = `<base_output_directory>/model/`
    /// * AIP_CHECKPOINT_DIR = `<base_output_directory>/checkpoints/`
    /// * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/logs/`
    ///
    /// For CustomJob backing a Trial of HyperparameterTuningJob:
    ///
    /// * AIP_MODEL_DIR = `<base_output_directory>/<trial_id>/model/`
    /// * AIP_CHECKPOINT_DIR = `<base_output_directory>/<trial_id>/checkpoints/`
    /// * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/<trial_id>/logs/`
    ///
    /// [google.cloud.aiplatform.v1.Trial.id]: crate::model::Trial::id
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_output_directory: std::option::Option<crate::model::GcsDestination>,

    /// The ID of the location to store protected artifacts. e.g. us-central1.
    /// Populate only when the location is different than CustomJob location.
    /// List of supported locations:
    /// <https://cloud.google.com/vertex-ai/docs/general/locations>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protected_artifact_location_id: std::string::String,

    /// Optional. The name of a Vertex AI
    /// [Tensorboard][google.cloud.aiplatform.v1.Tensorboard] resource to which
    /// this CustomJob will upload Tensorboard logs. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    ///
    /// [google.cloud.aiplatform.v1.Tensorboard]: crate::model::Tensorboard
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,

    /// Optional. Whether you want Vertex AI to enable [interactive shell
    /// access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
    /// to training containers.
    ///
    /// If set to `true`, you can access interactive shells at the URIs given
    /// by
    /// [CustomJob.web_access_uris][google.cloud.aiplatform.v1.CustomJob.web_access_uris]
    /// or
    /// [Trial.web_access_uris][google.cloud.aiplatform.v1.Trial.web_access_uris]
    /// (within
    /// [HyperparameterTuningJob.trials][google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]).
    ///
    /// [google.cloud.aiplatform.v1.CustomJob.web_access_uris]: crate::model::CustomJob::web_access_uris
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]: crate::model::HyperparameterTuningJob::trials
    /// [google.cloud.aiplatform.v1.Trial.web_access_uris]: crate::model::Trial::web_access_uris
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_web_access: bool,

    /// Optional. Whether you want Vertex AI to enable access to the customized
    /// dashboard in training chief container.
    ///
    /// If set to `true`, you can access the dashboard at the URIs given
    /// by
    /// [CustomJob.web_access_uris][google.cloud.aiplatform.v1.CustomJob.web_access_uris]
    /// or
    /// [Trial.web_access_uris][google.cloud.aiplatform.v1.Trial.web_access_uris]
    /// (within
    /// [HyperparameterTuningJob.trials][google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]).
    ///
    /// [google.cloud.aiplatform.v1.CustomJob.web_access_uris]: crate::model::CustomJob::web_access_uris
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]: crate::model::HyperparameterTuningJob::trials
    /// [google.cloud.aiplatform.v1.Trial.web_access_uris]: crate::model::Trial::web_access_uris
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_dashboard_access: bool,

    /// Optional. The Experiment associated with this job.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub experiment: std::string::String,

    /// Optional. The Experiment Run associated with this job.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub experiment_run: std::string::String,

    /// Optional. The name of the Model resources for which to generate a mapping
    /// to artifact URIs. Applicable only to some of the Google-provided custom
    /// jobs. Format: `projects/{project}/locations/{location}/models/{model}`
    ///
    /// In order to retrieve a specific version of the model, also provide
    /// the version ID or version alias.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// If no version ID or alias is specified, the "default" version will be
    /// returned. The "default" version alias is created for the first version of
    /// the model, and can be moved to other versions later on. There will be
    /// exactly one default version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CustomJobSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [persistent_resource_id][crate::model::CustomJobSpec::persistent_resource_id].
    pub fn set_persistent_resource_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource_id = v.into();
        self
    }

    /// Sets the value of [scheduling][crate::model::CustomJobSpec::scheduling].
    pub fn set_scheduling<T: std::convert::Into<std::option::Option<crate::model::Scheduling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scheduling = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::CustomJobSpec::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [network][crate::model::CustomJobSpec::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [base_output_directory][crate::model::CustomJobSpec::base_output_directory].
    pub fn set_base_output_directory<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_output_directory = v.into();
        self
    }

    /// Sets the value of [protected_artifact_location_id][crate::model::CustomJobSpec::protected_artifact_location_id].
    pub fn set_protected_artifact_location_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.protected_artifact_location_id = v.into();
        self
    }

    /// Sets the value of [tensorboard][crate::model::CustomJobSpec::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }

    /// Sets the value of [enable_web_access][crate::model::CustomJobSpec::enable_web_access].
    pub fn set_enable_web_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_web_access = v.into();
        self
    }

    /// Sets the value of [enable_dashboard_access][crate::model::CustomJobSpec::enable_dashboard_access].
    pub fn set_enable_dashboard_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_dashboard_access = v.into();
        self
    }

    /// Sets the value of [experiment][crate::model::CustomJobSpec::experiment].
    pub fn set_experiment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment = v.into();
        self
    }

    /// Sets the value of [experiment_run][crate::model::CustomJobSpec::experiment_run].
    pub fn set_experiment_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment_run = v.into();
        self
    }

    /// Sets the value of [worker_pool_specs][crate::model::CustomJobSpec::worker_pool_specs].
    pub fn set_worker_pool_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkerPoolSpec>,
    {
        use std::iter::Iterator;
        self.worker_pool_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::CustomJobSpec::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [models][crate::model::CustomJobSpec::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CustomJobSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CustomJobSpec"
    }
}

/// Represents the spec of a worker pool in a job.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkerPoolSpec {
    /// Optional. Immutable. The specification of a single machine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Optional. The number of worker replicas to use for this worker pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub replica_count: i64,

    /// Optional. List of NFS mount spec.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_mounts: std::vec::Vec<crate::model::NfsMount>,

    /// Disk spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_spec: std::option::Option<crate::model::DiskSpec>,

    /// The custom task to be executed in this worker pool.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub task: std::option::Option<crate::model::worker_pool_spec::Task>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl WorkerPoolSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_spec][crate::model::WorkerPoolSpec::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::WorkerPoolSpec::replica_count].
    pub fn set_replica_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [disk_spec][crate::model::WorkerPoolSpec::disk_spec].
    pub fn set_disk_spec<T: std::convert::Into<std::option::Option<crate::model::DiskSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_spec = v.into();
        self
    }

    /// Sets the value of [nfs_mounts][crate::model::WorkerPoolSpec::nfs_mounts].
    pub fn set_nfs_mounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsMount>,
    {
        use std::iter::Iterator;
        self.nfs_mounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [task][crate::model::WorkerPoolSpec::task].
    ///
    /// Note that all the setters affecting `task` are mutually
    /// exclusive.
    pub fn set_task<
        T: std::convert::Into<std::option::Option<crate::model::worker_pool_spec::Task>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = v.into();
        self
    }

    /// The value of [task][crate::model::WorkerPoolSpec::task]
    /// if it holds a `ContainerSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn container_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContainerSpec>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::worker_pool_spec::Task::ContainerSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [task][crate::model::WorkerPoolSpec::task]
    /// if it holds a `PythonPackageSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn python_package_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PythonPackageSpec>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::worker_pool_spec::Task::PythonPackageSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::WorkerPoolSpec::task]
    /// to hold a `ContainerSpec`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_container_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::ContainerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::worker_pool_spec::Task::ContainerSpec(
            v.into(),
        ));
        self
    }

    /// Sets the value of [task][crate::model::WorkerPoolSpec::task]
    /// to hold a `PythonPackageSpec`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_python_package_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::PythonPackageSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(
            crate::model::worker_pool_spec::Task::PythonPackageSpec(v.into()),
        );
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for WorkerPoolSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WorkerPoolSpec"
    }
}

/// Defines additional types related to [WorkerPoolSpec].
#[cfg(feature = "job_service")]
pub mod worker_pool_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The custom task to be executed in this worker pool.
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Task {
        /// The custom container task.
        ContainerSpec(std::boxed::Box<crate::model::ContainerSpec>),
        /// The Python packaged task.
        PythonPackageSpec(std::boxed::Box<crate::model::PythonPackageSpec>),
    }
}

/// The spec of a Container.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerSpec {
    /// Required. The URI of a container image in the Container Registry that is to
    /// be run on each worker replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// The command to be invoked when the container is started.
    /// It overrides the entrypoint instruction in Dockerfile when provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub command: std::vec::Vec<std::string::String>,

    /// The arguments to be passed when starting the container.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Environment variables to be passed to the container.
    /// Maximum limit is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ContainerSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_uri][crate::model::ContainerSpec::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [command][crate::model::ContainerSpec::command].
    pub fn set_command<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.command = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::ContainerSpec::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::ContainerSpec::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ContainerSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ContainerSpec"
    }
}

/// The spec of a Python packaged code.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PythonPackageSpec {
    /// Required. The URI of a container image in Artifact Registry that will run
    /// the provided Python package. Vertex AI provides a wide range of executor
    /// images with pre-installed packages to meet users' various use cases. See
    /// the list of [pre-built containers for
    /// training](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
    /// You must use an image from this list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub executor_image_uri: std::string::String,

    /// Required. The Google Cloud Storage location of the Python package files
    /// which are the training program and its dependent packages. The maximum
    /// number of package URIs is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub package_uris: std::vec::Vec<std::string::String>,

    /// Required. The Python module name to run after installing the packages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub python_module: std::string::String,

    /// Command line arguments to be passed to the Python task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Environment variables to be passed to the python module.
    /// Maximum limit is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl PythonPackageSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [executor_image_uri][crate::model::PythonPackageSpec::executor_image_uri].
    pub fn set_executor_image_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.executor_image_uri = v.into();
        self
    }

    /// Sets the value of [python_module][crate::model::PythonPackageSpec::python_module].
    pub fn set_python_module<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.python_module = v.into();
        self
    }

    /// Sets the value of [package_uris][crate::model::PythonPackageSpec::package_uris].
    pub fn set_package_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.package_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::PythonPackageSpec::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::PythonPackageSpec::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for PythonPackageSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PythonPackageSpec"
    }
}

/// All parameters related to queuing and scheduling of custom jobs.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scheduling {
    /// Optional. The maximum job running time. The default is 7 days.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Restarts the entire CustomJob if a worker gets restarted.
    /// This feature can be used by distributed training jobs that are not
    /// resilient to workers leaving and joining a job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub restart_job_on_worker_restart: bool,

    /// Optional. This determines which type of scheduling strategy to use.
    pub strategy: crate::model::scheduling::Strategy,

    /// Optional. Indicates if the job should retry for internal errors after the
    /// job starts running. If true, overrides
    /// `Scheduling.restart_job_on_worker_restart` to false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_retries: bool,

    /// Optional. This is the maximum duration that a job will wait for the
    /// requested resources to be provisioned if the scheduling strategy is set to
    /// [Strategy.DWS_FLEX_START].
    /// If set to 0, the job will wait indefinitely. The default is 24 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_wait_duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl Scheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timeout][crate::model::Scheduling::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [restart_job_on_worker_restart][crate::model::Scheduling::restart_job_on_worker_restart].
    pub fn set_restart_job_on_worker_restart<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.restart_job_on_worker_restart = v.into();
        self
    }

    /// Sets the value of [strategy][crate::model::Scheduling::strategy].
    pub fn set_strategy<T: std::convert::Into<crate::model::scheduling::Strategy>>(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = v.into();
        self
    }

    /// Sets the value of [disable_retries][crate::model::Scheduling::disable_retries].
    pub fn set_disable_retries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_retries = v.into();
        self
    }

    /// Sets the value of [max_wait_duration][crate::model::Scheduling::max_wait_duration].
    pub fn set_max_wait_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_wait_duration = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for Scheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Scheduling"
    }
}

/// Defines additional types related to [Scheduling].
#[cfg(feature = "job_service")]
pub mod scheduling {
    #[allow(unused_imports)]
    use super::*;

    /// Optional. This determines which type of scheduling strategy to use. Right
    /// now users have two options such as STANDARD which will use regular on
    /// demand resources to schedule the job, the other is SPOT which would
    /// leverage spot resources alongwith regular resources to schedule
    /// the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Strategy {
        /// Strategy will default to STANDARD.
        Unspecified,
        /// Deprecated. Regular on-demand provisioning strategy.
        #[deprecated]
        OnDemand,
        /// Deprecated. Low cost by making potential use of spot resources.
        #[deprecated]
        LowCost,
        /// Standard provisioning strategy uses regular on-demand resources.
        Standard,
        /// Spot provisioning strategy uses spot resources.
        Spot,
        /// Flex Start strategy uses DWS to queue for resources.
        FlexStart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Strategy::value] or
        /// [Strategy::name].
        UnknownValue(strategy::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "job_service")]
    pub mod strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "job_service")]
    impl Strategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::LowCost => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::Spot => std::option::Option::Some(4),
                Self::FlexStart => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STRATEGY_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::LowCost => std::option::Option::Some("LOW_COST"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::FlexStart => std::option::Option::Some("FLEX_START"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::default::Default for Strategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "job_service")]
    impl std::fmt::Display for Strategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<i32> for Strategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::LowCost,
                3 => Self::Standard,
                4 => Self::Spot,
                6 => Self::FlexStart,
                _ => Self::UnknownValue(strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<&str> for Strategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "LOW_COST" => Self::LowCost,
                "STANDARD" => Self::Standard,
                "SPOT" => Self::Spot,
                "FLEX_START" => Self::FlexStart,
                _ => Self::UnknownValue(strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl serde::ser::Serialize for Strategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::LowCost => serializer.serialize_i32(2),
                Self::Standard => serializer.serialize_i32(3),
                Self::Spot => serializer.serialize_i32(4),
                Self::FlexStart => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl<'de> serde::de::Deserialize<'de> for Strategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Strategy>::new(
                ".google.cloud.aiplatform.v1.Scheduling.Strategy",
            ))
        }
    }
}

/// A piece of data in a Dataset. Could be an image, a video, a document or plain
/// text.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataItem {
    /// Output only. The resource name of the DataItem.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this DataItem was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this DataItem was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize your DataItems.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one DataItem(System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The data that the DataItem represents (for example, an image or a
    /// text snippet). The schema of the payload is stored in the parent Dataset's
    /// [metadata schema's][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]
    /// dataItemSchemaUri field.
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<wkt::Value>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl DataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataItem::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataItem::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataItem::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::DataItem::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataItem::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DataItem::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DataItem::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataItem::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for DataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataItem"
    }
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataLabelingJob {
    /// Output only. Resource name of the DataLabelingJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the DataLabelingJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    /// Display name of a DataLabelingJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Dataset resource names. Right now we only support labeling from a
    /// single Dataset. Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<std::string::String>,

    /// Labels to assign to annotations generated by this DataLabelingJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotation_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Number of labelers to work on each DataItem.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub labeler_count: i32,

    /// Required. The Google Cloud Storage location of the instruction pdf. This
    /// pdf is shared with labelers, and provides detailed description on how to
    /// label DataItems in Datasets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instruction_uri: std::string::String,

    /// Required. Points to a YAML file stored on Google Cloud Storage describing
    /// the config for a specific type of DataLabelingJob. The schema files that
    /// can be used here are found in the
    /// <https://storage.googleapis.com/google-cloud-aiplatform> bucket in the
    /// /schema/datalabelingjob/inputs/ folder.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inputs_schema_uri: std::string::String,

    /// Required. Input config parameters for the DataLabelingJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inputs: std::option::Option<wkt::Value>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Current labeling job progress percentage scaled in interval
    /// [0, 100], indicating the percentage of DataItems that has been finished.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub labeling_progress: i32,

    /// Output only. Estimated cost(in US dollars) that the DataLabelingJob has
    /// incurred to date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_spend: std::option::Option<gtype::model::Money>,

    /// Output only. Timestamp when this DataLabelingJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this DataLabelingJob was updated most recently.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. DataLabelingJob errors. It is only populated when job's state
    /// is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize your DataLabelingJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for each DataLabelingJob:
    ///
    /// * "aiplatform.googleapis.com/schema": output only, its value is the
    ///   [inputs_schema][google.cloud.aiplatform.v1.DataLabelingJob.inputs_schema_uri]'s
    ///   title.
    ///
    /// [google.cloud.aiplatform.v1.DataLabelingJob.inputs_schema_uri]: crate::model::DataLabelingJob::inputs_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The SpecialistPools' resource names associated with this job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_pools: std::vec::Vec<std::string::String>,

    /// Customer-managed encryption key spec for a DataLabelingJob. If set, this
    /// DataLabelingJob will be secured by this key.
    ///
    /// Note: Annotations created in the DataLabelingJob are associated with
    /// the EncryptionSpec of the Dataset they are exported to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Parameters that configure the active learning pipeline. Active learning
    /// will label the data incrementally via several iterations. For every
    /// iteration, it will select a batch of data based on the sampling strategy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_learning_config: std::option::Option<crate::model::ActiveLearningConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DataLabelingJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataLabelingJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataLabelingJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labeler_count][crate::model::DataLabelingJob::labeler_count].
    pub fn set_labeler_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.labeler_count = v.into();
        self
    }

    /// Sets the value of [instruction_uri][crate::model::DataLabelingJob::instruction_uri].
    pub fn set_instruction_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instruction_uri = v.into();
        self
    }

    /// Sets the value of [inputs_schema_uri][crate::model::DataLabelingJob::inputs_schema_uri].
    pub fn set_inputs_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inputs_schema_uri = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::DataLabelingJob::inputs].
    pub fn set_inputs<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.inputs = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataLabelingJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labeling_progress][crate::model::DataLabelingJob::labeling_progress].
    pub fn set_labeling_progress<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.labeling_progress = v.into();
        self
    }

    /// Sets the value of [current_spend][crate::model::DataLabelingJob::current_spend].
    pub fn set_current_spend<T: std::convert::Into<std::option::Option<gtype::model::Money>>>(
        mut self,
        v: T,
    ) -> Self {
        self.current_spend = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataLabelingJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataLabelingJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::DataLabelingJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::DataLabelingJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [active_learning_config][crate::model::DataLabelingJob::active_learning_config].
    pub fn set_active_learning_config<
        T: std::convert::Into<std::option::Option<crate::model::ActiveLearningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.active_learning_config = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::DataLabelingJob::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [specialist_pools][crate::model::DataLabelingJob::specialist_pools].
    pub fn set_specialist_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specialist_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotation_labels][crate::model::DataLabelingJob::annotation_labels].
    pub fn set_annotation_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotation_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::DataLabelingJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DataLabelingJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataLabelingJob"
    }
}

/// Parameters that configure the active learning pipeline. Active learning will
/// label the data incrementally by several iterations. For every iteration, it
/// will select a batch of data based on the sampling strategy.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActiveLearningConfig {
    /// Active learning data sampling config. For every active learning labeling
    /// iteration, it will select a batch of data based on the sampling strategy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_config: std::option::Option<crate::model::SampleConfig>,

    /// CMLE training config. For every active learning labeling iteration, system
    /// will train a machine learning model on CMLE. The trained model will be used
    /// by data sampling algorithm to select DataItems.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_config: std::option::Option<crate::model::TrainingConfig>,

    /// Required. Max human labeling DataItems. The rest part will be labeled by
    /// machine.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub human_labeling_budget:
        std::option::Option<crate::model::active_learning_config::HumanLabelingBudget>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ActiveLearningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sample_config][crate::model::ActiveLearningConfig::sample_config].
    pub fn set_sample_config<
        T: std::convert::Into<std::option::Option<crate::model::SampleConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_config = v.into();
        self
    }

    /// Sets the value of [training_config][crate::model::ActiveLearningConfig::training_config].
    pub fn set_training_config<
        T: std::convert::Into<std::option::Option<crate::model::TrainingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_config = v.into();
        self
    }

    /// Sets the value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget].
    ///
    /// Note that all the setters affecting `human_labeling_budget` are mutually
    /// exclusive.
    pub fn set_human_labeling_budget<
        T: std::convert::Into<
                std::option::Option<crate::model::active_learning_config::HumanLabelingBudget>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.human_labeling_budget = v.into();
        self
    }

    /// The value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// if it holds a `MaxDataItemCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_data_item_count(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.human_labeling_budget.as_ref().and_then(|v| match v {
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// if it holds a `MaxDataItemPercentage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_data_item_percentage(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.human_labeling_budget.as_ref().and_then(|v| match v {
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemPercentage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// to hold a `MaxDataItemCount`.
    ///
    /// Note that all the setters affecting `human_labeling_budget` are
    /// mutually exclusive.
    pub fn set_max_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.human_labeling_budget = std::option::Option::Some(
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemCount(v.into()),
        );
        self
    }

    /// Sets the value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// to hold a `MaxDataItemPercentage`.
    ///
    /// Note that all the setters affecting `human_labeling_budget` are
    /// mutually exclusive.
    pub fn set_max_data_item_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.human_labeling_budget = std::option::Option::Some(
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemPercentage(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ActiveLearningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ActiveLearningConfig"
    }
}

/// Defines additional types related to [ActiveLearningConfig].
#[cfg(feature = "job_service")]
pub mod active_learning_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Max human labeling DataItems. The rest part will be labeled by
    /// machine.
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum HumanLabelingBudget {
        /// Max number of human labeled DataItems.
        MaxDataItemCount(i64),
        /// Max percent of total DataItems for human labeling.
        MaxDataItemPercentage(i32),
    }
}

/// Active learning data sampling config. For every active learning labeling
/// iteration, it will select a batch of data based on the sampling strategy.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SampleConfig {
    /// Field to choose sampling strategy. Sampling strategy will decide which data
    /// should be selected for human labeling in every batch.
    pub sample_strategy: crate::model::sample_config::SampleStrategy,

    /// Decides sample size for the initial batch. initial_batch_sample_percentage
    /// is used by default.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub initial_batch_sample_size:
        std::option::Option<crate::model::sample_config::InitialBatchSampleSize>,

    /// Decides sample size for the following batches.
    /// following_batch_sample_percentage is used by default.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub following_batch_sample_size:
        std::option::Option<crate::model::sample_config::FollowingBatchSampleSize>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl SampleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sample_strategy][crate::model::SampleConfig::sample_strategy].
    pub fn set_sample_strategy<
        T: std::convert::Into<crate::model::sample_config::SampleStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_strategy = v.into();
        self
    }

    /// Sets the value of [initial_batch_sample_size][crate::model::SampleConfig::initial_batch_sample_size].
    ///
    /// Note that all the setters affecting `initial_batch_sample_size` are mutually
    /// exclusive.
    pub fn set_initial_batch_sample_size<
        T: std::convert::Into<
                std::option::Option<crate::model::sample_config::InitialBatchSampleSize>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initial_batch_sample_size = v.into();
        self
    }

    /// The value of [initial_batch_sample_size][crate::model::SampleConfig::initial_batch_sample_size]
    /// if it holds a `InitialBatchSamplePercentage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn initial_batch_sample_percentage(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.initial_batch_sample_size.as_ref().and_then(|v| match v {
            crate::model::sample_config::InitialBatchSampleSize::InitialBatchSamplePercentage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [initial_batch_sample_size][crate::model::SampleConfig::initial_batch_sample_size]
    /// to hold a `InitialBatchSamplePercentage`.
    ///
    /// Note that all the setters affecting `initial_batch_sample_size` are
    /// mutually exclusive.
    pub fn set_initial_batch_sample_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_batch_sample_size = std::option::Option::Some(
            crate::model::sample_config::InitialBatchSampleSize::InitialBatchSamplePercentage(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [following_batch_sample_size][crate::model::SampleConfig::following_batch_sample_size].
    ///
    /// Note that all the setters affecting `following_batch_sample_size` are mutually
    /// exclusive.
    pub fn set_following_batch_sample_size<
        T: std::convert::Into<
                std::option::Option<crate::model::sample_config::FollowingBatchSampleSize>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.following_batch_sample_size = v.into();
        self
    }

    /// The value of [following_batch_sample_size][crate::model::SampleConfig::following_batch_sample_size]
    /// if it holds a `FollowingBatchSamplePercentage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn following_batch_sample_percentage(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.following_batch_sample_size.as_ref().and_then(|v| match v {
            crate::model::sample_config::FollowingBatchSampleSize::FollowingBatchSamplePercentage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [following_batch_sample_size][crate::model::SampleConfig::following_batch_sample_size]
    /// to hold a `FollowingBatchSamplePercentage`.
    ///
    /// Note that all the setters affecting `following_batch_sample_size` are
    /// mutually exclusive.
    pub fn set_following_batch_sample_percentage<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.following_batch_sample_size = std::option::Option::Some(
            crate::model::sample_config::FollowingBatchSampleSize::FollowingBatchSamplePercentage(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for SampleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SampleConfig"
    }
}

/// Defines additional types related to [SampleConfig].
#[cfg(feature = "job_service")]
pub mod sample_config {
    #[allow(unused_imports)]
    use super::*;

    /// Sample strategy decides which subset of DataItems should be selected for
    /// human labeling in every batch.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SampleStrategy {
        /// Default will be treated as UNCERTAINTY.
        Unspecified,
        /// Sample the most uncertain data to label.
        Uncertainty,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SampleStrategy::value] or
        /// [SampleStrategy::name].
        UnknownValue(sample_strategy::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "job_service")]
    pub mod sample_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "job_service")]
    impl SampleStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Uncertainty => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SAMPLE_STRATEGY_UNSPECIFIED"),
                Self::Uncertainty => std::option::Option::Some("UNCERTAINTY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::default::Default for SampleStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "job_service")]
    impl std::fmt::Display for SampleStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<i32> for SampleStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Uncertainty,
                _ => Self::UnknownValue(sample_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<&str> for SampleStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SAMPLE_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "UNCERTAINTY" => Self::Uncertainty,
                _ => Self::UnknownValue(sample_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl serde::ser::Serialize for SampleStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Uncertainty => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl<'de> serde::de::Deserialize<'de> for SampleStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SampleStrategy>::new(
                ".google.cloud.aiplatform.v1.SampleConfig.SampleStrategy",
            ))
        }
    }

    /// Decides sample size for the initial batch. initial_batch_sample_percentage
    /// is used by default.
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum InitialBatchSampleSize {
        /// The percentage of data needed to be labeled in the first batch.
        InitialBatchSamplePercentage(i32),
    }

    /// Decides sample size for the following batches.
    /// following_batch_sample_percentage is used by default.
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FollowingBatchSampleSize {
        /// The percentage of data needed to be labeled in each following batch
        /// (except the first batch).
        FollowingBatchSamplePercentage(i32),
    }
}

/// CMLE training config. For every active learning labeling iteration, system
/// will train a machine learning model on CMLE. The trained model will be used
/// by data sampling algorithm to select DataItems.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainingConfig {
    /// The timeout hours for the CMLE training job, expressed in milli hours
    /// i.e. 1,000 value in this field means 1 hour.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub timeout_training_milli_hours: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl TrainingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timeout_training_milli_hours][crate::model::TrainingConfig::timeout_training_milli_hours].
    pub fn set_timeout_training_milli_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.timeout_training_milli_hours = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for TrainingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrainingConfig"
    }
}

/// A collection of DataItems and Annotations on them.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dataset {
    /// Output only. Identifier. The resource name of the Dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the Dataset.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Points to a YAML file stored on Google Cloud Storage describing
    /// additional information about the Dataset. The schema is defined as an
    /// OpenAPI 3.0.2 Schema Object. The schema files that can be used here are
    /// found in gs://google-cloud-aiplatform/schema/dataset/metadata/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_uri: std::string::String,

    /// Required. Additional information about the Dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. The number of DataItems in this Dataset. Only apply for
    /// non-structured Dataset.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub data_item_count: i64,

    /// Output only. Timestamp when this Dataset was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Dataset was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Datasets.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Dataset (System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for each Dataset:
    ///
    /// * "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
    ///   value is the
    ///   [metadata_schema's][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]
    ///   title.
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// All SavedQueries belong to the Dataset will be returned in List/Get
    /// Dataset response. The annotation_specs field
    /// will not be populated except for UI cases which will only use
    /// [annotation_spec_count][google.cloud.aiplatform.v1.SavedQuery.annotation_spec_count].
    /// In CreateDataset request, a SavedQuery is created together if
    /// this field is set, up to one SavedQuery can be set in CreateDatasetRequest.
    /// The SavedQuery should not contain any AnnotationSpec.
    ///
    /// [google.cloud.aiplatform.v1.SavedQuery.annotation_spec_count]: crate::model::SavedQuery::annotation_spec_count
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub saved_queries: std::vec::Vec<crate::model::SavedQuery>,

    /// Customer-managed encryption key spec for a Dataset. If set, this Dataset
    /// and all sub-resources of this Dataset will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. The resource name of the Artifact that was created in
    /// MetadataStore when creating the Dataset. The Artifact resource name pattern
    /// is
    /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_artifact: std::string::String,

    /// Optional. Reference to the public base model last used by the dataset. Only
    /// set for prompt datasets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_reference: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Dataset::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [metadata_schema_uri][crate::model::Dataset::metadata_schema_uri].
    pub fn set_metadata_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Dataset::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [data_item_count][crate::model::Dataset::data_item_count].
    pub fn set_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_item_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Dataset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Dataset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dataset::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Dataset::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [metadata_artifact][crate::model::Dataset::metadata_artifact].
    pub fn set_metadata_artifact<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_artifact = v.into();
        self
    }

    /// Sets the value of [model_reference][crate::model::Dataset::model_reference].
    pub fn set_model_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_reference = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Dataset::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Dataset::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [saved_queries][crate::model::Dataset::saved_queries].
    pub fn set_saved_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SavedQuery>,
    {
        use std::iter::Iterator;
        self.saved_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Dataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Dataset"
    }
}

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataConfig {
    /// Labels that will be applied to newly imported DataItems. If an identical
    /// DataItem as one being imported already exists in the Dataset, then these
    /// labels will be appended to these of the already existing one, and if labels
    /// with identical key is imported before, the old label value will be
    /// overwritten. If two DataItems are identical in the same import data
    /// operation, the labels will be combined and if key collision happens in this
    /// case, one of the values will be picked randomly. Two DataItems are
    /// considered identical if their content bytes are identical (e.g. image bytes
    /// or pdf bytes).
    /// These labels will be overridden by Annotation labels specified inside index
    /// file referenced by
    /// [import_schema_uri][google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri],
    /// e.g. jsonl file.
    ///
    /// [google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri]: crate::model::ImportDataConfig::import_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub data_item_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels that will be applied to newly imported Annotations. If two
    /// Annotations are identical, one of them will be deduped. Two Annotations are
    /// considered identical if their
    /// [payload][google.cloud.aiplatform.v1.Annotation.payload],
    /// [payload_schema_uri][google.cloud.aiplatform.v1.Annotation.payload_schema_uri]
    /// and all of their [labels][google.cloud.aiplatform.v1.Annotation.labels] are
    /// the same. These labels will be overridden by Annotation labels specified
    /// inside index file referenced by
    /// [import_schema_uri][google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri],
    /// e.g. jsonl file.
    ///
    /// [google.cloud.aiplatform.v1.Annotation.labels]: crate::model::Annotation::labels
    /// [google.cloud.aiplatform.v1.Annotation.payload]: crate::model::Annotation::payload
    /// [google.cloud.aiplatform.v1.Annotation.payload_schema_uri]: crate::model::Annotation::payload_schema_uri
    /// [google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri]: crate::model::ImportDataConfig::import_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotation_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Points to a YAML file stored on Google Cloud Storage describing
    /// the import format. Validation will be done against the schema. The schema
    /// is defined as an [OpenAPI 3.0.2 Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_schema_uri: std::string::String,

    /// The source of the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_data_config::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ImportDataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_schema_uri][crate::model::ImportDataConfig::import_schema_uri].
    pub fn set_import_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_schema_uri = v.into();
        self
    }

    /// Sets the value of [data_item_labels][crate::model::ImportDataConfig::data_item_labels].
    pub fn set_data_item_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_item_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotation_labels][crate::model::ImportDataConfig::annotation_labels].
    pub fn set_annotation_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotation_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source][crate::model::ImportDataConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_data_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportDataConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_data_config::Source::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDataConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_data_config::Source::GcsSource(v.into()),
        );
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ImportDataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataConfig"
    }
}

/// Defines additional types related to [ImportDataConfig].
#[cfg(feature = "dataset_service")]
pub mod import_data_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the input.
    #[cfg(feature = "dataset_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Google Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Describes what part of the Dataset is to be exported, the destination of
/// the export and how to export.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataConfig {
    /// An expression for filtering what part of the Dataset is to be exported.
    /// Only Annotations that match this filter will be exported. The filter syntax
    /// is the same as in
    /// [ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations].
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotations_filter: std::string::String,

    /// The ID of a SavedQuery (annotation set) under the Dataset specified by
    /// [ExportDataRequest.name][google.cloud.aiplatform.v1.ExportDataRequest.name]
    /// used for filtering Annotations for training.
    ///
    /// Only used for custom training data export use cases.
    /// Only applicable to Datasets that have SavedQueries.
    ///
    /// Only Annotations that are associated with this SavedQuery are used in
    /// respectively training. When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [saved_query_id][google.cloud.aiplatform.v1.ExportDataConfig.saved_query_id]
    /// and
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter].
    ///
    /// Only one of
    /// [saved_query_id][google.cloud.aiplatform.v1.ExportDataConfig.saved_query_id]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri]
    /// should be specified as both of them represent the same thing: problem type.
    ///
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri]: crate::model::ExportDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter]: crate::model::ExportDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.ExportDataConfig.saved_query_id]: crate::model::ExportDataConfig::saved_query_id
    /// [google.cloud.aiplatform.v1.ExportDataRequest.name]: crate::model::ExportDataRequest::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub saved_query_id: std::string::String,

    /// The Cloud Storage URI that points to a YAML file describing the annotation
    /// schema. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// The schema files that can be used here are found in
    /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
    /// chosen schema must be consistent with
    /// [metadata][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri] of the
    /// Dataset specified by
    /// [ExportDataRequest.name][google.cloud.aiplatform.v1.ExportDataRequest.name].
    ///
    /// Only used for custom training data export use cases.
    /// Only applicable to Datasets that have DataItems and Annotations.
    ///
    /// Only Annotations that both match this schema and belong to DataItems not
    /// ignored by the split method are used in respectively training, validation
    /// or test role, depending on the role of the DataItem they are on.
    ///
    /// When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri]: crate::model::ExportDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter]: crate::model::ExportDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.ExportDataRequest.name]: crate::model::ExportDataRequest::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_schema_uri: std::string::String,

    /// Indicates the usage of the exported files.
    pub export_use: crate::model::export_data_config::ExportUse,

    /// The destination of the output.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_data_config::Destination>,

    /// The instructions how the export data should be split between the
    /// training, validation and test sets.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::export_data_config::Split>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ExportDataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [annotations_filter][crate::model::ExportDataConfig::annotations_filter].
    pub fn set_annotations_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotations_filter = v.into();
        self
    }

    /// Sets the value of [saved_query_id][crate::model::ExportDataConfig::saved_query_id].
    pub fn set_saved_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query_id = v.into();
        self
    }

    /// Sets the value of [annotation_schema_uri][crate::model::ExportDataConfig::annotation_schema_uri].
    pub fn set_annotation_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_schema_uri = v.into();
        self
    }

    /// Sets the value of [export_use][crate::model::ExportDataConfig::export_use].
    pub fn set_export_use<T: std::convert::Into<crate::model::export_data_config::ExportUse>>(
        mut self,
        v: T,
    ) -> Self {
        self.export_use = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportDataConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_data_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportDataConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_data_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportDataConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_data_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::ExportDataConfig::split].
    ///
    /// Note that all the setters affecting `split` are mutually
    /// exclusive.
    pub fn set_split<
        T: std::convert::Into<std::option::Option<crate::model::export_data_config::Split>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = v.into();
        self
    }

    /// The value of [split][crate::model::ExportDataConfig::split]
    /// if it holds a `FractionSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fraction_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExportFractionSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::export_data_config::Split::FractionSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::ExportDataConfig::split]
    /// if it holds a `FilterSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filter_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExportFilterSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::export_data_config::Split::FilterSplit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [split][crate::model::ExportDataConfig::split]
    /// to hold a `FractionSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_fraction_split<
        T: std::convert::Into<std::boxed::Box<crate::model::ExportFractionSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::export_data_config::Split::FractionSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::ExportDataConfig::split]
    /// to hold a `FilterSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_filter_split<
        T: std::convert::Into<std::boxed::Box<crate::model::ExportFilterSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::export_data_config::Split::FilterSplit(v.into()),
        );
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ExportDataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataConfig"
    }
}

/// Defines additional types related to [ExportDataConfig].
#[cfg(feature = "dataset_service")]
pub mod export_data_config {
    #[allow(unused_imports)]
    use super::*;

    /// ExportUse indicates the usage of the exported files. It restricts file
    /// destination, format, annotations to be exported, whether to allow
    /// unannotated data to be exported and whether to clone files to temp Cloud
    /// Storage bucket.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "dataset_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExportUse {
        /// Regular user export.
        Unspecified,
        /// Export for custom code training.
        CustomCodeTraining,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExportUse::value] or
        /// [ExportUse::name].
        UnknownValue(export_use::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "dataset_service")]
    pub mod export_use {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "dataset_service")]
    impl ExportUse {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomCodeTraining => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXPORT_USE_UNSPECIFIED"),
                Self::CustomCodeTraining => std::option::Option::Some("CUSTOM_CODE_TRAINING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "dataset_service")]
    impl std::default::Default for ExportUse {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "dataset_service")]
    impl std::fmt::Display for ExportUse {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "dataset_service")]
    impl std::convert::From<i32> for ExportUse {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                6 => Self::CustomCodeTraining,
                _ => Self::UnknownValue(export_use::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "dataset_service")]
    impl std::convert::From<&str> for ExportUse {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPORT_USE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOM_CODE_TRAINING" => Self::CustomCodeTraining,
                _ => Self::UnknownValue(export_use::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "dataset_service")]
    impl serde::ser::Serialize for ExportUse {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomCodeTraining => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "dataset_service")]
    impl<'de> serde::de::Deserialize<'de> for ExportUse {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExportUse>::new(
                ".google.cloud.aiplatform.v1.ExportDataConfig.ExportUse",
            ))
        }
    }

    /// The destination of the output.
    #[cfg(feature = "dataset_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// The Google Cloud Storage location where the output is to be written to.
        /// In the given directory a new directory will be created with name:
        /// `export-data-<dataset-display-name>-<timestamp-of-export-call>` where
        /// timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All export
        /// output will be written into that directory. Inside that directory,
        /// annotations with the same schema will be grouped into sub directories
        /// which are named with the corresponding annotations' schema title. Inside
        /// these sub directories, a schema.yaml will be created to describe the
        /// output format.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }

    /// The instructions how the export data should be split between the
    /// training, validation and test sets.
    #[cfg(feature = "dataset_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Split {
        /// Split based on fractions defining the size of each set.
        FractionSplit(std::boxed::Box<crate::model::ExportFractionSplit>),
        /// Split based on the provided filters for each set.
        FilterSplit(std::boxed::Box<crate::model::ExportFilterSplit>),
    }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFractionSplit {
    /// The fraction of the input data that is to be used to train the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub test_fraction: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ExportFractionSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::ExportFractionSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::ExportFractionSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::ExportFractionSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ExportFractionSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFractionSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored. Currently only
/// supported for Datasets containing DataItems.
/// If any of the filters in this message are to match nothing, then they can be
/// set as '-' (the minus sign).
///
/// Supported only for unstructured Datasets.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFilterSplit {
    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to train the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to validate the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub validation_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to test the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub test_filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ExportFilterSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_filter][crate::model::ExportFilterSplit::training_filter].
    pub fn set_training_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.training_filter = v.into();
        self
    }

    /// Sets the value of [validation_filter][crate::model::ExportFilterSplit::validation_filter].
    pub fn set_validation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_filter = v.into();
        self
    }

    /// Sets the value of [test_filter][crate::model::ExportFilterSplit::test_filter].
    pub fn set_test_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_filter = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ExportFilterSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFilterSplit"
    }
}

/// Request message for
/// [DatasetService.CreateDataset][google.cloud.aiplatform.v1.DatasetService.CreateDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDataset]: crate::client::DatasetService::create_dataset
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetRequest {
    /// Required. The resource name of the Location to create the Dataset in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Dataset to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl CreateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for CreateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetRequest"
    }
}

/// Runtime operation information for
/// [DatasetService.CreateDataset][google.cloud.aiplatform.v1.DatasetService.CreateDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDataset]: crate::client::DatasetService::create_dataset
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl CreateDatasetOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateDatasetOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for CreateDatasetOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.GetDataset][google.cloud.aiplatform.v1.DatasetService.GetDataset].
/// Next ID: 4
///
/// [google.cloud.aiplatform.v1.DatasetService.GetDataset]: crate::client::DatasetService::get_dataset
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. The name of the Dataset resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetDatasetRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDatasetRequest"
    }
}

/// Request message for
/// [DatasetService.UpdateDataset][google.cloud.aiplatform.v1.DatasetService.UpdateDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.UpdateDataset]: crate::client::DatasetService::update_dataset
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatasetRequest {
    /// Required. The Dataset which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. Updatable fields:
    ///
    /// * `display_name`
    /// * `description`
    /// * `labels`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl UpdateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::UpdateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatasetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for UpdateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDatasetRequest"
    }
}

/// Request message for
/// [DatasetService.UpdateDatasetVersion][google.cloud.aiplatform.v1.DatasetService.UpdateDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.UpdateDatasetVersion]: crate::client::DatasetService::update_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatasetVersionRequest {
    /// Required. The DatasetVersion which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_version: std::option::Option<crate::model::DatasetVersion>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. Updatable fields:
    ///
    /// * `display_name`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl UpdateDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_version][crate::model::UpdateDatasetVersionRequest::dataset_version].
    pub fn set_dataset_version<
        T: std::convert::Into<std::option::Option<crate::model::DatasetVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_version = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatasetVersionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for UpdateDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDatasetVersionRequest"
    }
}

/// Request message for
/// [DatasetService.ListDatasets][google.cloud.aiplatform.v1.DatasetService.ListDatasets].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasets]: crate::client::DatasetService::list_datasets
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. The name of the Dataset's parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. For field names
    /// both snake_case and camelCase are supported.
    ///
    /// * `display_name`: supports = and !=
    /// * `metadata_schema_uri`: supports = and !=
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    ///
    /// Some examples:
    ///
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDatasetsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatasetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetsRequest"
    }
}

/// Response message for
/// [DatasetService.ListDatasets][google.cloud.aiplatform.v1.DatasetService.ListDatasets].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasets]: crate::client::DatasetService::list_datasets
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsResponse {
    /// A list of Datasets that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<crate::model::Dataset>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::ListDatasetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetsResponse"
    }
}

#[cfg(feature = "dataset_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatasetsResponse {
    type PageItem = crate::model::Dataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DatasetService.DeleteDataset][google.cloud.aiplatform.v1.DatasetService.DeleteDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.DeleteDataset]: crate::client::DatasetService::delete_dataset
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. The resource name of the Dataset to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDatasetRequest"
    }
}

/// Request message for
/// [DatasetService.ImportData][google.cloud.aiplatform.v1.DatasetService.ImportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ImportData]: crate::client::DatasetService::import_data
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataRequest {
    /// Required. The name of the Dataset resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The desired input locations. The contents of all input locations
    /// will be imported in one batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub import_configs: std::vec::Vec<crate::model::ImportDataConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ImportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [import_configs][crate::model::ImportDataRequest::import_configs].
    pub fn set_import_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportDataConfig>,
    {
        use std::iter::Iterator;
        self.import_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ImportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataRequest"
    }
}

/// Response message for
/// [DatasetService.ImportData][google.cloud.aiplatform.v1.DatasetService.ImportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ImportData]: crate::client::DatasetService::import_data
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ImportDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ImportDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataResponse"
    }
}

/// Runtime operation information for
/// [DatasetService.ImportData][google.cloud.aiplatform.v1.DatasetService.ImportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ImportData]: crate::client::DatasetService::import_data
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ImportDataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ImportDataOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ImportDataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.ExportData][google.cloud.aiplatform.v1.DatasetService.ExportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ExportData]: crate::client::DatasetService::export_data
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataRequest {
    /// Required. The name of the Dataset resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The desired output location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_config: std::option::Option<crate::model::ExportDataConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ExportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportDataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [export_config][crate::model::ExportDataRequest::export_config].
    pub fn set_export_config<
        T: std::convert::Into<std::option::Option<crate::model::ExportDataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_config = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ExportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataRequest"
    }
}

/// Response message for
/// [DatasetService.ExportData][google.cloud.aiplatform.v1.DatasetService.ExportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ExportData]: crate::client::DatasetService::export_data
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataResponse {
    /// All of the files that are exported in this export operation. For custom
    /// code training export, only three (training, validation and test)
    /// Cloud Storage paths in wildcard format are populated
    /// (for example, gs://.../training-*).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exported_files: std::vec::Vec<std::string::String>,

    /// Only present for custom code training export use case. Records data stats,
    /// i.e., train/validation/test item/annotation counts calculated during
    /// the export operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_stats: std::option::Option<crate::model::model::DataStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ExportDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_stats][crate::model::ExportDataResponse::data_stats].
    pub fn set_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::model::DataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_stats = v.into();
        self
    }

    /// Sets the value of [exported_files][crate::model::ExportDataResponse::exported_files].
    pub fn set_exported_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exported_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ExportDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataResponse"
    }
}

/// Runtime operation information for
/// [DatasetService.ExportData][google.cloud.aiplatform.v1.DatasetService.ExportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ExportData]: crate::client::DatasetService::export_data
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A Google Cloud Storage directory which path ends with '/'. The exported
    /// data is stored in the directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_output_directory: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ExportDataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ExportDataOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [gcs_output_directory][crate::model::ExportDataOperationMetadata::gcs_output_directory].
    pub fn set_gcs_output_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_output_directory = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ExportDataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.CreateDatasetVersion][google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion]: crate::client::DatasetService::create_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetVersionRequest {
    /// Required. The name of the Dataset resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The version to be created. The same CMEK policies with the
    /// original Dataset will be applied the dataset version. So here we don't need
    /// to specify the EncryptionSpecType here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_version: std::option::Option<crate::model::DatasetVersion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl CreateDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset_version][crate::model::CreateDatasetVersionRequest::dataset_version].
    pub fn set_dataset_version<
        T: std::convert::Into<std::option::Option<crate::model::DatasetVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_version = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for CreateDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetVersionRequest"
    }
}

/// Runtime operation information for
/// [DatasetService.CreateDatasetVersion][google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion]: crate::client::DatasetService::create_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetVersionOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl CreateDatasetVersionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateDatasetVersionOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for CreateDatasetVersionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetVersionOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.DeleteDatasetVersion][google.cloud.aiplatform.v1.DatasetService.DeleteDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.DeleteDatasetVersion]: crate::client::DatasetService::delete_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetVersionRequest {
    /// Required. The resource name of the Dataset version to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl DeleteDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for DeleteDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDatasetVersionRequest"
    }
}

/// Request message for
/// [DatasetService.GetDatasetVersion][google.cloud.aiplatform.v1.DatasetService.GetDatasetVersion].
/// Next ID: 4
///
/// [google.cloud.aiplatform.v1.DatasetService.GetDatasetVersion]: crate::client::DatasetService::get_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetVersionRequest {
    /// Required. The resource name of the Dataset version to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl GetDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetDatasetVersionRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for GetDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDatasetVersionRequest"
    }
}

/// Request message for
/// [DatasetService.ListDatasetVersions][google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions]: crate::client::DatasetService::list_dataset_versions
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetVersionsRequest {
    /// Required. The resource name of the Dataset to list DatasetVersions from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListDatasetVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDatasetVersionsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatasetVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListDatasetVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetVersionsRequest"
    }
}

/// Response message for
/// [DatasetService.ListDatasetVersions][google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions]: crate::client::DatasetService::list_dataset_versions
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetVersionsResponse {
    /// A list of DatasetVersions that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dataset_versions: std::vec::Vec<crate::model::DatasetVersion>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListDatasetVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [dataset_versions][crate::model::ListDatasetVersionsResponse::dataset_versions].
    pub fn set_dataset_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatasetVersion>,
    {
        use std::iter::Iterator;
        self.dataset_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListDatasetVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetVersionsResponse"
    }
}

#[cfg(feature = "dataset_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatasetVersionsResponse {
    type PageItem = crate::model::DatasetVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dataset_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DatasetService.RestoreDatasetVersion][google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion]: crate::client::DatasetService::restore_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatasetVersionRequest {
    /// Required. The name of the DatasetVersion resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl RestoreDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreDatasetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for RestoreDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RestoreDatasetVersionRequest"
    }
}

/// Runtime operation information for
/// [DatasetService.RestoreDatasetVersion][google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion]: crate::client::DatasetService::restore_dataset_version
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatasetVersionOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl RestoreDatasetVersionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::RestoreDatasetVersionOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for RestoreDatasetVersionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RestoreDatasetVersionOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataItemsRequest {
    /// Required. The resource name of the Dataset to list DataItems from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListDataItemsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataItemsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataItemsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataItemsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataItemsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDataItemsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataItemsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListDataItemsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataItemsRequest"
    }
}

/// Response message for
/// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataItemsResponse {
    /// A list of DataItems that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_items: std::vec::Vec<crate::model::DataItem>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListDataItemsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDataItemsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [data_items][crate::model::ListDataItemsResponse::data_items].
    pub fn set_data_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataItem>,
    {
        use std::iter::Iterator;
        self.data_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListDataItemsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataItemsResponse"
    }
}

#[cfg(feature = "dataset_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataItemsResponse {
    type PageItem = crate::model::DataItem;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DatasetService.SearchDataItems][google.cloud.aiplatform.v1.DatasetService.SearchDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.SearchDataItems]: crate::client::DatasetService::search_data_items
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDataItemsRequest {
    /// Required. The resource name of the Dataset from which to search DataItems.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// The resource name of a SavedQuery(annotation set in UI).
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
    /// All of the search will be done in the context of this SavedQuery.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub saved_query: std::string::String,

    /// The resource name of a DataLabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    /// If this field is set, all of the search will be done in the context of
    /// this DataLabelingJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_labeling_job: std::string::String,

    /// An expression for filtering the DataItem that will be returned.
    ///
    /// * `data_item_id` - for = or !=.
    /// * `labeled` - for = or !=.
    /// * `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that
    ///   have at least one annotation with annotation_spec_id =
    ///   `ANNOTATION_SPEC_ID` in the context of SavedQuery or DataLabelingJob.
    ///
    /// For example:
    ///
    /// * `data_item=1`
    /// * `has_annotation(5)`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_item_filter: std::string::String,

    /// An expression for filtering the Annotations that will be returned per
    /// DataItem.
    ///
    /// * `annotation_spec_id` - for = or !=.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub annotations_filter: std::string::String,

    /// An expression that specifies what Annotations will be returned per
    /// DataItem. Annotations satisfied either of the conditions will be returned.
    ///
    /// * `annotation_spec_id` - for = or !=.
    ///   Must specify `saved_query_id=` - saved query id that annotations should
    ///   belong to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub annotation_filters: std::vec::Vec<std::string::String>,

    /// Mask specifying which fields of
    /// [DataItemView][google.cloud.aiplatform.v1.DataItemView] to read.
    ///
    /// [google.cloud.aiplatform.v1.DataItemView]: crate::model::DataItemView
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_mask: std::option::Option<wkt::FieldMask>,

    /// If set, only up to this many of Annotations will be returned per
    /// DataItemView. The maximum value is 1000. If not set, the maximum value will
    /// be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub annotations_limit: i32,

    /// Requested page size. Server may return fewer results than requested.
    /// Default and maximum page size is 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub order_by: std::string::String,

    /// A token identifying a page of results for the server to return
    /// Typically obtained via
    /// [SearchDataItemsResponse.next_page_token][google.cloud.aiplatform.v1.SearchDataItemsResponse.next_page_token]
    /// of the previous
    /// [DatasetService.SearchDataItems][google.cloud.aiplatform.v1.DatasetService.SearchDataItems]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.SearchDataItems]: crate::client::DatasetService::search_data_items
    /// [google.cloud.aiplatform.v1.SearchDataItemsResponse.next_page_token]: crate::model::SearchDataItemsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub order: std::option::Option<crate::model::search_data_items_request::Order>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl SearchDataItemsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::SearchDataItemsRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [saved_query][crate::model::SearchDataItemsRequest::saved_query].
    #[deprecated]
    pub fn set_saved_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query = v.into();
        self
    }

    /// Sets the value of [data_labeling_job][crate::model::SearchDataItemsRequest::data_labeling_job].
    pub fn set_data_labeling_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_labeling_job = v.into();
        self
    }

    /// Sets the value of [data_item_filter][crate::model::SearchDataItemsRequest::data_item_filter].
    pub fn set_data_item_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item_filter = v.into();
        self
    }

    /// Sets the value of [annotations_filter][crate::model::SearchDataItemsRequest::annotations_filter].
    #[deprecated]
    pub fn set_annotations_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotations_filter = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::SearchDataItemsRequest::field_mask].
    pub fn set_field_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_mask = v.into();
        self
    }

    /// Sets the value of [annotations_limit][crate::model::SearchDataItemsRequest::annotations_limit].
    pub fn set_annotations_limit<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.annotations_limit = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchDataItemsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchDataItemsRequest::order_by].
    #[deprecated]
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchDataItemsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [annotation_filters][crate::model::SearchDataItemsRequest::annotation_filters].
    pub fn set_annotation_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotation_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [order][crate::model::SearchDataItemsRequest::order].
    ///
    /// Note that all the setters affecting `order` are mutually
    /// exclusive.
    pub fn set_order<
        T: std::convert::Into<std::option::Option<crate::model::search_data_items_request::Order>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.order = v.into();
        self
    }

    /// The value of [order][crate::model::SearchDataItemsRequest::order]
    /// if it holds a `OrderByDataItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn order_by_data_item(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.order.as_ref().and_then(|v| match v {
            crate::model::search_data_items_request::Order::OrderByDataItem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [order][crate::model::SearchDataItemsRequest::order]
    /// if it holds a `OrderByAnnotation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn order_by_annotation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::search_data_items_request::OrderByAnnotation>,
    > {
        #[allow(unreachable_patterns)]
        self.order.as_ref().and_then(|v| match v {
            crate::model::search_data_items_request::Order::OrderByAnnotation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [order][crate::model::SearchDataItemsRequest::order]
    /// to hold a `OrderByDataItem`.
    ///
    /// Note that all the setters affecting `order` are
    /// mutually exclusive.
    pub fn set_order_by_data_item<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.order = std::option::Option::Some(
            crate::model::search_data_items_request::Order::OrderByDataItem(v.into()),
        );
        self
    }

    /// Sets the value of [order][crate::model::SearchDataItemsRequest::order]
    /// to hold a `OrderByAnnotation`.
    ///
    /// Note that all the setters affecting `order` are
    /// mutually exclusive.
    pub fn set_order_by_annotation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::search_data_items_request::OrderByAnnotation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.order = std::option::Option::Some(
            crate::model::search_data_items_request::Order::OrderByAnnotation(v.into()),
        );
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for SearchDataItemsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsRequest"
    }
}

/// Defines additional types related to [SearchDataItemsRequest].
#[cfg(feature = "dataset_service")]
pub mod search_data_items_request {
    #[allow(unused_imports)]
    use super::*;

    /// Expression that allows ranking results based on annotation's property.
    #[cfg(feature = "dataset_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrderByAnnotation {
        /// Required. Saved query of the Annotation. Only Annotations belong to this
        /// saved query will be considered for ordering.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub saved_query: std::string::String,

        /// A comma-separated list of annotation fields to order by, sorted in
        /// ascending order. Use "desc" after a field name for descending. Must also
        /// specify saved_query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub order_by: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "dataset_service")]
    impl OrderByAnnotation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [saved_query][crate::model::search_data_items_request::OrderByAnnotation::saved_query].
        pub fn set_saved_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.saved_query = v.into();
            self
        }

        /// Sets the value of [order_by][crate::model::search_data_items_request::OrderByAnnotation::order_by].
        pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.order_by = v.into();
            self
        }
    }

    #[cfg(feature = "dataset_service")]
    impl wkt::message::Message for OrderByAnnotation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsRequest.OrderByAnnotation"
        }
    }

    #[cfg(feature = "dataset_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Order {
        /// A comma-separated list of data item fields to order by, sorted in
        /// ascending order. Use "desc" after a field name for descending.
        OrderByDataItem(std::string::String),
        /// Expression that allows ranking results based on annotation's property.
        OrderByAnnotation(
            std::boxed::Box<crate::model::search_data_items_request::OrderByAnnotation>,
        ),
    }
}

/// Response message for
/// [DatasetService.SearchDataItems][google.cloud.aiplatform.v1.DatasetService.SearchDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.SearchDataItems]: crate::client::DatasetService::search_data_items
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDataItemsResponse {
    /// The DataItemViews read.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_item_views: std::vec::Vec<crate::model::DataItemView>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [SearchDataItemsRequest.page_token][google.cloud.aiplatform.v1.SearchDataItemsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.SearchDataItemsRequest.page_token]: crate::model::SearchDataItemsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl SearchDataItemsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchDataItemsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [data_item_views][crate::model::SearchDataItemsResponse::data_item_views].
    pub fn set_data_item_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataItemView>,
    {
        use std::iter::Iterator;
        self.data_item_views = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for SearchDataItemsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsResponse"
    }
}

#[cfg(feature = "dataset_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchDataItemsResponse {
    type PageItem = crate::model::DataItemView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_item_views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A container for a single DataItem and Annotations on it.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataItemView {
    /// The DataItem.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_item: std::option::Option<crate::model::DataItem>,

    /// The Annotations on the DataItem. If too many Annotations should be returned
    /// for the DataItem, this field will be truncated per annotations_limit in
    /// request. If it was, then the has_truncated_annotations will be set to true.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub annotations: std::vec::Vec<crate::model::Annotation>,

    /// True if and only if the Annotations field has been truncated. It happens if
    /// more Annotations for this DataItem met the request's annotation_filter than
    /// are allowed to be returned by annotations_limit.
    /// Note that if Annotations field is not being returned due to field mask,
    /// then this field will not be set to true no matter how many Annotations are
    /// there.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub has_truncated_annotations: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl DataItemView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::DataItemView::data_item].
    pub fn set_data_item<T: std::convert::Into<std::option::Option<crate::model::DataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// Sets the value of [has_truncated_annotations][crate::model::DataItemView::has_truncated_annotations].
    pub fn set_has_truncated_annotations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_truncated_annotations = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::DataItemView::annotations].
    pub fn set_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Annotation>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for DataItemView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataItemView"
    }
}

/// Request message for
/// [DatasetService.ListSavedQueries][google.cloud.aiplatform.v1.DatasetService.ListSavedQueries].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListSavedQueries]: crate::client::DatasetService::list_saved_queries
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSavedQueriesRequest {
    /// Required. The resource name of the Dataset to list SavedQueries from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListSavedQueriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSavedQueriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSavedQueriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSavedQueriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSavedQueriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListSavedQueriesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSavedQueriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListSavedQueriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSavedQueriesRequest"
    }
}

/// Response message for
/// [DatasetService.ListSavedQueries][google.cloud.aiplatform.v1.DatasetService.ListSavedQueries].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListSavedQueries]: crate::client::DatasetService::list_saved_queries
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSavedQueriesResponse {
    /// A list of SavedQueries that match the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub saved_queries: std::vec::Vec<crate::model::SavedQuery>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListSavedQueriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSavedQueriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [saved_queries][crate::model::ListSavedQueriesResponse::saved_queries].
    pub fn set_saved_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SavedQuery>,
    {
        use std::iter::Iterator;
        self.saved_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListSavedQueriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSavedQueriesResponse"
    }
}

#[cfg(feature = "dataset_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSavedQueriesResponse {
    type PageItem = crate::model::SavedQuery;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.saved_queries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DatasetService.DeleteSavedQuery][google.cloud.aiplatform.v1.DatasetService.DeleteSavedQuery].
///
/// [google.cloud.aiplatform.v1.DatasetService.DeleteSavedQuery]: crate::client::DatasetService::delete_saved_query
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSavedQueryRequest {
    /// Required. The resource name of the SavedQuery to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl DeleteSavedQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSavedQueryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for DeleteSavedQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteSavedQueryRequest"
    }
}

/// Request message for
/// [DatasetService.GetAnnotationSpec][google.cloud.aiplatform.v1.DatasetService.GetAnnotationSpec].
///
/// [google.cloud.aiplatform.v1.DatasetService.GetAnnotationSpec]: crate::client::DatasetService::get_annotation_spec
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAnnotationSpecRequest {
    /// Required. The name of the AnnotationSpec resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl GetAnnotationSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnnotationSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetAnnotationSpecRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for GetAnnotationSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetAnnotationSpecRequest"
    }
}

/// Request message for
/// [DatasetService.ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnnotationsRequest {
    /// Required. The resource name of the DataItem to list Annotations from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListAnnotationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnnotationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAnnotationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnnotationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnnotationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListAnnotationsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAnnotationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListAnnotationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListAnnotationsRequest"
    }
}

/// Response message for
/// [DatasetService.ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnnotationsResponse {
    /// A list of Annotations that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub annotations: std::vec::Vec<crate::model::Annotation>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl ListAnnotationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAnnotationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::ListAnnotationsResponse::annotations].
    pub fn set_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Annotation>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for ListAnnotationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListAnnotationsResponse"
    }
}

#[cfg(feature = "dataset_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAnnotationsResponse {
    type PageItem = crate::model::Annotation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.annotations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Describes the dataset version.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetVersion {
    /// Output only. Identifier. The resource name of the DatasetVersion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this DatasetVersion was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this DatasetVersion was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Name of the associated BigQuery dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub big_query_dataset_name: std::string::String,

    /// The user-defined name of the DatasetVersion.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Output only. Additional information about the DatasetVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. Reference to the public base model last used by the dataset
    /// version. Only set for prompt dataset versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_reference: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl DatasetVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatasetVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DatasetVersion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DatasetVersion::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DatasetVersion::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [big_query_dataset_name][crate::model::DatasetVersion::big_query_dataset_name].
    pub fn set_big_query_dataset_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.big_query_dataset_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DatasetVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::DatasetVersion::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [model_reference][crate::model::DatasetVersion::model_reference].
    pub fn set_model_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_reference = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DatasetVersion::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DatasetVersion::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for DatasetVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DatasetVersion"
    }
}

/// Points to a DeployedIndex.
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedIndexRef {
    /// Immutable. A resource name of the IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Immutable. The ID of the DeployedIndex in the above IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    /// Output only. The display name of the DeployedIndex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl DeployedIndexRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::DeployedIndexRef::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::DeployedIndexRef::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeployedIndexRef::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for DeployedIndexRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexRef"
    }
}

/// Points to a DeployedModel.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedModelRef {
    /// Immutable. A resource name of an Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Immutable. An ID of a DeployedModel in the above Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl DeployedModelRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DeployedModelRef::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::DeployedModelRef::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for DeployedModelRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModelRef"
    }
}

/// A description of resources that can be shared by multiple DeployedModels,
/// whose underlying specification consists of a DedicatedResources.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeploymentResourcePool {
    /// Immutable. The resource name of the DeploymentResourcePool.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The underlying DedicatedResources that the DeploymentResourcePool
    /// uses.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_resources: std::option::Option<crate::model::DedicatedResources>,

    /// Customer-managed encryption key spec for a DeploymentResourcePool. If set,
    /// this DeploymentResourcePool will be secured by this key. Endpoints and the
    /// DeploymentResourcePool they deploy in need to have the same EncryptionSpec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The service account that the DeploymentResourcePool's container(s) run as.
    /// Specify the email address of the service account. If this service account
    /// is not specified, the container(s) run as a service account that doesn't
    /// have access to the resource project.
    ///
    /// Users deploying the Models to this DeploymentResourcePool must have the
    /// `iam.serviceAccounts.actAs` permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// If the DeploymentResourcePool is deployed with custom-trained Models or
    /// AutoML Tabular Models, the container(s) of the DeploymentResourcePool will
    /// send `stderr` and `stdout` streams to Cloud Logging by default.
    /// Please note that the logs incur cost, which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging/pricing).
    ///
    /// User can disable container logging by setting this flag to true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_container_logging: bool,

    /// Output only. Timestamp when this DeploymentResourcePool was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl DeploymentResourcePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeploymentResourcePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [dedicated_resources][crate::model::DeploymentResourcePool::dedicated_resources].
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::option::Option<crate::model::DedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_resources = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::DeploymentResourcePool::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DeploymentResourcePool::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disable_container_logging][crate::model::DeploymentResourcePool::disable_container_logging].
    pub fn set_disable_container_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_container_logging = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeploymentResourcePool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DeploymentResourcePool::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DeploymentResourcePool::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for DeploymentResourcePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeploymentResourcePool"
    }
}

/// Request message for CreateDeploymentResourcePool method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeploymentResourcePoolRequest {
    /// Required. The parent location resource where this DeploymentResourcePool
    /// will be created. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DeploymentResourcePool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_resource_pool: std::option::Option<crate::model::DeploymentResourcePool>,

    /// Required. The ID to use for the DeploymentResourcePool, which
    /// will become the final component of the DeploymentResourcePool's resource
    /// name.
    ///
    /// The maximum length is 63 characters, and valid characters
    /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_resource_pool_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl CreateDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeploymentResourcePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deployment_resource_pool][crate::model::CreateDeploymentResourcePoolRequest::deployment_resource_pool].
    pub fn set_deployment_resource_pool<
        T: std::convert::Into<std::option::Option<crate::model::DeploymentResourcePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool = v.into();
        self
    }

    /// Sets the value of [deployment_resource_pool_id][crate::model::CreateDeploymentResourcePoolRequest::deployment_resource_pool_id].
    pub fn set_deployment_resource_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool_id = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for CreateDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDeploymentResourcePoolRequest"
    }
}

/// Runtime operation information for CreateDeploymentResourcePool method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeploymentResourcePoolOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl CreateDeploymentResourcePoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateDeploymentResourcePoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for CreateDeploymentResourcePoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDeploymentResourcePoolOperationMetadata"
    }
}

/// Request message for GetDeploymentResourcePool method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeploymentResourcePoolRequest {
    /// Required. The name of the DeploymentResourcePool to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl GetDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeploymentResourcePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for GetDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDeploymentResourcePoolRequest"
    }
}

/// Request message for ListDeploymentResourcePools method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentResourcePoolsRequest {
    /// Required. The parent Location which owns this collection of
    /// DeploymentResourcePools. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of DeploymentResourcePools to return. The service may
    /// return fewer than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous `ListDeploymentResourcePools` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDeploymentResourcePools` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl ListDeploymentResourcePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeploymentResourcePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentResourcePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentResourcePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for ListDeploymentResourcePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDeploymentResourcePoolsRequest"
    }
}

/// Response message for ListDeploymentResourcePools method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentResourcePoolsResponse {
    /// The DeploymentResourcePools from the specified location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployment_resource_pools: std::vec::Vec<crate::model::DeploymentResourcePool>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl ListDeploymentResourcePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentResourcePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [deployment_resource_pools][crate::model::ListDeploymentResourcePoolsResponse::deployment_resource_pools].
    pub fn set_deployment_resource_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeploymentResourcePool>,
    {
        use std::iter::Iterator;
        self.deployment_resource_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for ListDeploymentResourcePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDeploymentResourcePoolsResponse"
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeploymentResourcePoolsResponse {
    type PageItem = crate::model::DeploymentResourcePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployment_resource_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for UpdateDeploymentResourcePool method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeploymentResourcePoolRequest {
    /// Required. The DeploymentResourcePool to update.
    ///
    /// The DeploymentResourcePool's `name` field is used to identify the
    /// DeploymentResourcePool to update.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_resource_pool: std::option::Option<crate::model::DeploymentResourcePool>,

    /// Required. The list of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl UpdateDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment_resource_pool][crate::model::UpdateDeploymentResourcePoolRequest::deployment_resource_pool].
    pub fn set_deployment_resource_pool<
        T: std::convert::Into<std::option::Option<crate::model::DeploymentResourcePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeploymentResourcePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for UpdateDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolRequest"
    }
}

/// Runtime operation information for UpdateDeploymentResourcePool method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeploymentResourcePoolOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl UpdateDeploymentResourcePoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateDeploymentResourcePoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for UpdateDeploymentResourcePoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolOperationMetadata"
    }
}

/// Request message for DeleteDeploymentResourcePool method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDeploymentResourcePoolRequest {
    /// Required. The name of the DeploymentResourcePool to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl DeleteDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeploymentResourcePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for DeleteDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDeploymentResourcePoolRequest"
    }
}

/// Request message for QueryDeployedModels method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryDeployedModelsRequest {
    /// Required. The name of the target DeploymentResourcePool to query.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_resource_pool: std::string::String,

    /// The maximum number of DeployedModels to return. The service may return
    /// fewer than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous `QueryDeployedModels` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryDeployedModels` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl QueryDeployedModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment_resource_pool][crate::model::QueryDeployedModelsRequest::deployment_resource_pool].
    pub fn set_deployment_resource_pool<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryDeployedModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryDeployedModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for QueryDeployedModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryDeployedModelsRequest"
    }
}

/// Response message for QueryDeployedModels method.
#[cfg(feature = "deployment_resource_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryDeployedModelsResponse {
    /// DEPRECATED Use deployed_model_refs instead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub deployed_models: std::vec::Vec<crate::model::DeployedModel>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// References to the DeployedModels that share the specified
    /// deploymentResourcePool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_model_refs: std::vec::Vec<crate::model::DeployedModelRef>,

    /// The total number of DeployedModels on this DeploymentResourcePool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_deployed_model_count: i32,

    /// The total number of Endpoints that have DeployedModels on this
    /// DeploymentResourcePool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_endpoint_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployment_resource_pool_service")]
impl QueryDeployedModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::QueryDeployedModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_deployed_model_count][crate::model::QueryDeployedModelsResponse::total_deployed_model_count].
    pub fn set_total_deployed_model_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_deployed_model_count = v.into();
        self
    }

    /// Sets the value of [total_endpoint_count][crate::model::QueryDeployedModelsResponse::total_endpoint_count].
    pub fn set_total_endpoint_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_endpoint_count = v.into();
        self
    }

    /// Sets the value of [deployed_models][crate::model::QueryDeployedModelsResponse::deployed_models].
    #[deprecated]
    pub fn set_deployed_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModel>,
    {
        use std::iter::Iterator;
        self.deployed_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployed_model_refs][crate::model::QueryDeployedModelsResponse::deployed_model_refs].
    pub fn set_deployed_model_refs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModelRef>,
    {
        use std::iter::Iterator;
        self.deployed_model_refs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
impl wkt::message::Message for QueryDeployedModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryDeployedModelsResponse"
    }
}

#[cfg(feature = "deployment_resource_pool_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for QueryDeployedModelsResponse {
    type PageItem = crate::model::DeployedModel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployed_models
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents a customer-managed encryption key spec that can be applied to
/// a top-level resource.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "schedule_service",
    feature = "tensorboard_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionSpec {
    /// Required. The Cloud KMS resource identifier of the customer managed
    /// encryption key used to protect a resource. Has the form:
    /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
    /// The key needs to be in the same region as where the compute resource is
    /// created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "schedule_service",
    feature = "tensorboard_service",
))]
impl EncryptionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionSpec::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "schedule_service",
    feature = "tensorboard_service",
))]
impl wkt::message::Message for EncryptionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EncryptionSpec"
    }
}

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Endpoint {
    /// Output only. The resource name of the Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the Endpoint.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The models deployed in this Endpoint.
    /// To add or remove DeployedModels use
    /// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel]
    /// and
    /// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel]
    /// respectively.
    ///
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_models: std::vec::Vec<crate::model::DeployedModel>,

    /// A map from a DeployedModel's ID to the percentage of this Endpoint's
    /// traffic that should be forwarded to that DeployedModel.
    ///
    /// If a DeployedModel's ID is not listed in this map, then it receives no
    /// traffic.
    ///
    /// The traffic percentage values must add up to 100, or map must be empty if
    /// the Endpoint is to not accept any traffic at a moment.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub traffic_split: std::collections::HashMap<std::string::String, i32>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Endpoints.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Endpoint was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Endpoint was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Customer-managed encryption key spec for an Endpoint. If set, this
    /// Endpoint and all sub-resources of this Endpoint will be secured by
    /// this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. The full name of the Google Compute Engine
    /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
    /// to which the Endpoint should be peered.
    ///
    /// Private services access must already be configured for the network. If left
    /// unspecified, the Endpoint is not peered with any network.
    ///
    /// Only one of the fields,
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] or
    /// [enable_private_service_connect][google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect],
    /// can be set.
    ///
    /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
    /// `projects/{project}/global/networks/{network}`.
    /// Where `{project}` is a project number, as in `12345`, and `{network}` is
    /// network name.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect]: crate::model::Endpoint::enable_private_service_connect
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Deprecated: If true, expose the Endpoint via private service connect.
    ///
    /// Only one of the fields,
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] or
    /// [enable_private_service_connect][google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect],
    /// can be set.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect]: crate::model::Endpoint::enable_private_service_connect
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub enable_private_service_connect: bool,

    /// Optional. Configuration for private service connect.
    ///
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] and
    /// [private_service_connect_config][google.cloud.aiplatform.v1.Endpoint.private_service_connect_config]
    /// are mutually exclusive.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    /// [google.cloud.aiplatform.v1.Endpoint.private_service_connect_config]: crate::model::Endpoint::private_service_connect_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_service_connect_config:
        std::option::Option<crate::model::PrivateServiceConnectConfig>,

    /// Output only. Resource name of the Model Monitoring job associated with this
    /// Endpoint if monitoring is enabled by
    /// [JobService.CreateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob].
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    ///
    /// [google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob]: crate::client::JobService::create_model_deployment_monitoring_job
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_deployment_monitoring_job: std::string::String,

    /// Configures the request-response logging for online prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_request_response_logging_config:
        std::option::Option<crate::model::PredictRequestResponseLoggingConfig>,

    /// If true, the endpoint will be exposed through a dedicated
    /// DNS [Endpoint.dedicated_endpoint_dns]. Your request to the dedicated DNS
    /// will be isolated from other users' traffic and will have better performance
    /// and reliability.
    /// Note: Once you enabled dedicated endpoint, you won't be able to send
    /// request to the shared DNS {region}-aiplatform.googleapis.com. The
    /// limitation will be removed soon.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub dedicated_endpoint_enabled: bool,

    /// Output only. DNS of the dedicated endpoint. Will only be populated if
    /// dedicated_endpoint_enabled is true.
    /// Format:
    /// `https://{endpoint_id}.{region}-{project_number}.prediction.vertexai.goog`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dedicated_endpoint_dns: std::string::String,

    /// Configurations that are applied to the endpoint for online prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_connection_config: std::option::Option<crate::model::ClientConnectionConfig>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl Endpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Endpoint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Endpoint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Endpoint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Endpoint::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Endpoint::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Endpoint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Endpoint::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Endpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [enable_private_service_connect][crate::model::Endpoint::enable_private_service_connect].
    #[deprecated]
    pub fn set_enable_private_service_connect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_service_connect = v.into();
        self
    }

    /// Sets the value of [private_service_connect_config][crate::model::Endpoint::private_service_connect_config].
    pub fn set_private_service_connect_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateServiceConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_service_connect_config = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::Endpoint::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }

    /// Sets the value of [predict_request_response_logging_config][crate::model::Endpoint::predict_request_response_logging_config].
    pub fn set_predict_request_response_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::PredictRequestResponseLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_request_response_logging_config = v.into();
        self
    }

    /// Sets the value of [dedicated_endpoint_enabled][crate::model::Endpoint::dedicated_endpoint_enabled].
    pub fn set_dedicated_endpoint_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dedicated_endpoint_enabled = v.into();
        self
    }

    /// Sets the value of [dedicated_endpoint_dns][crate::model::Endpoint::dedicated_endpoint_dns].
    pub fn set_dedicated_endpoint_dns<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_endpoint_dns = v.into();
        self
    }

    /// Sets the value of [client_connection_config][crate::model::Endpoint::client_connection_config].
    pub fn set_client_connection_config<
        T: std::convert::Into<std::option::Option<crate::model::ClientConnectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_connection_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Endpoint::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Endpoint::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [deployed_models][crate::model::Endpoint::deployed_models].
    pub fn set_deployed_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModel>,
    {
        use std::iter::Iterator;
        self.deployed_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [traffic_split][crate::model::Endpoint::traffic_split].
    pub fn set_traffic_split<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.traffic_split = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Endpoint::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for Endpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Endpoint"
    }
}

/// A deployment of a Model. Endpoints contain one or more DeployedModels.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedModel {
    /// Immutable. The ID of the DeployedModel. If not provided upon deployment,
    /// Vertex AI will generate a value for this ID.
    ///
    /// This value should be 1-10 characters, and valid characters are `/[0-9]/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Required. The resource name of the Model that this is the deployment of.
    /// Note that the Model may be in a different location than the DeployedModel's
    /// Endpoint.
    ///
    /// The resource name may contain version id or version alias to specify the
    /// version.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// if no version is specified, the default version will be deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the model that is deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    /// The display name of the DeployedModel. If not provided upon creation,
    /// the Model's display_name is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp when the DeployedModel was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Explanation configuration for this DeployedModel.
    ///
    /// When deploying a Model using
    /// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel],
    /// this value overrides the value of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec].
    /// All fields of
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// are optional in the request. If a field of
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// is not populated, the value of the same field of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// is inherited. If the corresponding
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// is not populated, all fields of the
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// will be used for the explanation configuration.
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

    /// If true, deploy the model without explainable feature, regardless the
    /// existence of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// or
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_explanations: bool,

    /// The service account that the DeployedModel's container runs as. Specify the
    /// email address of the service account. If this service account is not
    /// specified, the container runs as a service account that doesn't have access
    /// to the resource project.
    ///
    /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// For custom-trained Models and AutoML Tabular Models, the container of the
    /// DeployedModel instances will send `stderr` and `stdout` streams to
    /// Cloud Logging by default. Please note that the logs incur cost,
    /// which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging/pricing).
    ///
    /// User can disable container logging by setting this flag to true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_container_logging: bool,

    /// If true, online prediction access logs are sent to Cloud
    /// Logging.
    /// These logs are like standard server access logs, containing
    /// information like timestamp and latency for each prediction request.
    ///
    /// Note that logs may incur a cost, especially if your project
    /// receives prediction requests at a high queries per second rate (QPS).
    /// Estimate your costs before enabling this option.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_access_logging: bool,

    /// Output only. Provide paths for users to send predict/explain/health
    /// requests directly to the deployed model services running on Cloud via
    /// private services access. This field is populated if
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] is configured.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_endpoints: std::option::Option<crate::model::PrivateEndpoints>,

    /// Configuration for faster model deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub faster_deployment_config: std::option::Option<crate::model::FasterDeploymentConfig>,

    /// Output only. Runtime status of the deployed model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::deployed_model::Status>,

    /// System labels to apply to Model Garden deployments.
    /// System labels are managed by Google for internal use only.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub system_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Spec for configuring speculative decoding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub speculative_decoding_spec: std::option::Option<crate::model::SpeculativeDecodingSpec>,

    /// The prediction (for example, the machine) resources that the DeployedModel
    /// uses. The user is billed for the resources (at least their minimal amount)
    /// even if the DeployedModel receives no traffic.
    /// Not all Models support all resources types. See
    /// [Model.supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types].
    /// Required except for Large Model Deploy use cases.
    ///
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub prediction_resources:
        std::option::Option<crate::model::deployed_model::PredictionResources>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl DeployedModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::DeployedModel::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::DeployedModel::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::DeployedModel::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeployedModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployedModel::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [explanation_spec][crate::model::DeployedModel::explanation_spec].
    pub fn set_explanation_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec = v.into();
        self
    }

    /// Sets the value of [disable_explanations][crate::model::DeployedModel::disable_explanations].
    pub fn set_disable_explanations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_explanations = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DeployedModel::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disable_container_logging][crate::model::DeployedModel::disable_container_logging].
    pub fn set_disable_container_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_container_logging = v.into();
        self
    }

    /// Sets the value of [enable_access_logging][crate::model::DeployedModel::enable_access_logging].
    pub fn set_enable_access_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_access_logging = v.into();
        self
    }

    /// Sets the value of [private_endpoints][crate::model::DeployedModel::private_endpoints].
    pub fn set_private_endpoints<
        T: std::convert::Into<std::option::Option<crate::model::PrivateEndpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoints = v.into();
        self
    }

    /// Sets the value of [faster_deployment_config][crate::model::DeployedModel::faster_deployment_config].
    pub fn set_faster_deployment_config<
        T: std::convert::Into<std::option::Option<crate::model::FasterDeploymentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.faster_deployment_config = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DeployedModel::status].
    pub fn set_status<
        T: std::convert::Into<std::option::Option<crate::model::deployed_model::Status>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [speculative_decoding_spec][crate::model::DeployedModel::speculative_decoding_spec].
    pub fn set_speculative_decoding_spec<
        T: std::convert::Into<std::option::Option<crate::model::SpeculativeDecodingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculative_decoding_spec = v.into();
        self
    }

    /// Sets the value of [system_labels][crate::model::DeployedModel::system_labels].
    pub fn set_system_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.system_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources].
    ///
    /// Note that all the setters affecting `prediction_resources` are mutually
    /// exclusive.
    pub fn set_prediction_resources<
        T: std::convert::Into<std::option::Option<crate::model::deployed_model::PredictionResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = v.into();
        self
    }

    /// The value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// if it holds a `DedicatedResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dedicated_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DedicatedResources>> {
        #[allow(unreachable_patterns)]
        self.prediction_resources.as_ref().and_then(|v| match v {
            crate::model::deployed_model::PredictionResources::DedicatedResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// if it holds a `AutomaticResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automatic_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticResources>> {
        #[allow(unreachable_patterns)]
        self.prediction_resources.as_ref().and_then(|v| match v {
            crate::model::deployed_model::PredictionResources::AutomaticResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// if it holds a `SharedResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn shared_resources(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.prediction_resources.as_ref().and_then(|v| match v {
            crate::model::deployed_model::PredictionResources::SharedResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// to hold a `DedicatedResources`.
    ///
    /// Note that all the setters affecting `prediction_resources` are
    /// mutually exclusive.
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::DedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = std::option::Option::Some(
            crate::model::deployed_model::PredictionResources::DedicatedResources(v.into()),
        );
        self
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// to hold a `AutomaticResources`.
    ///
    /// Note that all the setters affecting `prediction_resources` are
    /// mutually exclusive.
    pub fn set_automatic_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::AutomaticResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = std::option::Option::Some(
            crate::model::deployed_model::PredictionResources::AutomaticResources(v.into()),
        );
        self
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// to hold a `SharedResources`.
    ///
    /// Note that all the setters affecting `prediction_resources` are
    /// mutually exclusive.
    pub fn set_shared_resources<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = std::option::Option::Some(
            crate::model::deployed_model::PredictionResources::SharedResources(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl wkt::message::Message for DeployedModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModel"
    }
}

/// Defines additional types related to [DeployedModel].
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
pub mod deployed_model {
    #[allow(unused_imports)]
    use super::*;

    /// Runtime status of the deployed model.
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Status {
        /// Output only. The latest deployed model's status message (if any).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Output only. The time at which the status was last updated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The number of available replicas of the deployed model.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub available_replica_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    impl Status {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [message][crate::model::deployed_model::Status::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [last_update_time][crate::model::deployed_model::Status::last_update_time].
        pub fn set_last_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_update_time = v.into();
            self
        }

        /// Sets the value of [available_replica_count][crate::model::deployed_model::Status::available_replica_count].
        pub fn set_available_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.available_replica_count = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    impl wkt::message::Message for Status {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModel.Status"
        }
    }

    /// The prediction (for example, the machine) resources that the DeployedModel
    /// uses. The user is billed for the resources (at least their minimal amount)
    /// even if the DeployedModel receives no traffic.
    /// Not all Models support all resources types. See
    /// [Model.supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types].
    /// Required except for Large Model Deploy use cases.
    ///
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PredictionResources {
        /// A description of resources that are dedicated to the DeployedModel, and
        /// that need a higher degree of manual configuration.
        DedicatedResources(std::boxed::Box<crate::model::DedicatedResources>),
        /// A description of resources that to large degree are decided by Vertex
        /// AI, and require only a modest additional configuration.
        AutomaticResources(std::boxed::Box<crate::model::AutomaticResources>),
        /// The resource name of the shared DeploymentResourcePool to deploy on.
        /// Format:
        /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
        SharedResources(std::string::String),
    }
}

/// PrivateEndpoints proto is used to provide paths for users to send
/// requests privately.
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateEndpoints {
    /// Output only. Http(s) path to send prediction requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predict_http_uri: std::string::String,

    /// Output only. Http(s) path to send explain requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explain_http_uri: std::string::String,

    /// Output only. Http(s) path to send health check requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_http_uri: std::string::String,

    /// Output only. The name of the service attachment resource. Populated if
    /// private service connect is enabled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl PrivateEndpoints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [predict_http_uri][crate::model::PrivateEndpoints::predict_http_uri].
    pub fn set_predict_http_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predict_http_uri = v.into();
        self
    }

    /// Sets the value of [explain_http_uri][crate::model::PrivateEndpoints::explain_http_uri].
    pub fn set_explain_http_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.explain_http_uri = v.into();
        self
    }

    /// Sets the value of [health_http_uri][crate::model::PrivateEndpoints::health_http_uri].
    pub fn set_health_http_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.health_http_uri = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PrivateEndpoints::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl wkt::message::Message for PrivateEndpoints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PrivateEndpoints"
    }
}

/// Configuration for logging request-response to a BigQuery table.
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictRequestResponseLoggingConfig {
    /// If logging is enabled or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Percentage of requests to be logged, expressed as a fraction in
    /// range(0,1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub sampling_rate: f64,

    /// BigQuery table for logging.
    /// If only given a project, a new dataset will be created with name
    /// `logging_<endpoint-display-name>_<endpoint-id>` where
    /// \<endpoint-display-name\> will be made BigQuery-dataset-name compatible (e.g.
    /// most special characters will become underscores). If no table name is
    /// given, a new table will be created with name `request_response_logging`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_destination: std::option::Option<crate::model::BigQueryDestination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl PredictRequestResponseLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PredictRequestResponseLoggingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [sampling_rate][crate::model::PredictRequestResponseLoggingConfig::sampling_rate].
    pub fn set_sampling_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.sampling_rate = v.into();
        self
    }

    /// Sets the value of [bigquery_destination][crate::model::PredictRequestResponseLoggingConfig::bigquery_destination].
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_destination = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for PredictRequestResponseLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictRequestResponseLoggingConfig"
    }
}

/// Configurations (e.g. inference timeout) that are applied on your endpoints.
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClientConnectionConfig {
    /// Customizable online prediction request timeout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inference_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl ClientConnectionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inference_timeout][crate::model::ClientConnectionConfig::inference_timeout].
    pub fn set_inference_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.inference_timeout = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for ClientConnectionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ClientConnectionConfig"
    }
}

/// Configuration for faster model deployment.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FasterDeploymentConfig {
    /// If true, enable fast tryout feature for this deployed model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub fast_tryout_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl FasterDeploymentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fast_tryout_enabled][crate::model::FasterDeploymentConfig::fast_tryout_enabled].
    pub fn set_fast_tryout_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fast_tryout_enabled = v.into();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl wkt::message::Message for FasterDeploymentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FasterDeploymentConfig"
    }
}

/// Configuration for Speculative Decoding.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeculativeDecodingSpec {
    /// The number of speculative tokens to generate at each step.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub speculative_token_count: i32,

    /// The type of speculation method to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub speculation: std::option::Option<crate::model::speculative_decoding_spec::Speculation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl SpeculativeDecodingSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speculative_token_count][crate::model::SpeculativeDecodingSpec::speculative_token_count].
    pub fn set_speculative_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.speculative_token_count = v.into();
        self
    }

    /// Sets the value of [speculation][crate::model::SpeculativeDecodingSpec::speculation].
    ///
    /// Note that all the setters affecting `speculation` are mutually
    /// exclusive.
    pub fn set_speculation<
        T: std::convert::Into<
                std::option::Option<crate::model::speculative_decoding_spec::Speculation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculation = v.into();
        self
    }

    /// The value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// if it holds a `DraftModelSpeculation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn draft_model_speculation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::speculative_decoding_spec::DraftModelSpeculation>,
    > {
        #[allow(unreachable_patterns)]
        self.speculation.as_ref().and_then(|v| match v {
            crate::model::speculative_decoding_spec::Speculation::DraftModelSpeculation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// if it holds a `NgramSpeculation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ngram_speculation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::speculative_decoding_spec::NgramSpeculation>,
    > {
        #[allow(unreachable_patterns)]
        self.speculation.as_ref().and_then(|v| match v {
            crate::model::speculative_decoding_spec::Speculation::NgramSpeculation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// to hold a `DraftModelSpeculation`.
    ///
    /// Note that all the setters affecting `speculation` are
    /// mutually exclusive.
    pub fn set_draft_model_speculation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::speculative_decoding_spec::DraftModelSpeculation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculation = std::option::Option::Some(
            crate::model::speculative_decoding_spec::Speculation::DraftModelSpeculation(v.into()),
        );
        self
    }

    /// Sets the value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// to hold a `NgramSpeculation`.
    ///
    /// Note that all the setters affecting `speculation` are
    /// mutually exclusive.
    pub fn set_ngram_speculation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::speculative_decoding_spec::NgramSpeculation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculation = std::option::Option::Some(
            crate::model::speculative_decoding_spec::Speculation::NgramSpeculation(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
impl wkt::message::Message for SpeculativeDecodingSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec"
    }
}

/// Defines additional types related to [SpeculativeDecodingSpec].
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
))]
pub mod speculative_decoding_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Draft model speculation works by using the smaller model to generate
    /// candidate tokens for speculative decoding.
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DraftModelSpeculation {
        /// Required. The resource name of the draft model.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub draft_model: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    impl DraftModelSpeculation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [draft_model][crate::model::speculative_decoding_spec::DraftModelSpeculation::draft_model].
        pub fn set_draft_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.draft_model = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    impl wkt::message::Message for DraftModelSpeculation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec.DraftModelSpeculation"
        }
    }

    /// N-Gram speculation works by trying to find matching tokens in the
    /// previous prompt sequence and use those as speculation for generating
    /// new tokens.
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NgramSpeculation {
        /// The number of last N input tokens used as ngram to search/match
        /// against the previous prompt sequence.
        /// This is equal to the N in N-Gram.
        /// The default value is 3 if not specified.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub ngram_size: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    impl NgramSpeculation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ngram_size][crate::model::speculative_decoding_spec::NgramSpeculation::ngram_size].
        pub fn set_ngram_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.ngram_size = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    impl wkt::message::Message for NgramSpeculation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec.NgramSpeculation"
        }
    }

    /// The type of speculation method to use.
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Speculation {
        /// draft model speculation.
        DraftModelSpeculation(
            std::boxed::Box<crate::model::speculative_decoding_spec::DraftModelSpeculation>,
        ),
        /// N-Gram speculation.
        NgramSpeculation(
            std::boxed::Box<crate::model::speculative_decoding_spec::NgramSpeculation>,
        ),
    }
}

/// Request message for
/// [EndpointService.CreateEndpoint][google.cloud.aiplatform.v1.EndpointService.CreateEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.CreateEndpoint]: crate::client::EndpointService::create_endpoint
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEndpointRequest {
    /// Required. The resource name of the Location to create the Endpoint in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Endpoint to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    /// Immutable. The ID to use for endpoint, which will become the final
    /// component of the endpoint resource name.
    /// If not provided, Vertex AI will generate a value for this ID.
    ///
    /// If the first character is a letter, this value may be up to 63 characters,
    /// and valid characters are `[a-z0-9-]`. The last character must be a letter
    /// or number.
    ///
    /// If the first character is a number, this value may be up to 9 characters,
    /// and valid characters are `[0-9]` with no leading zeros.
    ///
    /// When using HTTP/JSON, this field is populated
    /// based on a query string argument, such as `?endpoint_id=12345`. This is the
    /// fallback for fields that are not included in either the URI or the body.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl CreateEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEndpointRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::CreateEndpointRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [endpoint_id][crate::model::CreateEndpointRequest::endpoint_id].
    pub fn set_endpoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint_id = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for CreateEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEndpointRequest"
    }
}

/// Runtime operation information for
/// [EndpointService.CreateEndpoint][google.cloud.aiplatform.v1.EndpointService.CreateEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.CreateEndpoint]: crate::client::EndpointService::create_endpoint
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEndpointOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl CreateEndpointOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateEndpointOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for CreateEndpointOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEndpointOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.GetEndpoint][google.cloud.aiplatform.v1.EndpointService.GetEndpoint]
///
/// [google.cloud.aiplatform.v1.EndpointService.GetEndpoint]: crate::client::EndpointService::get_endpoint
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEndpointRequest {
    /// Required. The name of the Endpoint resource.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl GetEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for GetEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetEndpointRequest"
    }
}

/// Request message for
/// [EndpointService.ListEndpoints][google.cloud.aiplatform.v1.EndpointService.ListEndpoints].
///
/// [google.cloud.aiplatform.v1.EndpointService.ListEndpoints]: crate::client::EndpointService::list_endpoints
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEndpointsRequest {
    /// Required. The resource name of the Location from which to list the
    /// Endpoints. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `endpoint` supports `=` and `!=`. `endpoint` represents the Endpoint
    ///   ID, i.e. the last segment of the Endpoint's
    ///   [resource name][google.cloud.aiplatform.v1.Endpoint.name].
    /// * `display_name` supports `=` and `!=`.
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:*` or `labels:key` - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    /// * `base_model_name` only supports `=`.
    ///
    /// Some examples:
    ///
    /// * `endpoint=1`
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    /// * `baseModelName="text-bison"`
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.name]: crate::model::Endpoint::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListEndpointsResponse.next_page_token][google.cloud.aiplatform.v1.ListEndpointsResponse.next_page_token]
    /// of the previous
    /// [EndpointService.ListEndpoints][google.cloud.aiplatform.v1.EndpointService.ListEndpoints]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.EndpointService.ListEndpoints]: crate::client::EndpointService::list_endpoints
    /// [google.cloud.aiplatform.v1.ListEndpointsResponse.next_page_token]: crate::model::ListEndpointsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl ListEndpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEndpointsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEndpointsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEndpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEndpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEndpointsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEndpointsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for ListEndpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEndpointsRequest"
    }
}

/// Response message for
/// [EndpointService.ListEndpoints][google.cloud.aiplatform.v1.EndpointService.ListEndpoints].
///
/// [google.cloud.aiplatform.v1.EndpointService.ListEndpoints]: crate::client::EndpointService::list_endpoints
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEndpointsResponse {
    /// List of Endpoints in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub endpoints: std::vec::Vec<crate::model::Endpoint>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListEndpointsRequest.page_token][google.cloud.aiplatform.v1.ListEndpointsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListEndpointsRequest.page_token]: crate::model::ListEndpointsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl ListEndpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEndpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::ListEndpointsResponse::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Endpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for ListEndpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEndpointsResponse"
    }
}

#[cfg(feature = "endpoint_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEndpointsResponse {
    type PageItem = crate::model::Endpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.endpoints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [EndpointService.UpdateEndpoint][google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint]: crate::client::EndpointService::update_endpoint
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointRequest {
    /// Required. The Endpoint which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl UpdateEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UpdateEndpointRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEndpointRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for UpdateEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointRequest"
    }
}

/// Request message for
/// [EndpointService.UpdateEndpointLongRunning][google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning].
///
/// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning]: crate::client::EndpointService::update_endpoint_long_running
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointLongRunningRequest {
    /// Required. The Endpoint which replaces the resource on the server. Currently
    /// we only support updating the `client_connection_config` field, all the
    /// other fields' update will be blocked.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl UpdateEndpointLongRunningRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UpdateEndpointLongRunningRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for UpdateEndpointLongRunningRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointLongRunningRequest"
    }
}

/// Runtime operation information for
/// [EndpointService.UpdateEndpointLongRunning][google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning].
///
/// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning]: crate::client::EndpointService::update_endpoint_long_running
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl UpdateEndpointOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateEndpointOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for UpdateEndpointOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.DeleteEndpoint][google.cloud.aiplatform.v1.EndpointService.DeleteEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeleteEndpoint]: crate::client::EndpointService::delete_endpoint
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEndpointRequest {
    /// Required. The name of the Endpoint resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl DeleteEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for DeleteEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteEndpointRequest"
    }
}

/// Request message for
/// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployModelRequest {
    /// Required. The name of the Endpoint resource into which to deploy a Model.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The DeployedModel to be created within the Endpoint. Note that
    /// [Endpoint.traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split]
    /// must be updated for the DeployedModel to start receiving traffic, either as
    /// part of this call, or via
    /// [EndpointService.UpdateEndpoint][google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint].
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    /// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint]: crate::client::EndpointService::update_endpoint
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,

    /// A map from a DeployedModel's ID to the percentage of this Endpoint's
    /// traffic that should be forwarded to that DeployedModel.
    ///
    /// If this field is non-empty, then the Endpoint's
    /// [traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split] will be
    /// overwritten with it. To refer to the ID of the just being deployed Model, a
    /// "0" should be used, and the actual ID of the new DeployedModel will be
    /// filled in its place by this method. The traffic percentage values must add
    /// up to 100.
    ///
    /// If this field is empty, then the Endpoint's
    /// [traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split] is not
    /// updated.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub traffic_split: std::collections::HashMap<std::string::String, i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl DeployModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DeployModelRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model][crate::model::DeployModelRequest::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }

    /// Sets the value of [traffic_split][crate::model::DeployModelRequest::traffic_split].
    pub fn set_traffic_split<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.traffic_split = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for DeployModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelRequest"
    }
}

/// Response message for
/// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployModelResponse {
    /// The DeployedModel that had been deployed in the Endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl DeployModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model][crate::model::DeployModelResponse::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for DeployModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelResponse"
    }
}

/// Runtime operation information for
/// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployModelOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl DeployModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeployModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for DeployModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployModelRequest {
    /// Required. The name of the Endpoint resource from which to undeploy a Model.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The ID of the DeployedModel to be undeployed from the Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// If this field is provided, then the Endpoint's
    /// [traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split] will be
    /// overwritten with it. If last DeployedModel is being undeployed from the
    /// Endpoint, the [Endpoint.traffic_split] will always end up empty when this
    /// call returns. A DeployedModel will be successfully undeployed only if it
    /// doesn't have any traffic assigned to it when this method executes, or if
    /// this field unassigns any traffic to it.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub traffic_split: std::collections::HashMap<std::string::String, i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl UndeployModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UndeployModelRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::UndeployModelRequest::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [traffic_split][crate::model::UndeployModelRequest::traffic_split].
    pub fn set_traffic_split<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.traffic_split = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for UndeployModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelRequest"
    }
}

/// Response message for
/// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployModelResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl UndeployModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for UndeployModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelResponse"
    }
}

/// Runtime operation information for
/// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployModelOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl UndeployModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UndeployModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for UndeployModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.MutateDeployedModel][google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel]: crate::client::EndpointService::mutate_deployed_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedModelRequest {
    /// Required. The name of the Endpoint resource into which to mutate a
    /// DeployedModel. Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The DeployedModel to be mutated within the Endpoint. Only the
    /// following fields can be mutated:
    ///
    /// * `min_replica_count` in either
    ///   [DedicatedResources][google.cloud.aiplatform.v1.DedicatedResources] or
    ///   [AutomaticResources][google.cloud.aiplatform.v1.AutomaticResources]
    /// * `max_replica_count` in either
    ///   [DedicatedResources][google.cloud.aiplatform.v1.DedicatedResources] or
    ///   [AutomaticResources][google.cloud.aiplatform.v1.AutomaticResources]
    /// * [autoscaling_metric_specs][google.cloud.aiplatform.v1.DedicatedResources.autoscaling_metric_specs]
    /// * `disable_container_logging` (v1 only)
    /// * `enable_container_logging` (v1beta1 only)
    ///
    /// [google.cloud.aiplatform.v1.AutomaticResources]: crate::model::AutomaticResources
    /// [google.cloud.aiplatform.v1.DedicatedResources]: crate::model::DedicatedResources
    /// [google.cloud.aiplatform.v1.DedicatedResources.autoscaling_metric_specs]: crate::model::DedicatedResources::autoscaling_metric_specs
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl MutateDeployedModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::MutateDeployedModelRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model][crate::model::MutateDeployedModelRequest::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::MutateDeployedModelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for MutateDeployedModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelRequest"
    }
}

/// Response message for
/// [EndpointService.MutateDeployedModel][google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel]: crate::client::EndpointService::mutate_deployed_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedModelResponse {
    /// The DeployedModel that's being mutated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl MutateDeployedModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model][crate::model::MutateDeployedModelResponse::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for MutateDeployedModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelResponse"
    }
}

/// Runtime operation information for
/// [EndpointService.MutateDeployedModel][google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel]: crate::client::EndpointService::mutate_deployed_model
#[cfg(feature = "endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedModelOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "endpoint_service")]
impl MutateDeployedModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::MutateDeployedModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "endpoint_service")]
impl wkt::message::Message for MutateDeployedModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelOperationMetadata"
    }
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about. For example, driver is an entity type, and
/// driver0 is an instance of an entity type driver.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityType {
    /// Immutable. Name of the EntityType.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    ///
    /// The last part entity_type is assigned by the client. The entity_type can be
    /// up to 64 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z and underscore(_), and ASCII digits 0-9 starting with a letter. The
    /// value will be unique given a featurestore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description of the EntityType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this EntityType was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this EntityType was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize your
    /// EntityTypes.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one EntityType (System
    /// labels are excluded)."
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Used to perform a consistent read-modify-write updates. If not
    /// set, a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The default monitoring configuration for all Features with value
    /// type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) BOOL,
    /// STRING, DOUBLE or INT64 under this EntityType.
    ///
    /// If this is populated with
    /// [FeaturestoreMonitoringConfig.monitoring_interval] specified, snapshot
    /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
    /// disabled.
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitoring_config: std::option::Option<crate::model::FeaturestoreMonitoringConfig>,

    /// Optional. Config for data retention policy in offline storage.
    /// TTL in days for feature values that will be stored in offline storage.
    /// The Feature Store offline storage periodically removes obsolete feature
    /// values older than `offline_storage_ttl_days` since the feature generation
    /// time. If unset (or explicitly set to 0), default to 4000 days TTL.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub offline_storage_ttl_days: i32,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl EntityType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntityType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntityType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EntityType::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EntityType::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::EntityType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::EntityType::monitoring_config].
    pub fn set_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::FeaturestoreMonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_config = v.into();
        self
    }

    /// Sets the value of [offline_storage_ttl_days][crate::model::EntityType::offline_storage_ttl_days].
    pub fn set_offline_storage_ttl_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.offline_storage_ttl_days = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::EntityType::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::EntityType::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntityType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for EntityType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EntityType"
    }
}

/// Represents an environment variable present in a Container or Python Module.
#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvVar {
    /// Required. Name of the environment variable. Must be a valid C identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Variables that reference a $(VAR_NAME) are expanded
    /// using the previous defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. The $(VAR_NAME)
    /// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
    /// references will never be expanded, regardless of whether the variable
    /// exists or not.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
))]
impl EnvVar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnvVar::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EnvVar::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
))]
impl wkt::message::Message for EnvVar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EnvVar"
    }
}

/// Reference to a secret stored in the Cloud Secret Manager that will
/// provide the value for this environment variable.
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretRef {
    /// Required. The name of the secret in Cloud Secret Manager.
    /// Format: {secret_name}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret: std::string::String,

    /// The Cloud Secret Manager secret version.
    /// Can be 'latest' for the latest version, an integer for a specific
    /// version, or a version alias.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl SecretRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret][crate::model::SecretRef::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SecretRef::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for SecretRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SecretRef"
    }
}

/// Represents an environment variable where the value is a secret in Cloud
/// Secret Manager.
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretEnvVar {
    /// Required. Name of the secret environment variable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Reference to a secret stored in the Cloud Secret Manager that
    /// will provide the value for this environment variable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secret_ref: std::option::Option<crate::model::SecretRef>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl SecretEnvVar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecretEnvVar::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [secret_ref][crate::model::SecretEnvVar::secret_ref].
    pub fn set_secret_ref<T: std::convert::Into<std::option::Option<crate::model::SecretRef>>>(
        mut self,
        v: T,
    ) -> Self {
        self.secret_ref = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for SecretEnvVar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SecretEnvVar"
    }
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluatedAnnotation {
    /// Output only. Type of the EvaluatedAnnotation.
    #[serde(rename = "type")]
    pub r#type: crate::model::evaluated_annotation::EvaluatedAnnotationType,

    /// Output only. The model predicted annotations.
    ///
    /// For true positive, there is one and only one prediction, which matches the
    /// only one ground truth annotation in
    /// [ground_truths][google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths].
    ///
    /// For false positive, there is one and only one prediction, which doesn't
    /// match any ground truth annotation of the corresponding
    /// [data_item_view_id][google.cloud.aiplatform.v1.EvaluatedAnnotation.evaluated_data_item_view_id].
    ///
    /// For false negative, there are zero or more predictions which are similar to
    /// the only ground truth annotation in
    /// [ground_truths][google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths]
    /// but not enough for a match.
    ///
    /// The schema of the prediction is stored in
    /// [ModelEvaluation.annotation_schema_uri][google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.evaluated_data_item_view_id]: crate::model::EvaluatedAnnotation::evaluated_data_item_view_id
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths]: crate::model::EvaluatedAnnotation::ground_truths
    /// [google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]: crate::model::ModelEvaluation::annotation_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predictions: std::vec::Vec<wkt::Value>,

    /// Output only. The ground truth Annotations, i.e. the Annotations that exist
    /// in the test data the Model is evaluated on.
    ///
    /// For true positive, there is one and only one ground truth annotation, which
    /// matches the only prediction in
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions].
    ///
    /// For false positive, there are zero or more ground truth annotations that
    /// are similar to the only prediction in
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions],
    /// but not enough for a match.
    ///
    /// For false negative, there is one and only one ground truth annotation,
    /// which doesn't match any predictions created by the model.
    ///
    /// The schema of the ground truth is stored in
    /// [ModelEvaluation.annotation_schema_uri][google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]: crate::model::EvaluatedAnnotation::predictions
    /// [google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]: crate::model::ModelEvaluation::annotation_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ground_truths: std::vec::Vec<wkt::Value>,

    /// Output only. The data item payload that the Model predicted this
    /// EvaluatedAnnotation on.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_item_payload: std::option::Option<wkt::Value>,

    /// Output only. ID of the EvaluatedDataItemView under the same ancestor
    /// ModelEvaluation. The EvaluatedDataItemView consists of all ground truths
    /// and predictions on
    /// [data_item_payload][google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload].
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload]: crate::model::EvaluatedAnnotation::data_item_payload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub evaluated_data_item_view_id: std::string::String,

    /// Explanations of
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions].
    /// Each element of the explanations indicates the explanation for one
    /// explanation Method.
    ///
    /// The attributions list in the
    /// [EvaluatedAnnotationExplanation.explanation][google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation.explanation]
    /// object corresponds to the
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]
    /// list. For example, the second element in the attributions list explains the
    /// second element in the predictions list.
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]: crate::model::EvaluatedAnnotation::predictions
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation.explanation]: crate::model::EvaluatedAnnotationExplanation::explanation
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explanations: std::vec::Vec<crate::model::EvaluatedAnnotationExplanation>,

    /// Annotations of model error analysis results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_analysis_annotations: std::vec::Vec<crate::model::ErrorAnalysisAnnotation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl EvaluatedAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::EvaluatedAnnotation::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::evaluated_annotation::EvaluatedAnnotationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [data_item_payload][crate::model::EvaluatedAnnotation::data_item_payload].
    pub fn set_data_item_payload<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item_payload = v.into();
        self
    }

    /// Sets the value of [evaluated_data_item_view_id][crate::model::EvaluatedAnnotation::evaluated_data_item_view_id].
    pub fn set_evaluated_data_item_view_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluated_data_item_view_id = v.into();
        self
    }

    /// Sets the value of [predictions][crate::model::EvaluatedAnnotation::predictions].
    pub fn set_predictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.predictions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ground_truths][crate::model::EvaluatedAnnotation::ground_truths].
    pub fn set_ground_truths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.ground_truths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [explanations][crate::model::EvaluatedAnnotation::explanations].
    pub fn set_explanations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedAnnotationExplanation>,
    {
        use std::iter::Iterator;
        self.explanations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_analysis_annotations][crate::model::EvaluatedAnnotation::error_analysis_annotations].
    pub fn set_error_analysis_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorAnalysisAnnotation>,
    {
        use std::iter::Iterator;
        self.error_analysis_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for EvaluatedAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluatedAnnotation"
    }
}

/// Defines additional types related to [EvaluatedAnnotation].
#[cfg(feature = "model_service")]
pub mod evaluated_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the type of the EvaluatedAnnotation. The type is determined
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "model_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluatedAnnotationType {
        /// Invalid value.
        Unspecified,
        /// The EvaluatedAnnotation is a true positive. It has a prediction created
        /// by the Model and a ground truth Annotation which the prediction matches.
        TruePositive,
        /// The EvaluatedAnnotation is false positive. It has a prediction created by
        /// the Model which does not match any ground truth annotation.
        FalsePositive,
        /// The EvaluatedAnnotation is false negative. It has a ground truth
        /// annotation which is not matched by any of the model created predictions.
        FalseNegative,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluatedAnnotationType::value] or
        /// [EvaluatedAnnotationType::name].
        UnknownValue(evaluated_annotation_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "model_service")]
    pub mod evaluated_annotation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "model_service")]
    impl EvaluatedAnnotationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TruePositive => std::option::Option::Some(1),
                Self::FalsePositive => std::option::Option::Some(2),
                Self::FalseNegative => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EVALUATED_ANNOTATION_TYPE_UNSPECIFIED")
                }
                Self::TruePositive => std::option::Option::Some("TRUE_POSITIVE"),
                Self::FalsePositive => std::option::Option::Some("FALSE_POSITIVE"),
                Self::FalseNegative => std::option::Option::Some("FALSE_NEGATIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl std::default::Default for EvaluatedAnnotationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "model_service")]
    impl std::fmt::Display for EvaluatedAnnotationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "model_service")]
    impl std::convert::From<i32> for EvaluatedAnnotationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TruePositive,
                2 => Self::FalsePositive,
                3 => Self::FalseNegative,
                _ => Self::UnknownValue(evaluated_annotation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl std::convert::From<&str> for EvaluatedAnnotationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TRUE_POSITIVE" => Self::TruePositive,
                "FALSE_POSITIVE" => Self::FalsePositive,
                "FALSE_NEGATIVE" => Self::FalseNegative,
                _ => Self::UnknownValue(evaluated_annotation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl serde::ser::Serialize for EvaluatedAnnotationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TruePositive => serializer.serialize_i32(1),
                Self::FalsePositive => serializer.serialize_i32(2),
                Self::FalseNegative => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl<'de> serde::de::Deserialize<'de> for EvaluatedAnnotationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<EvaluatedAnnotationType>::new(
                    ".google.cloud.aiplatform.v1.EvaluatedAnnotation.EvaluatedAnnotationType",
                ),
            )
        }
    }
}

/// Explanation result of the prediction produced by the Model.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluatedAnnotationExplanation {
    /// Explanation type.
    ///
    /// For AutoML Image Classification models, possible values are:
    ///
    /// * `image-integrated-gradients`
    /// * `image-xrai`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation_type: std::string::String,

    /// Explanation attribution response details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation: std::option::Option<crate::model::Explanation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl EvaluatedAnnotationExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [explanation_type][crate::model::EvaluatedAnnotationExplanation::explanation_type].
    pub fn set_explanation_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_type = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::EvaluatedAnnotationExplanation::explanation].
    pub fn set_explanation<
        T: std::convert::Into<std::option::Option<crate::model::Explanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for EvaluatedAnnotationExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation"
    }
}

/// Model error analysis for each annotation.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorAnalysisAnnotation {
    /// Attributed items for a given annotation, typically representing neighbors
    /// from the training sets constrained by the query type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attributed_items: std::vec::Vec<crate::model::error_analysis_annotation::AttributedItem>,

    /// The query type used for finding the attributed items.
    pub query_type: crate::model::error_analysis_annotation::QueryType,

    /// The outlier score of this annotated item. Usually defined as the min of all
    /// distances from attributed items.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub outlier_score: f64,

    /// The threshold used to determine if this annotation is an outlier or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub outlier_threshold: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ErrorAnalysisAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_type][crate::model::ErrorAnalysisAnnotation::query_type].
    pub fn set_query_type<
        T: std::convert::Into<crate::model::error_analysis_annotation::QueryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query_type = v.into();
        self
    }

    /// Sets the value of [outlier_score][crate::model::ErrorAnalysisAnnotation::outlier_score].
    pub fn set_outlier_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.outlier_score = v.into();
        self
    }

    /// Sets the value of [outlier_threshold][crate::model::ErrorAnalysisAnnotation::outlier_threshold].
    pub fn set_outlier_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.outlier_threshold = v.into();
        self
    }

    /// Sets the value of [attributed_items][crate::model::ErrorAnalysisAnnotation::attributed_items].
    pub fn set_attributed_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::error_analysis_annotation::AttributedItem>,
    {
        use std::iter::Iterator;
        self.attributed_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ErrorAnalysisAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ErrorAnalysisAnnotation"
    }
}

/// Defines additional types related to [ErrorAnalysisAnnotation].
#[cfg(feature = "model_service")]
pub mod error_analysis_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Attributed items for a given annotation, typically representing neighbors
    /// from the training sets constrained by the query type.
    #[cfg(feature = "model_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AttributedItem {
        /// The unique ID for each annotation. Used by FE to allocate the annotation
        /// in DB.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub annotation_resource_name: std::string::String,

        /// The distance of this item to the annotation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub distance: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_service")]
    impl AttributedItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [annotation_resource_name][crate::model::error_analysis_annotation::AttributedItem::annotation_resource_name].
        pub fn set_annotation_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.annotation_resource_name = v.into();
            self
        }

        /// Sets the value of [distance][crate::model::error_analysis_annotation::AttributedItem::distance].
        pub fn set_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.distance = v.into();
            self
        }
    }

    #[cfg(feature = "model_service")]
    impl wkt::message::Message for AttributedItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ErrorAnalysisAnnotation.AttributedItem"
        }
    }

    /// The query type used for finding the attributed items.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "model_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QueryType {
        /// Unspecified query type for model error analysis.
        Unspecified,
        /// Query similar samples across all classes in the dataset.
        AllSimilar,
        /// Query similar samples from the same class of the input sample.
        SameClassSimilar,
        /// Query dissimilar samples from the same class of the input sample.
        SameClassDissimilar,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QueryType::value] or
        /// [QueryType::name].
        UnknownValue(query_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "model_service")]
    pub mod query_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "model_service")]
    impl QueryType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllSimilar => std::option::Option::Some(1),
                Self::SameClassSimilar => std::option::Option::Some(2),
                Self::SameClassDissimilar => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("QUERY_TYPE_UNSPECIFIED"),
                Self::AllSimilar => std::option::Option::Some("ALL_SIMILAR"),
                Self::SameClassSimilar => std::option::Option::Some("SAME_CLASS_SIMILAR"),
                Self::SameClassDissimilar => std::option::Option::Some("SAME_CLASS_DISSIMILAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl std::default::Default for QueryType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "model_service")]
    impl std::fmt::Display for QueryType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "model_service")]
    impl std::convert::From<i32> for QueryType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllSimilar,
                2 => Self::SameClassSimilar,
                3 => Self::SameClassDissimilar,
                _ => Self::UnknownValue(query_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl std::convert::From<&str> for QueryType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "QUERY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALL_SIMILAR" => Self::AllSimilar,
                "SAME_CLASS_SIMILAR" => Self::SameClassSimilar,
                "SAME_CLASS_DISSIMILAR" => Self::SameClassDissimilar,
                _ => Self::UnknownValue(query_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl serde::ser::Serialize for QueryType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllSimilar => serializer.serialize_i32(1),
                Self::SameClassSimilar => serializer.serialize_i32(2),
                Self::SameClassDissimilar => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "model_service")]
    impl<'de> serde::de::Deserialize<'de> for QueryType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QueryType>::new(
                ".google.cloud.aiplatform.v1.ErrorAnalysisAnnotation.QueryType",
            ))
        }
    }
}

/// Request message for EvaluationService.EvaluateInstances.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluateInstancesRequest {
    /// Required. The resource name of the Location to evaluate the instances.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Instances and specs for evaluation
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metric_inputs: std::option::Option<crate::model::evaluate_instances_request::MetricInputs>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl EvaluateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::EvaluateInstancesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs].
    ///
    /// Note that all the setters affecting `metric_inputs` are mutually
    /// exclusive.
    pub fn set_metric_inputs<
        T: std::convert::Into<
                std::option::Option<crate::model::evaluate_instances_request::MetricInputs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = v.into();
        self
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ExactMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exact_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExactMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ExactMatchInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `BleuInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bleu_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::BleuInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::BleuInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `RougeInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rouge_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::RougeInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::RougeInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `FluencyInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fluency_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FluencyInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::FluencyInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `CoherenceInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn coherence_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CoherenceInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::CoherenceInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SafetyInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn safety_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::SafetyInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SafetyInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `GroundednessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn groundedness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GroundednessInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::GroundednessInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `FulfillmentInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fulfillment_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FulfillmentInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::FulfillmentInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SummarizationQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationQualityInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SummarizationQualityInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PairwiseSummarizationQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pairwise_summarization_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseSummarizationQualityInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PairwiseSummarizationQualityInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SummarizationHelpfulnessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_helpfulness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationHelpfulnessInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SummarizationHelpfulnessInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SummarizationVerbosityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_verbosity_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationVerbosityInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SummarizationVerbosityInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringQualityInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringQualityInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PairwiseQuestionAnsweringQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pairwise_question_answering_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PairwiseQuestionAnsweringQualityInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringRelevanceInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_relevance_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringRelevanceInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringRelevanceInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringHelpfulnessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_helpfulness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringHelpfulnessInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringCorrectnessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_correctness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringCorrectnessInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringCorrectnessInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PointwiseMetricInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pointwise_metric_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PointwiseMetricInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PointwiseMetricInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PairwiseMetricInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pairwise_metric_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseMetricInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PairwiseMetricInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolCallValidInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_call_valid_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolCallValidInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolCallValidInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolNameMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_name_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolNameMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolNameMatchInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolParameterKeyMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_parameter_key_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKeyMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKeyMatchInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolParameterKvMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_parameter_kv_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKVMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKvMatchInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `CometInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn comet_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::CometInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::CometInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `MetricxInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn metricx_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetricxInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::MetricxInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ExactMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_exact_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ExactMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ExactMatchInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `BleuInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_bleu_input<T: std::convert::Into<std::boxed::Box<crate::model::BleuInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::BleuInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `RougeInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_rouge_input<T: std::convert::Into<std::boxed::Box<crate::model::RougeInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::RougeInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `FluencyInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_fluency_input<T: std::convert::Into<std::boxed::Box<crate::model::FluencyInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::FluencyInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `CoherenceInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_coherence_input<
        T: std::convert::Into<std::boxed::Box<crate::model::CoherenceInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::CoherenceInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SafetyInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_safety_input<T: std::convert::Into<std::boxed::Box<crate::model::SafetyInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SafetyInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `GroundednessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_groundedness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::GroundednessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::GroundednessInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `FulfillmentInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_fulfillment_input<
        T: std::convert::Into<std::boxed::Box<crate::model::FulfillmentInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::FulfillmentInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SummarizationQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_summarization_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SummarizationQualityInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PairwiseSummarizationQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pairwise_summarization_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseSummarizationQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PairwiseSummarizationQualityInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SummarizationHelpfulnessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_summarization_helpfulness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationHelpfulnessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SummarizationHelpfulnessInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SummarizationVerbosityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_summarization_verbosity_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationVerbosityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SummarizationVerbosityInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringQualityInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PairwiseQuestionAnsweringQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pairwise_question_answering_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PairwiseQuestionAnsweringQualityInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringRelevanceInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_relevance_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringRelevanceInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringRelevanceInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringHelpfulnessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_helpfulness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringHelpfulnessInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringCorrectnessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_correctness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringCorrectnessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringCorrectnessInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PointwiseMetricInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pointwise_metric_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PointwiseMetricInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PointwiseMetricInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PairwiseMetricInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pairwise_metric_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseMetricInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PairwiseMetricInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolCallValidInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_call_valid_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolCallValidInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolCallValidInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolNameMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_name_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolNameMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolNameMatchInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolParameterKeyMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_parameter_key_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKeyMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKeyMatchInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolParameterKvMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_parameter_kv_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKVMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKvMatchInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `CometInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_comet_input<T: std::convert::Into<std::boxed::Box<crate::model::CometInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::CometInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `MetricxInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_metricx_input<T: std::convert::Into<std::boxed::Box<crate::model::MetricxInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::MetricxInput(v.into()),
        );
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for EvaluateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluateInstancesRequest"
    }
}

/// Defines additional types related to [EvaluateInstancesRequest].
#[cfg(feature = "evaluation_service")]
pub mod evaluate_instances_request {
    #[allow(unused_imports)]
    use super::*;

    /// Instances and specs for evaluation
    #[cfg(feature = "evaluation_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MetricInputs {
        /// Auto metric instances.
        /// Instances and metric spec for exact match metric.
        ExactMatchInput(std::boxed::Box<crate::model::ExactMatchInput>),
        /// Instances and metric spec for bleu metric.
        BleuInput(std::boxed::Box<crate::model::BleuInput>),
        /// Instances and metric spec for rouge metric.
        RougeInput(std::boxed::Box<crate::model::RougeInput>),
        /// LLM-based metric instance.
        /// General text generation metrics, applicable to other categories.
        /// Input for fluency metric.
        FluencyInput(std::boxed::Box<crate::model::FluencyInput>),
        /// Input for coherence metric.
        CoherenceInput(std::boxed::Box<crate::model::CoherenceInput>),
        /// Input for safety metric.
        SafetyInput(std::boxed::Box<crate::model::SafetyInput>),
        /// Input for groundedness metric.
        GroundednessInput(std::boxed::Box<crate::model::GroundednessInput>),
        /// Input for fulfillment metric.
        FulfillmentInput(std::boxed::Box<crate::model::FulfillmentInput>),
        /// Input for summarization quality metric.
        SummarizationQualityInput(std::boxed::Box<crate::model::SummarizationQualityInput>),
        /// Input for pairwise summarization quality metric.
        PairwiseSummarizationQualityInput(
            std::boxed::Box<crate::model::PairwiseSummarizationQualityInput>,
        ),
        /// Input for summarization helpfulness metric.
        SummarizationHelpfulnessInput(std::boxed::Box<crate::model::SummarizationHelpfulnessInput>),
        /// Input for summarization verbosity metric.
        SummarizationVerbosityInput(std::boxed::Box<crate::model::SummarizationVerbosityInput>),
        /// Input for question answering quality metric.
        QuestionAnsweringQualityInput(std::boxed::Box<crate::model::QuestionAnsweringQualityInput>),
        /// Input for pairwise question answering quality metric.
        PairwiseQuestionAnsweringQualityInput(
            std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityInput>,
        ),
        /// Input for question answering relevance metric.
        QuestionAnsweringRelevanceInput(
            std::boxed::Box<crate::model::QuestionAnsweringRelevanceInput>,
        ),
        /// Input for question answering helpfulness
        /// metric.
        QuestionAnsweringHelpfulnessInput(
            std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessInput>,
        ),
        /// Input for question answering correctness
        /// metric.
        QuestionAnsweringCorrectnessInput(
            std::boxed::Box<crate::model::QuestionAnsweringCorrectnessInput>,
        ),
        /// Input for pointwise metric.
        PointwiseMetricInput(std::boxed::Box<crate::model::PointwiseMetricInput>),
        /// Input for pairwise metric.
        PairwiseMetricInput(std::boxed::Box<crate::model::PairwiseMetricInput>),
        /// Tool call metric instances.
        /// Input for tool call valid metric.
        ToolCallValidInput(std::boxed::Box<crate::model::ToolCallValidInput>),
        /// Input for tool name match metric.
        ToolNameMatchInput(std::boxed::Box<crate::model::ToolNameMatchInput>),
        /// Input for tool parameter key match metric.
        ToolParameterKeyMatchInput(std::boxed::Box<crate::model::ToolParameterKeyMatchInput>),
        /// Input for tool parameter key value match metric.
        ToolParameterKvMatchInput(std::boxed::Box<crate::model::ToolParameterKVMatchInput>),
        /// Translation metrics.
        /// Input for Comet metric.
        CometInput(std::boxed::Box<crate::model::CometInput>),
        /// Input for Metricx metric.
        MetricxInput(std::boxed::Box<crate::model::MetricxInput>),
    }
}

/// Response message for EvaluationService.EvaluateInstances.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluateInstancesResponse {
    /// Evaluation results will be served in the same order as presented in
    /// EvaluationRequest.instances.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub evaluation_results:
        std::option::Option<crate::model::evaluate_instances_response::EvaluationResults>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl EvaluateInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results].
    ///
    /// Note that all the setters affecting `evaluation_results` are mutually
    /// exclusive.
    pub fn set_evaluation_results<
        T: std::convert::Into<
                std::option::Option<crate::model::evaluate_instances_response::EvaluationResults>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = v.into();
        self
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ExactMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exact_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExactMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ExactMatchResults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `BleuResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bleu_results(&self) -> std::option::Option<&std::boxed::Box<crate::model::BleuResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::BleuResults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `RougeResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rouge_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RougeResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::RougeResults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `FluencyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fluency_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FluencyResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::FluencyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `CoherenceResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn coherence_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CoherenceResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::CoherenceResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SafetyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn safety_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SafetyResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SafetyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `GroundednessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn groundedness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GroundednessResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::GroundednessResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `FulfillmentResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fulfillment_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FulfillmentResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::FulfillmentResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SummarizationQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationQualityResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PairwiseSummarizationQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pairwise_summarization_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseSummarizationQualityResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseSummarizationQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SummarizationHelpfulnessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_helpfulness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationHelpfulnessResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationHelpfulnessResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SummarizationVerbosityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_verbosity_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationVerbosityResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationVerbosityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringQualityResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PairwiseQuestionAnsweringQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pairwise_question_answering_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseQuestionAnsweringQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringRelevanceResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_relevance_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringRelevanceResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringRelevanceResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringHelpfulnessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_helpfulness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringHelpfulnessResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringCorrectnessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn question_answering_correctness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringCorrectnessResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringCorrectnessResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PointwiseMetricResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pointwise_metric_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PointwiseMetricResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PointwiseMetricResult(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PairwiseMetricResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pairwise_metric_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseMetricResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseMetricResult(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolCallValidResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_call_valid_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolCallValidResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolCallValidResults(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolNameMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_name_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolNameMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolNameMatchResults(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolParameterKeyMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_parameter_key_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKeyMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKeyMatchResults(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolParameterKvMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tool_parameter_kv_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKVMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKvMatchResults(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `CometResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn comet_result(&self) -> std::option::Option<&std::boxed::Box<crate::model::CometResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::CometResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `MetricxResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn metricx_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetricxResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::MetricxResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ExactMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_exact_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ExactMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ExactMatchResults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `BleuResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_bleu_results<T: std::convert::Into<std::boxed::Box<crate::model::BleuResults>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::BleuResults(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `RougeResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_rouge_results<T: std::convert::Into<std::boxed::Box<crate::model::RougeResults>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::RougeResults(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `FluencyResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_fluency_result<
        T: std::convert::Into<std::boxed::Box<crate::model::FluencyResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::FluencyResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `CoherenceResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_coherence_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CoherenceResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::CoherenceResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SafetyResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_safety_result<T: std::convert::Into<std::boxed::Box<crate::model::SafetyResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SafetyResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `GroundednessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_groundedness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::GroundednessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::GroundednessResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `FulfillmentResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_fulfillment_result<
        T: std::convert::Into<std::boxed::Box<crate::model::FulfillmentResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::FulfillmentResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SummarizationQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_summarization_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PairwiseSummarizationQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pairwise_summarization_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseSummarizationQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseSummarizationQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SummarizationHelpfulnessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_summarization_helpfulness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationHelpfulnessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationHelpfulnessResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SummarizationVerbosityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_summarization_verbosity_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationVerbosityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationVerbosityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PairwiseQuestionAnsweringQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pairwise_question_answering_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseQuestionAnsweringQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringRelevanceResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_relevance_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringRelevanceResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringRelevanceResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringHelpfulnessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_helpfulness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringHelpfulnessResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringCorrectnessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_correctness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringCorrectnessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringCorrectnessResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PointwiseMetricResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pointwise_metric_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PointwiseMetricResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PointwiseMetricResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PairwiseMetricResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pairwise_metric_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseMetricResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseMetricResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolCallValidResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_call_valid_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolCallValidResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolCallValidResults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolNameMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_name_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolNameMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolNameMatchResults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolParameterKeyMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_parameter_key_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKeyMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKeyMatchResults(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolParameterKvMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_parameter_kv_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKVMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKvMatchResults(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `CometResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_comet_result<T: std::convert::Into<std::boxed::Box<crate::model::CometResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::CometResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `MetricxResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_metricx_result<
        T: std::convert::Into<std::boxed::Box<crate::model::MetricxResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::MetricxResult(v.into()),
        );
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for EvaluateInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluateInstancesResponse"
    }
}

/// Defines additional types related to [EvaluateInstancesResponse].
#[cfg(feature = "evaluation_service")]
pub mod evaluate_instances_response {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluation results will be served in the same order as presented in
    /// EvaluationRequest.instances.
    #[cfg(feature = "evaluation_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EvaluationResults {
        /// Auto metric evaluation results.
        /// Results for exact match metric.
        ExactMatchResults(std::boxed::Box<crate::model::ExactMatchResults>),
        /// Results for bleu metric.
        BleuResults(std::boxed::Box<crate::model::BleuResults>),
        /// Results for rouge metric.
        RougeResults(std::boxed::Box<crate::model::RougeResults>),
        /// LLM-based metric evaluation result.
        /// General text generation metrics, applicable to other categories.
        /// Result for fluency metric.
        FluencyResult(std::boxed::Box<crate::model::FluencyResult>),
        /// Result for coherence metric.
        CoherenceResult(std::boxed::Box<crate::model::CoherenceResult>),
        /// Result for safety metric.
        SafetyResult(std::boxed::Box<crate::model::SafetyResult>),
        /// Result for groundedness metric.
        GroundednessResult(std::boxed::Box<crate::model::GroundednessResult>),
        /// Result for fulfillment metric.
        FulfillmentResult(std::boxed::Box<crate::model::FulfillmentResult>),
        /// Summarization only metrics.
        /// Result for summarization quality metric.
        SummarizationQualityResult(std::boxed::Box<crate::model::SummarizationQualityResult>),
        /// Result for pairwise summarization quality metric.
        PairwiseSummarizationQualityResult(
            std::boxed::Box<crate::model::PairwiseSummarizationQualityResult>,
        ),
        /// Result for summarization helpfulness metric.
        SummarizationHelpfulnessResult(
            std::boxed::Box<crate::model::SummarizationHelpfulnessResult>,
        ),
        /// Result for summarization verbosity metric.
        SummarizationVerbosityResult(std::boxed::Box<crate::model::SummarizationVerbosityResult>),
        /// Question answering only metrics.
        /// Result for question answering quality metric.
        QuestionAnsweringQualityResult(
            std::boxed::Box<crate::model::QuestionAnsweringQualityResult>,
        ),
        /// Result for pairwise question answering quality metric.
        PairwiseQuestionAnsweringQualityResult(
            std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityResult>,
        ),
        /// Result for question answering relevance metric.
        QuestionAnsweringRelevanceResult(
            std::boxed::Box<crate::model::QuestionAnsweringRelevanceResult>,
        ),
        /// Result for question answering helpfulness metric.
        QuestionAnsweringHelpfulnessResult(
            std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessResult>,
        ),
        /// Result for question answering correctness metric.
        QuestionAnsweringCorrectnessResult(
            std::boxed::Box<crate::model::QuestionAnsweringCorrectnessResult>,
        ),
        /// Generic metrics.
        /// Result for pointwise metric.
        PointwiseMetricResult(std::boxed::Box<crate::model::PointwiseMetricResult>),
        /// Result for pairwise metric.
        PairwiseMetricResult(std::boxed::Box<crate::model::PairwiseMetricResult>),
        /// Tool call metrics.
        /// Results for tool call valid metric.
        ToolCallValidResults(std::boxed::Box<crate::model::ToolCallValidResults>),
        /// Results for tool name match metric.
        ToolNameMatchResults(std::boxed::Box<crate::model::ToolNameMatchResults>),
        /// Results for tool parameter key match  metric.
        ToolParameterKeyMatchResults(std::boxed::Box<crate::model::ToolParameterKeyMatchResults>),
        /// Results for tool parameter key value match metric.
        ToolParameterKvMatchResults(std::boxed::Box<crate::model::ToolParameterKVMatchResults>),
        /// Translation metrics.
        /// Result for Comet metric.
        CometResult(std::boxed::Box<crate::model::CometResult>),
        /// Result for Metricx metric.
        MetricxResult(std::boxed::Box<crate::model::MetricxResult>),
    }
}

/// Input for exact match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchInput {
    /// Required. Spec for exact match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ExactMatchSpec>,

    /// Required. Repeated exact match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ExactMatchInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ExactMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ExactMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExactMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ExactMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExactMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ExactMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchInput"
    }
}

/// Spec for exact match instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ExactMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ExactMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ExactMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ExactMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchInstance"
    }
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchSpec {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ExactMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ExactMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchSpec"
    }
}

/// Results for exact match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchResults {
    /// Output only. Exact match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exact_match_metric_values: std::vec::Vec<crate::model::ExactMatchMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ExactMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exact_match_metric_values][crate::model::ExactMatchResults::exact_match_metric_values].
    pub fn set_exact_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExactMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.exact_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ExactMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchResults"
    }
}

/// Exact match metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchMetricValue {
    /// Output only. Exact match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ExactMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ExactMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ExactMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchMetricValue"
    }
}

/// Input for bleu metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuInput {
    /// Required. Spec for bleu score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::BleuSpec>,

    /// Required. Repeated bleu instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::BleuInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl BleuInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::BleuInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::BleuSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::BleuInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BleuInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for BleuInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuInput"
    }
}

/// Spec for bleu instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl BleuInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::BleuInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::BleuInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for BleuInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuInstance"
    }
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to 1.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuSpec {
    /// Optional. Whether to use_effective_order to compute bleu score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_effective_order: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl BleuSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_effective_order][crate::model::BleuSpec::use_effective_order].
    pub fn set_use_effective_order<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_effective_order = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for BleuSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuSpec"
    }
}

/// Results for bleu metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuResults {
    /// Output only. Bleu metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bleu_metric_values: std::vec::Vec<crate::model::BleuMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl BleuResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bleu_metric_values][crate::model::BleuResults::bleu_metric_values].
    pub fn set_bleu_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BleuMetricValue>,
    {
        use std::iter::Iterator;
        self.bleu_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for BleuResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuResults"
    }
}

/// Bleu metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuMetricValue {
    /// Output only. Bleu score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl BleuMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::BleuMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for BleuMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuMetricValue"
    }
}

/// Input for rouge metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeInput {
    /// Required. Spec for rouge score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::RougeSpec>,

    /// Required. Repeated rouge instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::RougeInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl RougeInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::RougeInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::RougeSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::RougeInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RougeInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for RougeInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeInput"
    }
}

/// Spec for rouge instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl RougeInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::RougeInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::RougeInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for RougeInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeInstance"
    }
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeSpec {
    /// Optional. Supported rouge types are rougen[1-9], rougeL, and rougeLsum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rouge_type: std::string::String,

    /// Optional. Whether to use stemmer to compute rouge score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_stemmer: bool,

    /// Optional. Whether to split summaries while using rougeLsum.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub split_summaries: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl RougeSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rouge_type][crate::model::RougeSpec::rouge_type].
    pub fn set_rouge_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rouge_type = v.into();
        self
    }

    /// Sets the value of [use_stemmer][crate::model::RougeSpec::use_stemmer].
    pub fn set_use_stemmer<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_stemmer = v.into();
        self
    }

    /// Sets the value of [split_summaries][crate::model::RougeSpec::split_summaries].
    pub fn set_split_summaries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.split_summaries = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for RougeSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeSpec"
    }
}

/// Results for rouge metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeResults {
    /// Output only. Rouge metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rouge_metric_values: std::vec::Vec<crate::model::RougeMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl RougeResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rouge_metric_values][crate::model::RougeResults::rouge_metric_values].
    pub fn set_rouge_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RougeMetricValue>,
    {
        use std::iter::Iterator;
        self.rouge_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for RougeResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeResults"
    }
}

/// Rouge metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeMetricValue {
    /// Output only. Rouge score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl RougeMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::RougeMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for RougeMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeMetricValue"
    }
}

/// Input for coherence metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceInput {
    /// Required. Spec for coherence score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::CoherenceSpec>,

    /// Required. Coherence instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::CoherenceInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CoherenceInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::CoherenceInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::CoherenceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CoherenceInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::CoherenceInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CoherenceInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceInput"
    }
}

/// Spec for coherence instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CoherenceInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::CoherenceInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CoherenceInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceInstance"
    }
}

/// Spec for coherence score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceSpec {
    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CoherenceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::CoherenceSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CoherenceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceSpec"
    }
}

/// Spec for coherence result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceResult {
    /// Output only. Coherence score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for coherence score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for coherence score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CoherenceResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::CoherenceResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::CoherenceResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::CoherenceResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CoherenceResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceResult"
    }
}

/// Input for fluency metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencyInput {
    /// Required. Spec for fluency score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::FluencySpec>,

    /// Required. Fluency instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::FluencyInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FluencyInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::FluencyInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::FluencySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::FluencyInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::FluencyInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FluencyInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyInput"
    }
}

/// Spec for fluency instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencyInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FluencyInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::FluencyInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FluencyInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyInstance"
    }
}

/// Spec for fluency score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencySpec {
    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FluencySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::FluencySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FluencySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencySpec"
    }
}

/// Spec for fluency result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencyResult {
    /// Output only. Fluency score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for fluency score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for fluency score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FluencyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::FluencyResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::FluencyResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::FluencyResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FluencyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyResult"
    }
}

/// Input for safety metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyInput {
    /// Required. Spec for safety metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SafetySpec>,

    /// Required. Safety instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SafetyInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SafetyInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SafetyInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::SafetySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SafetyInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SafetyInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SafetyInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyInput"
    }
}

/// Spec for safety instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SafetyInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SafetyInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SafetyInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyInstance"
    }
}

/// Spec for safety metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetySpec {
    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SafetySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::SafetySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SafetySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetySpec"
    }
}

/// Spec for safety result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyResult {
    /// Output only. Safety score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for safety score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for safety score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SafetyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SafetyResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SafetyResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SafetyResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SafetyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyResult"
    }
}

/// Input for groundedness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessInput {
    /// Required. Spec for groundedness metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::GroundednessSpec>,

    /// Required. Groundedness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::GroundednessInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl GroundednessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::GroundednessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::GroundednessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::GroundednessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::GroundednessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for GroundednessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessInput"
    }
}

/// Spec for groundedness instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Background information provided in context used to compare
    /// against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl GroundednessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::GroundednessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [context][crate::model::GroundednessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for GroundednessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessInstance"
    }
}

/// Spec for groundedness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessSpec {
    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl GroundednessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::GroundednessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for GroundednessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessSpec"
    }
}

/// Spec for groundedness result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessResult {
    /// Output only. Groundedness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for groundedness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for groundedness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl GroundednessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::GroundednessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::GroundednessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::GroundednessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for GroundednessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessResult"
    }
}

/// Input for fulfillment metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentInput {
    /// Required. Spec for fulfillment score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::FulfillmentSpec>,

    /// Required. Fulfillment instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::FulfillmentInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FulfillmentInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::FulfillmentInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::FulfillmentSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::FulfillmentInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::FulfillmentInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FulfillmentInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentInput"
    }
}

/// Spec for fulfillment instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Inference instruction prompt to compare prediction with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FulfillmentInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::FulfillmentInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::FulfillmentInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FulfillmentInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentInstance"
    }
}

/// Spec for fulfillment metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentSpec {
    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FulfillmentSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::FulfillmentSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FulfillmentSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentSpec"
    }
}

/// Spec for fulfillment result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentResult {
    /// Output only. Fulfillment score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for fulfillment score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for fulfillment score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl FulfillmentResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::FulfillmentResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::FulfillmentResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::FulfillmentResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for FulfillmentResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentResult"
    }
}

/// Input for summarization quality metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualityInput {
    /// Required. Spec for summarization quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SummarizationQualitySpec>,

    /// Required. Summarization quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SummarizationQualityInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SummarizationQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SummarizationQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationQualityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityInput"
    }
}

/// Spec for summarization quality instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualityInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SummarizationQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::SummarizationQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::SummarizationQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::SummarizationQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityInstance"
    }
}

/// Spec for summarization quality score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualitySpec {
    /// Optional. Whether to use instance.reference to compute summarization
    /// quality.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::SummarizationQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualitySpec"
    }
}

/// Spec for summarization quality result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualityResult {
    /// Output only. Summarization Quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for summarization quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SummarizationQualityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SummarizationQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SummarizationQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityResult"
    }
}

/// Input for pairwise summarization quality metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualityInput {
    /// Required. Spec for pairwise summarization quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PairwiseSummarizationQualitySpec>,

    /// Required. Pairwise summarization quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PairwiseSummarizationQualityInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseSummarizationQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PairwiseSummarizationQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseSummarizationQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PairwiseSummarizationQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseSummarizationQualityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseSummarizationQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityInput"
    }
}

/// Spec for pairwise summarization quality instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualityInstance {
    /// Required. Output of the candidate model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Output of the baseline model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub baseline_prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseSummarizationQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::PairwiseSummarizationQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [baseline_prediction][crate::model::PairwiseSummarizationQualityInstance::baseline_prediction].
    pub fn set_baseline_prediction<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.baseline_prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::PairwiseSummarizationQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::PairwiseSummarizationQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::PairwiseSummarizationQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseSummarizationQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityInstance"
    }
}

/// Spec for pairwise summarization quality score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualitySpec {
    /// Optional. Whether to use instance.reference to compute pairwise
    /// summarization quality.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseSummarizationQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::PairwiseSummarizationQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PairwiseSummarizationQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseSummarizationQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualitySpec"
    }
}

/// Spec for pairwise summarization quality result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualityResult {
    /// Output only. Pairwise summarization prediction choice.
    pub pairwise_choice: crate::model::PairwiseChoice,

    /// Output only. Explanation for summarization quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseSummarizationQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pairwise_choice][crate::model::PairwiseSummarizationQualityResult::pairwise_choice].
    pub fn set_pairwise_choice<T: std::convert::Into<crate::model::PairwiseChoice>>(
        mut self,
        v: T,
    ) -> Self {
        self.pairwise_choice = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PairwiseSummarizationQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::PairwiseSummarizationQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseSummarizationQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityResult"
    }
}

/// Input for summarization helpfulness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessInput {
    /// Required. Spec for summarization helpfulness score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SummarizationHelpfulnessSpec>,

    /// Required. Summarization helpfulness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SummarizationHelpfulnessInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationHelpfulnessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SummarizationHelpfulnessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationHelpfulnessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SummarizationHelpfulnessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationHelpfulnessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationHelpfulnessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessInput"
    }
}

/// Spec for summarization helpfulness instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Optional. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationHelpfulnessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SummarizationHelpfulnessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::SummarizationHelpfulnessInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::SummarizationHelpfulnessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::SummarizationHelpfulnessInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationHelpfulnessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessInstance"
    }
}

/// Spec for summarization helpfulness score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessSpec {
    /// Optional. Whether to use instance.reference to compute summarization
    /// helpfulness.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationHelpfulnessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::SummarizationHelpfulnessSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationHelpfulnessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationHelpfulnessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessSpec"
    }
}

/// Spec for summarization helpfulness result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessResult {
    /// Output only. Summarization Helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for summarization helpfulness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationHelpfulnessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SummarizationHelpfulnessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SummarizationHelpfulnessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SummarizationHelpfulnessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationHelpfulnessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessResult"
    }
}

/// Input for summarization verbosity metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbosityInput {
    /// Required. Spec for summarization verbosity score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SummarizationVerbositySpec>,

    /// Required. Summarization verbosity instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SummarizationVerbosityInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationVerbosityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SummarizationVerbosityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationVerbositySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SummarizationVerbosityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationVerbosityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationVerbosityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityInput"
    }
}

/// Spec for summarization verbosity instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbosityInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Optional. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationVerbosityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SummarizationVerbosityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::SummarizationVerbosityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::SummarizationVerbosityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::SummarizationVerbosityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationVerbosityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityInstance"
    }
}

/// Spec for summarization verbosity score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbositySpec {
    /// Optional. Whether to use instance.reference to compute summarization
    /// verbosity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationVerbositySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::SummarizationVerbositySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationVerbositySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationVerbositySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbositySpec"
    }
}

/// Spec for summarization verbosity result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbosityResult {
    /// Output only. Summarization Verbosity score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for summarization verbosity score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization verbosity score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl SummarizationVerbosityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SummarizationVerbosityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SummarizationVerbosityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SummarizationVerbosityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for SummarizationVerbosityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityResult"
    }
}

/// Input for question answering quality metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualityInput {
    /// Required. Spec for question answering quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringQualitySpec>,

    /// Required. Question answering quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringQualityInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringQualityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityInput"
    }
}

/// Spec for question answering quality instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualityInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Question Answering prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityInstance"
    }
}

/// Spec for question answering quality score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualitySpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// quality.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualitySpec"
    }
}

/// Spec for question answering quality result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualityResult {
    /// Output only. Question Answering Quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringQualityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityResult"
    }
}

/// Input for pairwise question answering quality metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualityInput {
    /// Required. Spec for pairwise question answering quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PairwiseQuestionAnsweringQualitySpec>,

    /// Required. Pairwise question answering quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PairwiseQuestionAnsweringQualityInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseQuestionAnsweringQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PairwiseQuestionAnsweringQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseQuestionAnsweringQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PairwiseQuestionAnsweringQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<
                std::option::Option<crate::model::PairwiseQuestionAnsweringQualityInstance>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseQuestionAnsweringQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInput"
    }
}

/// Spec for pairwise question answering quality instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualityInstance {
    /// Required. Output of the candidate model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Output of the baseline model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub baseline_prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Question Answering prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseQuestionAnsweringQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::PairwiseQuestionAnsweringQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [baseline_prediction][crate::model::PairwiseQuestionAnsweringQualityInstance::baseline_prediction].
    pub fn set_baseline_prediction<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.baseline_prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::PairwiseQuestionAnsweringQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::PairwiseQuestionAnsweringQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::PairwiseQuestionAnsweringQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseQuestionAnsweringQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInstance"
    }
}

/// Spec for pairwise question answering quality score metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualitySpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// quality.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseQuestionAnsweringQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::PairwiseQuestionAnsweringQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PairwiseQuestionAnsweringQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseQuestionAnsweringQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualitySpec"
    }
}

/// Spec for pairwise question answering quality result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualityResult {
    /// Output only. Pairwise question answering prediction choice.
    pub pairwise_choice: crate::model::PairwiseChoice,

    /// Output only. Explanation for question answering quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseQuestionAnsweringQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pairwise_choice][crate::model::PairwiseQuestionAnsweringQualityResult::pairwise_choice].
    pub fn set_pairwise_choice<T: std::convert::Into<crate::model::PairwiseChoice>>(
        mut self,
        v: T,
    ) -> Self {
        self.pairwise_choice = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PairwiseQuestionAnsweringQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::PairwiseQuestionAnsweringQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseQuestionAnsweringQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityResult"
    }
}

/// Input for question answering relevance metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceInput {
    /// Required. Spec for question answering relevance score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringRelevanceSpec>,

    /// Required. Question answering relevance instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringRelevanceInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringRelevanceInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringRelevanceInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringRelevanceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringRelevanceInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringRelevanceInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringRelevanceInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInput"
    }
}

/// Spec for question answering relevance instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Text provided as context to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. The question asked and other instruction in the inference prompt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringRelevanceInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringRelevanceInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringRelevanceInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringRelevanceInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringRelevanceInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringRelevanceInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInstance"
    }
}

/// Spec for question answering relevance metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceSpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// relevance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringRelevanceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringRelevanceSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringRelevanceSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringRelevanceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceSpec"
    }
}

/// Spec for question answering relevance result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceResult {
    /// Output only. Question Answering Relevance score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering relevance score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering relevance score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringRelevanceResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringRelevanceResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringRelevanceResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringRelevanceResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringRelevanceResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceResult"
    }
}

/// Input for question answering helpfulness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessInput {
    /// Required. Spec for question answering helpfulness score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringHelpfulnessSpec>,

    /// Required. Question answering helpfulness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringHelpfulnessInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringHelpfulnessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringHelpfulnessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringHelpfulnessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringHelpfulnessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringHelpfulnessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringHelpfulnessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInput"
    }
}

/// Spec for question answering helpfulness instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Text provided as context to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. The question asked and other instruction in the inference prompt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringHelpfulnessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringHelpfulnessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringHelpfulnessInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringHelpfulnessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringHelpfulnessInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringHelpfulnessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInstance"
    }
}

/// Spec for question answering helpfulness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessSpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// helpfulness.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringHelpfulnessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringHelpfulnessSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringHelpfulnessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringHelpfulnessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessSpec"
    }
}

/// Spec for question answering helpfulness result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessResult {
    /// Output only. Question Answering Helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering helpfulness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringHelpfulnessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringHelpfulnessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringHelpfulnessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringHelpfulnessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringHelpfulnessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessResult"
    }
}

/// Input for question answering correctness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessInput {
    /// Required. Spec for question answering correctness score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringCorrectnessSpec>,

    /// Required. Question answering correctness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringCorrectnessInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringCorrectnessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringCorrectnessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringCorrectnessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringCorrectnessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringCorrectnessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringCorrectnessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInput"
    }
}

/// Spec for question answering correctness instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Text provided as context to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. The question asked and other instruction in the inference prompt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringCorrectnessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringCorrectnessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringCorrectnessInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringCorrectnessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringCorrectnessInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringCorrectnessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInstance"
    }
}

/// Spec for question answering correctness metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessSpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// correctness.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringCorrectnessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringCorrectnessSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringCorrectnessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringCorrectnessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessSpec"
    }
}

/// Spec for question answering correctness result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessResult {
    /// Output only. Question Answering Correctness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering correctness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering correctness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl QuestionAnsweringCorrectnessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringCorrectnessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringCorrectnessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringCorrectnessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for QuestionAnsweringCorrectnessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessResult"
    }
}

/// Input for pointwise metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricInput {
    /// Required. Spec for pointwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PointwiseMetricSpec>,

    /// Required. Pointwise metric instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PointwiseMetricInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PointwiseMetricInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PointwiseMetricInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PointwiseMetricSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PointwiseMetricInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::PointwiseMetricInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PointwiseMetricInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricInput"
    }
}

/// Pointwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricInstance {
    /// Instance for pointwise metric.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::pointwise_metric_instance::Instance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PointwiseMetricInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::PointwiseMetricInstance::instance].
    ///
    /// Note that all the setters affecting `instance` are mutually
    /// exclusive.
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::pointwise_metric_instance::Instance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// The value of [instance][crate::model::PointwiseMetricInstance::instance]
    /// if it holds a `JsonInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_instance(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::pointwise_metric_instance::Instance::JsonInstance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance][crate::model::PointwiseMetricInstance::instance]
    /// to hold a `JsonInstance`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_json_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::pointwise_metric_instance::Instance::JsonInstance(v.into()),
        );
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PointwiseMetricInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricInstance"
    }
}

/// Defines additional types related to [PointwiseMetricInstance].
#[cfg(feature = "evaluation_service")]
pub mod pointwise_metric_instance {
    #[allow(unused_imports)]
    use super::*;

    /// Instance for pointwise metric.
    #[cfg(feature = "evaluation_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Instance {
        /// Instance specified as a json string. String key-value pairs are expected
        /// in the json_instance to render
        /// PointwiseMetricSpec.instance_prompt_template.
        JsonInstance(std::string::String),
    }
}

/// Spec for pointwise metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricSpec {
    /// Required. Metric prompt template for pointwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_prompt_template: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PointwiseMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_prompt_template][crate::model::PointwiseMetricSpec::metric_prompt_template].
    pub fn set_metric_prompt_template<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_prompt_template = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PointwiseMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricSpec"
    }
}

/// Spec for pointwise metric result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricResult {
    /// Output only. Pointwise metric score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for pointwise metric score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PointwiseMetricResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::PointwiseMetricResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PointwiseMetricResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PointwiseMetricResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricResult"
    }
}

/// Input for pairwise metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricInput {
    /// Required. Spec for pairwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PairwiseMetricSpec>,

    /// Required. Pairwise metric instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PairwiseMetricInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseMetricInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PairwiseMetricInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseMetricSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PairwiseMetricInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseMetricInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseMetricInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricInput"
    }
}

/// Pairwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricInstance {
    /// Instance for pairwise metric.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::pairwise_metric_instance::Instance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseMetricInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::PairwiseMetricInstance::instance].
    ///
    /// Note that all the setters affecting `instance` are mutually
    /// exclusive.
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::pairwise_metric_instance::Instance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// The value of [instance][crate::model::PairwiseMetricInstance::instance]
    /// if it holds a `JsonInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_instance(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::pairwise_metric_instance::Instance::JsonInstance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance][crate::model::PairwiseMetricInstance::instance]
    /// to hold a `JsonInstance`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_json_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::pairwise_metric_instance::Instance::JsonInstance(v.into()),
        );
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseMetricInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricInstance"
    }
}

/// Defines additional types related to [PairwiseMetricInstance].
#[cfg(feature = "evaluation_service")]
pub mod pairwise_metric_instance {
    #[allow(unused_imports)]
    use super::*;

    /// Instance for pairwise metric.
    #[cfg(feature = "evaluation_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Instance {
        /// Instance specified as a json string. String key-value pairs are expected
        /// in the json_instance to render
        /// PairwiseMetricSpec.instance_prompt_template.
        JsonInstance(std::string::String),
    }
}

/// Spec for pairwise metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricSpec {
    /// Required. Metric prompt template for pairwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_prompt_template: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_prompt_template][crate::model::PairwiseMetricSpec::metric_prompt_template].
    pub fn set_metric_prompt_template<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_prompt_template = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricSpec"
    }
}

/// Spec for pairwise metric result.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricResult {
    /// Output only. Pairwise metric choice.
    pub pairwise_choice: crate::model::PairwiseChoice,

    /// Output only. Explanation for pairwise metric score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl PairwiseMetricResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pairwise_choice][crate::model::PairwiseMetricResult::pairwise_choice].
    pub fn set_pairwise_choice<T: std::convert::Into<crate::model::PairwiseChoice>>(
        mut self,
        v: T,
    ) -> Self {
        self.pairwise_choice = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PairwiseMetricResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for PairwiseMetricResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricResult"
    }
}

/// Input for tool call valid metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidInput {
    /// Required. Spec for tool call valid metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolCallValidSpec>,

    /// Required. Repeated tool call valid instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolCallValidInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolCallValidInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolCallValidInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolCallValidSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolCallValidInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolCallValidInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolCallValidInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidInput"
    }
}

/// Spec for tool call valid metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidSpec {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolCallValidSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolCallValidSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidSpec"
    }
}

/// Spec for tool call valid instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolCallValidInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolCallValidInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolCallValidInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolCallValidInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidInstance"
    }
}

/// Results for tool call valid metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidResults {
    /// Output only. Tool call valid metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_call_valid_metric_values: std::vec::Vec<crate::model::ToolCallValidMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolCallValidResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_call_valid_metric_values][crate::model::ToolCallValidResults::tool_call_valid_metric_values].
    pub fn set_tool_call_valid_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolCallValidMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_call_valid_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolCallValidResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidResults"
    }
}

/// Tool call valid metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidMetricValue {
    /// Output only. Tool call valid score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolCallValidMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolCallValidMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolCallValidMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidMetricValue"
    }
}

/// Input for tool name match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchInput {
    /// Required. Spec for tool name match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolNameMatchSpec>,

    /// Required. Repeated tool name match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolNameMatchInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolNameMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolNameMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolNameMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolNameMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolNameMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolNameMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchInput"
    }
}

/// Spec for tool name match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchSpec {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolNameMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolNameMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchSpec"
    }
}

/// Spec for tool name match instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolNameMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolNameMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolNameMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolNameMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchInstance"
    }
}

/// Results for tool name match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchResults {
    /// Output only. Tool name match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_name_match_metric_values: std::vec::Vec<crate::model::ToolNameMatchMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolNameMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_name_match_metric_values][crate::model::ToolNameMatchResults::tool_name_match_metric_values].
    pub fn set_tool_name_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolNameMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_name_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolNameMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchResults"
    }
}

/// Tool name match metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchMetricValue {
    /// Output only. Tool name match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolNameMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolNameMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolNameMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchMetricValue"
    }
}

/// Input for tool parameter key match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchInput {
    /// Required. Spec for tool parameter key match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolParameterKeyMatchSpec>,

    /// Required. Repeated tool parameter key match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolParameterKeyMatchInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKeyMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolParameterKeyMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolParameterKeyMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolParameterKeyMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKeyMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKeyMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchInput"
    }
}

/// Spec for tool parameter key match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchSpec {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKeyMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKeyMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchSpec"
    }
}

/// Spec for tool parameter key match instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKeyMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolParameterKeyMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolParameterKeyMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKeyMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchInstance"
    }
}

/// Results for tool parameter key match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchResults {
    /// Output only. Tool parameter key match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_parameter_key_match_metric_values:
        std::vec::Vec<crate::model::ToolParameterKeyMatchMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKeyMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_parameter_key_match_metric_values][crate::model::ToolParameterKeyMatchResults::tool_parameter_key_match_metric_values].
    pub fn set_tool_parameter_key_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKeyMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_parameter_key_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKeyMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchResults"
    }
}

/// Tool parameter key match metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchMetricValue {
    /// Output only. Tool parameter key match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKeyMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolParameterKeyMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKeyMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchMetricValue"
    }
}

/// Input for tool parameter key value match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchInput {
    /// Required. Spec for tool parameter key value match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolParameterKVMatchSpec>,

    /// Required. Repeated tool parameter key value match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolParameterKVMatchInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKVMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolParameterKVMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolParameterKVMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolParameterKVMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKVMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKVMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchInput"
    }
}

/// Spec for tool parameter key value match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchSpec {
    /// Optional. Whether to use STRICT string match on parameter values.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_strict_string_match: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKVMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_strict_string_match][crate::model::ToolParameterKVMatchSpec::use_strict_string_match].
    pub fn set_use_strict_string_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_strict_string_match = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKVMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchSpec"
    }
}

/// Spec for tool parameter key value match instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKVMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolParameterKVMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolParameterKVMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKVMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchInstance"
    }
}

/// Results for tool parameter key value match metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchResults {
    /// Output only. Tool parameter key value match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_parameter_kv_match_metric_values:
        std::vec::Vec<crate::model::ToolParameterKVMatchMetricValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKVMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_parameter_kv_match_metric_values][crate::model::ToolParameterKVMatchResults::tool_parameter_kv_match_metric_values].
    pub fn set_tool_parameter_kv_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKVMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_parameter_kv_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKVMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchResults"
    }
}

/// Tool parameter key value match metric value for an instance.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchMetricValue {
    /// Output only. Tool parameter key value match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl ToolParameterKVMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolParameterKVMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for ToolParameterKVMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchMetricValue"
    }
}

/// Input for Comet metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometInput {
    /// Required. Spec for comet metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::CometSpec>,

    /// Required. Comet instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::CometInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CometInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::CometInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::CometSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CometInput::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::CometInstance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CometInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometInput"
    }
}

/// Spec for Comet metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometSpec {
    /// Required. Which version to use for evaluation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::comet_spec::CometVersion>,

    /// Optional. Source language in BCP-47 format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language: std::string::String,

    /// Optional. Target language in BCP-47 format. Covers both prediction and
    /// reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CometSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::CometSpec::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::comet_spec::CometVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [source_language][crate::model::CometSpec::source_language].
    pub fn set_source_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_language = v.into();
        self
    }

    /// Sets the value of [target_language][crate::model::CometSpec::target_language].
    pub fn set_target_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_language = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CometSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometSpec"
    }
}

/// Defines additional types related to [CometSpec].
#[cfg(feature = "evaluation_service")]
pub mod comet_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Comet version options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "evaluation_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CometVersion {
        /// Comet version unspecified.
        Unspecified,
        /// Comet 22 for translation + source + reference
        /// (source-reference-combined).
        Comet22SrcRef,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CometVersion::value] or
        /// [CometVersion::name].
        UnknownValue(comet_version::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "evaluation_service")]
    pub mod comet_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "evaluation_service")]
    impl CometVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Comet22SrcRef => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMET_VERSION_UNSPECIFIED"),
                Self::Comet22SrcRef => std::option::Option::Some("COMET_22_SRC_REF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::default::Default for CometVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::fmt::Display for CometVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::convert::From<i32> for CometVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Comet22SrcRef,
                _ => Self::UnknownValue(comet_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::convert::From<&str> for CometVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMET_VERSION_UNSPECIFIED" => Self::Unspecified,
                "COMET_22_SRC_REF" => Self::Comet22SrcRef,
                _ => Self::UnknownValue(comet_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl serde::ser::Serialize for CometVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Comet22SrcRef => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl<'de> serde::de::Deserialize<'de> for CometVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CometVersion>::new(
                ".google.cloud.aiplatform.v1.CometSpec.CometVersion",
            ))
        }
    }
}

/// Spec for Comet instance - The fields used for evaluation are dependent on the
/// comet version.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Source text in original language.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CometInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::CometInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::CometInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CometInstance::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CometInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometInstance"
    }
}

/// Spec for Comet result - calculates the comet score for the given instance
/// using the version specified in the spec.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometResult {
    /// Output only. Comet score. Range depends on version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl CometResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::CometResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for CometResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometResult"
    }
}

/// Input for MetricX metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxInput {
    /// Required. Spec for Metricx metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::MetricxSpec>,

    /// Required. Metricx instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::MetricxInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl MetricxInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::MetricxInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::MetricxSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::MetricxInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::MetricxInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for MetricxInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxInput"
    }
}

/// Spec for MetricX metric.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxSpec {
    /// Required. Which version to use for evaluation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::metricx_spec::MetricxVersion>,

    /// Optional. Source language in BCP-47 format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language: std::string::String,

    /// Optional. Target language in BCP-47 format. Covers both prediction and
    /// reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl MetricxSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::MetricxSpec::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::metricx_spec::MetricxVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [source_language][crate::model::MetricxSpec::source_language].
    pub fn set_source_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_language = v.into();
        self
    }

    /// Sets the value of [target_language][crate::model::MetricxSpec::target_language].
    pub fn set_target_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_language = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for MetricxSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxSpec"
    }
}

/// Defines additional types related to [MetricxSpec].
#[cfg(feature = "evaluation_service")]
pub mod metricx_spec {
    #[allow(unused_imports)]
    use super::*;

    /// MetricX Version options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "evaluation_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetricxVersion {
        /// MetricX version unspecified.
        Unspecified,
        /// MetricX 2024 (2.6) for translation + reference (reference-based).
        Metricx24Ref,
        /// MetricX 2024 (2.6) for translation + source (QE).
        Metricx24Src,
        /// MetricX 2024 (2.6) for translation + source + reference
        /// (source-reference-combined).
        Metricx24SrcRef,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetricxVersion::value] or
        /// [MetricxVersion::name].
        UnknownValue(metricx_version::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "evaluation_service")]
    pub mod metricx_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "evaluation_service")]
    impl MetricxVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Metricx24Ref => std::option::Option::Some(1),
                Self::Metricx24Src => std::option::Option::Some(2),
                Self::Metricx24SrcRef => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METRICX_VERSION_UNSPECIFIED"),
                Self::Metricx24Ref => std::option::Option::Some("METRICX_24_REF"),
                Self::Metricx24Src => std::option::Option::Some("METRICX_24_SRC"),
                Self::Metricx24SrcRef => std::option::Option::Some("METRICX_24_SRC_REF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::default::Default for MetricxVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::fmt::Display for MetricxVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::convert::From<i32> for MetricxVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Metricx24Ref,
                2 => Self::Metricx24Src,
                3 => Self::Metricx24SrcRef,
                _ => Self::UnknownValue(metricx_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl std::convert::From<&str> for MetricxVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METRICX_VERSION_UNSPECIFIED" => Self::Unspecified,
                "METRICX_24_REF" => Self::Metricx24Ref,
                "METRICX_24_SRC" => Self::Metricx24Src,
                "METRICX_24_SRC_REF" => Self::Metricx24SrcRef,
                _ => Self::UnknownValue(metricx_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl serde::ser::Serialize for MetricxVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Metricx24Ref => serializer.serialize_i32(1),
                Self::Metricx24Src => serializer.serialize_i32(2),
                Self::Metricx24SrcRef => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "evaluation_service")]
    impl<'de> serde::de::Deserialize<'de> for MetricxVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricxVersion>::new(
                ".google.cloud.aiplatform.v1.MetricxSpec.MetricxVersion",
            ))
        }
    }
}

/// Spec for MetricX instance - The fields used for evaluation are dependent on
/// the MetricX version.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Source text in original language.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl MetricxInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::MetricxInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::MetricxInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [source][crate::model::MetricxInstance::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for MetricxInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxInstance"
    }
}

/// Spec for MetricX result - calculates the MetricX score for the given instance
/// using the version specified in the spec.
#[cfg(feature = "evaluation_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxResult {
    /// Output only. MetricX score. Range depends on version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "evaluation_service")]
impl MetricxResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::MetricxResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

#[cfg(feature = "evaluation_service")]
impl wkt::message::Message for MetricxResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxResult"
    }
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Required. The relative resource name of the Artifact in the Event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact: std::string::String,

    /// Output only. The relative resource name of the Execution in the Event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,

    /// Output only. Time the Event occurred.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_time: std::option::Option<wkt::Timestamp>,

    /// Required. The type of the Event.
    #[serde(rename = "type")]
    pub r#type: crate::model::event::Type,

    /// The labels with user-defined metadata to annotate Events.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Event (System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact][crate::model::Event::artifact].
    pub fn set_artifact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::Event::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::Event::event_time].
    pub fn set_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Event::type].
    pub fn set_type<T: std::convert::Into<crate::model::event::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Event::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Event"
    }
}

/// Defines additional types related to [Event].
#[cfg(feature = "metadata_service")]
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Describes whether an Event's Artifact is the Execution's input or output.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "metadata_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified whether input or output of the Execution.
        Unspecified,
        /// An input of the Execution.
        Input,
        /// An output of the Execution.
        Output,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "metadata_service")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "metadata_service")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Input => std::option::Option::Some(1),
                Self::Output => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Input => std::option::Option::Some("INPUT"),
                Self::Output => std::option::Option::Some("OUTPUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Input,
                2 => Self::Output,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INPUT" => Self::Input,
                "OUTPUT" => Self::Output,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Input => serializer.serialize_i32(1),
                Self::Output => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.aiplatform.v1.Event.Type",
            ))
        }
    }
}

/// Instance of a general execution.
#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Execution {
    /// Output only. The resource name of the Execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name of the Execution.
    /// May be up to 128 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The state of this Execution. This is a property of the Execution, and does
    /// not imply or capture any ongoing process. This property is managed by
    /// clients (such as Vertex AI Pipelines) and the system does not prescribe
    /// or check the validity of state transitions.
    pub state: crate::model::execution::State,

    /// An eTag used to perform consistent read-modify-write updates. If not set, a
    /// blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Executions.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Execution (System
    /// labels are excluded).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Execution was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Execution was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The title of the schema describing the metadata.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_title: std::string::String,

    /// The version of the schema in `schema_title` to use.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Properties of the Execution.
    /// Top level metadata keys' heading and trailing spaces will be trimmed.
    /// The size of this field should not exceed 200KB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Description of the Execution
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
impl Execution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Execution::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Execution::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Execution::state].
    pub fn set_state<T: std::convert::Into<crate::model::execution::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Execution::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Execution::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Execution::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [schema_title][crate::model::Execution::schema_title].
    pub fn set_schema_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_title = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::Execution::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Execution::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Execution::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Execution::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
impl wkt::message::Message for Execution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Execution"
    }
}

/// Defines additional types related to [Execution].
#[cfg(any(
    feature = "metadata_service",
    feature = "pipeline_service",
    feature = "schedule_service",
))]
pub mod execution {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the state of the Execution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Execution state
        Unspecified,
        /// The Execution is new
        New,
        /// The Execution is running
        Running,
        /// The Execution has finished running
        Complete,
        /// The Execution has failed
        Failed,
        /// The Execution completed through Cache hit.
        Cached,
        /// The Execution was cancelled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::New => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Complete => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Cached => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::New => std::option::Option::Some("NEW"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cached => std::option::Option::Some("CACHED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::New,
                2 => Self::Running,
                3 => Self::Complete,
                4 => Self::Failed,
                5 => Self::Cached,
                6 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NEW" => Self::New,
                "RUNNING" => Self::Running,
                "COMPLETE" => Self::Complete,
                "FAILED" => Self::Failed,
                "CACHED" => Self::Cached,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::New => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Complete => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Cached => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "metadata_service",
        feature = "pipeline_service",
        feature = "schedule_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.Execution.State",
            ))
        }
    }
}

/// Explanation of a prediction (provided in
/// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions])
/// produced by the Model on a given
/// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances].
///
/// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
/// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
#[cfg(any(feature = "model_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Explanation {
    /// Output only. Feature attributions grouped by predicted outputs.
    ///
    /// For Models that predict only one output, such as regression Models that
    /// predict only one score, there is only one attibution that explains the
    /// predicted output. For Models that predict multiple outputs, such as
    /// multiclass Models that predict multiple classes, each element explains one
    /// specific item.
    /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// can be used to identify which output this attribution is explaining.
    ///
    /// By default, we provide Shapley values for the predicted class. However,
    /// you can configure the explanation request to generate Shapley values for
    /// any other classes too. For example, if a model predicts a probability of
    /// `0.4` for approving a loan application, the model's decision is to reject
    /// the application since `p(reject) = 0.6 > p(approve) = 0.4`, and the default
    /// Shapley values would be computed for rejection decision and not approval,
    /// even though the latter might be the positive class.
    ///
    /// If users set
    /// [ExplanationParameters.top_k][google.cloud.aiplatform.v1.ExplanationParameters.top_k],
    /// the attributions are sorted by
    /// [instance_output_value][google.cloud.aiplatform.v1.Attribution.instance_output_value]
    /// in descending order. If
    /// [ExplanationParameters.output_indices][google.cloud.aiplatform.v1.ExplanationParameters.output_indices]
    /// is specified, the attributions are stored by
    /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// in the same order as they appear in the output_indices.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.instance_output_value]: crate::model::Attribution::instance_output_value
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationParameters.output_indices]: crate::model::ExplanationParameters::output_indices
    /// [google.cloud.aiplatform.v1.ExplanationParameters.top_k]: crate::model::ExplanationParameters::top_k
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attributions: std::vec::Vec<crate::model::Attribution>,

    /// Output only. List of the nearest neighbors for example-based explanations.
    ///
    /// For models deployed with the examples explanations feature enabled, the
    /// attributions field is empty and instead the neighbors field is populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub neighbors: std::vec::Vec<crate::model::Neighbor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "model_service", feature = "prediction_service",))]
impl Explanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributions][crate::model::Explanation::attributions].
    pub fn set_attributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attribution>,
    {
        use std::iter::Iterator;
        self.attributions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [neighbors][crate::model::Explanation::neighbors].
    pub fn set_neighbors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Neighbor>,
    {
        use std::iter::Iterator;
        self.neighbors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "model_service", feature = "prediction_service",))]
impl wkt::message::Message for Explanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Explanation"
    }
}

/// Aggregated explanation metrics for a Model over a set of instances.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelExplanation {
    /// Output only. Aggregated attributions explaining the Model's prediction
    /// outputs over the set of instances. The attributions are grouped by outputs.
    ///
    /// For Models that predict only one output, such as regression Models that
    /// predict only one score, there is only one attibution that explains the
    /// predicted output. For Models that predict multiple outputs, such as
    /// multiclass Models that predict multiple classes, each element explains one
    /// specific item.
    /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// can be used to identify which output this attribution is explaining.
    ///
    /// The
    /// [baselineOutputValue][google.cloud.aiplatform.v1.Attribution.baseline_output_value],
    /// [instanceOutputValue][google.cloud.aiplatform.v1.Attribution.instance_output_value]
    /// and
    /// [featureAttributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// fields are averaged over the test data.
    ///
    /// NOTE: Currently AutoML tabular classification Models produce only one
    /// attribution, which averages attributions over all the classes it predicts.
    /// [Attribution.approximation_error][google.cloud.aiplatform.v1.Attribution.approximation_error]
    /// is not populated.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.approximation_error]: crate::model::Attribution::approximation_error
    /// [google.cloud.aiplatform.v1.Attribution.baseline_output_value]: crate::model::Attribution::baseline_output_value
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    /// [google.cloud.aiplatform.v1.Attribution.instance_output_value]: crate::model::Attribution::instance_output_value
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mean_attributions: std::vec::Vec<crate::model::Attribution>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ModelExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mean_attributions][crate::model::ModelExplanation::mean_attributions].
    pub fn set_mean_attributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attribution>,
    {
        use std::iter::Iterator;
        self.mean_attributions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ModelExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelExplanation"
    }
}

/// Attribution that explains a particular prediction output.
#[cfg(any(feature = "model_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Attribution {
    /// Output only. Model predicted output if the input instance is constructed
    /// from the baselines of all the features defined in
    /// [ExplanationMetadata.inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    /// The field name of the output is determined by the key in
    /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
    ///
    /// If the Model's predicted output has multiple dimensions (rank > 1), this is
    /// the value in the output located by
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index].
    ///
    /// If there are multiple baselines, their output values are averaged.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.outputs]: crate::model::ExplanationMetadata::outputs
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub baseline_output_value: f64,

    /// Output only. Model predicted output on the corresponding [explanation
    /// instance][ExplainRequest.instances]. The field name of the output is
    /// determined by the key in
    /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
    ///
    /// If the Model predicted output has multiple dimensions, this is the value in
    /// the output located by
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index].
    ///
    /// [ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.outputs]: crate::model::ExplanationMetadata::outputs
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub instance_output_value: f64,

    /// Output only. Attributions of each explained feature. Features are extracted
    /// from the [prediction
    /// instances][google.cloud.aiplatform.v1.ExplainRequest.instances] according
    /// to [explanation metadata for
    /// inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    ///
    /// The value is a struct, whose keys are the name of the feature. The values
    /// are how much the feature in the
    /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances] contributed
    /// to the predicted result.
    ///
    /// The format of the value is determined by the feature's input format:
    ///
    /// * If the feature is a scalar value, the attribution value is a
    ///   [floating number][google.protobuf.Value.number_value].
    ///
    /// * If the feature is an array of scalar values, the attribution value is
    ///   an [array][google.protobuf.Value.list_value].
    ///
    /// * If the feature is a struct, the attribution value is a
    ///   [struct][google.protobuf.Value.struct_value]. The keys in the
    ///   attribution value struct are the same as the keys in the feature
    ///   struct. The formats of the values in the attribution struct are
    ///   determined by the formats of the values in the feature struct.
    ///
    ///
    /// The
    /// [ExplanationMetadata.feature_attributions_schema_uri][google.cloud.aiplatform.v1.ExplanationMetadata.feature_attributions_schema_uri]
    /// field, pointed to by the
    /// [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] field of the
    /// [Endpoint.deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
    /// object, points to the schema file that describes the features and their
    /// attribution values (if it is populated).
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.deployed_models]: crate::model::Endpoint::deployed_models
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.feature_attributions_schema_uri]: crate::model::ExplanationMetadata::feature_attributions_schema_uri
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    /// [google.cloud.aiplatform.v1.ExplanationSpec]: crate::model::ExplanationSpec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_attributions: std::option::Option<wkt::Value>,

    /// Output only. The index that locates the explained prediction output.
    ///
    /// If the prediction output is a scalar value, output_index is not populated.
    /// If the prediction output has multiple dimensions, the length of the
    /// output_index list is the same as the number of dimensions of the output.
    /// The i-th element in output_index is the element index of the i-th dimension
    /// of the output vector. Indices start from 0.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub output_index: std::vec::Vec<i32>,

    /// Output only. The display name of the output identified by
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index]. For
    /// example, the predicted class name by a multi-classification Model.
    ///
    /// This field is only populated iff the Model predicts display names as a
    /// separate field along with the explained output. The predicted display name
    /// must has the same shape of the explained output, and can be located using
    /// output_index.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_display_name: std::string::String,

    /// Output only. Error of
    /// [feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// caused by approximation used in the explanation method. Lower value means
    /// more precise attributions.
    ///
    /// * For Sampled Shapley
    ///   [attribution][google.cloud.aiplatform.v1.ExplanationParameters.sampled_shapley_attribution],
    ///   increasing
    ///   [path_count][google.cloud.aiplatform.v1.SampledShapleyAttribution.path_count]
    ///   might reduce the error.
    /// * For Integrated Gradients
    ///   [attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution],
    ///   increasing
    ///   [step_count][google.cloud.aiplatform.v1.IntegratedGradientsAttribution.step_count]
    ///   might reduce the error.
    /// * For [XRAI
    ///   attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution],
    ///   increasing
    ///   [step_count][google.cloud.aiplatform.v1.XraiAttribution.step_count] might
    ///   reduce the error.
    ///
    /// See [this introduction](/vertex-ai/docs/explainable-ai/overview)
    /// for more information.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
    /// [google.cloud.aiplatform.v1.ExplanationParameters.sampled_shapley_attribution]: crate::model::ExplanationParameters::method
    /// [google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]: crate::model::ExplanationParameters::method
    /// [google.cloud.aiplatform.v1.IntegratedGradientsAttribution.step_count]: crate::model::IntegratedGradientsAttribution::step_count
    /// [google.cloud.aiplatform.v1.SampledShapleyAttribution.path_count]: crate::model::SampledShapleyAttribution::path_count
    /// [google.cloud.aiplatform.v1.XraiAttribution.step_count]: crate::model::XraiAttribution::step_count
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub approximation_error: f64,

    /// Output only. Name of the explain output. Specified as the key in
    /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.outputs]: crate::model::ExplanationMetadata::outputs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "model_service", feature = "prediction_service",))]
impl Attribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [baseline_output_value][crate::model::Attribution::baseline_output_value].
    pub fn set_baseline_output_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.baseline_output_value = v.into();
        self
    }

    /// Sets the value of [instance_output_value][crate::model::Attribution::instance_output_value].
    pub fn set_instance_output_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.instance_output_value = v.into();
        self
    }

    /// Sets the value of [feature_attributions][crate::model::Attribution::feature_attributions].
    pub fn set_feature_attributions<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_attributions = v.into();
        self
    }

    /// Sets the value of [output_display_name][crate::model::Attribution::output_display_name].
    pub fn set_output_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_display_name = v.into();
        self
    }

    /// Sets the value of [approximation_error][crate::model::Attribution::approximation_error].
    pub fn set_approximation_error<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.approximation_error = v.into();
        self
    }

    /// Sets the value of [output_name][crate::model::Attribution::output_name].
    pub fn set_output_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_name = v.into();
        self
    }

    /// Sets the value of [output_index][crate::model::Attribution::output_index].
    pub fn set_output_index<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.output_index = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "model_service", feature = "prediction_service",))]
impl wkt::message::Message for Attribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Attribution"
    }
}

/// Neighbors for example-based explanations.
#[cfg(any(feature = "model_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Neighbor {
    /// Output only. The neighbor id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub neighbor_id: std::string::String,

    /// Output only. The neighbor distance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub neighbor_distance: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "model_service", feature = "prediction_service",))]
impl Neighbor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_id][crate::model::Neighbor::neighbor_id].
    pub fn set_neighbor_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.neighbor_id = v.into();
        self
    }

    /// Sets the value of [neighbor_distance][crate::model::Neighbor::neighbor_distance].
    pub fn set_neighbor_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.neighbor_distance = v.into();
        self
    }
}

#[cfg(any(feature = "model_service", feature = "prediction_service",))]
impl wkt::message::Message for Neighbor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Neighbor"
    }
}

/// Specification of Model explanation.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationSpec {
    /// Required. Parameters that configure explaining of the Model's predictions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::ExplanationParameters>,

    /// Optional. Metadata describing the Model's input and output for explanation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::ExplanationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl ExplanationSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::ExplanationSpec::parameters].
    pub fn set_parameters<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ExplanationSpec::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for ExplanationSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationSpec"
    }
}

/// Parameters to configure explaining for Model's predictions.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationParameters {
    /// If populated, returns attributions for top K indices of outputs
    /// (defaults to 1). Only applies to Models that predicts more than one outputs
    /// (e,g, multi-class Models). When set to -1, returns explanations for all
    /// outputs.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub top_k: i32,

    /// If populated, only returns attributions that have
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// contained in output_indices. It must be an ndarray of integers, with the
    /// same shape of the output it's explaining.
    ///
    /// If not populated, returns attributions for
    /// [top_k][google.cloud.aiplatform.v1.ExplanationParameters.top_k] indices of
    /// outputs. If neither top_k nor output_indices is populated, returns the
    /// argmax index of the outputs.
    ///
    /// Only applicable to Models that predict multiple outputs (e,g, multi-class
    /// Models that predict multiple classes).
    ///
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationParameters.top_k]: crate::model::ExplanationParameters::top_k
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_indices: std::option::Option<wkt::ListValue>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::explanation_parameters::Method>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl ExplanationParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top_k][crate::model::ExplanationParameters::top_k].
    pub fn set_top_k<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top_k = v.into();
        self
    }

    /// Sets the value of [output_indices][crate::model::ExplanationParameters::output_indices].
    pub fn set_output_indices<T: std::convert::Into<std::option::Option<wkt::ListValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_indices = v.into();
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method].
    ///
    /// Note that all the setters affecting `method` are mutually
    /// exclusive.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::explanation_parameters::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `SampledShapleyAttribution`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sampled_shapley_attribution(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SampledShapleyAttribution>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::SampledShapleyAttribution(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `IntegratedGradientsAttribution`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integrated_gradients_attribution(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntegratedGradientsAttribution>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::IntegratedGradientsAttribution(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `XraiAttribution`, `None` if the field is not set or
    /// holds a different branch.
    pub fn xrai_attribution(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::XraiAttribution>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::XraiAttribution(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `Examples`, `None` if the field is not set or
    /// holds a different branch.
    pub fn examples(&self) -> std::option::Option<&std::boxed::Box<crate::model::Examples>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::Examples(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `SampledShapleyAttribution`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_sampled_shapley_attribution<
        T: std::convert::Into<std::boxed::Box<crate::model::SampledShapleyAttribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::SampledShapleyAttribution(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `IntegratedGradientsAttribution`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_integrated_gradients_attribution<
        T: std::convert::Into<std::boxed::Box<crate::model::IntegratedGradientsAttribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::IntegratedGradientsAttribution(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `XraiAttribution`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_xrai_attribution<
        T: std::convert::Into<std::boxed::Box<crate::model::XraiAttribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::XraiAttribution(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `Examples`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_examples<T: std::convert::Into<std::boxed::Box<crate::model::Examples>>>(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::Examples(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for ExplanationParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationParameters"
    }
}

/// Defines additional types related to [ExplanationParameters].
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
pub mod explanation_parameters {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// An attribution method that approximates Shapley values for features that
        /// contribute to the label being predicted. A sampling strategy is used to
        /// approximate the value rather than considering all subsets of features.
        /// Refer to this paper for model details: <https://arxiv.org/abs/1306.4265>.
        SampledShapleyAttribution(std::boxed::Box<crate::model::SampledShapleyAttribution>),
        /// An attribution method that computes Aumann-Shapley values taking
        /// advantage of the model's fully differentiable structure. Refer to this
        /// paper for more details: <https://arxiv.org/abs/1703.01365>
        IntegratedGradientsAttribution(
            std::boxed::Box<crate::model::IntegratedGradientsAttribution>,
        ),
        /// An attribution method that redistributes Integrated Gradients
        /// attribution to segmented regions, taking advantage of the model's fully
        /// differentiable structure. Refer to this paper for
        /// more details: <https://arxiv.org/abs/1906.02825>
        ///
        /// XRAI currently performs better on natural images, like a picture of a
        /// house or an animal. If the images are taken in artificial environments,
        /// like a lab or manufacturing line, or from diagnostic equipment, like
        /// x-rays or quality-control cameras, use Integrated Gradients instead.
        XraiAttribution(std::boxed::Box<crate::model::XraiAttribution>),
        /// Example-based explanations that returns the nearest neighbors from the
        /// provided dataset.
        Examples(std::boxed::Box<crate::model::Examples>),
    }
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted. A sampling strategy is used to
/// approximate the value rather than considering all subsets of features.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SampledShapleyAttribution {
    /// Required. The number of feature permutations to consider when approximating
    /// the Shapley values.
    ///
    /// Valid range of its value is [1, 50], inclusively.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub path_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl SampledShapleyAttribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path_count][crate::model::SampledShapleyAttribution::path_count].
    pub fn set_path_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.path_count = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for SampledShapleyAttribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SampledShapleyAttribution"
    }
}

/// An attribution method that computes the Aumann-Shapley value taking advantage
/// of the model's fully differentiable structure. Refer to this paper for
/// more details: <https://arxiv.org/abs/1703.01365>
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IntegratedGradientsAttribution {
    /// Required. The number of steps for approximating the path integral.
    /// A good value to start is 50 and gradually increase until the
    /// sum to diff property is within the desired error range.
    ///
    /// Valid range of its value is [1, 100], inclusively.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub step_count: i32,

    /// Config for SmoothGrad approximation of gradients.
    ///
    /// When enabled, the gradients are approximated by averaging the gradients
    /// from noisy samples in the vicinity of the inputs. Adding
    /// noise can help improve the computed gradients. Refer to this paper for more
    /// details: <https://arxiv.org/pdf/1706.03825.pdf>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub smooth_grad_config: std::option::Option<crate::model::SmoothGradConfig>,

    /// Config for IG with blur baseline.
    ///
    /// When enabled, a linear path from the maximally blurred image to the input
    /// image is created. Using a blurred baseline instead of zero (black image) is
    /// motivated by the BlurIG approach explained here:
    /// <https://arxiv.org/abs/2004.03383>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blur_baseline_config: std::option::Option<crate::model::BlurBaselineConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl IntegratedGradientsAttribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_count][crate::model::IntegratedGradientsAttribution::step_count].
    pub fn set_step_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.step_count = v.into();
        self
    }

    /// Sets the value of [smooth_grad_config][crate::model::IntegratedGradientsAttribution::smooth_grad_config].
    pub fn set_smooth_grad_config<
        T: std::convert::Into<std::option::Option<crate::model::SmoothGradConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.smooth_grad_config = v.into();
        self
    }

    /// Sets the value of [blur_baseline_config][crate::model::IntegratedGradientsAttribution::blur_baseline_config].
    pub fn set_blur_baseline_config<
        T: std::convert::Into<std::option::Option<crate::model::BlurBaselineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.blur_baseline_config = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for IntegratedGradientsAttribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IntegratedGradientsAttribution"
    }
}

/// An explanation method that redistributes Integrated Gradients
/// attributions to segmented regions, taking advantage of the model's fully
/// differentiable structure. Refer to this paper for more details:
/// <https://arxiv.org/abs/1906.02825>
///
/// Supported only by image Models.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct XraiAttribution {
    /// Required. The number of steps for approximating the path integral.
    /// A good value to start is 50 and gradually increase until the
    /// sum to diff property is met within the desired error range.
    ///
    /// Valid range of its value is [1, 100], inclusively.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub step_count: i32,

    /// Config for SmoothGrad approximation of gradients.
    ///
    /// When enabled, the gradients are approximated by averaging the gradients
    /// from noisy samples in the vicinity of the inputs. Adding
    /// noise can help improve the computed gradients. Refer to this paper for more
    /// details: <https://arxiv.org/pdf/1706.03825.pdf>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub smooth_grad_config: std::option::Option<crate::model::SmoothGradConfig>,

    /// Config for XRAI with blur baseline.
    ///
    /// When enabled, a linear path from the maximally blurred image to the input
    /// image is created. Using a blurred baseline instead of zero (black image) is
    /// motivated by the BlurIG approach explained here:
    /// <https://arxiv.org/abs/2004.03383>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blur_baseline_config: std::option::Option<crate::model::BlurBaselineConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl XraiAttribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_count][crate::model::XraiAttribution::step_count].
    pub fn set_step_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.step_count = v.into();
        self
    }

    /// Sets the value of [smooth_grad_config][crate::model::XraiAttribution::smooth_grad_config].
    pub fn set_smooth_grad_config<
        T: std::convert::Into<std::option::Option<crate::model::SmoothGradConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.smooth_grad_config = v.into();
        self
    }

    /// Sets the value of [blur_baseline_config][crate::model::XraiAttribution::blur_baseline_config].
    pub fn set_blur_baseline_config<
        T: std::convert::Into<std::option::Option<crate::model::BlurBaselineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.blur_baseline_config = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for XraiAttribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.XraiAttribution"
    }
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// <https://arxiv.org/pdf/1706.03825.pdf>
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SmoothGradConfig {
    /// The number of gradient samples to use for
    /// approximation. The higher this number, the more accurate the gradient
    /// is, but the runtime complexity increases by this factor as well.
    /// Valid range of its value is [1, 50]. Defaults to 3.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub noisy_sample_count: i32,

    /// Represents the standard deviation of the gaussian kernel
    /// that will be used to add noise to the interpolated inputs
    /// prior to computing gradients.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub gradient_noise_sigma:
        std::option::Option<crate::model::smooth_grad_config::GradientNoiseSigma>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl SmoothGradConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noisy_sample_count][crate::model::SmoothGradConfig::noisy_sample_count].
    pub fn set_noisy_sample_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.noisy_sample_count = v.into();
        self
    }

    /// Sets the value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma].
    ///
    /// Note that all the setters affecting `gradient_noise_sigma` are mutually
    /// exclusive.
    pub fn set_gradient_noise_sigma<
        T: std::convert::Into<
                std::option::Option<crate::model::smooth_grad_config::GradientNoiseSigma>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gradient_noise_sigma = v.into();
        self
    }

    /// The value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// if it holds a `NoiseSigma`, `None` if the field is not set or
    /// holds a different branch.
    pub fn noise_sigma(&self) -> std::option::Option<&f32> {
        #[allow(unreachable_patterns)]
        self.gradient_noise_sigma.as_ref().and_then(|v| match v {
            crate::model::smooth_grad_config::GradientNoiseSigma::NoiseSigma(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// if it holds a `FeatureNoiseSigma`, `None` if the field is not set or
    /// holds a different branch.
    pub fn feature_noise_sigma(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureNoiseSigma>> {
        #[allow(unreachable_patterns)]
        self.gradient_noise_sigma.as_ref().and_then(|v| match v {
            crate::model::smooth_grad_config::GradientNoiseSigma::FeatureNoiseSigma(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// to hold a `NoiseSigma`.
    ///
    /// Note that all the setters affecting `gradient_noise_sigma` are
    /// mutually exclusive.
    pub fn set_noise_sigma<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.gradient_noise_sigma = std::option::Option::Some(
            crate::model::smooth_grad_config::GradientNoiseSigma::NoiseSigma(v.into()),
        );
        self
    }

    /// Sets the value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// to hold a `FeatureNoiseSigma`.
    ///
    /// Note that all the setters affecting `gradient_noise_sigma` are
    /// mutually exclusive.
    pub fn set_feature_noise_sigma<
        T: std::convert::Into<std::boxed::Box<crate::model::FeatureNoiseSigma>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gradient_noise_sigma = std::option::Option::Some(
            crate::model::smooth_grad_config::GradientNoiseSigma::FeatureNoiseSigma(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for SmoothGradConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SmoothGradConfig"
    }
}

/// Defines additional types related to [SmoothGradConfig].
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
pub mod smooth_grad_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the standard deviation of the gaussian kernel
    /// that will be used to add noise to the interpolated inputs
    /// prior to computing gradients.
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GradientNoiseSigma {
        /// This is a single float value and will be used to add noise to all the
        /// features. Use this field when all features are normalized to have the
        /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
        /// features are normalized to have 0-mean and 1-variance. Learn more about
        /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
        ///
        /// For best results the recommended value is about 10% - 20% of the standard
        /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
        /// paper: <https://arxiv.org/pdf/1706.03825.pdf>. Defaults to 0.1.
        ///
        /// If the distribution is different per feature, set
        /// [feature_noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.feature_noise_sigma]
        /// instead for each feature.
        ///
        /// [google.cloud.aiplatform.v1.SmoothGradConfig.feature_noise_sigma]: crate::model::SmoothGradConfig::gradient_noise_sigma
        NoiseSigma(f32),
        /// This is similar to
        /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma],
        /// but provides additional flexibility. A separate noise sigma can be
        /// provided for each feature, which is useful if their distributions are
        /// different. No noise is added to features that are not set. If this field
        /// is unset,
        /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
        /// will be used for all features.
        ///
        /// [google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]: crate::model::SmoothGradConfig::gradient_noise_sigma
        FeatureNoiseSigma(std::boxed::Box<crate::model::FeatureNoiseSigma>),
    }
}

/// Noise sigma by features. Noise sigma represents the standard deviation of the
/// gaussian kernel that will be used to add noise to interpolated inputs prior
/// to computing gradients.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureNoiseSigma {
    /// Noise sigma per feature. No noise is added to features that are not set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub noise_sigma: std::vec::Vec<crate::model::feature_noise_sigma::NoiseSigmaForFeature>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl FeatureNoiseSigma {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noise_sigma][crate::model::FeatureNoiseSigma::noise_sigma].
    pub fn set_noise_sigma<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::feature_noise_sigma::NoiseSigmaForFeature>,
    {
        use std::iter::Iterator;
        self.noise_sigma = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for FeatureNoiseSigma {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureNoiseSigma"
    }
}

/// Defines additional types related to [FeatureNoiseSigma].
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
pub mod feature_noise_sigma {
    #[allow(unused_imports)]
    use super::*;

    /// Noise sigma for a single feature.
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NoiseSigmaForFeature {
        /// The name of the input feature for which noise sigma is provided. The
        /// features are defined in
        /// [explanation metadata
        /// inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
        ///
        /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// This represents the standard deviation of the Gaussian kernel that will
        /// be used to add noise to the feature prior to computing gradients. Similar
        /// to [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
        /// but represents the noise added to the current feature. Defaults to 0.1.
        ///
        /// [google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]: crate::model::SmoothGradConfig::gradient_noise_sigma
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub sigma: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl NoiseSigmaForFeature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::feature_noise_sigma::NoiseSigmaForFeature::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [sigma][crate::model::feature_noise_sigma::NoiseSigmaForFeature::sigma].
        pub fn set_sigma<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.sigma = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl wkt::message::Message for NoiseSigmaForFeature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureNoiseSigma.NoiseSigmaForFeature"
        }
    }
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// <https://arxiv.org/abs/2004.03383>
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BlurBaselineConfig {
    /// The standard deviation of the blur kernel for the blurred baseline. The
    /// same blurring parameter is used for both the height and the width
    /// dimension. If not set, the method defaults to the zero (i.e. black for
    /// images) baseline.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_blur_sigma: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl BlurBaselineConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_blur_sigma][crate::model::BlurBaselineConfig::max_blur_sigma].
    pub fn set_max_blur_sigma<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.max_blur_sigma = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for BlurBaselineConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BlurBaselineConfig"
    }
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Examples {
    /// The number of neighbors to return when querying for examples.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub neighbor_count: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::examples::Source>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::examples::Config>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl Examples {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_count][crate::model::Examples::neighbor_count].
    pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.neighbor_count = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Examples::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::examples::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Examples::source]
    /// if it holds a `ExampleGcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn example_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::examples::ExampleGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::examples::Source::ExampleGcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Examples::source]
    /// to hold a `ExampleGcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_example_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::examples::ExampleGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::examples::Source::ExampleGcsSource(v.into()));
        self
    }

    /// Sets the value of [config][crate::model::Examples::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::examples::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::Examples::config]
    /// if it holds a `NearestNeighborSearchConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn nearest_neighbor_search_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Value>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::examples::Config::NearestNeighborSearchConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [config][crate::model::Examples::config]
    /// if it holds a `Presets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presets(&self) -> std::option::Option<&std::boxed::Box<crate::model::Presets>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::examples::Config::Presets(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Examples::config]
    /// to hold a `NearestNeighborSearchConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_nearest_neighbor_search_config<
        T: std::convert::Into<std::boxed::Box<wkt::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::examples::Config::NearestNeighborSearchConfig(v.into()),
        );
        self
    }

    /// Sets the value of [config][crate::model::Examples::config]
    /// to hold a `Presets`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_presets<T: std::convert::Into<std::boxed::Box<crate::model::Presets>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(crate::model::examples::Config::Presets(v.into()));
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for Examples {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Examples"
    }
}

/// Defines additional types related to [Examples].
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
pub mod examples {
    #[allow(unused_imports)]
    use super::*;

    /// The Cloud Storage input instances.
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExampleGcsSource {
        /// The format in which instances are given, if not specified, assume it's
        /// JSONL format. Currently only JSONL format is supported.
        pub data_format: crate::model::examples::example_gcs_source::DataFormat,

        /// The Cloud Storage location for the input instances.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub gcs_source: std::option::Option<crate::model::GcsSource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl ExampleGcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_format][crate::model::examples::ExampleGcsSource::data_format].
        pub fn set_data_format<
            T: std::convert::Into<crate::model::examples::example_gcs_source::DataFormat>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_format = v.into();
            self
        }

        /// Sets the value of [gcs_source][crate::model::examples::ExampleGcsSource::gcs_source].
        pub fn set_gcs_source<
            T: std::convert::Into<std::option::Option<crate::model::GcsSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.gcs_source = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl wkt::message::Message for ExampleGcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Examples.ExampleGcsSource"
        }
    }

    /// Defines additional types related to [ExampleGcsSource].
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    pub mod example_gcs_source {
        #[allow(unused_imports)]
        use super::*;

        /// The format of the input example instances.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DataFormat {
            /// Format unspecified, used when unset.
            Unspecified,
            /// Examples are stored in JSONL files.
            Jsonl,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DataFormat::value] or
            /// [DataFormat::name].
            UnknownValue(data_format::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        pub mod data_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl DataFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Jsonl => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("DATA_FORMAT_UNSPECIFIED"),
                    Self::Jsonl => std::option::Option::Some("JSONL"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl std::default::Default for DataFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl std::fmt::Display for DataFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl std::convert::From<i32> for DataFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Jsonl,
                    _ => Self::UnknownValue(data_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl std::convert::From<&str> for DataFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "JSONL" => Self::Jsonl,
                    _ => Self::UnknownValue(data_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl serde::ser::Serialize for DataFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Jsonl => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
            feature = "prediction_service",
        ))]
        impl<'de> serde::de::Deserialize<'de> for DataFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFormat>::new(
                    ".google.cloud.aiplatform.v1.Examples.ExampleGcsSource.DataFormat",
                ))
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Cloud Storage input instances.
        ExampleGcsSource(std::boxed::Box<crate::model::examples::ExampleGcsSource>),
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// The full configuration for the generated index, the semantics are the
        /// same as [metadata][google.cloud.aiplatform.v1.Index.metadata] and should
        /// match
        /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
        ///
        /// [google.cloud.aiplatform.v1.Index.metadata]: crate::model::Index::metadata
        NearestNeighborSearchConfig(std::boxed::Box<wkt::Value>),
        /// Simplified preset configuration, which automatically sets configuration
        /// values based on the desired query speed-precision trade-off and modality.
        Presets(std::boxed::Box<crate::model::Presets>),
    }
}

/// Preset configuration for example-based explanations
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Presets {
    /// Preset option controlling parameters for speed-precision trade-off when
    /// querying for examples. If omitted, defaults to `PRECISE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::presets::Query>,

    /// The modality of the uploaded model, which automatically configures the
    /// distance measurement and feature normalization for the underlying example
    /// index and queries. If your model does not precisely fit one of these types,
    /// it is okay to choose the closest type.
    pub modality: crate::model::presets::Modality,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl Presets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::Presets::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::presets::Query>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [modality][crate::model::Presets::modality].
    pub fn set_modality<T: std::convert::Into<crate::model::presets::Modality>>(
        mut self,
        v: T,
    ) -> Self {
        self.modality = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for Presets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Presets"
    }
}

/// Defines additional types related to [Presets].
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
))]
pub mod presets {
    #[allow(unused_imports)]
    use super::*;

    /// Preset option controlling parameters for query speed-precision trade-off
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Query {
        /// More precise neighbors as a trade-off against slower response.
        Precise,
        /// Faster response as a trade-off against less precise neighbors.
        Fast,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Query::value] or
        /// [Query::name].
        UnknownValue(query::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    pub mod query {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl Query {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Precise => std::option::Option::Some(0),
                Self::Fast => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Precise => std::option::Option::Some("PRECISE"),
                Self::Fast => std::option::Option::Some("FAST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::default::Default for Query {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::fmt::Display for Query {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::convert::From<i32> for Query {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Precise,
                1 => Self::Fast,
                _ => Self::UnknownValue(query::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::convert::From<&str> for Query {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRECISE" => Self::Precise,
                "FAST" => Self::Fast,
                _ => Self::UnknownValue(query::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl serde::ser::Serialize for Query {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Precise => serializer.serialize_i32(0),
                Self::Fast => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Query {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Query>::new(
                ".google.cloud.aiplatform.v1.Presets.Query",
            ))
        }
    }

    /// Preset option controlling parameters for different modalities
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Modality {
        /// Should not be set. Added as a recommended best practice for enums
        Unspecified,
        /// IMAGE modality
        Image,
        /// TEXT modality
        Text,
        /// TABULAR modality
        Tabular,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Modality::value] or
        /// [Modality::name].
        UnknownValue(modality::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    pub mod modality {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl Modality {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Image => std::option::Option::Some(1),
                Self::Text => std::option::Option::Some(2),
                Self::Tabular => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODALITY_UNSPECIFIED"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Tabular => std::option::Option::Some("TABULAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::default::Default for Modality {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::fmt::Display for Modality {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::convert::From<i32> for Modality {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Image,
                2 => Self::Text,
                3 => Self::Tabular,
                _ => Self::UnknownValue(modality::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl std::convert::From<&str> for Modality {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODALITY_UNSPECIFIED" => Self::Unspecified,
                "IMAGE" => Self::Image,
                "TEXT" => Self::Text,
                "TABULAR" => Self::Tabular,
                _ => Self::UnknownValue(modality::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl serde::ser::Serialize for Modality {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Image => serializer.serialize_i32(1),
                Self::Text => serializer.serialize_i32(2),
                Self::Tabular => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
        feature = "prediction_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Modality {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Modality>::new(
                ".google.cloud.aiplatform.v1.Presets.Modality",
            ))
        }
    }
}

/// The [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] entries
/// that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] time.
///
/// [google.cloud.aiplatform.v1.ExplanationSpec]: crate::model::ExplanationSpec
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationSpecOverride {
    /// The parameters to be overridden. Note that the
    /// attribution method cannot be changed. If not specified,
    /// no parameter is overridden.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::ExplanationParameters>,

    /// The metadata to be overridden. If not specified, no metadata is overridden.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::ExplanationMetadataOverride>,

    /// The example-based explanations parameter overrides.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub examples_override: std::option::Option<crate::model::ExamplesOverride>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl ExplanationSpecOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::ExplanationSpecOverride::parameters].
    pub fn set_parameters<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ExplanationSpecOverride::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationMetadataOverride>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [examples_override][crate::model::ExplanationSpecOverride::examples_override].
    pub fn set_examples_override<
        T: std::convert::Into<std::option::Option<crate::model::ExamplesOverride>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.examples_override = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for ExplanationSpecOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationSpecOverride"
    }
}

/// The [ExplanationMetadata][google.cloud.aiplatform.v1.ExplanationMetadata]
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] time.
///
/// [google.cloud.aiplatform.v1.ExplanationMetadata]: crate::model::ExplanationMetadata
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationMetadataOverride {
    /// Required. Overrides the [input
    /// metadata][google.cloud.aiplatform.v1.ExplanationMetadata.inputs] of the
    /// features. The key is the name of the feature to be overridden. The keys
    /// specified here must exist in the input metadata to be overridden. If a
    /// feature is not specified here, the corresponding feature's input metadata
    /// is not overridden.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub inputs: std::collections::HashMap<
        std::string::String,
        crate::model::explanation_metadata_override::InputMetadataOverride,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl ExplanationMetadataOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::ExplanationMetadataOverride::inputs].
    pub fn set_inputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::explanation_metadata_override::InputMetadataOverride>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for ExplanationMetadataOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadataOverride"
    }
}

/// Defines additional types related to [ExplanationMetadataOverride].
#[cfg(feature = "prediction_service")]
pub mod explanation_metadata_override {
    #[allow(unused_imports)]
    use super::*;

    /// The [input
    /// metadata][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]
    /// entries to be overridden.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]: crate::model::explanation_metadata::InputMetadata
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputMetadataOverride {
        /// Baseline inputs for this feature.
        ///
        /// This overrides the `input_baseline` field of the
        /// [ExplanationMetadata.InputMetadata][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]
        /// object of the corresponding feature's input metadata. If it's not
        /// specified, the original baselines are not overridden.
        ///
        /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]: crate::model::explanation_metadata::InputMetadata
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub input_baselines: std::vec::Vec<wkt::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl InputMetadataOverride {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_baselines][crate::model::explanation_metadata_override::InputMetadataOverride::input_baselines].
        pub fn set_input_baselines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.input_baselines = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for InputMetadataOverride {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadataOverride.InputMetadataOverride"
        }
    }
}

/// Overrides for example-based explanations.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExamplesOverride {
    /// The number of neighbors to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub neighbor_count: i32,

    /// The number of neighbors to return that have the same crowding tag.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub crowding_count: i32,

    /// Restrict the resulting nearest neighbors to respect these constraints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub restrictions: std::vec::Vec<crate::model::ExamplesRestrictionsNamespace>,

    /// If true, return the embeddings instead of neighbors.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub return_embeddings: bool,

    /// The format of the data being provided with each call.
    pub data_format: crate::model::examples_override::DataFormat,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl ExamplesOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_count][crate::model::ExamplesOverride::neighbor_count].
    pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.neighbor_count = v.into();
        self
    }

    /// Sets the value of [crowding_count][crate::model::ExamplesOverride::crowding_count].
    pub fn set_crowding_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.crowding_count = v.into();
        self
    }

    /// Sets the value of [return_embeddings][crate::model::ExamplesOverride::return_embeddings].
    pub fn set_return_embeddings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_embeddings = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::ExamplesOverride::data_format].
    pub fn set_data_format<T: std::convert::Into<crate::model::examples_override::DataFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::ExamplesOverride::restrictions].
    pub fn set_restrictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExamplesRestrictionsNamespace>,
    {
        use std::iter::Iterator;
        self.restrictions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for ExamplesOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExamplesOverride"
    }
}

/// Defines additional types related to [ExamplesOverride].
#[cfg(feature = "prediction_service")]
pub mod examples_override {
    #[allow(unused_imports)]
    use super::*;

    /// Data format enum.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataFormat {
        /// Unspecified format. Must not be used.
        Unspecified,
        /// Provided data is a set of model inputs.
        Instances,
        /// Provided data is a set of embeddings.
        Embeddings,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataFormat::value] or
        /// [DataFormat::name].
        UnknownValue(data_format::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod data_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl DataFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Instances => std::option::Option::Some(1),
                Self::Embeddings => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_FORMAT_UNSPECIFIED"),
                Self::Instances => std::option::Option::Some("INSTANCES"),
                Self::Embeddings => std::option::Option::Some("EMBEDDINGS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for DataFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for DataFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for DataFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Instances,
                2 => Self::Embeddings,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for DataFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "INSTANCES" => Self::Instances,
                "EMBEDDINGS" => Self::Embeddings,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for DataFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Instances => serializer.serialize_i32(1),
                Self::Embeddings => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for DataFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFormat>::new(
                ".google.cloud.aiplatform.v1.ExamplesOverride.DataFormat",
            ))
        }
    }
}

/// Restrictions namespace for example-based explanations overrides.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExamplesRestrictionsNamespace {
    /// The namespace name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespace_name: std::string::String,

    /// The list of allowed tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allow: std::vec::Vec<std::string::String>,

    /// The list of deny tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deny: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl ExamplesRestrictionsNamespace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespace_name][crate::model::ExamplesRestrictionsNamespace::namespace_name].
    pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace_name = v.into();
        self
    }

    /// Sets the value of [allow][crate::model::ExamplesRestrictionsNamespace::allow].
    pub fn set_allow<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allow = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deny][crate::model::ExamplesRestrictionsNamespace::deny].
    pub fn set_deny<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deny = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for ExamplesRestrictionsNamespace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExamplesRestrictionsNamespace"
    }
}

/// Metadata describing the Model's input and output for explanation.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationMetadata {
    /// Required. Map from feature names to feature input metadata. Keys are the
    /// name of the features. Values are the specification of the feature.
    ///
    /// An empty InputMetadata is valid. It describes a text feature which has the
    /// name specified as the key in
    /// [ExplanationMetadata.inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    /// The baseline of the empty feature is chosen by Vertex AI.
    ///
    /// For Vertex AI-provided Tensorflow images, the key can be any friendly
    /// name of the feature. Once specified,
    /// [featureAttributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// are keyed by this key (if not grouped with another feature).
    ///
    /// For custom images, the key must match with the key in
    /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances].
    ///
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub inputs: std::collections::HashMap<
        std::string::String,
        crate::model::explanation_metadata::InputMetadata,
    >,

    /// Required. Map from output names to output metadata.
    ///
    /// For Vertex AI-provided Tensorflow images, keys can be any user defined
    /// string that consists of any UTF-8 characters.
    ///
    /// For custom images, keys are the name of the output field in the prediction
    /// to be explained.
    ///
    /// Currently only one key is allowed.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub outputs: std::collections::HashMap<
        std::string::String,
        crate::model::explanation_metadata::OutputMetadata,
    >,

    /// Points to a YAML file stored on Google Cloud Storage describing the format
    /// of the [feature
    /// attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML tabular Models always have this field populated by Vertex AI.
    /// Note: The URI given on output may be different, including the URI scheme,
    /// than the one given on input. The output URI will point to a location where
    /// the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_attributions_schema_uri: std::string::String,

    /// Name of the source to generate embeddings for example based explanations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latent_space_source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl ExplanationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_attributions_schema_uri][crate::model::ExplanationMetadata::feature_attributions_schema_uri].
    pub fn set_feature_attributions_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_attributions_schema_uri = v.into();
        self
    }

    /// Sets the value of [latent_space_source][crate::model::ExplanationMetadata::latent_space_source].
    pub fn set_latent_space_source<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latent_space_source = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::ExplanationMetadata::inputs].
    pub fn set_inputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::explanation_metadata::InputMetadata>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [outputs][crate::model::ExplanationMetadata::outputs].
    pub fn set_outputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::explanation_metadata::OutputMetadata>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for ExplanationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata"
    }
}

/// Defines additional types related to [ExplanationMetadata].
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
pub mod explanation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of the input of a feature.
    ///
    /// Fields other than
    /// [InputMetadata.input_baselines][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.input_baselines]
    /// are applicable only for Models that are using Vertex AI-provided images for
    /// Tensorflow.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.input_baselines]: crate::model::explanation_metadata::InputMetadata::input_baselines
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputMetadata {
        /// Baseline inputs for this feature.
        ///
        /// If no baseline is specified, Vertex AI chooses the baseline for this
        /// feature. If multiple baselines are specified, Vertex AI returns the
        /// average attributions across them in
        /// [Attribution.feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions].
        ///
        /// For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape
        /// of each baseline must match the shape of the input tensor. If a scalar is
        /// provided, we broadcast to the same shape as the input tensor.
        ///
        /// For custom images, the element of the baselines must be in the same
        /// format as the feature's input in the
        /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances][]. The
        /// schema of any single instance may be specified via Endpoint's
        /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
        /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
        /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
        ///
        /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
        /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
        /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
        /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
        /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub input_baselines: std::vec::Vec<wkt::Value>,

        /// Name of the input tensor for this feature. Required and is only
        /// applicable to Vertex AI-provided images for Tensorflow.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub input_tensor_name: std::string::String,

        /// Defines how the feature is encoded into the input tensor. Defaults to
        /// IDENTITY.
        pub encoding: crate::model::explanation_metadata::input_metadata::Encoding,

        /// Modality of the feature. Valid values are: numeric, image. Defaults to
        /// numeric.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub modality: std::string::String,

        /// The domain details of the input feature value. Like min/max, original
        /// mean or standard deviation if normalized.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_value_domain: std::option::Option<
            crate::model::explanation_metadata::input_metadata::FeatureValueDomain,
        >,

        /// Specifies the index of the values of the input tensor.
        /// Required when the input tensor is a sparse representation. Refer to
        /// Tensorflow documentation for more details:
        /// <https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub indices_tensor_name: std::string::String,

        /// Specifies the shape of the values of the input if the input is a sparse
        /// representation. Refer to Tensorflow documentation for more details:
        /// <https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dense_shape_tensor_name: std::string::String,

        /// A list of feature names for each index in the input tensor.
        /// Required when the input
        /// [InputMetadata.encoding][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoding]
        /// is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
        ///
        /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoding]: crate::model::explanation_metadata::InputMetadata::encoding
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub index_feature_mapping: std::vec::Vec<std::string::String>,

        /// Encoded tensor is a transformation of the input tensor. Must be provided
        /// if choosing
        /// [Integrated Gradients
        /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]
        /// or [XRAI
        /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]
        /// and the input tensor is not differentiable.
        ///
        /// An encoded tensor is generated if the input tensor is encoded by a lookup
        /// table.
        ///
        /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
        /// [google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]: crate::model::ExplanationParameters::method
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub encoded_tensor_name: std::string::String,

        /// A list of baselines for the encoded tensor.
        ///
        /// The shape of each baseline should match the shape of the encoded tensor.
        /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
        /// encoded tensor.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub encoded_baselines: std::vec::Vec<wkt::Value>,

        /// Visualization configurations for image explanation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub visualization:
            std::option::Option<crate::model::explanation_metadata::input_metadata::Visualization>,

        /// Name of the group that the input belongs to. Features with the same group
        /// name will be treated as one feature when computing attributions. Features
        /// grouped together can have different shapes in value. If provided, there
        /// will be one single attribution generated in
        /// [Attribution.feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions],
        /// keyed by the group name.
        ///
        /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub group_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl InputMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_tensor_name][crate::model::explanation_metadata::InputMetadata::input_tensor_name].
        pub fn set_input_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.input_tensor_name = v.into();
            self
        }

        /// Sets the value of [encoding][crate::model::explanation_metadata::InputMetadata::encoding].
        pub fn set_encoding<
            T: std::convert::Into<crate::model::explanation_metadata::input_metadata::Encoding>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }

        /// Sets the value of [modality][crate::model::explanation_metadata::InputMetadata::modality].
        pub fn set_modality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.modality = v.into();
            self
        }

        /// Sets the value of [feature_value_domain][crate::model::explanation_metadata::InputMetadata::feature_value_domain].
        pub fn set_feature_value_domain<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::explanation_metadata::input_metadata::FeatureValueDomain,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_value_domain = v.into();
            self
        }

        /// Sets the value of [indices_tensor_name][crate::model::explanation_metadata::InputMetadata::indices_tensor_name].
        pub fn set_indices_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.indices_tensor_name = v.into();
            self
        }

        /// Sets the value of [dense_shape_tensor_name][crate::model::explanation_metadata::InputMetadata::dense_shape_tensor_name].
        pub fn set_dense_shape_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dense_shape_tensor_name = v.into();
            self
        }

        /// Sets the value of [encoded_tensor_name][crate::model::explanation_metadata::InputMetadata::encoded_tensor_name].
        pub fn set_encoded_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.encoded_tensor_name = v.into();
            self
        }

        /// Sets the value of [visualization][crate::model::explanation_metadata::InputMetadata::visualization].
        pub fn set_visualization<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::explanation_metadata::input_metadata::Visualization,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.visualization = v.into();
            self
        }

        /// Sets the value of [group_name][crate::model::explanation_metadata::InputMetadata::group_name].
        pub fn set_group_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_name = v.into();
            self
        }

        /// Sets the value of [input_baselines][crate::model::explanation_metadata::InputMetadata::input_baselines].
        pub fn set_input_baselines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.input_baselines = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [index_feature_mapping][crate::model::explanation_metadata::InputMetadata::index_feature_mapping].
        pub fn set_index_feature_mapping<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.index_feature_mapping = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [encoded_baselines][crate::model::explanation_metadata::InputMetadata::encoded_baselines].
        pub fn set_encoded_baselines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.encoded_baselines = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for InputMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata"
        }
    }

    /// Defines additional types related to [InputMetadata].
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    pub mod input_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Domain details of the input feature value. Provides numeric information
        /// about the feature, such as its range (min, max). If the feature has been
        /// pre-processed, for example with z-scoring, then it provides information
        /// about how to recover the original feature. For example, if the input
        /// feature is an image and it has been pre-processed to obtain 0-mean and
        /// stddev = 1 values, then original_mean, and original_stddev refer to the
        /// mean and stddev of the original feature (e.g. image tensor) from which
        /// input feature (with mean = 0 and stddev = 1) was obtained.
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FeatureValueDomain {
            /// The minimum permissible value for this feature.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub min_value: f32,

            /// The maximum permissible value for this feature.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_value: f32,

            /// If this input feature has been normalized to a mean value of 0,
            /// the original_mean specifies the mean value of the domain prior to
            /// normalization.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub original_mean: f32,

            /// If this input feature has been normalized to a standard deviation of
            /// 1.0, the original_stddev specifies the standard deviation of the domain
            /// prior to normalization.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub original_stddev: f32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl FeatureValueDomain {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_value][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::min_value].
            pub fn set_min_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::max_value].
            pub fn set_max_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [original_mean][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::original_mean].
            pub fn set_original_mean<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.original_mean = v.into();
                self
            }

            /// Sets the value of [original_stddev][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::original_stddev].
            pub fn set_original_stddev<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.original_stddev = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl wkt::message::Message for FeatureValueDomain {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.FeatureValueDomain"
            }
        }

        /// Visualization configurations for image explanation.
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Visualization {
            /// Type of the image visualization. Only applicable to
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution].
            /// OUTLINES shows regions of attribution, while PIXELS shows per-pixel
            /// attribution. Defaults to OUTLINES.
            ///
            /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
            #[serde(rename = "type")]
            pub r#type: crate::model::explanation_metadata::input_metadata::visualization::Type,

            /// Whether to only highlight pixels with positive contributions, negative
            /// or both. Defaults to POSITIVE.
            pub polarity:
                crate::model::explanation_metadata::input_metadata::visualization::Polarity,

            /// The color scheme used for the highlighted areas.
            ///
            /// Defaults to PINK_GREEN for
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution],
            /// which shows positive attributions in green and negative in pink.
            ///
            /// Defaults to VIRIDIS for
            /// [XRAI
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution],
            /// which highlights the most influential regions in yellow and the least
            /// influential in blue.
            ///
            /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
            /// [google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]: crate::model::ExplanationParameters::method
            pub color_map:
                crate::model::explanation_metadata::input_metadata::visualization::ColorMap,

            /// Excludes attributions above the specified percentile from the
            /// highlighted areas. Using the clip_percent_upperbound and
            /// clip_percent_lowerbound together can be useful for filtering out noise
            /// and making it easier to see areas of strong attribution. Defaults to
            /// 99.9.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub clip_percent_upperbound: f32,

            /// Excludes attributions below the specified percentile, from the
            /// highlighted areas. Defaults to 62.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub clip_percent_lowerbound: f32,

            /// How the original image is displayed in the visualization.
            /// Adjusting the overlay can help increase visual clarity if the original
            /// image makes it difficult to view the visualization. Defaults to NONE.
            pub overlay_type:
                crate::model::explanation_metadata::input_metadata::visualization::OverlayType,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl Visualization {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::explanation_metadata::input_metadata::Visualization::type].
            pub fn set_type<
                T: std::convert::Into<
                        crate::model::explanation_metadata::input_metadata::visualization::Type,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [polarity][crate::model::explanation_metadata::input_metadata::Visualization::polarity].
            pub fn set_polarity<
                T: std::convert::Into<
                        crate::model::explanation_metadata::input_metadata::visualization::Polarity,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.polarity = v.into();
                self
            }

            /// Sets the value of [color_map][crate::model::explanation_metadata::input_metadata::Visualization::color_map].
            pub fn set_color_map<
                T: std::convert::Into<
                        crate::model::explanation_metadata::input_metadata::visualization::ColorMap,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.color_map = v.into();
                self
            }

            /// Sets the value of [clip_percent_upperbound][crate::model::explanation_metadata::input_metadata::Visualization::clip_percent_upperbound].
            pub fn set_clip_percent_upperbound<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.clip_percent_upperbound = v.into();
                self
            }

            /// Sets the value of [clip_percent_lowerbound][crate::model::explanation_metadata::input_metadata::Visualization::clip_percent_lowerbound].
            pub fn set_clip_percent_lowerbound<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.clip_percent_lowerbound = v.into();
                self
            }

            /// Sets the value of [overlay_type][crate::model::explanation_metadata::input_metadata::Visualization::overlay_type].
            pub fn set_overlay_type<T: std::convert::Into<crate::model::explanation_metadata::input_metadata::visualization::OverlayType>>(mut self, v: T) -> Self{
                self.overlay_type = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl wkt::message::Message for Visualization {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization"
            }
        }

        /// Defines additional types related to [Visualization].
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        pub mod visualization {
            #[allow(unused_imports)]
            use super::*;

            /// Type of the image visualization. Only applicable to
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution].
            ///
            /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// Should not be used.
                Unspecified,
                /// Shows which pixel contributed to the image prediction.
                Pixels,
                /// Shows which region contributed to the image prediction by outlining
                /// the region.
                Outlines,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Type::value] or
                /// [Type::name].
                UnknownValue(r#type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            pub mod r#type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl Type {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Pixels => std::option::Option::Some(1),
                        Self::Outlines => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                        Self::Pixels => std::option::Option::Some("PIXELS"),
                        Self::Outlines => std::option::Option::Some("OUTLINES"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::default::Default for Type {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::fmt::Display for Type {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Pixels,
                        2 => Self::Outlines,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<&str> for Type {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "TYPE_UNSPECIFIED" => Self::Unspecified,
                        "PIXELS" => Self::Pixels,
                        "OUTLINES" => Self::Outlines,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl serde::ser::Serialize for Type {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Pixels => serializer.serialize_i32(1),
                        Self::Outlines => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl<'de> serde::de::Deserialize<'de> for Type {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                        ".google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization.Type"))
                }
            }

            /// Whether to only highlight pixels with positive contributions, negative
            /// or both. Defaults to POSITIVE.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Polarity {
                /// Default value. This is the same as POSITIVE.
                Unspecified,
                /// Highlights the pixels/outlines that were most influential to the
                /// model's prediction.
                Positive,
                /// Setting polarity to negative highlights areas that does not lead to
                /// the models's current prediction.
                Negative,
                /// Shows both positive and negative attributions.
                Both,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Polarity::value] or
                /// [Polarity::name].
                UnknownValue(polarity::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            pub mod polarity {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl Polarity {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Positive => std::option::Option::Some(1),
                        Self::Negative => std::option::Option::Some(2),
                        Self::Both => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("POLARITY_UNSPECIFIED"),
                        Self::Positive => std::option::Option::Some("POSITIVE"),
                        Self::Negative => std::option::Option::Some("NEGATIVE"),
                        Self::Both => std::option::Option::Some("BOTH"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::default::Default for Polarity {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::fmt::Display for Polarity {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<i32> for Polarity {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Positive,
                        2 => Self::Negative,
                        3 => Self::Both,
                        _ => Self::UnknownValue(polarity::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<&str> for Polarity {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "POLARITY_UNSPECIFIED" => Self::Unspecified,
                        "POSITIVE" => Self::Positive,
                        "NEGATIVE" => Self::Negative,
                        "BOTH" => Self::Both,
                        _ => Self::UnknownValue(polarity::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl serde::ser::Serialize for Polarity {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Positive => serializer.serialize_i32(1),
                        Self::Negative => serializer.serialize_i32(2),
                        Self::Both => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl<'de> serde::de::Deserialize<'de> for Polarity {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Polarity>::new(
                        ".google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization.Polarity"))
                }
            }

            /// The color scheme used for highlighting areas.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ColorMap {
                /// Should not be used.
                Unspecified,
                /// Positive: green. Negative: pink.
                PinkGreen,
                /// Viridis color map: A perceptually uniform color mapping which is
                /// easier to see by those with colorblindness and progresses from yellow
                /// to green to blue. Positive: yellow. Negative: blue.
                Viridis,
                /// Positive: red. Negative: red.
                Red,
                /// Positive: green. Negative: green.
                Green,
                /// Positive: green. Negative: red.
                RedGreen,
                /// PiYG palette.
                PinkWhiteGreen,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ColorMap::value] or
                /// [ColorMap::name].
                UnknownValue(color_map::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            pub mod color_map {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl ColorMap {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::PinkGreen => std::option::Option::Some(1),
                        Self::Viridis => std::option::Option::Some(2),
                        Self::Red => std::option::Option::Some(3),
                        Self::Green => std::option::Option::Some(4),
                        Self::RedGreen => std::option::Option::Some(6),
                        Self::PinkWhiteGreen => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("COLOR_MAP_UNSPECIFIED"),
                        Self::PinkGreen => std::option::Option::Some("PINK_GREEN"),
                        Self::Viridis => std::option::Option::Some("VIRIDIS"),
                        Self::Red => std::option::Option::Some("RED"),
                        Self::Green => std::option::Option::Some("GREEN"),
                        Self::RedGreen => std::option::Option::Some("RED_GREEN"),
                        Self::PinkWhiteGreen => std::option::Option::Some("PINK_WHITE_GREEN"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::default::Default for ColorMap {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::fmt::Display for ColorMap {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<i32> for ColorMap {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::PinkGreen,
                        2 => Self::Viridis,
                        3 => Self::Red,
                        4 => Self::Green,
                        5 => Self::PinkWhiteGreen,
                        6 => Self::RedGreen,
                        _ => Self::UnknownValue(color_map::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<&str> for ColorMap {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "COLOR_MAP_UNSPECIFIED" => Self::Unspecified,
                        "PINK_GREEN" => Self::PinkGreen,
                        "VIRIDIS" => Self::Viridis,
                        "RED" => Self::Red,
                        "GREEN" => Self::Green,
                        "RED_GREEN" => Self::RedGreen,
                        "PINK_WHITE_GREEN" => Self::PinkWhiteGreen,
                        _ => Self::UnknownValue(color_map::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl serde::ser::Serialize for ColorMap {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::PinkGreen => serializer.serialize_i32(1),
                        Self::Viridis => serializer.serialize_i32(2),
                        Self::Red => serializer.serialize_i32(3),
                        Self::Green => serializer.serialize_i32(4),
                        Self::RedGreen => serializer.serialize_i32(6),
                        Self::PinkWhiteGreen => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl<'de> serde::de::Deserialize<'de> for ColorMap {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColorMap>::new(
                        ".google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization.ColorMap"))
                }
            }

            /// How the original image is displayed in the visualization.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum OverlayType {
                /// Default value. This is the same as NONE.
                Unspecified,
                /// No overlay.
                None,
                /// The attributions are shown on top of the original image.
                Original,
                /// The attributions are shown on top of grayscaled version of the
                /// original image.
                Grayscale,
                /// The attributions are used as a mask to reveal predictive parts of
                /// the image and hide the un-predictive parts.
                MaskBlack,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [OverlayType::value] or
                /// [OverlayType::name].
                UnknownValue(overlay_type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            pub mod overlay_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl OverlayType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::None => std::option::Option::Some(1),
                        Self::Original => std::option::Option::Some(2),
                        Self::Grayscale => std::option::Option::Some(3),
                        Self::MaskBlack => std::option::Option::Some(4),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("OVERLAY_TYPE_UNSPECIFIED"),
                        Self::None => std::option::Option::Some("NONE"),
                        Self::Original => std::option::Option::Some("ORIGINAL"),
                        Self::Grayscale => std::option::Option::Some("GRAYSCALE"),
                        Self::MaskBlack => std::option::Option::Some("MASK_BLACK"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::default::Default for OverlayType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::fmt::Display for OverlayType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<i32> for OverlayType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::None,
                        2 => Self::Original,
                        3 => Self::Grayscale,
                        4 => Self::MaskBlack,
                        _ => Self::UnknownValue(overlay_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl std::convert::From<&str> for OverlayType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "OVERLAY_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "NONE" => Self::None,
                        "ORIGINAL" => Self::Original,
                        "GRAYSCALE" => Self::Grayscale,
                        "MASK_BLACK" => Self::MaskBlack,
                        _ => Self::UnknownValue(overlay_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl serde::ser::Serialize for OverlayType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::None => serializer.serialize_i32(1),
                        Self::Original => serializer.serialize_i32(2),
                        Self::Grayscale => serializer.serialize_i32(3),
                        Self::MaskBlack => serializer.serialize_i32(4),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "dataset_service",
                feature = "deployment_resource_pool_service",
                feature = "endpoint_service",
                feature = "job_service",
                feature = "model_service",
                feature = "pipeline_service",
            ))]
            impl<'de> serde::de::Deserialize<'de> for OverlayType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<OverlayType>::new(
                        ".google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization.OverlayType"))
                }
            }
        }

        /// Defines how a feature is encoded. Defaults to IDENTITY.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Encoding {
            /// Default value. This is the same as IDENTITY.
            Unspecified,
            /// The tensor represents one feature.
            Identity,
            /// The tensor represents a bag of features where each index maps to
            /// a feature.
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = [27, 6.0, 150]
            /// index_feature_mapping = ["age", "height", "weight"]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]: crate::model::explanation_metadata::InputMetadata::index_feature_mapping
            BagOfFeatures,
            /// The tensor represents a bag of features where each index maps to a
            /// feature. Zero values in the tensor indicates feature being
            /// non-existent.
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = [2, 0, 5, 0, 1]
            /// index_feature_mapping = ["a", "b", "c", "d", "e"]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]: crate::model::explanation_metadata::InputMetadata::index_feature_mapping
            BagOfFeaturesSparse,
            /// The tensor is a list of binaries representing whether a feature exists
            /// or not (1 indicates existence).
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = [1, 0, 1, 0, 1]
            /// index_feature_mapping = ["a", "b", "c", "d", "e"]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]: crate::model::explanation_metadata::InputMetadata::index_feature_mapping
            Indicator,
            /// The tensor is encoded into a 1-dimensional array represented by an
            /// encoded tensor.
            /// [InputMetadata.encoded_tensor_name][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = ["This", "is", "a", "test", "."]
            /// encoded = [0.1, 0.2, 0.3, 0.4, 0.5]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]: crate::model::explanation_metadata::InputMetadata::encoded_tensor_name
            CombinedEmbedding,
            /// Select this encoding when the input tensor is encoded into a
            /// 2-dimensional array represented by an encoded tensor.
            /// [InputMetadata.encoded_tensor_name][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]
            /// must be provided for this encoding. The first dimension of the encoded
            /// tensor's shape is the same as the input tensor's shape. For example:
            ///
            /// ```norust
            /// input = ["This", "is", "a", "test", "."]
            /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5],
            ///            [0.2, 0.1, 0.4, 0.3, 0.5],
            ///            [0.5, 0.1, 0.3, 0.5, 0.4],
            ///            [0.5, 0.3, 0.1, 0.2, 0.4],
            ///            [0.4, 0.3, 0.2, 0.5, 0.1]]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]: crate::model::explanation_metadata::InputMetadata::encoded_tensor_name
            ConcatEmbedding,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Encoding::value] or
            /// [Encoding::name].
            UnknownValue(encoding::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl Encoding {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Identity => std::option::Option::Some(1),
                    Self::BagOfFeatures => std::option::Option::Some(2),
                    Self::BagOfFeaturesSparse => std::option::Option::Some(3),
                    Self::Indicator => std::option::Option::Some(4),
                    Self::CombinedEmbedding => std::option::Option::Some(5),
                    Self::ConcatEmbedding => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENCODING_UNSPECIFIED"),
                    Self::Identity => std::option::Option::Some("IDENTITY"),
                    Self::BagOfFeatures => std::option::Option::Some("BAG_OF_FEATURES"),
                    Self::BagOfFeaturesSparse => {
                        std::option::Option::Some("BAG_OF_FEATURES_SPARSE")
                    }
                    Self::Indicator => std::option::Option::Some("INDICATOR"),
                    Self::CombinedEmbedding => std::option::Option::Some("COMBINED_EMBEDDING"),
                    Self::ConcatEmbedding => std::option::Option::Some("CONCAT_EMBEDDING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::default::Default for Encoding {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::fmt::Display for Encoding {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::convert::From<i32> for Encoding {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Identity,
                    2 => Self::BagOfFeatures,
                    3 => Self::BagOfFeaturesSparse,
                    4 => Self::Indicator,
                    5 => Self::CombinedEmbedding,
                    6 => Self::ConcatEmbedding,
                    _ => Self::UnknownValue(encoding::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::convert::From<&str> for Encoding {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENCODING_UNSPECIFIED" => Self::Unspecified,
                    "IDENTITY" => Self::Identity,
                    "BAG_OF_FEATURES" => Self::BagOfFeatures,
                    "BAG_OF_FEATURES_SPARSE" => Self::BagOfFeaturesSparse,
                    "INDICATOR" => Self::Indicator,
                    "COMBINED_EMBEDDING" => Self::CombinedEmbedding,
                    "CONCAT_EMBEDDING" => Self::ConcatEmbedding,
                    _ => Self::UnknownValue(encoding::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl serde::ser::Serialize for Encoding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Identity => serializer.serialize_i32(1),
                    Self::BagOfFeatures => serializer.serialize_i32(2),
                    Self::BagOfFeaturesSparse => serializer.serialize_i32(3),
                    Self::Indicator => serializer.serialize_i32(4),
                    Self::CombinedEmbedding => serializer.serialize_i32(5),
                    Self::ConcatEmbedding => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl<'de> serde::de::Deserialize<'de> for Encoding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Encoding>::new(
                    ".google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Encoding",
                ))
            }
        }
    }

    /// Metadata of the prediction output to be explained.
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputMetadata {
        /// Name of the output tensor. Required and is only applicable to Vertex
        /// AI provided images for Tensorflow.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub output_tensor_name: std::string::String,

        /// Defines how to map
        /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
        /// to
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name].
        ///
        /// If neither of the fields are specified,
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
        /// will not be populated.
        ///
        /// [google.cloud.aiplatform.v1.Attribution.output_display_name]: crate::model::Attribution::output_display_name
        /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub display_name_mapping: std::option::Option<
            crate::model::explanation_metadata::output_metadata::DisplayNameMapping,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl OutputMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [output_tensor_name][crate::model::explanation_metadata::OutputMetadata::output_tensor_name].
        pub fn set_output_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_tensor_name = v.into();
            self
        }

        /// Sets the value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping].
        ///
        /// Note that all the setters affecting `display_name_mapping` are mutually
        /// exclusive.
        pub fn set_display_name_mapping<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::explanation_metadata::output_metadata::DisplayNameMapping,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.display_name_mapping = v.into();
            self
        }

        /// The value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// if it holds a `IndexDisplayNameMapping`, `None` if the field is not set or
        /// holds a different branch.
        pub fn index_display_name_mapping(
            &self,
        ) -> std::option::Option<&std::boxed::Box<wkt::Value>> {
            #[allow(unreachable_patterns)]
            self.display_name_mapping.as_ref().and_then(|v| match v {
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::IndexDisplayNameMapping(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// if it holds a `DisplayNameMappingKey`, `None` if the field is not set or
        /// holds a different branch.
        pub fn display_name_mapping_key(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.display_name_mapping.as_ref().and_then(|v| match v {
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::DisplayNameMappingKey(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// to hold a `IndexDisplayNameMapping`.
        ///
        /// Note that all the setters affecting `display_name_mapping` are
        /// mutually exclusive.
        pub fn set_index_display_name_mapping<
            T: std::convert::Into<std::boxed::Box<wkt::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.display_name_mapping = std::option::Option::Some(
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::IndexDisplayNameMapping(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// to hold a `DisplayNameMappingKey`.
        ///
        /// Note that all the setters affecting `display_name_mapping` are
        /// mutually exclusive.
        pub fn set_display_name_mapping_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name_mapping = std::option::Option::Some(
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::DisplayNameMappingKey(
                    v.into()
                )
            );
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for OutputMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.OutputMetadata"
        }
    }

    /// Defines additional types related to [OutputMetadata].
    #[cfg(any(
        feature = "dataset_service",
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "job_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    pub mod output_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Defines how to map
        /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
        /// to
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name].
        ///
        /// If neither of the fields are specified,
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
        /// will not be populated.
        ///
        /// [google.cloud.aiplatform.v1.Attribution.output_display_name]: crate::model::Attribution::output_display_name
        /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
        #[cfg(any(
            feature = "dataset_service",
            feature = "deployment_resource_pool_service",
            feature = "endpoint_service",
            feature = "job_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DisplayNameMapping {
            /// Static mapping between the index and display name.
            ///
            /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
            /// list of scores of all the classes in a pre-defined order for a
            /// multi-classification Model. It's not feasible if the outputs are
            /// non-deterministic, e.g. the Model produces top-k classes or sort the
            /// outputs by their values.
            ///
            /// The shape of the value must be an n-dimensional array of strings. The
            /// number of dimensions must match that of the outputs to be explained.
            /// The
            /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
            /// is populated by locating in the mapping with
            /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index].
            ///
            /// [google.cloud.aiplatform.v1.Attribution.output_display_name]: crate::model::Attribution::output_display_name
            /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
            IndexDisplayNameMapping(std::boxed::Box<wkt::Value>),
            /// Specify a field name in the prediction to look for the display name.
            ///
            /// Use this if the prediction contains the display names for the outputs.
            ///
            /// The display names in the prediction must have the same shape of the
            /// outputs, so that it can be located by
            /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
            /// for a specific output.
            ///
            /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
            DisplayNameMappingKey(std::string::String),
        }
    }
}

/// Feature Metadata information.
/// For example, color is a feature that describes an apple.
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Feature {
    /// Immutable. Name of the Feature.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
    ///
    /// The last part feature is assigned by the client. The feature can be up to
    /// 64 characters long and can consist only of ASCII Latin letters A-Z and a-z,
    /// underscore(_), and ASCII digits 0-9 starting with a letter. The value will
    /// be unique given an entity type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Description of the Feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Immutable. Only applicable for Vertex AI Feature Store (Legacy).
    /// Type of Feature value.
    pub value_type: crate::model::feature::ValueType,

    /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
    /// Timestamp when this EntityType was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
    /// Timestamp when this EntityType was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize your Features.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one Feature (System
    /// labels are excluded)."
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Only applicable for Vertex AI Feature Store (Legacy).
    /// If not set, use the monitoring_config defined for the EntityType this
    /// Feature belongs to.
    /// Only Features with type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) BOOL,
    /// STRING, DOUBLE or INT64 can enable monitoring.
    ///
    /// If set to true, all types of data monitoring are disabled despite the
    /// config on EntityType.
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_monitoring: bool,

    /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
    /// The list of historical stats and anomalies with specified objectives.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub monitoring_stats_anomalies: std::vec::Vec<crate::model::feature::MonitoringStatsAnomaly>,

    /// Only applicable for Vertex AI Feature Store.
    /// The name of the BigQuery Table/View column hosting data for this version.
    /// If no value is provided, will use feature_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_column_name: std::string::String,

    /// Entity responsible for maintaining this feature. Can be comma separated
    /// list of email addresses or URIs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub point_of_contact: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl Feature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Feature::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Feature::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::Feature::value_type].
    pub fn set_value_type<T: std::convert::Into<crate::model::feature::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Feature::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Feature::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Feature::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [disable_monitoring][crate::model::Feature::disable_monitoring].
    pub fn set_disable_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_monitoring = v.into();
        self
    }

    /// Sets the value of [version_column_name][crate::model::Feature::version_column_name].
    pub fn set_version_column_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_column_name = v.into();
        self
    }

    /// Sets the value of [point_of_contact][crate::model::Feature::point_of_contact].
    pub fn set_point_of_contact<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.point_of_contact = v.into();
        self
    }

    /// Sets the value of [monitoring_stats_anomalies][crate::model::Feature::monitoring_stats_anomalies].
    pub fn set_monitoring_stats_anomalies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::feature::MonitoringStatsAnomaly>,
    {
        use std::iter::Iterator;
        self.monitoring_stats_anomalies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Feature::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for Feature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Feature"
    }
}

/// Defines additional types related to [Feature].
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
pub mod feature {
    #[allow(unused_imports)]
    use super::*;

    /// A list of historical
    /// [SnapshotAnalysis][google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis]
    /// or
    /// [ImportFeaturesAnalysis][google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis]
    /// stats requested by user, sorted by
    /// [FeatureStatsAnomaly.start_time][google.cloud.aiplatform.v1.FeatureStatsAnomaly.start_time]
    /// descending.
    ///
    /// [google.cloud.aiplatform.v1.FeatureStatsAnomaly.start_time]: crate::model::FeatureStatsAnomaly::start_time
    /// [google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis]: crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis
    /// [google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis]: crate::model::featurestore_monitoring_config::SnapshotAnalysis
    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MonitoringStatsAnomaly {
        /// Output only. The objective for each stats.
        pub objective: crate::model::feature::monitoring_stats_anomaly::Objective,

        /// Output only. The stats and anomalies generated at specific timestamp.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_stats_anomaly: std::option::Option<crate::model::FeatureStatsAnomaly>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl MonitoringStatsAnomaly {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [objective][crate::model::feature::MonitoringStatsAnomaly::objective].
        pub fn set_objective<
            T: std::convert::Into<crate::model::feature::monitoring_stats_anomaly::Objective>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.objective = v.into();
            self
        }

        /// Sets the value of [feature_stats_anomaly][crate::model::feature::MonitoringStatsAnomaly::feature_stats_anomaly].
        pub fn set_feature_stats_anomaly<
            T: std::convert::Into<std::option::Option<crate::model::FeatureStatsAnomaly>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_stats_anomaly = v.into();
            self
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl wkt::message::Message for MonitoringStatsAnomaly {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Feature.MonitoringStatsAnomaly"
        }
    }

    /// Defines additional types related to [MonitoringStatsAnomaly].
    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    pub mod monitoring_stats_anomaly {
        #[allow(unused_imports)]
        use super::*;

        /// If the objective in the request is both
        /// Import Feature Analysis and Snapshot Analysis, this objective could be
        /// one of them. Otherwise, this objective should be the same as the
        /// objective in the request.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Objective {
            /// If it's OBJECTIVE_UNSPECIFIED, monitoring_stats will be empty.
            Unspecified,
            /// Stats are generated by Import Feature Analysis.
            ImportFeatureAnalysis,
            /// Stats are generated by Snapshot Analysis.
            SnapshotAnalysis,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Objective::value] or
            /// [Objective::name].
            UnknownValue(objective::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        pub mod objective {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl Objective {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ImportFeatureAnalysis => std::option::Option::Some(1),
                    Self::SnapshotAnalysis => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OBJECTIVE_UNSPECIFIED"),
                    Self::ImportFeatureAnalysis => {
                        std::option::Option::Some("IMPORT_FEATURE_ANALYSIS")
                    }
                    Self::SnapshotAnalysis => std::option::Option::Some("SNAPSHOT_ANALYSIS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl std::default::Default for Objective {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl std::fmt::Display for Objective {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl std::convert::From<i32> for Objective {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ImportFeatureAnalysis,
                    2 => Self::SnapshotAnalysis,
                    _ => Self::UnknownValue(objective::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl std::convert::From<&str> for Objective {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OBJECTIVE_UNSPECIFIED" => Self::Unspecified,
                    "IMPORT_FEATURE_ANALYSIS" => Self::ImportFeatureAnalysis,
                    "SNAPSHOT_ANALYSIS" => Self::SnapshotAnalysis,
                    _ => Self::UnknownValue(objective::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl serde::ser::Serialize for Objective {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ImportFeatureAnalysis => serializer.serialize_i32(1),
                    Self::SnapshotAnalysis => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
        impl<'de> serde::de::Deserialize<'de> for Objective {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Objective>::new(
                    ".google.cloud.aiplatform.v1.Feature.MonitoringStatsAnomaly.Objective",
                ))
            }
        }
    }

    /// Only applicable for Vertex AI Legacy Feature Store.
    /// An enum representing the value type of a feature.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// The value type is unspecified.
        Unspecified,
        /// Used for Feature that is a boolean.
        Bool,
        /// Used for Feature that is a list of boolean.
        BoolArray,
        /// Used for Feature that is double.
        Double,
        /// Used for Feature that is a list of double.
        DoubleArray,
        /// Used for Feature that is INT64.
        Int64,
        /// Used for Feature that is a list of INT64.
        Int64Array,
        /// Used for Feature that is string.
        String,
        /// Used for Feature that is a list of String.
        StringArray,
        /// Used for Feature that is bytes.
        Bytes,
        /// Used for Feature that is struct.
        Struct,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bool => std::option::Option::Some(1),
                Self::BoolArray => std::option::Option::Some(2),
                Self::Double => std::option::Option::Some(3),
                Self::DoubleArray => std::option::Option::Some(4),
                Self::Int64 => std::option::Option::Some(9),
                Self::Int64Array => std::option::Option::Some(10),
                Self::String => std::option::Option::Some(11),
                Self::StringArray => std::option::Option::Some(12),
                Self::Bytes => std::option::Option::Some(13),
                Self::Struct => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::BoolArray => std::option::Option::Some("BOOL_ARRAY"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::DoubleArray => std::option::Option::Some("DOUBLE_ARRAY"),
                Self::Int64 => std::option::Option::Some("INT64"),
                Self::Int64Array => std::option::Option::Some("INT64_ARRAY"),
                Self::String => std::option::Option::Some("STRING"),
                Self::StringArray => std::option::Option::Some("STRING_ARRAY"),
                Self::Bytes => std::option::Option::Some("BYTES"),
                Self::Struct => std::option::Option::Some("STRUCT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bool,
                2 => Self::BoolArray,
                3 => Self::Double,
                4 => Self::DoubleArray,
                9 => Self::Int64,
                10 => Self::Int64Array,
                11 => Self::String,
                12 => Self::StringArray,
                13 => Self::Bytes,
                14 => Self::Struct,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BOOL" => Self::Bool,
                "BOOL_ARRAY" => Self::BoolArray,
                "DOUBLE" => Self::Double,
                "DOUBLE_ARRAY" => Self::DoubleArray,
                "INT64" => Self::Int64,
                "INT64_ARRAY" => Self::Int64Array,
                "STRING" => Self::String,
                "STRING_ARRAY" => Self::StringArray,
                "BYTES" => Self::Bytes,
                "STRUCT" => Self::Struct,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bool => serializer.serialize_i32(1),
                Self::BoolArray => serializer.serialize_i32(2),
                Self::Double => serializer.serialize_i32(3),
                Self::DoubleArray => serializer.serialize_i32(4),
                Self::Int64 => serializer.serialize_i32(9),
                Self::Int64Array => serializer.serialize_i32(10),
                Self::String => serializer.serialize_i32(11),
                Self::StringArray => serializer.serialize_i32(12),
                Self::Bytes => serializer.serialize_i32(13),
                Self::Struct => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.aiplatform.v1.Feature.ValueType",
            ))
        }
    }
}

/// Vertex AI Feature Group.
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureGroup {
    /// Identifier. Name of the FeatureGroup. Format:
    /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this FeatureGroup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this FeatureGroup was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// FeatureGroup.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one
    /// FeatureGroup(System labels are excluded)." System reserved label keys
    /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the FeatureGroup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::feature_group::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl FeatureGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureGroup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeatureGroup::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::FeatureGroup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FeatureGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::FeatureGroup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source][crate::model::FeatureGroup::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::feature_group::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FeatureGroup::source]
    /// if it holds a `BigQuery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_group::BigQuery>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_group::Source::BigQuery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FeatureGroup::source]
    /// to hold a `BigQuery`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_group::BigQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::feature_group::Source::BigQuery(v.into()));
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for FeatureGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup"
    }
}

/// Defines additional types related to [FeatureGroup].
#[cfg(feature = "feature_registry_service")]
pub mod feature_group {
    #[allow(unused_imports)]
    use super::*;

    /// Input source type for BigQuery Tables and Views.
    #[cfg(feature = "feature_registry_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQuery {
        /// Required. Immutable. The BigQuery source URI that points to either a
        /// BigQuery Table or View.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub big_query_source: std::option::Option<crate::model::BigQuerySource>,

        /// Optional. Columns to construct entity_id / row keys.
        /// If not provided defaults to `entity_id`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub entity_id_columns: std::vec::Vec<std::string::String>,

        /// Optional. Set if the data source is not a time-series.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub static_data_source: bool,

        /// Optional. If the source is a time-series source, this can be set to
        /// control how downstream sources (ex:
        /// [FeatureView][google.cloud.aiplatform.v1.FeatureView] ) will treat
        /// time-series sources. If not set, will treat the source as a time-series
        /// source with `feature_timestamp` as timestamp column and no scan boundary.
        ///
        /// [google.cloud.aiplatform.v1.FeatureView]: crate::model::FeatureView
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series: std::option::Option<crate::model::feature_group::big_query::TimeSeries>,

        /// Optional. If set, all feature values will be fetched
        /// from a single row per unique entityId including nulls.
        /// If not set, will collapse all rows for each unique entityId into a singe
        /// row with any non-null values if present, if no non-null values are
        /// present will sync null.
        /// ex: If source has schema
        /// `(entity_id, feature_timestamp, f0, f1)` and the following rows:
        /// `(e1, 2020-01-01T10:00:00.123Z, 10, 15)`
        /// `(e1, 2020-02-01T10:00:00.123Z, 20, null)`
        /// If dense is set, `(e1, 20, null)` is synced to online stores. If dense is
        /// not set, `(e1, 20, 15)` is synced to online stores.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub dense: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_registry_service")]
    impl BigQuery {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [big_query_source][crate::model::feature_group::BigQuery::big_query_source].
        pub fn set_big_query_source<
            T: std::convert::Into<std::option::Option<crate::model::BigQuerySource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.big_query_source = v.into();
            self
        }

        /// Sets the value of [static_data_source][crate::model::feature_group::BigQuery::static_data_source].
        pub fn set_static_data_source<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.static_data_source = v.into();
            self
        }

        /// Sets the value of [time_series][crate::model::feature_group::BigQuery::time_series].
        pub fn set_time_series<
            T: std::convert::Into<
                    std::option::Option<crate::model::feature_group::big_query::TimeSeries>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series = v.into();
            self
        }

        /// Sets the value of [dense][crate::model::feature_group::BigQuery::dense].
        pub fn set_dense<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.dense = v.into();
            self
        }

        /// Sets the value of [entity_id_columns][crate::model::feature_group::BigQuery::entity_id_columns].
        pub fn set_entity_id_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_id_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_registry_service")]
    impl wkt::message::Message for BigQuery {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup.BigQuery"
        }
    }

    /// Defines additional types related to [BigQuery].
    #[cfg(feature = "feature_registry_service")]
    pub mod big_query {
        #[allow(unused_imports)]
        use super::*;

        #[cfg(feature = "feature_registry_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TimeSeries {
            /// Optional. Column hosting timestamp values for a time-series source.
            /// Will be used to determine the latest `feature_values` for each entity.
            /// Optional. If not provided, column named `feature_timestamp` of
            /// type `TIMESTAMP` will be used.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub timestamp_column: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "feature_registry_service")]
        impl TimeSeries {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [timestamp_column][crate::model::feature_group::big_query::TimeSeries::timestamp_column].
            pub fn set_timestamp_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.timestamp_column = v.into();
                self
            }
        }

        #[cfg(feature = "feature_registry_service")]
        impl wkt::message::Message for TimeSeries {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup.BigQuery.TimeSeries"
            }
        }
    }

    #[cfg(feature = "feature_registry_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Indicates that features for this group come from BigQuery Table/View.
        /// By default treats the source as a sparse time series source. The BigQuery
        /// source table or view must have at least one entity ID column and a column
        /// named `feature_timestamp`.
        BigQuery(std::boxed::Box<crate::model::feature_group::BigQuery>),
    }
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI
/// defined proto, for UI to display.
#[cfg(any(
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "job_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureStatsAnomaly {
    /// Feature importance score, only populated when cross-feature monitoring is
    /// enabled. For now only used to represent feature attribution score within
    /// range [0, 1] for
    /// [ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW][google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW]
    /// and
    /// [ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT][google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT].
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT]: crate::model::ModelDeploymentMonitoringObjectiveType::FeatureAttributionDrift
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW]: crate::model::ModelDeploymentMonitoringObjectiveType::FeatureAttributionSkew
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub score: f64,

    /// Path of the stats file for current feature values in Cloud Storage bucket.
    /// Format: gs://<bucket_name>/<object_name>/stats.
    /// Example: gs://monitoring_bucket/feature_name/stats.
    /// Stats are stored as binary format with Protobuf message
    /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stats_uri: std::string::String,

    /// Path of the anomaly file for current feature values in Cloud Storage
    /// bucket.
    /// Format: gs://<bucket_name>/<object_name>/anomalies.
    /// Example: gs://monitoring_bucket/feature_name/anomalies.
    /// Stats are stored as binary format with Protobuf message
    /// Anoamlies are stored as binary format with Protobuf message
    /// [tensorflow.metadata.v0.AnomalyInfo]
    /// (<https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto>).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub anomaly_uri: std::string::String,

    /// Deviation from the current stats to baseline stats.
    ///
    /// . For categorical feature, the distribution distance is calculated by
    ///   L-inifinity norm.
    /// . For numerical feature, the distribution distance is calculated by
    ///   JensenShannon divergence.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub distribution_deviation: f64,

    /// This is the threshold used when detecting anomalies.
    /// The threshold can be changed by user, so this one might be different from
    /// [ThresholdConfig.value][google.cloud.aiplatform.v1.ThresholdConfig.value].
    ///
    /// [google.cloud.aiplatform.v1.ThresholdConfig.value]: crate::model::ThresholdConfig::threshold
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub anomaly_detection_threshold: f64,

    /// The start timestamp of window where stats were generated.
    /// For objectives where time window doesn't make sense (e.g. Featurestore
    /// Snapshot Monitoring), start_time is only used to indicate the monitoring
    /// intervals, so it always equals to (end_time - monitoring_interval).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end timestamp of window where stats were generated.
    /// For objectives where time window doesn't make sense (e.g. Featurestore
    /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
    /// generate stats (e.g. timestamp we take snapshots for feature values).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "job_service",
))]
impl FeatureStatsAnomaly {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::FeatureStatsAnomaly::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [stats_uri][crate::model::FeatureStatsAnomaly::stats_uri].
    pub fn set_stats_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.stats_uri = v.into();
        self
    }

    /// Sets the value of [anomaly_uri][crate::model::FeatureStatsAnomaly::anomaly_uri].
    pub fn set_anomaly_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.anomaly_uri = v.into();
        self
    }

    /// Sets the value of [distribution_deviation][crate::model::FeatureStatsAnomaly::distribution_deviation].
    pub fn set_distribution_deviation<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.distribution_deviation = v.into();
        self
    }

    /// Sets the value of [anomaly_detection_threshold][crate::model::FeatureStatsAnomaly::anomaly_detection_threshold].
    pub fn set_anomaly_detection_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.anomaly_detection_threshold = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::FeatureStatsAnomaly::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::FeatureStatsAnomaly::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

#[cfg(any(
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "job_service",
))]
impl wkt::message::Message for FeatureStatsAnomaly {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureStatsAnomaly"
    }
}

/// Vertex AI Feature Online Store provides a centralized repository for serving
/// ML features and embedding indexes at low latency. The Feature Online Store is
/// a top-level container.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureOnlineStore {
    /// Identifier. Name of the FeatureOnlineStore. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this FeatureOnlineStore was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this FeatureOnlineStore was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// FeatureOnlineStore.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one
    /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
    /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the featureOnlineStore.
    pub state: crate::model::feature_online_store::State,

    /// Optional. The dedicated serving endpoint for this FeatureOnlineStore, which
    /// is different from common Vertex service endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_serving_endpoint:
        std::option::Option<crate::model::feature_online_store::DedicatedServingEndpoint>,

    /// Optional. Customer-managed encryption key spec for data storage. If set,
    /// online store will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub storage_type: std::option::Option<crate::model::feature_online_store::StorageType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl FeatureOnlineStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureOnlineStore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureOnlineStore::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeatureOnlineStore::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::FeatureOnlineStore::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::FeatureOnlineStore::state].
    pub fn set_state<T: std::convert::Into<crate::model::feature_online_store::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [dedicated_serving_endpoint][crate::model::FeatureOnlineStore::dedicated_serving_endpoint].
    pub fn set_dedicated_serving_endpoint<
        T: std::convert::Into<
                std::option::Option<crate::model::feature_online_store::DedicatedServingEndpoint>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_serving_endpoint = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::FeatureOnlineStore::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::FeatureOnlineStore::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::FeatureOnlineStore::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::FeatureOnlineStore::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStore::storage_type].
    ///
    /// Note that all the setters affecting `storage_type` are mutually
    /// exclusive.
    pub fn set_storage_type<
        T: std::convert::Into<std::option::Option<crate::model::feature_online_store::StorageType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// The value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// if it holds a `Bigtable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigtable(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_online_store::Bigtable>> {
        #[allow(unreachable_patterns)]
        self.storage_type.as_ref().and_then(|v| match v {
            crate::model::feature_online_store::StorageType::Bigtable(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// if it holds a `Optimized`, `None` if the field is not set or
    /// holds a different branch.
    pub fn optimized(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_online_store::Optimized>> {
        #[allow(unreachable_patterns)]
        self.storage_type.as_ref().and_then(|v| match v {
            crate::model::feature_online_store::StorageType::Optimized(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// to hold a `Bigtable`.
    ///
    /// Note that all the setters affecting `storage_type` are
    /// mutually exclusive.
    pub fn set_bigtable<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_online_store::Bigtable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = std::option::Option::Some(
            crate::model::feature_online_store::StorageType::Bigtable(v.into()),
        );
        self
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// to hold a `Optimized`.
    ///
    /// Note that all the setters affecting `storage_type` are
    /// mutually exclusive.
    pub fn set_optimized<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_online_store::Optimized>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = std::option::Option::Some(
            crate::model::feature_online_store::StorageType::Optimized(v.into()),
        );
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for FeatureOnlineStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore"
    }
}

/// Defines additional types related to [FeatureOnlineStore].
#[cfg(feature = "feature_online_store_admin_service")]
pub mod feature_online_store {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Bigtable {
        /// Required. Autoscaling config applied to Bigtable Instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub auto_scaling:
            std::option::Option<crate::model::feature_online_store::bigtable::AutoScaling>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl Bigtable {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [auto_scaling][crate::model::feature_online_store::Bigtable::auto_scaling].
        pub fn set_auto_scaling<
            T: std::convert::Into<
                    std::option::Option<crate::model::feature_online_store::bigtable::AutoScaling>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auto_scaling = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for Bigtable {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable"
        }
    }

    /// Defines additional types related to [Bigtable].
    #[cfg(feature = "feature_online_store_admin_service")]
    pub mod bigtable {
        #[allow(unused_imports)]
        use super::*;

        #[cfg(feature = "feature_online_store_admin_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AutoScaling {
            /// Required. The minimum number of nodes to scale down to. Must be greater
            /// than or equal to 1.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub min_node_count: i32,

            /// Required. The maximum number of nodes to scale up to. Must be greater
            /// than or equal to min_node_count, and less than or equal to 10 times of
            /// 'min_node_count'.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_node_count: i32,

            /// Optional. A percentage of the cluster's CPU capacity. Can be from 10%
            /// to 80%. When a cluster's CPU utilization exceeds the target that you
            /// have set, Bigtable immediately adds nodes to the cluster. When CPU
            /// utilization is substantially lower than the target, Bigtable removes
            /// nodes. If not set will default to 50%.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub cpu_utilization_target: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl AutoScaling {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_node_count][crate::model::feature_online_store::bigtable::AutoScaling::min_node_count].
            pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.min_node_count = v.into();
                self
            }

            /// Sets the value of [max_node_count][crate::model::feature_online_store::bigtable::AutoScaling::max_node_count].
            pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_node_count = v.into();
                self
            }

            /// Sets the value of [cpu_utilization_target][crate::model::feature_online_store::bigtable::AutoScaling::cpu_utilization_target].
            pub fn set_cpu_utilization_target<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_utilization_target = v.into();
                self
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl wkt::message::Message for AutoScaling {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable.AutoScaling"
            }
        }
    }

    /// Optimized storage type
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Optimized {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl Optimized {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for Optimized {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Optimized"
        }
    }

    /// The dedicated serving endpoint for this FeatureOnlineStore. Only need to
    /// set when you choose Optimized storage type. Public endpoint is provisioned
    /// by default.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DedicatedServingEndpoint {
        /// Output only. This field will be populated with the domain name to use for
        /// this FeatureOnlineStore
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub public_endpoint_domain_name: std::string::String,

        /// Optional. Private service connect config. The private service connection
        /// is available only for Optimized storage type, not for embedding
        /// management now. If
        /// [PrivateServiceConnectConfig.enable_private_service_connect][google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]
        /// set to true, customers will use private service connection to send
        /// request. Otherwise, the connection will set to public endpoint.
        ///
        /// [google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]: crate::model::PrivateServiceConnectConfig::enable_private_service_connect
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub private_service_connect_config:
            std::option::Option<crate::model::PrivateServiceConnectConfig>,

        /// Output only. The name of the service attachment resource. Populated if
        /// private service connect is enabled and after FeatureViewSync is created.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_attachment: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl DedicatedServingEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [public_endpoint_domain_name][crate::model::feature_online_store::DedicatedServingEndpoint::public_endpoint_domain_name].
        pub fn set_public_endpoint_domain_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.public_endpoint_domain_name = v.into();
            self
        }

        /// Sets the value of [private_service_connect_config][crate::model::feature_online_store::DedicatedServingEndpoint::private_service_connect_config].
        pub fn set_private_service_connect_config<
            T: std::convert::Into<std::option::Option<crate::model::PrivateServiceConnectConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.private_service_connect_config = v.into();
            self
        }

        /// Sets the value of [service_attachment][crate::model::feature_online_store::DedicatedServingEndpoint::service_attachment].
        pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for DedicatedServingEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.DedicatedServingEndpoint"
        }
    }

    /// Possible states a featureOnlineStore can have.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "feature_online_store_admin_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// State when the featureOnlineStore configuration is not being updated and
        /// the fields reflect the current configuration of the featureOnlineStore.
        /// The featureOnlineStore is usable in this state.
        Stable,
        /// The state of the featureOnlineStore configuration when it is being
        /// updated. During an update, the fields reflect either the original
        /// configuration or the updated configuration of the featureOnlineStore. The
        /// featureOnlineStore is still usable in this state.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "feature_online_store_admin_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Stable => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Stable => std::option::Option::Some("STABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Stable,
                2 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STABLE" => Self::Stable,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Stable => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.FeatureOnlineStore.State",
            ))
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StorageType {
        /// Contains settings for the Cloud Bigtable instance that will be created
        /// to serve featureValues for all FeatureViews under this
        /// FeatureOnlineStore.
        Bigtable(std::boxed::Box<crate::model::feature_online_store::Bigtable>),
        /// Contains settings for the Optimized store that will be created
        /// to serve featureValues for all FeatureViews under this
        /// FeatureOnlineStore. When choose Optimized storage type, need to set
        /// [PrivateServiceConnectConfig.enable_private_service_connect][google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]
        /// to use private endpoint. Otherwise will use public endpoint by default.
        ///
        /// [google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]: crate::model::PrivateServiceConnectConfig::enable_private_service_connect
        Optimized(std::boxed::Box<crate::model::feature_online_store::Optimized>),
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.CreateFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::create_feature_online_store
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureOnlineStoreRequest {
    /// Required. The resource name of the Location to create FeatureOnlineStores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The FeatureOnlineStore to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_online_store: std::option::Option<crate::model::FeatureOnlineStore>,

    /// Required. The ID to use for this FeatureOnlineStore, which will become the
    /// final component of the FeatureOnlineStore's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_online_store_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl CreateFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureOnlineStoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature_online_store][crate::model::CreateFeatureOnlineStoreRequest::feature_online_store].
    pub fn set_feature_online_store<
        T: std::convert::Into<std::option::Option<crate::model::FeatureOnlineStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_online_store = v.into();
        self
    }

    /// Sets the value of [feature_online_store_id][crate::model::CreateFeatureOnlineStoreRequest::feature_online_store_id].
    pub fn set_feature_online_store_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_online_store_id = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for CreateFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.GetFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::get_feature_online_store
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureOnlineStoreRequest {
    /// Required. The name of the FeatureOnlineStore resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl GetFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureOnlineStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for GetFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]: crate::client::FeatureOnlineStoreAdminService::list_feature_online_stores
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureOnlineStoresRequest {
    /// Required. The resource name of the Location to list FeatureOnlineStores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureOnlineStores that match the filter expression. The
    /// following fields are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `labels`: Supports key-value equality and key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
    ///   FeatureOnlineStores created or updated after 2020-01-01.
    /// * `labels.env = "prod"`
    ///   FeatureOnlineStores with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureOnlineStores to return. The service may return
    /// fewer than this value. If unspecified, at most 100 FeatureOnlineStores will
    /// be returned. The maximum value is 100; any value greater than 100 will be
    /// coerced to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]: crate::client::FeatureOnlineStoreAdminService::list_feature_online_stores
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported Fields:
    ///
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl ListFeatureOnlineStoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureOnlineStoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureOnlineStoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureOnlineStoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureOnlineStoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureOnlineStoresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for ListFeatureOnlineStoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]: crate::client::FeatureOnlineStoreAdminService::list_feature_online_stores
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureOnlineStoresResponse {
    /// The FeatureOnlineStores matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_online_stores: std::vec::Vec<crate::model::FeatureOnlineStore>,

    /// A token, which can be sent as
    /// [ListFeatureOnlineStoresRequest.page_token][google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest.page_token]: crate::model::ListFeatureOnlineStoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl ListFeatureOnlineStoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureOnlineStoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_online_stores][crate::model::ListFeatureOnlineStoresResponse::feature_online_stores].
    pub fn set_feature_online_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureOnlineStore>,
    {
        use std::iter::Iterator;
        self.feature_online_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for ListFeatureOnlineStoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureOnlineStoresResponse"
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeatureOnlineStoresResponse {
    type PageItem = crate::model::FeatureOnlineStore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_online_stores
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::update_feature_online_store
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureOnlineStoreRequest {
    /// Required. The FeatureOnlineStore's `name` field is used to identify the
    /// FeatureOnlineStore to be updated. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_online_store: std::option::Option<crate::model::FeatureOnlineStore>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// FeatureOnlineStore resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `description`
    /// * `bigtable`
    /// * `bigtable.auto_scaling`
    /// * `bigtable.enable_multi_region_replica`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl UpdateFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_online_store][crate::model::UpdateFeatureOnlineStoreRequest::feature_online_store].
    pub fn set_feature_online_store<
        T: std::convert::Into<std::option::Option<crate::model::FeatureOnlineStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_online_store = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureOnlineStoreRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for UpdateFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::delete_feature_online_store
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureOnlineStoreRequest {
    /// Required. The name of the FeatureOnlineStore to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any FeatureViews and Features for this FeatureOnlineStore
    /// will also be deleted. (Otherwise, the request will only work if the
    /// FeatureOnlineStore has no FeatureViews.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl DeleteFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureOnlineStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFeatureOnlineStoreRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for DeleteFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.CreateFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureView]: crate::client::FeatureOnlineStoreAdminService::create_feature_view
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureViewRequest {
    /// Required. The resource name of the FeatureOnlineStore to create
    /// FeatureViews. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The FeatureView to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_view: std::option::Option<crate::model::FeatureView>,

    /// Required. The ID to use for the FeatureView, which will become the final
    /// component of the FeatureView's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within a FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view_id: std::string::String,

    /// Immutable. If set to true, one on demand sync will be run immediately,
    /// regardless whether the
    /// [FeatureView.sync_config][google.cloud.aiplatform.v1.FeatureView.sync_config]
    /// is configured or not.
    ///
    /// [google.cloud.aiplatform.v1.FeatureView.sync_config]: crate::model::FeatureView::sync_config
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_sync_immediately: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl CreateFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature_view][crate::model::CreateFeatureViewRequest::feature_view].
    pub fn set_feature_view<
        T: std::convert::Into<std::option::Option<crate::model::FeatureView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [feature_view_id][crate::model::CreateFeatureViewRequest::feature_view_id].
    pub fn set_feature_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view_id = v.into();
        self
    }

    /// Sets the value of [run_sync_immediately][crate::model::CreateFeatureViewRequest::run_sync_immediately].
    pub fn set_run_sync_immediately<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_sync_immediately = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for CreateFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureViewRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.GetFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureView]: crate::client::FeatureOnlineStoreAdminService::get_feature_view
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureViewRequest {
    /// Required. The name of the FeatureView resource.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl GetFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for GetFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureViewRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]: crate::client::FeatureOnlineStoreAdminService::list_feature_views
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewsRequest {
    /// Required. The resource name of the FeatureOnlineStore to list FeatureViews.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureViews that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `labels`: Supports key-value equality as well as key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
    ///   update_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViews
    ///   created or updated after 2020-01-31T15:30:00.000000Z.
    /// * `labels.active = yes AND labels.env = prod` --> FeatureViews having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any FeatureView which has a label with 'env' as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureViews to return. The service may return fewer
    /// than this value. If unspecified, at most 1000 FeatureViews will be
    /// returned. The maximum value is 1000; any value greater than 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]: crate::client::FeatureOnlineStoreAdminService::list_feature_views
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `feature_view_id`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl ListFeatureViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureViewsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureViewsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for ListFeatureViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewsRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]: crate::client::FeatureOnlineStoreAdminService::list_feature_views
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewsResponse {
    /// The FeatureViews matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_views: std::vec::Vec<crate::model::FeatureView>,

    /// A token, which can be sent as
    /// [ListFeatureViewsRequest.page_token][google.cloud.aiplatform.v1.ListFeatureViewsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureViewsRequest.page_token]: crate::model::ListFeatureViewsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl ListFeatureViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_views][crate::model::ListFeatureViewsResponse::feature_views].
    pub fn set_feature_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureView>,
    {
        use std::iter::Iterator;
        self.feature_views = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for ListFeatureViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewsResponse"
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeatureViewsResponse {
    type PageItem = crate::model::FeatureView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.UpdateFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureView]: crate::client::FeatureOnlineStoreAdminService::update_feature_view
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureViewRequest {
    /// Required. The FeatureView's `name` field is used to identify the
    /// FeatureView to be updated. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_view: std::option::Option<crate::model::FeatureView>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// FeatureView resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `service_agent_type`
    /// * `big_query_source`
    /// * `big_query_source.uri`
    /// * `big_query_source.entity_id_columns`
    /// * `feature_registry_source`
    /// * `feature_registry_source.feature_groups`
    /// * `sync_config`
    /// * `sync_config.cron`
    /// * `optimized_config.automatic_resources`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl UpdateFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::UpdateFeatureViewRequest::feature_view].
    pub fn set_feature_view<
        T: std::convert::Into<std::option::Option<crate::model::FeatureView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureViewRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for UpdateFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureViewRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.DeleteFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureView]: crate::client::FeatureOnlineStoreAdminService::delete_feature_view
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureViewRequest {
    /// Required. The name of the FeatureView to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl DeleteFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for DeleteFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureViewRequest"
    }
}

/// Details of operations that perform create FeatureOnlineStore.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureOnlineStoreOperationMetadata {
    /// Operation metadata for FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl CreateFeatureOnlineStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureOnlineStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for CreateFeatureOnlineStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOnlineStoreOperationMetadata"
    }
}

/// Details of operations that perform update FeatureOnlineStore.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureOnlineStoreOperationMetadata {
    /// Operation metadata for FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl UpdateFeatureOnlineStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureOnlineStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for UpdateFeatureOnlineStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreOperationMetadata"
    }
}

/// Details of operations that perform create FeatureView.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureViewOperationMetadata {
    /// Operation metadata for FeatureView Create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl CreateFeatureViewOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureViewOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for CreateFeatureViewOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureViewOperationMetadata"
    }
}

/// Details of operations that perform update FeatureView.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureViewOperationMetadata {
    /// Operation metadata for FeatureView Update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl UpdateFeatureViewOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureViewOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for UpdateFeatureViewOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureViewOperationMetadata"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.SyncFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView]: crate::client::FeatureOnlineStoreAdminService::sync_feature_view
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncFeatureViewRequest {
    /// Required. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl SyncFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::SyncFeatureViewRequest::feature_view].
    pub fn set_feature_view<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for SyncFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyncFeatureViewRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.SyncFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView]: crate::client::FeatureOnlineStoreAdminService::sync_feature_view
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncFeatureViewResponse {
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view_sync: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl SyncFeatureViewResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view_sync][crate::model::SyncFeatureViewResponse::feature_view_sync].
    pub fn set_feature_view_sync<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_view_sync = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for SyncFeatureViewResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyncFeatureViewResponse"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.GetFeatureViewSync][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureViewSync].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureViewSync]: crate::client::FeatureOnlineStoreAdminService::get_feature_view_sync
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureViewSyncRequest {
    /// Required. The name of the FeatureViewSync resource.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl GetFeatureViewSyncRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureViewSyncRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for GetFeatureViewSyncRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureViewSyncRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]: crate::client::FeatureOnlineStoreAdminService::list_feature_view_syncs
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewSyncsRequest {
    /// Required. The resource name of the FeatureView to list FeatureViewSyncs.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureViewSyncs that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    ///
    /// Examples:
    ///
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViewSyncs
    ///   created after 2020-01-31T15:30:00.000000Z.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureViewSyncs to return. The service may return
    /// fewer than this value. If unspecified, at most 1000 FeatureViewSyncs will
    /// be returned. The maximum value is 1000; any value greater than 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]: crate::client::FeatureOnlineStoreAdminService::list_feature_view_syncs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `create_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl ListFeatureViewSyncsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureViewSyncsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureViewSyncsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureViewSyncsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureViewSyncsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureViewSyncsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for ListFeatureViewSyncsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]: crate::client::FeatureOnlineStoreAdminService::list_feature_view_syncs
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewSyncsResponse {
    /// The FeatureViewSyncs matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_view_syncs: std::vec::Vec<crate::model::FeatureViewSync>,

    /// A token, which can be sent as
    /// [ListFeatureViewSyncsRequest.page_token][google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest.page_token]: crate::model::ListFeatureViewSyncsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl ListFeatureViewSyncsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureViewSyncsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_view_syncs][crate::model::ListFeatureViewSyncsResponse::feature_view_syncs].
    pub fn set_feature_view_syncs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureViewSync>,
    {
        use std::iter::Iterator;
        self.feature_view_syncs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for ListFeatureViewSyncsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewSyncsResponse"
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeatureViewSyncsResponse {
    type PageItem = crate::model::FeatureViewSync;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_view_syncs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Lookup key for a feature view.
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureViewDataKey {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub key_oneof: std::option::Option<crate::model::feature_view_data_key::KeyOneof>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl FeatureViewDataKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof].
    ///
    /// Note that all the setters affecting `key_oneof` are mutually
    /// exclusive.
    pub fn set_key_oneof<
        T: std::convert::Into<std::option::Option<crate::model::feature_view_data_key::KeyOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_oneof = v.into();
        self
    }

    /// The value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// if it holds a `Key`, `None` if the field is not set or
    /// holds a different branch.
    pub fn key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key_oneof.as_ref().and_then(|v| match v {
            crate::model::feature_view_data_key::KeyOneof::Key(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// if it holds a `CompositeKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn composite_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view_data_key::CompositeKey>>
    {
        #[allow(unreachable_patterns)]
        self.key_oneof.as_ref().and_then(|v| match v {
            crate::model::feature_view_data_key::KeyOneof::CompositeKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// to hold a `Key`.
    ///
    /// Note that all the setters affecting `key_oneof` are
    /// mutually exclusive.
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_oneof =
            std::option::Option::Some(crate::model::feature_view_data_key::KeyOneof::Key(v.into()));
        self
    }

    /// Sets the value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// to hold a `CompositeKey`.
    ///
    /// Note that all the setters affecting `key_oneof` are
    /// mutually exclusive.
    pub fn set_composite_key<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view_data_key::CompositeKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_oneof = std::option::Option::Some(
            crate::model::feature_view_data_key::KeyOneof::CompositeKey(v.into()),
        );
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for FeatureViewDataKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDataKey"
    }
}

/// Defines additional types related to [FeatureViewDataKey].
#[cfg(feature = "feature_online_store_service")]
pub mod feature_view_data_key {
    #[allow(unused_imports)]
    use super::*;

    /// ID that is comprised from several parts (columns).
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CompositeKey {
        /// Parts to construct Entity ID. Should match with the same ID columns as
        /// defined in FeatureView in the same order.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub parts: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl CompositeKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parts][crate::model::feature_view_data_key::CompositeKey::parts].
        pub fn set_parts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.parts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for CompositeKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDataKey.CompositeKey"
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum KeyOneof {
        /// String key to use for lookup.
        Key(std::string::String),
        /// The actual Entity ID will be composed from this struct. This should match
        /// with the way ID is defined in the FeatureView spec.
        CompositeKey(std::boxed::Box<crate::model::feature_view_data_key::CompositeKey>),
    }
}

/// Request message for
/// [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues].
/// All the features under the requested feature view will be returned.
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]: crate::client::FeatureOnlineStoreService::fetch_feature_values
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchFeatureValuesRequest {
    /// Required. FeatureView resource format
    /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view: std::string::String,

    /// Optional. The request key to fetch feature values for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_key: std::option::Option<crate::model::FeatureViewDataKey>,

    /// Optional. Response data format. If not set,
    /// [FeatureViewDataFormat.KEY_VALUE][google.cloud.aiplatform.v1.FeatureViewDataFormat.KEY_VALUE]
    /// will be used.
    ///
    /// [google.cloud.aiplatform.v1.FeatureViewDataFormat.KEY_VALUE]: crate::model::FeatureViewDataFormat::KeyValue
    pub data_format: crate::model::FeatureViewDataFormat,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl FetchFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::FetchFeatureValuesRequest::feature_view].
    pub fn set_feature_view<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [data_key][crate::model::FetchFeatureValuesRequest::data_key].
    pub fn set_data_key<
        T: std::convert::Into<std::option::Option<crate::model::FeatureViewDataKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_key = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::FetchFeatureValuesRequest::data_format].
    pub fn set_data_format<T: std::convert::Into<crate::model::FeatureViewDataFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for FetchFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]: crate::client::FeatureOnlineStoreService::fetch_feature_values
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchFeatureValuesResponse {
    /// The data key associated with this response.
    /// Will only be populated for
    /// [FeatureOnlineStoreService.StreamingFetchFeatureValues][] RPCs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_key: std::option::Option<crate::model::FeatureViewDataKey>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub format: std::option::Option<crate::model::fetch_feature_values_response::Format>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl FetchFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_key][crate::model::FetchFeatureValuesResponse::data_key].
    pub fn set_data_key<
        T: std::convert::Into<std::option::Option<crate::model::FeatureViewDataKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_key = v.into();
        self
    }

    /// Sets the value of [format][crate::model::FetchFeatureValuesResponse::format].
    ///
    /// Note that all the setters affecting `format` are mutually
    /// exclusive.
    pub fn set_format<
        T: std::convert::Into<
                std::option::Option<crate::model::fetch_feature_values_response::Format>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// The value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// if it holds a `KeyValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn key_values(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::fetch_feature_values_response::FeatureNameValuePairList>,
    > {
        #[allow(unreachable_patterns)]
        self.format.as_ref().and_then(|v| match v {
            crate::model::fetch_feature_values_response::Format::KeyValues(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// if it holds a `ProtoStruct`, `None` if the field is not set or
    /// holds a different branch.
    pub fn proto_struct(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.format.as_ref().and_then(|v| match v {
            crate::model::fetch_feature_values_response::Format::ProtoStruct(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// to hold a `KeyValues`.
    ///
    /// Note that all the setters affecting `format` are
    /// mutually exclusive.
    pub fn set_key_values<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::fetch_feature_values_response::FeatureNameValuePairList,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format = std::option::Option::Some(
            crate::model::fetch_feature_values_response::Format::KeyValues(v.into()),
        );
        self
    }

    /// Sets the value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// to hold a `ProtoStruct`.
    ///
    /// Note that all the setters affecting `format` are
    /// mutually exclusive.
    pub fn set_proto_struct<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = std::option::Option::Some(
            crate::model::fetch_feature_values_response::Format::ProtoStruct(v.into()),
        );
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for FetchFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse"
    }
}

/// Defines additional types related to [FetchFeatureValuesResponse].
#[cfg(feature = "feature_online_store_service")]
pub mod fetch_feature_values_response {
    #[allow(unused_imports)]
    use super::*;

    /// Response structure in the format of key (feature name) and (feature) value
    /// pair.
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureNameValuePairList {

        /// List of feature names and values.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub features: std::vec::Vec<crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl FeatureNameValuePairList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [features][crate::model::fetch_feature_values_response::FeatureNameValuePairList::features].
        pub fn set_features<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair>
        {
            use std::iter::Iterator;
            self.features = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for FeatureNameValuePairList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList"
        }
    }

    /// Defines additional types related to [FeatureNameValuePairList].
    #[cfg(feature = "feature_online_store_service")]
    pub mod feature_name_value_pair_list {
        #[allow(unused_imports)]
        use super::*;

        /// Feature name & value pair.
        #[cfg(feature = "feature_online_store_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FeatureNameValuePair {

            /// Feature short name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub data: std::option::Option<crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "feature_online_store_service")]
        impl FeatureNameValuePair {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [data][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::data].
            ///
            /// Note that all the setters affecting `data` are mutually
            /// exclusive.
            pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data>>>(mut self, v: T) -> Self
            {
                self.data = v.into();
                self
            }

            /// The value of [data][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::data]
            /// if it holds a `Value`, `None` if the field is not set or
            /// holds a different branch.
            pub fn value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureValue>> {
                #[allow(unreachable_patterns)]
                self.data.as_ref().and_then(|v| match v {
                    crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data::Value(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [data][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::data]
            /// to hold a `Value`.
            ///
            /// Note that all the setters affecting `data` are
            /// mutually exclusive.
            pub fn set_value<T: std::convert::Into<std::boxed::Box<crate::model::FeatureValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.data = std::option::Option::Some(
                    crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data::Value(
                        v.into()
                    )
                );
                self
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl wkt::message::Message for FeatureNameValuePair {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair"
            }
        }

        /// Defines additional types related to [FeatureNameValuePair].
        #[cfg(feature = "feature_online_store_service")]
        pub mod feature_name_value_pair {
            #[allow(unused_imports)]
            use super::*;

            #[cfg(feature = "feature_online_store_service")]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Data {
                /// Feature value.
                Value(std::boxed::Box<crate::model::FeatureValue>),
            }
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Format {
        /// Feature values in KeyValue format.
        KeyValues(
            std::boxed::Box<crate::model::fetch_feature_values_response::FeatureNameValuePairList>,
        ),
        /// Feature values in proto Struct format.
        ProtoStruct(std::boxed::Box<wkt::Struct>),
    }
}

/// A query to find a number of similar entities.
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NearestNeighborQuery {
    /// Optional. The number of similar entities to be retrieved from feature view
    /// for each query.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub neighbor_count: i32,

    /// Optional. The list of string filters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub string_filters: std::vec::Vec<crate::model::nearest_neighbor_query::StringFilter>,

    /// Optional. The list of numeric filters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub numeric_filters: std::vec::Vec<crate::model::nearest_neighbor_query::NumericFilter>,

    /// Optional. Crowding is a constraint on a neighbor list produced by nearest
    /// neighbor search requiring that no more than
    /// sper_crowding_attribute_neighbor_count of the k neighbors returned have the
    /// same value of crowding_attribute. It's used for improving result diversity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub per_crowding_attribute_neighbor_count: i32,

    /// Optional. Parameters that can be set to tune query on the fly.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::nearest_neighbor_query::Parameters>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::nearest_neighbor_query::Instance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl NearestNeighborQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_count][crate::model::NearestNeighborQuery::neighbor_count].
    pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.neighbor_count = v.into();
        self
    }

    /// Sets the value of [per_crowding_attribute_neighbor_count][crate::model::NearestNeighborQuery::per_crowding_attribute_neighbor_count].
    pub fn set_per_crowding_attribute_neighbor_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_crowding_attribute_neighbor_count = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::NearestNeighborQuery::parameters].
    pub fn set_parameters<
        T: std::convert::Into<std::option::Option<crate::model::nearest_neighbor_query::Parameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [string_filters][crate::model::NearestNeighborQuery::string_filters].
    pub fn set_string_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nearest_neighbor_query::StringFilter>,
    {
        use std::iter::Iterator;
        self.string_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [numeric_filters][crate::model::NearestNeighborQuery::numeric_filters].
    pub fn set_numeric_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nearest_neighbor_query::NumericFilter>,
    {
        use std::iter::Iterator;
        self.numeric_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance][crate::model::NearestNeighborQuery::instance].
    ///
    /// Note that all the setters affecting `instance` are mutually
    /// exclusive.
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::nearest_neighbor_query::Instance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// The value of [instance][crate::model::NearestNeighborQuery::instance]
    /// if it holds a `EntityId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::nearest_neighbor_query::Instance::EntityId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [instance][crate::model::NearestNeighborQuery::instance]
    /// if it holds a `Embedding`, `None` if the field is not set or
    /// holds a different branch.
    pub fn embedding(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::nearest_neighbor_query::Embedding>>
    {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::nearest_neighbor_query::Instance::Embedding(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance][crate::model::NearestNeighborQuery::instance]
    /// to hold a `EntityId`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::nearest_neighbor_query::Instance::EntityId(v.into()),
        );
        self
    }

    /// Sets the value of [instance][crate::model::NearestNeighborQuery::instance]
    /// to hold a `Embedding`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_embedding<
        T: std::convert::Into<std::boxed::Box<crate::model::nearest_neighbor_query::Embedding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::nearest_neighbor_query::Instance::Embedding(v.into()),
        );
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for NearestNeighborQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery"
    }
}

/// Defines additional types related to [NearestNeighborQuery].
#[cfg(feature = "feature_online_store_service")]
pub mod nearest_neighbor_query {
    #[allow(unused_imports)]
    use super::*;

    /// The embedding vector.
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Embedding {
        /// Optional. Individual value in the embedding.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub value: std::vec::Vec<f32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl Embedding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::Embedding::value].
        pub fn set_value<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.value = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for Embedding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.Embedding"
        }
    }

    /// String filter is used to search a subset of the entities by using boolean
    /// rules on string columns.
    /// For example: if a query specifies string filter
    /// with 'name = color, allow_tokens = {red, blue}, deny_tokens = {purple}','
    /// then that query will match entities that are red or blue, but if those
    /// points are also purple, then they will be excluded even if they are
    /// red/blue. Only string filter is supported for now, numeric filter will be
    /// supported in the near future.
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StringFilter {
        /// Required. Column names in BigQuery that used as filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. The allowed tokens.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allow_tokens: std::vec::Vec<std::string::String>,

        /// Optional. The denied tokens.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub deny_tokens: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl StringFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::nearest_neighbor_query::StringFilter::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [allow_tokens][crate::model::nearest_neighbor_query::StringFilter::allow_tokens].
        pub fn set_allow_tokens<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allow_tokens = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [deny_tokens][crate::model::nearest_neighbor_query::StringFilter::deny_tokens].
        pub fn set_deny_tokens<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.deny_tokens = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for StringFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.StringFilter"
        }
    }

    /// Numeric filter is used to search a subset of the entities by using boolean
    /// rules on numeric columns.
    /// For example:
    /// Database Point 0: {name: "a" value_int: 42} {name: "b" value_float: 1.0}
    /// Database Point 1:  {name: "a" value_int: 10} {name: "b" value_float: 2.0}
    /// Database Point 2: {name: "a" value_int: -1} {name: "b" value_float: 3.0}
    /// Query: {name: "a" value_int: 12 operator: LESS}    // Matches Point 1, 2
    /// {name: "b" value_float: 2.0 operator: EQUAL} // Matches Point 1
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericFilter {
        /// Required. Column name in BigQuery that used as filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. This MUST be specified for queries and must NOT be specified
        /// for database points.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub op: std::option::Option<crate::model::nearest_neighbor_query::numeric_filter::Operator>,

        /// The type of Value must be consistent for all datapoints with a given
        /// name.  This is verified at runtime.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::nearest_neighbor_query::numeric_filter::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl NumericFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::nearest_neighbor_query::NumericFilter::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [op][crate::model::nearest_neighbor_query::NumericFilter::op].
        pub fn set_op<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::nearest_neighbor_query::numeric_filter::Operator,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.op = v.into();
            self
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::nearest_neighbor_query::numeric_filter::Value,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// if it holds a `ValueInt`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value_int(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueInt(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// if it holds a `ValueFloat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value_float(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueFloat(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// if it holds a `ValueDouble`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value_double(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueDouble(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// to hold a `ValueInt`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_int<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueInt(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// to hold a `ValueFloat`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueFloat(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// to hold a `ValueDouble`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueDouble(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for NumericFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.NumericFilter"
        }
    }

    /// Defines additional types related to [NumericFilter].
    #[cfg(feature = "feature_online_store_service")]
    pub mod numeric_filter {
        #[allow(unused_imports)]
        use super::*;

        /// Datapoints for which Operator is true relative to the query's Value
        /// field will be allowlisted.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "feature_online_store_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operator {
            /// Unspecified operator.
            Unspecified,
            /// Entities are eligible if their value is < the query's.
            Less,
            /// Entities are eligible if their value is <= the query's.
            LessEqual,
            /// Entities are eligible if their value is == the query's.
            Equal,
            /// Entities are eligible if their value is >= the query's.
            GreaterEqual,
            /// Entities are eligible if their value is > the query's.
            Greater,
            /// Entities are eligible if their value is != the query's.
            NotEqual,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Operator::value] or
            /// [Operator::name].
            UnknownValue(operator::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "feature_online_store_service")]
        pub mod operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "feature_online_store_service")]
        impl Operator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Less => std::option::Option::Some(1),
                    Self::LessEqual => std::option::Option::Some(2),
                    Self::Equal => std::option::Option::Some(3),
                    Self::GreaterEqual => std::option::Option::Some(4),
                    Self::Greater => std::option::Option::Some(5),
                    Self::NotEqual => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                    Self::Less => std::option::Option::Some("LESS"),
                    Self::LessEqual => std::option::Option::Some("LESS_EQUAL"),
                    Self::Equal => std::option::Option::Some("EQUAL"),
                    Self::GreaterEqual => std::option::Option::Some("GREATER_EQUAL"),
                    Self::Greater => std::option::Option::Some("GREATER"),
                    Self::NotEqual => std::option::Option::Some("NOT_EQUAL"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl std::default::Default for Operator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl std::fmt::Display for Operator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl std::convert::From<i32> for Operator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Less,
                    2 => Self::LessEqual,
                    3 => Self::Equal,
                    4 => Self::GreaterEqual,
                    5 => Self::Greater,
                    6 => Self::NotEqual,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl std::convert::From<&str> for Operator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "LESS" => Self::Less,
                    "LESS_EQUAL" => Self::LessEqual,
                    "EQUAL" => Self::Equal,
                    "GREATER_EQUAL" => Self::GreaterEqual,
                    "GREATER" => Self::Greater,
                    "NOT_EQUAL" => Self::NotEqual,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl serde::ser::Serialize for Operator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Less => serializer.serialize_i32(1),
                    Self::LessEqual => serializer.serialize_i32(2),
                    Self::Equal => serializer.serialize_i32(3),
                    Self::GreaterEqual => serializer.serialize_i32(4),
                    Self::Greater => serializer.serialize_i32(5),
                    Self::NotEqual => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "feature_online_store_service")]
        impl<'de> serde::de::Deserialize<'de> for Operator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                    ".google.cloud.aiplatform.v1.NearestNeighborQuery.NumericFilter.Operator",
                ))
            }
        }

        /// The type of Value must be consistent for all datapoints with a given
        /// name.  This is verified at runtime.
        #[cfg(feature = "feature_online_store_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// int value type.
            ValueInt(i64),
            /// float value type.
            ValueFloat(f32),
            /// double value type.
            ValueDouble(f64),
        }
    }

    /// Parameters that can be overrided in each query to tune query latency and
    /// recall.
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Parameters {
        /// Optional. The number of neighbors to find via approximate search before
        /// exact reordering is performed; if set, this value must be >
        /// neighbor_count.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub approximate_neighbor_candidates: i32,

        /// Optional. The fraction of the number of leaves to search, set at query
        /// time allows user to tune search performance. This value increase result
        /// in both search accuracy and latency increase. The value should be between
        /// 0.0 and 1.0.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub leaf_nodes_search_fraction: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl Parameters {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [approximate_neighbor_candidates][crate::model::nearest_neighbor_query::Parameters::approximate_neighbor_candidates].
        pub fn set_approximate_neighbor_candidates<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.approximate_neighbor_candidates = v.into();
            self
        }

        /// Sets the value of [leaf_nodes_search_fraction][crate::model::nearest_neighbor_query::Parameters::leaf_nodes_search_fraction].
        pub fn set_leaf_nodes_search_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.leaf_nodes_search_fraction = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for Parameters {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.Parameters"
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Instance {
        /// Optional. The entity id whose similar entities should be searched for.
        /// If embedding is set, search will use embedding instead of
        /// entity_id.
        EntityId(std::string::String),
        /// Optional. The embedding vector that be used for similar search.
        Embedding(std::boxed::Box<crate::model::nearest_neighbor_query::Embedding>),
    }
}

/// The request message for
/// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]: crate::client::FeatureOnlineStoreService::search_nearest_entities
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchNearestEntitiesRequest {
    /// Required. FeatureView resource format
    /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view: std::string::String,

    /// Required. The query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::NearestNeighborQuery>,

    /// Optional. If set to true, the full entities (including all vector values
    /// and metadata) of the nearest neighbors are returned; otherwise only entity
    /// id of the nearest neighbors will be returned. Note that returning full
    /// entities will significantly increase the latency and cost of the query.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub return_full_entity: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl SearchNearestEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::SearchNearestEntitiesRequest::feature_view].
    pub fn set_feature_view<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchNearestEntitiesRequest::query].
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::NearestNeighborQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [return_full_entity][crate::model::SearchNearestEntitiesRequest::return_full_entity].
    pub fn set_return_full_entity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_full_entity = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for SearchNearestEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchNearestEntitiesRequest"
    }
}

/// Nearest neighbors for one query.
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NearestNeighbors {
    /// All its neighbors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub neighbors: std::vec::Vec<crate::model::nearest_neighbors::Neighbor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl NearestNeighbors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbors][crate::model::NearestNeighbors::neighbors].
    pub fn set_neighbors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nearest_neighbors::Neighbor>,
    {
        use std::iter::Iterator;
        self.neighbors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for NearestNeighbors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighbors"
    }
}

/// Defines additional types related to [NearestNeighbors].
#[cfg(feature = "feature_online_store_service")]
pub mod nearest_neighbors {
    #[allow(unused_imports)]
    use super::*;

    /// A neighbor of the query vector.
    #[cfg(feature = "feature_online_store_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Neighbor {
        /// The id of the similar entity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_id: std::string::String,

        /// The distance between the neighbor and the query vector.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub distance: f64,

        /// The attributes of the neighbor, e.g. filters, crowding and metadata
        /// Note that full entities are returned only when "return_full_entity"
        /// is set to true. Otherwise, only the "entity_id" and "distance" fields
        /// are populated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub entity_key_values: std::option::Option<crate::model::FetchFeatureValuesResponse>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_service")]
    impl Neighbor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::nearest_neighbors::Neighbor::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [distance][crate::model::nearest_neighbors::Neighbor::distance].
        pub fn set_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.distance = v.into();
            self
        }

        /// Sets the value of [entity_key_values][crate::model::nearest_neighbors::Neighbor::entity_key_values].
        pub fn set_entity_key_values<
            T: std::convert::Into<std::option::Option<crate::model::FetchFeatureValuesResponse>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entity_key_values = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_service")]
    impl wkt::message::Message for Neighbor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighbors.Neighbor"
        }
    }
}

/// Response message for
/// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]: crate::client::FeatureOnlineStoreService::search_nearest_entities
#[cfg(feature = "feature_online_store_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchNearestEntitiesResponse {
    /// The nearest neighbors of the query entity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nearest_neighbors: std::option::Option<crate::model::NearestNeighbors>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_service")]
impl SearchNearestEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nearest_neighbors][crate::model::SearchNearestEntitiesResponse::nearest_neighbors].
    pub fn set_nearest_neighbors<
        T: std::convert::Into<std::option::Option<crate::model::NearestNeighbors>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nearest_neighbors = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_service")]
impl wkt::message::Message for SearchNearestEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchNearestEntitiesResponse"
    }
}

/// Request message for
/// [FeatureRegistryService.CreateFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeatureGroup]: crate::client::FeatureRegistryService::create_feature_group
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureGroupRequest {
    /// Required. The resource name of the Location to create FeatureGroups.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The FeatureGroup to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_group: std::option::Option<crate::model::FeatureGroup>,

    /// Required. The ID to use for this FeatureGroup, which will become the final
    /// component of the FeatureGroup's resource name.
    ///
    /// This value may be up to 128 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_group_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl CreateFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature_group][crate::model::CreateFeatureGroupRequest::feature_group].
    pub fn set_feature_group<
        T: std::convert::Into<std::option::Option<crate::model::FeatureGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_group = v.into();
        self
    }

    /// Sets the value of [feature_group_id][crate::model::CreateFeatureGroupRequest::feature_group_id].
    pub fn set_feature_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_group_id = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for CreateFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureGroupRequest"
    }
}

/// Request message for
/// [FeatureRegistryService.GetFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.GetFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.GetFeatureGroup]: crate::client::FeatureRegistryService::get_feature_group
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureGroupRequest {
    /// Required. The name of the FeatureGroup resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl GetFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for GetFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureGroupRequest"
    }
}

/// Request message for
/// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]: crate::client::FeatureRegistryService::list_feature_groups
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureGroupsRequest {
    /// Required. The resource name of the Location to list FeatureGroups.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureGroups that match the filter expression. The
    /// following fields are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `labels`: Supports key-value equality and key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
    ///   FeatureGroups created or updated after 2020-01-01.
    /// * `labels.env = "prod"`
    ///   FeatureGroups with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureGroups to return. The service may return
    /// fewer than this value. If unspecified, at most 100 FeatureGroups will
    /// be returned. The maximum value is 100; any value greater than 100 will be
    /// coerced to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]: crate::client::FeatureRegistryService::list_feature_groups
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported Fields:
    ///
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl ListFeatureGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for ListFeatureGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureGroupsRequest"
    }
}

/// Response message for
/// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]: crate::client::FeatureRegistryService::list_feature_groups
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureGroupsResponse {
    /// The FeatureGroups matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_groups: std::vec::Vec<crate::model::FeatureGroup>,

    /// A token, which can be sent as
    /// [ListFeatureGroupsRequest.page_token][google.cloud.aiplatform.v1.ListFeatureGroupsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureGroupsRequest.page_token]: crate::model::ListFeatureGroupsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl ListFeatureGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_groups][crate::model::ListFeatureGroupsResponse::feature_groups].
    pub fn set_feature_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureGroup>,
    {
        use std::iter::Iterator;
        self.feature_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for ListFeatureGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureGroupsResponse"
    }
}

#[cfg(feature = "feature_registry_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeatureGroupsResponse {
    type PageItem = crate::model::FeatureGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeatureRegistryService.UpdateFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeatureGroup]: crate::client::FeatureRegistryService::update_feature_group
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureGroupRequest {
    /// Required. The FeatureGroup's `name` field is used to identify the
    /// FeatureGroup to be updated. Format:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_group: std::option::Option<crate::model::FeatureGroup>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// FeatureGroup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `description`
    /// * `big_query`
    /// * `big_query.entity_id_columns`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl UpdateFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_group][crate::model::UpdateFeatureGroupRequest::feature_group].
    pub fn set_feature_group<
        T: std::convert::Into<std::option::Option<crate::model::FeatureGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_group = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureGroupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for UpdateFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureGroupRequest"
    }
}

/// Request message for
/// [FeatureRegistryService.DeleteFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeatureGroup]: crate::client::FeatureRegistryService::delete_feature_group
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureGroupRequest {
    /// Required. The name of the FeatureGroup to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any Features under this FeatureGroup
    /// will also be deleted. (Otherwise, the request will only work if the
    /// FeatureGroup has no Features.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl DeleteFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFeatureGroupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for DeleteFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureGroupRequest"
    }
}

/// Details of operations that perform create FeatureGroup.
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureGroupOperationMetadata {
    /// Operation metadata for FeatureGroup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl CreateFeatureGroupOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureGroupOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for CreateFeatureGroupOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureGroupOperationMetadata"
    }
}

/// Details of operations that perform update FeatureGroup.
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureGroupOperationMetadata {
    /// Operation metadata for FeatureGroup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl UpdateFeatureGroupOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureGroupOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for UpdateFeatureGroupOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureGroupOperationMetadata"
    }
}

/// Details of operations that perform create FeatureGroup.
#[cfg(all(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "evaluation_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_online_store_service",
    feature = "feature_registry_service",
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "llm_utility_service",
    feature = "match_service",
    feature = "metadata_service",
    feature = "migration_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "prediction_service",
    feature = "reasoning_engine_execution_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
    feature = "vertex_rag_service",
    feature = "vizier_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRegistryFeatureOperationMetadata {
    /// Operation metadata for Feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "evaluation_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_online_store_service",
    feature = "feature_registry_service",
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "llm_utility_service",
    feature = "match_service",
    feature = "metadata_service",
    feature = "migration_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "prediction_service",
    feature = "reasoning_engine_execution_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
    feature = "vertex_rag_service",
    feature = "vizier_service",
))]
impl CreateRegistryFeatureOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateRegistryFeatureOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(all(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "evaluation_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_online_store_service",
    feature = "feature_registry_service",
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "llm_utility_service",
    feature = "match_service",
    feature = "metadata_service",
    feature = "migration_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "prediction_service",
    feature = "reasoning_engine_execution_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
    feature = "vertex_rag_service",
    feature = "vizier_service",
))]
impl wkt::message::Message for CreateRegistryFeatureOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRegistryFeatureOperationMetadata"
    }
}

/// Details of operations that perform update Feature.
#[cfg(feature = "feature_registry_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureOperationMetadata {
    /// Operation metadata for Feature Update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_registry_service")]
impl UpdateFeatureOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "feature_registry_service")]
impl wkt::message::Message for UpdateFeatureOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOperationMetadata"
    }
}

/// Matcher for Features of an EntityType by Feature ID.
#[cfg(any(
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IdMatcher {
    /// Required. The following are accepted as `ids`:
    ///
    /// * A single-element list containing only `*`, which selects all Features
    ///   in the target EntityType, or
    /// * A list containing only Feature IDs, which selects only Features with
    ///   those IDs in the target EntityType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
))]
impl IdMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ids][crate::model::IdMatcher::ids].
    pub fn set_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
))]
impl wkt::message::Message for IdMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IdMatcher"
    }
}

/// Selector for Features of an EntityType.
#[cfg(any(
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureSelector {
    /// Required. Matches Features based on ID.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub id_matcher: std::option::Option<crate::model::IdMatcher>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
))]
impl FeatureSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_matcher][crate::model::FeatureSelector::id_matcher].
    pub fn set_id_matcher<T: std::convert::Into<std::option::Option<crate::model::IdMatcher>>>(
        mut self,
        v: T,
    ) -> Self {
        self.id_matcher = v.into();
        self
    }
}

#[cfg(any(
    feature = "featurestore_online_serving_service",
    feature = "featurestore_service",
))]
impl wkt::message::Message for FeatureSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureSelector"
    }
}

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureView {
    /// Identifier. Name of the FeatureView. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this FeatureView was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this FeatureView was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// FeatureViews.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one
    /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
    /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Configures when data is to be synced/updated for this FeatureView. At the
    /// end of the sync the latest featureValues for each entityId of this
    /// FeatureView are made ready for online serving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sync_config: std::option::Option<crate::model::feature_view::SyncConfig>,

    /// Optional. Configuration for index preparation for vector search. It
    /// contains the required configurations to create an index from source data,
    /// so that approximate nearest neighbor (a.k.a ANN) algorithms search can be
    /// performed during online serving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_config: std::option::Option<crate::model::feature_view::IndexConfig>,

    /// Optional. Configuration for FeatureView created under Optimized
    /// FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub optimized_config: std::option::Option<crate::model::feature_view::OptimizedConfig>,

    /// Optional. Service agent type used during data sync. By default, the Vertex
    /// AI Service Agent is used. When using an IAM Policy to isolate this
    /// FeatureView within a project, a separate service account should be
    /// provisioned by setting this field to `SERVICE_AGENT_TYPE_FEATURE_VIEW`.
    /// This will generate a separate service account to access the BigQuery source
    /// table.
    pub service_agent_type: crate::model::feature_view::ServiceAgentType,

    /// Output only. A Service Account unique to this FeatureView. The role
    /// bigquery.dataViewer should be granted to this service account to allow
    /// Vertex AI Feature Store to sync data to the online store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::feature_view::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl FeatureView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureView::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeatureView::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::FeatureView::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [sync_config][crate::model::FeatureView::sync_config].
    pub fn set_sync_config<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::SyncConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_config = v.into();
        self
    }

    /// Sets the value of [index_config][crate::model::FeatureView::index_config].
    pub fn set_index_config<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::IndexConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_config = v.into();
        self
    }

    /// Sets the value of [optimized_config][crate::model::FeatureView::optimized_config].
    pub fn set_optimized_config<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::OptimizedConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.optimized_config = v.into();
        self
    }

    /// Sets the value of [service_agent_type][crate::model::FeatureView::service_agent_type].
    pub fn set_service_agent_type<
        T: std::convert::Into<crate::model::feature_view::ServiceAgentType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_agent_type = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::FeatureView::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::FeatureView::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::FeatureView::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::FeatureView::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source][crate::model::FeatureView::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FeatureView::source]
    /// if it holds a `BigQuerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_view::Source::BigQuerySource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::FeatureView::source]
    /// if it holds a `FeatureRegistrySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn feature_registry_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view::FeatureRegistrySource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_view::Source::FeatureRegistrySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::FeatureView::source]
    /// if it holds a `VertexRagSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_rag_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view::VertexRagSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_view::Source::VertexRagSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FeatureView::source]
    /// to hold a `BigQuerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_source<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::feature_view::Source::BigQuerySource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::FeatureView::source]
    /// to hold a `FeatureRegistrySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_feature_registry_source<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view::FeatureRegistrySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::feature_view::Source::FeatureRegistrySource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::FeatureView::source]
    /// to hold a `VertexRagSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_source<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view::VertexRagSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::feature_view::Source::VertexRagSource(v.into()),
        );
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for FeatureView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView"
    }
}

/// Defines additional types related to [FeatureView].
#[cfg(feature = "feature_online_store_admin_service")]
pub mod feature_view {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQuerySource {
        /// Required. The BigQuery view URI that will be materialized on each sync
        /// trigger based on FeatureView.SyncConfig.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// Required. Columns to construct entity_id / row keys.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub entity_id_columns: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl BigQuerySource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::feature_view::BigQuerySource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [entity_id_columns][crate::model::feature_view::BigQuerySource::entity_id_columns].
        pub fn set_entity_id_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_id_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for BigQuerySource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.BigQuerySource"
        }
    }

    /// Configuration for Sync. Only one option is set.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SyncConfig {
        /// Cron schedule (<https://en.wikipedia.org/wiki/Cron>) to launch scheduled
        /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
        /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
        /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
        /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
        /// "TZ=America/New_York 1 * * * *".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cron: std::string::String,

        /// Optional. If true, syncs the FeatureView in a continuous manner to Online
        /// Store.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub continuous: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl SyncConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cron][crate::model::feature_view::SyncConfig::cron].
        pub fn set_cron<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cron = v.into();
            self
        }

        /// Sets the value of [continuous][crate::model::feature_view::SyncConfig::continuous].
        pub fn set_continuous<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.continuous = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for SyncConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.SyncConfig"
        }
    }

    /// Configuration for vector indexing.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexConfig {
        /// Optional. Column of embedding. This column contains the source data to
        /// create index for vector search. embedding_column must be set when using
        /// vector search.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub embedding_column: std::string::String,

        /// Optional. Columns of features that're used to filter vector search
        /// results.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub filter_columns: std::vec::Vec<std::string::String>,

        /// Optional. Column of crowding. This column contains crowding attribute
        /// which is a constraint on a neighbor list produced by
        /// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
        /// to diversify search results. If
        /// [NearestNeighborQuery.per_crowding_attribute_neighbor_count][google.cloud.aiplatform.v1.NearestNeighborQuery.per_crowding_attribute_neighbor_count]
        /// is set to K in
        /// [SearchNearestEntitiesRequest][google.cloud.aiplatform.v1.SearchNearestEntitiesRequest],
        /// it's guaranteed that no more than K entities of the same crowding
        /// attribute are returned in the response.
        ///
        /// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]: crate::client::FeatureOnlineStoreService::search_nearest_entities
        /// [google.cloud.aiplatform.v1.NearestNeighborQuery.per_crowding_attribute_neighbor_count]: crate::model::NearestNeighborQuery::per_crowding_attribute_neighbor_count
        /// [google.cloud.aiplatform.v1.SearchNearestEntitiesRequest]: crate::model::SearchNearestEntitiesRequest
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub crowding_column: std::string::String,

        /// Optional. The number of dimensions of the input embedding.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub embedding_dimension: std::option::Option<i32>,

        /// Optional. The distance measure used in nearest neighbor search.
        pub distance_measure_type: crate::model::feature_view::index_config::DistanceMeasureType,

        /// The configuration with regard to the algorithms used for efficient
        /// search.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub algorithm_config:
            std::option::Option<crate::model::feature_view::index_config::AlgorithmConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl IndexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [embedding_column][crate::model::feature_view::IndexConfig::embedding_column].
        pub fn set_embedding_column<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.embedding_column = v.into();
            self
        }

        /// Sets the value of [crowding_column][crate::model::feature_view::IndexConfig::crowding_column].
        pub fn set_crowding_column<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.crowding_column = v.into();
            self
        }

        /// Sets the value of [embedding_dimension][crate::model::feature_view::IndexConfig::embedding_dimension].
        pub fn set_embedding_dimension<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.embedding_dimension = v.into();
            self
        }

        /// Sets the value of [distance_measure_type][crate::model::feature_view::IndexConfig::distance_measure_type].
        pub fn set_distance_measure_type<
            T: std::convert::Into<crate::model::feature_view::index_config::DistanceMeasureType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.distance_measure_type = v.into();
            self
        }

        /// Sets the value of [filter_columns][crate::model::feature_view::IndexConfig::filter_columns].
        pub fn set_filter_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.filter_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config].
        ///
        /// Note that all the setters affecting `algorithm_config` are mutually
        /// exclusive.
        pub fn set_algorithm_config<
            T: std::convert::Into<
                    std::option::Option<crate::model::feature_view::index_config::AlgorithmConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.algorithm_config = v.into();
            self
        }

        /// The value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// if it holds a `TreeAhConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn tree_ah_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::feature_view::index_config::TreeAHConfig>,
        > {
            #[allow(unreachable_patterns)]
            self.algorithm_config.as_ref().and_then(|v| match v {
                crate::model::feature_view::index_config::AlgorithmConfig::TreeAhConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// if it holds a `BruteForceConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn brute_force_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::feature_view::index_config::BruteForceConfig>,
        > {
            #[allow(unreachable_patterns)]
            self.algorithm_config.as_ref().and_then(|v| match v {
                crate::model::feature_view::index_config::AlgorithmConfig::BruteForceConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// to hold a `TreeAhConfig`.
        ///
        /// Note that all the setters affecting `algorithm_config` are
        /// mutually exclusive.
        pub fn set_tree_ah_config<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::feature_view::index_config::TreeAHConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.algorithm_config = std::option::Option::Some(
                crate::model::feature_view::index_config::AlgorithmConfig::TreeAhConfig(v.into()),
            );
            self
        }

        /// Sets the value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// to hold a `BruteForceConfig`.
        ///
        /// Note that all the setters affecting `algorithm_config` are
        /// mutually exclusive.
        pub fn set_brute_force_config<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::feature_view::index_config::BruteForceConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.algorithm_config = std::option::Option::Some(
                crate::model::feature_view::index_config::AlgorithmConfig::BruteForceConfig(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for IndexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig"
        }
    }

    /// Defines additional types related to [IndexConfig].
    #[cfg(feature = "feature_online_store_admin_service")]
    pub mod index_config {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration options for using brute force search.
        #[cfg(feature = "feature_online_store_admin_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BruteForceConfig {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl BruteForceConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl wkt::message::Message for BruteForceConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig.BruteForceConfig"
            }
        }

        /// Configuration options for the tree-AH algorithm.
        #[cfg(feature = "feature_online_store_admin_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TreeAHConfig {
            /// Optional. Number of embeddings on each leaf node. The default value is
            /// 1000 if not set.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub leaf_node_embedding_count: std::option::Option<i64>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl TreeAHConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [leaf_node_embedding_count][crate::model::feature_view::index_config::TreeAHConfig::leaf_node_embedding_count].
            pub fn set_leaf_node_embedding_count<
                T: std::convert::Into<std::option::Option<i64>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.leaf_node_embedding_count = v.into();
                self
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl wkt::message::Message for TreeAHConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig.TreeAHConfig"
            }
        }

        /// The distance measure used in nearest neighbor search.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "feature_online_store_admin_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DistanceMeasureType {
            /// Should not be set.
            Unspecified,
            /// Euclidean (L_2) Distance.
            SquaredL2Distance,
            /// Cosine Distance. Defined as 1 - cosine similarity.
            ///
            /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
            /// of COSINE distance. Our algorithms have been more optimized for
            /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
            /// mathematically equivalent to COSINE distance and results in the same
            /// ranking.
            CosineDistance,
            /// Dot Product Distance. Defined as a negative of the dot product.
            DotProductDistance,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DistanceMeasureType::value] or
            /// [DistanceMeasureType::name].
            UnknownValue(distance_measure_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "feature_online_store_admin_service")]
        pub mod distance_measure_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl DistanceMeasureType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SquaredL2Distance => std::option::Option::Some(1),
                    Self::CosineDistance => std::option::Option::Some(2),
                    Self::DotProductDistance => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("DISTANCE_MEASURE_TYPE_UNSPECIFIED")
                    }
                    Self::SquaredL2Distance => std::option::Option::Some("SQUARED_L2_DISTANCE"),
                    Self::CosineDistance => std::option::Option::Some("COSINE_DISTANCE"),
                    Self::DotProductDistance => std::option::Option::Some("DOT_PRODUCT_DISTANCE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl std::default::Default for DistanceMeasureType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl std::fmt::Display for DistanceMeasureType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl std::convert::From<i32> for DistanceMeasureType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SquaredL2Distance,
                    2 => Self::CosineDistance,
                    3 => Self::DotProductDistance,
                    _ => Self::UnknownValue(distance_measure_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl std::convert::From<&str> for DistanceMeasureType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DISTANCE_MEASURE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SQUARED_L2_DISTANCE" => Self::SquaredL2Distance,
                    "COSINE_DISTANCE" => Self::CosineDistance,
                    "DOT_PRODUCT_DISTANCE" => Self::DotProductDistance,
                    _ => Self::UnknownValue(distance_measure_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl serde::ser::Serialize for DistanceMeasureType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SquaredL2Distance => serializer.serialize_i32(1),
                    Self::CosineDistance => serializer.serialize_i32(2),
                    Self::DotProductDistance => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl<'de> serde::de::Deserialize<'de> for DistanceMeasureType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<DistanceMeasureType>::new(
                        ".google.cloud.aiplatform.v1.FeatureView.IndexConfig.DistanceMeasureType",
                    ),
                )
            }
        }

        /// The configuration with regard to the algorithms used for efficient
        /// search.
        #[cfg(feature = "feature_online_store_admin_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum AlgorithmConfig {
            /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
            ///
            /// + Asymmetric Hashing). Please refer to this paper for more details:
            ///   <https://arxiv.org/abs/1908.10396>
            TreeAhConfig(std::boxed::Box<crate::model::feature_view::index_config::TreeAHConfig>),
            /// Optional. Configuration options for using brute force search, which
            /// simply implements the standard linear search in the database for each
            /// query. It is primarily meant for benchmarking and to generate the
            /// ground truth for approximate search.
            BruteForceConfig(
                std::boxed::Box<crate::model::feature_view::index_config::BruteForceConfig>,
            ),
        }
    }

    /// A Feature Registry source for features that need to be synced to Online
    /// Store.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureRegistrySource {
        /// Required. List of features that need to be synced to Online Store.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub feature_groups:
            std::vec::Vec<crate::model::feature_view::feature_registry_source::FeatureGroup>,

        /// Optional. The project number of the parent project of the Feature Groups.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub project_number: std::option::Option<i64>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl FeatureRegistrySource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_number][crate::model::feature_view::FeatureRegistrySource::project_number].
        pub fn set_project_number<T: std::convert::Into<std::option::Option<i64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.project_number = v.into();
            self
        }

        /// Sets the value of [feature_groups][crate::model::feature_view::FeatureRegistrySource::feature_groups].
        pub fn set_feature_groups<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::feature_view::feature_registry_source::FeatureGroup,
                >,
        {
            use std::iter::Iterator;
            self.feature_groups = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for FeatureRegistrySource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource"
        }
    }

    /// Defines additional types related to [FeatureRegistrySource].
    #[cfg(feature = "feature_online_store_admin_service")]
    pub mod feature_registry_source {
        #[allow(unused_imports)]
        use super::*;

        /// Features belonging to a single feature group that will be
        /// synced to Online Store.
        #[cfg(feature = "feature_online_store_admin_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FeatureGroup {
            /// Required. Identifier of the feature group.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub feature_group_id: std::string::String,

            /// Required. Identifiers of features under the feature group.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub feature_ids: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl FeatureGroup {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [feature_group_id][crate::model::feature_view::feature_registry_source::FeatureGroup::feature_group_id].
            pub fn set_feature_group_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.feature_group_id = v.into();
                self
            }

            /// Sets the value of [feature_ids][crate::model::feature_view::feature_registry_source::FeatureGroup::feature_ids].
            pub fn set_feature_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.feature_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "feature_online_store_admin_service")]
        impl wkt::message::Message for FeatureGroup {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource.FeatureGroup"
            }
        }
    }

    /// A Vertex Rag source for features that need to be synced to Online
    /// Store.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexRagSource {
        /// Required. The BigQuery view/table URI that will be materialized on each
        /// manual sync trigger. The table/view is expected to have the following
        /// columns and types at least:
        ///
        /// - `corpus_id` (STRING, NULLABLE/REQUIRED)
        /// - `file_id` (STRING, NULLABLE/REQUIRED)
        /// - `chunk_id` (STRING, NULLABLE/REQUIRED)
        /// - `chunk_data_type` (STRING, NULLABLE/REQUIRED)
        /// - `chunk_data` (STRING, NULLABLE/REQUIRED)
        /// - `embeddings` (FLOAT, REPEATED)
        /// - `file_original_uri` (STRING, NULLABLE/REQUIRED)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// Optional. The RAG corpus id corresponding to this FeatureView.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub rag_corpus_id: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl VertexRagSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::feature_view::VertexRagSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [rag_corpus_id][crate::model::feature_view::VertexRagSource::rag_corpus_id].
        pub fn set_rag_corpus_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.rag_corpus_id = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for VertexRagSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.VertexRagSource"
        }
    }

    /// Configuration for FeatureViews created in Optimized FeatureOnlineStore.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OptimizedConfig {
        /// Optional. A description of resources that the FeatureView uses, which to
        /// large degree are decided by Vertex AI, and optionally allows only a
        /// modest additional configuration. If min_replica_count is not set, the
        /// default value is 2. If max_replica_count is not set, the default value
        /// is 6. The max allowed replica count is 1000.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub automatic_resources: std::option::Option<crate::model::AutomaticResources>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl OptimizedConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [automatic_resources][crate::model::feature_view::OptimizedConfig::automatic_resources].
        pub fn set_automatic_resources<
            T: std::convert::Into<std::option::Option<crate::model::AutomaticResources>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.automatic_resources = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for OptimizedConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.OptimizedConfig"
        }
    }

    /// Service agent type used during data sync.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "feature_online_store_admin_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServiceAgentType {
        /// By default, the project-level Vertex AI Service Agent is enabled.
        Unspecified,
        /// Indicates the project-level Vertex AI Service Agent
        /// (<https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents>)
        /// will be used during sync jobs.
        Project,
        /// Enable a FeatureView service account to be created by Vertex AI and
        /// output in the field `service_account_email`. This service account will
        /// be used to read from the source BigQuery table during sync.
        FeatureView,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ServiceAgentType::value] or
        /// [ServiceAgentType::name].
        UnknownValue(service_agent_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "feature_online_store_admin_service")]
    pub mod service_agent_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl ServiceAgentType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Project => std::option::Option::Some(1),
                Self::FeatureView => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_AGENT_TYPE_UNSPECIFIED"),
                Self::Project => std::option::Option::Some("SERVICE_AGENT_TYPE_PROJECT"),
                Self::FeatureView => std::option::Option::Some("SERVICE_AGENT_TYPE_FEATURE_VIEW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::default::Default for ServiceAgentType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::fmt::Display for ServiceAgentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::convert::From<i32> for ServiceAgentType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Project,
                2 => Self::FeatureView,
                _ => Self::UnknownValue(service_agent_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl std::convert::From<&str> for ServiceAgentType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_AGENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_AGENT_TYPE_PROJECT" => Self::Project,
                "SERVICE_AGENT_TYPE_FEATURE_VIEW" => Self::FeatureView,
                _ => Self::UnknownValue(service_agent_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl serde::ser::Serialize for ServiceAgentType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Project => serializer.serialize_i32(1),
                Self::FeatureView => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl<'de> serde::de::Deserialize<'de> for ServiceAgentType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceAgentType>::new(
                ".google.cloud.aiplatform.v1.FeatureView.ServiceAgentType",
            ))
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Configures how data is supposed to be extracted from a BigQuery
        /// source to be loaded onto the FeatureOnlineStore.
        BigQuerySource(std::boxed::Box<crate::model::feature_view::BigQuerySource>),
        /// Optional. Configures the features from a Feature Registry source that
        /// need to be loaded onto the FeatureOnlineStore.
        FeatureRegistrySource(std::boxed::Box<crate::model::feature_view::FeatureRegistrySource>),
        /// Optional. The Vertex RAG Source that the FeatureView is linked to.
        VertexRagSource(std::boxed::Box<crate::model::feature_view::VertexRagSource>),
    }
}

/// FeatureViewSync is a representation of sync operation which copies data from
/// data source to Feature View in Online Store.
#[cfg(feature = "feature_online_store_admin_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureViewSync {
    /// Identifier. Name of the FeatureViewSync. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Time when this FeatureViewSync is created. Creation of a
    /// FeatureViewSync means that the job is pending / waiting for sufficient
    /// resources but may not have started the actual data transfer yet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this FeatureViewSync is finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub run_time: std::option::Option<gtype::model::Interval>,

    /// Output only. Final status of the FeatureViewSync.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_status: std::option::Option<rpc::model::Status>,

    /// Output only. Summary of the sync job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sync_summary: std::option::Option<crate::model::feature_view_sync::SyncSummary>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "feature_online_store_admin_service")]
impl FeatureViewSync {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureViewSync::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureViewSync::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [run_time][crate::model::FeatureViewSync::run_time].
    pub fn set_run_time<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.run_time = v.into();
        self
    }

    /// Sets the value of [final_status][crate::model::FeatureViewSync::final_status].
    pub fn set_final_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.final_status = v.into();
        self
    }

    /// Sets the value of [sync_summary][crate::model::FeatureViewSync::sync_summary].
    pub fn set_sync_summary<
        T: std::convert::Into<std::option::Option<crate::model::feature_view_sync::SyncSummary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_summary = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::FeatureViewSync::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::FeatureViewSync::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

#[cfg(feature = "feature_online_store_admin_service")]
impl wkt::message::Message for FeatureViewSync {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewSync"
    }
}

/// Defines additional types related to [FeatureViewSync].
#[cfg(feature = "feature_online_store_admin_service")]
pub mod feature_view_sync {
    #[allow(unused_imports)]
    use super::*;

    /// Summary from the Sync job. For continuous syncs, the summary is updated
    /// periodically. For batch syncs, it gets updated on completion of the sync.
    #[cfg(feature = "feature_online_store_admin_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SyncSummary {
        /// Output only. Total number of rows synced.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub row_synced: i64,

        /// Output only. BigQuery slot milliseconds consumed for the sync job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_slot: i64,

        /// Lower bound of the system time watermark for the sync job. This is only
        /// set for continuously syncing feature views.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub system_watermark_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl SyncSummary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_synced][crate::model::feature_view_sync::SyncSummary::row_synced].
        pub fn set_row_synced<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.row_synced = v.into();
            self
        }

        /// Sets the value of [total_slot][crate::model::feature_view_sync::SyncSummary::total_slot].
        pub fn set_total_slot<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_slot = v.into();
            self
        }

        /// Sets the value of [system_watermark_time][crate::model::feature_view_sync::SyncSummary::system_watermark_time].
        pub fn set_system_watermark_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.system_watermark_time = v.into();
            self
        }
    }

    #[cfg(feature = "feature_online_store_admin_service")]
    impl wkt::message::Message for SyncSummary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewSync.SyncSummary"
        }
    }
}

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features. The Featurestore is a top-level container
/// for your features and their values.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Featurestore {
    /// Output only. Name of the Featurestore. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this Featurestore was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Featurestore was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// Featurestore.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one Featurestore(System
    /// labels are excluded)."
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Config for online storage resources. The field should not
    /// co-exist with the field of `OnlineStoreReplicationConfig`. If both of it
    /// and OnlineStoreReplicationConfig are unset, the feature store will not have
    /// an online store and cannot be used for online serving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub online_serving_config: std::option::Option<crate::model::featurestore::OnlineServingConfig>,

    /// Output only. State of the featurestore.
    pub state: crate::model::featurestore::State,

    /// Optional. TTL in days for feature values that will be stored in online
    /// serving storage. The Feature Store online storage periodically removes
    /// obsolete feature values older than `online_storage_ttl_days` since the
    /// feature generation time. Note that `online_storage_ttl_days` should be less
    /// than or equal to `offline_storage_ttl_days` for each EntityType under a
    /// featurestore. If not set, default to 4000 days
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub online_storage_ttl_days: i32,

    /// Optional. Customer-managed encryption key spec for data storage. If set,
    /// both of the online and offline data storage will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl Featurestore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Featurestore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Featurestore::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Featurestore::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Featurestore::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [online_serving_config][crate::model::Featurestore::online_serving_config].
    pub fn set_online_serving_config<
        T: std::convert::Into<std::option::Option<crate::model::featurestore::OnlineServingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.online_serving_config = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Featurestore::state].
    pub fn set_state<T: std::convert::Into<crate::model::featurestore::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [online_storage_ttl_days][crate::model::Featurestore::online_storage_ttl_days].
    pub fn set_online_storage_ttl_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.online_storage_ttl_days = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Featurestore::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Featurestore::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Featurestore::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Featurestore::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for Featurestore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore"
    }
}

/// Defines additional types related to [Featurestore].
#[cfg(feature = "featurestore_service")]
pub mod featurestore {
    #[allow(unused_imports)]
    use super::*;

    /// OnlineServingConfig specifies the details for provisioning online serving
    /// resources.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OnlineServingConfig {
        /// The number of nodes for the online store. The number of nodes doesn't
        /// scale automatically, but you can manually update the number of
        /// nodes. If set to 0, the featurestore will not have an
        /// online store and cannot be used for online serving.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub fixed_node_count: i32,

        /// Online serving scaling configuration.
        /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
        /// reset the other.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub scaling:
            std::option::Option<crate::model::featurestore::online_serving_config::Scaling>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl OnlineServingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [fixed_node_count][crate::model::featurestore::OnlineServingConfig::fixed_node_count].
        pub fn set_fixed_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.fixed_node_count = v.into();
            self
        }

        /// Sets the value of [scaling][crate::model::featurestore::OnlineServingConfig::scaling].
        pub fn set_scaling<
            T: std::convert::Into<
                    std::option::Option<crate::model::featurestore::online_serving_config::Scaling>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scaling = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for OnlineServingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig"
        }
    }

    /// Defines additional types related to [OnlineServingConfig].
    #[cfg(feature = "featurestore_service")]
    pub mod online_serving_config {
        #[allow(unused_imports)]
        use super::*;

        /// Online serving scaling configuration. If min_node_count and
        /// max_node_count are set to the same value, the cluster will be configured
        /// with the fixed number of node (no auto-scaling).
        #[cfg(feature = "featurestore_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Scaling {
            /// Required. The minimum number of nodes to scale down to. Must be greater
            /// than or equal to 1.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub min_node_count: i32,

            /// The maximum number of nodes to scale up to. Must be greater than
            /// min_node_count, and less than or equal to 10 times of 'min_node_count'.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_node_count: i32,

            /// Optional. The cpu utilization that the Autoscaler should be trying to
            /// achieve. This number is on a scale from 0 (no utilization) to 100
            /// (total utilization), and is limited between 10 and 80. When a cluster's
            /// CPU utilization exceeds the target that you have set, Bigtable
            /// immediately adds nodes to the cluster. When CPU utilization is
            /// substantially lower than the target, Bigtable removes nodes. If not set
            /// or set to 0, default to 50.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub cpu_utilization_target: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "featurestore_service")]
        impl Scaling {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_node_count][crate::model::featurestore::online_serving_config::Scaling::min_node_count].
            pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.min_node_count = v.into();
                self
            }

            /// Sets the value of [max_node_count][crate::model::featurestore::online_serving_config::Scaling::max_node_count].
            pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_node_count = v.into();
                self
            }

            /// Sets the value of [cpu_utilization_target][crate::model::featurestore::online_serving_config::Scaling::cpu_utilization_target].
            pub fn set_cpu_utilization_target<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_utilization_target = v.into();
                self
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl wkt::message::Message for Scaling {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig.Scaling"
            }
        }
    }

    /// Possible states a featurestore can have.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// State when the featurestore configuration is not being updated and the
        /// fields reflect the current configuration of the featurestore. The
        /// featurestore is usable in this state.
        Stable,
        /// The state of the featurestore configuration when it is being updated.
        /// During an update, the fields reflect either the original configuration
        /// or the updated configuration of the featurestore. For example,
        /// `online_serving_config.fixed_node_count` can take minutes to update.
        /// While the update is in progress, the featurestore is in the UPDATING
        /// state, and the value of `fixed_node_count` can be the original value or
        /// the updated value, depending on the progress of the operation. Until the
        /// update completes, the actual number of nodes can still be the original
        /// value of `fixed_node_count`. The featurestore is still usable in this
        /// state.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "featurestore_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "featurestore_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Stable => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Stable => std::option::Option::Some("STABLE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Stable,
                2 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STABLE" => Self::Stable,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Stable => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.Featurestore.State",
            ))
        }
    }
}

/// Configuration of how features in Featurestore are monitored.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeaturestoreMonitoringConfig {
    /// The config for Snapshot Analysis Based Feature Monitoring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_analysis:
        std::option::Option<crate::model::featurestore_monitoring_config::SnapshotAnalysis>,

    /// The config for ImportFeatures Analysis Based Feature Monitoring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_features_analysis:
        std::option::Option<crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis>,

    /// Threshold for numerical features of anomaly detection.
    /// This is shared by all objectives of Featurestore Monitoring for numerical
    /// features (i.e. Features with type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) DOUBLE
    /// or INT64).
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub numerical_threshold_config:
        std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,

    /// Threshold for categorical features of anomaly detection.
    /// This is shared by all types of Featurestore Monitoring for categorical
    /// features (i.e. Features with type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) BOOL or
    /// STRING).
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub categorical_threshold_config:
        std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl FeaturestoreMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot_analysis][crate::model::FeaturestoreMonitoringConfig::snapshot_analysis].
    pub fn set_snapshot_analysis<
        T: std::convert::Into<
                std::option::Option<crate::model::featurestore_monitoring_config::SnapshotAnalysis>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_analysis = v.into();
        self
    }

    /// Sets the value of [import_features_analysis][crate::model::FeaturestoreMonitoringConfig::import_features_analysis].
    pub fn set_import_features_analysis<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_features_analysis = v.into();
        self
    }

    /// Sets the value of [numerical_threshold_config][crate::model::FeaturestoreMonitoringConfig::numerical_threshold_config].
    pub fn set_numerical_threshold_config<
        T: std::convert::Into<
                std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.numerical_threshold_config = v.into();
        self
    }

    /// Sets the value of [categorical_threshold_config][crate::model::FeaturestoreMonitoringConfig::categorical_threshold_config].
    pub fn set_categorical_threshold_config<
        T: std::convert::Into<
                std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.categorical_threshold_config = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for FeaturestoreMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig"
    }
}

/// Defines additional types related to [FeaturestoreMonitoringConfig].
#[cfg(feature = "featurestore_service")]
pub mod featurestore_monitoring_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
    /// This type of analysis generates statistics for each Feature based on a
    /// snapshot of the latest feature value of each entities every
    /// monitoring_interval.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SnapshotAnalysis {
        /// The monitoring schedule for snapshot analysis.
        /// For EntityType-level config:
        /// unset / disabled = true indicates disabled by
        /// default for Features under it; otherwise by default enable snapshot
        /// analysis monitoring with monitoring_interval for Features under it.
        /// Feature-level config:
        /// disabled = true indicates disabled regardless of the EntityType-level
        /// config; unset monitoring_interval indicates going with EntityType-level
        /// config; otherwise run snapshot analysis monitoring with
        /// monitoring_interval regardless of the EntityType-level config.
        /// Explicitly Disable the snapshot analysis based monitoring.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub disabled: bool,

        /// Configuration of the snapshot analysis based monitoring pipeline
        /// running interval. The value indicates number of days.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub monitoring_interval_days: i32,

        /// Customized export features time window for snapshot analysis. Unit is one
        /// day. Default value is 3 weeks. Minimum value is 1 day. Maximum value is
        /// 4000 days.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub staleness_days: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl SnapshotAnalysis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disabled][crate::model::featurestore_monitoring_config::SnapshotAnalysis::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [monitoring_interval_days][crate::model::featurestore_monitoring_config::SnapshotAnalysis::monitoring_interval_days].
        pub fn set_monitoring_interval_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.monitoring_interval_days = v.into();
            self
        }

        /// Sets the value of [staleness_days][crate::model::featurestore_monitoring_config::SnapshotAnalysis::staleness_days].
        pub fn set_staleness_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.staleness_days = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for SnapshotAnalysis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis"
        }
    }

    /// Configuration of the Featurestore's ImportFeature Analysis Based
    /// Monitoring. This type of analysis generates statistics for values of each
    /// Feature imported by every
    /// [ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]
    /// operation.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImportFeaturesAnalysis {
        /// Whether to enable / disable / inherite default hebavior for import
        /// features analysis.
        pub state: crate::model::featurestore_monitoring_config::import_features_analysis::State,

        /// The baseline used to do anomaly detection for the statistics generated by
        /// import features analysis.
        pub anomaly_detection_baseline:
            crate::model::featurestore_monitoring_config::import_features_analysis::Baseline,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl ImportFeaturesAnalysis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis::state].
        pub fn set_state<
            T: std::convert::Into<
                    crate::model::featurestore_monitoring_config::import_features_analysis::State,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [anomaly_detection_baseline][crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis::anomaly_detection_baseline].
        pub fn set_anomaly_detection_baseline<T: std::convert::Into<crate::model::featurestore_monitoring_config::import_features_analysis::Baseline>>(mut self, v: T) -> Self{
            self.anomaly_detection_baseline = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for ImportFeaturesAnalysis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis"
        }
    }

    /// Defines additional types related to [ImportFeaturesAnalysis].
    #[cfg(feature = "featurestore_service")]
    pub mod import_features_analysis {
        #[allow(unused_imports)]
        use super::*;

        /// The state defines whether to enable ImportFeature analysis.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "featurestore_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Should not be used.
            Unspecified,
            /// The default behavior of whether to enable the monitoring.
            /// EntityType-level config: disabled.
            /// Feature-level config: inherited from the configuration of EntityType
            /// this Feature belongs to.
            Default,
            /// Explicitly enables import features analysis.
            /// EntityType-level config: by default enables import features analysis
            /// for all Features under it. Feature-level config: enables import
            /// features analysis regardless of the EntityType-level config.
            Enabled,
            /// Explicitly disables import features analysis.
            /// EntityType-level config: by default disables import features analysis
            /// for all Features under it. Feature-level config: disables import
            /// features analysis regardless of the EntityType-level config.
            Disabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "featurestore_service")]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "featurestore_service")]
        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Default => std::option::Option::Some(1),
                    Self::Enabled => std::option::Option::Some(2),
                    Self::Disabled => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Default => std::option::Option::Some("DEFAULT"),
                    Self::Enabled => std::option::Option::Some("ENABLED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Default,
                    2 => Self::Enabled,
                    3 => Self::Disabled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "DEFAULT" => Self::Default,
                    "ENABLED" => Self::Enabled,
                    "DISABLED" => Self::Disabled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Default => serializer.serialize_i32(1),
                    Self::Enabled => serializer.serialize_i32(2),
                    Self::Disabled => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis.State"))
            }
        }

        /// Defines the baseline to do anomaly detection for feature values imported
        /// by each
        /// [ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]
        /// operation.
        ///
        /// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "featurestore_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Baseline {
            /// Should not be used.
            Unspecified,
            /// Choose the later one statistics generated by either most recent
            /// snapshot analysis or previous import features analysis. If non of them
            /// exists, skip anomaly detection and only generate a statistics.
            LatestStats,
            /// Use the statistics generated by the most recent snapshot analysis if
            /// exists.
            MostRecentSnapshotStats,
            /// Use the statistics generated by the previous import features analysis
            /// if exists.
            PreviousImportFeaturesStats,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Baseline::value] or
            /// [Baseline::name].
            UnknownValue(baseline::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "featurestore_service")]
        pub mod baseline {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "featurestore_service")]
        impl Baseline {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::LatestStats => std::option::Option::Some(1),
                    Self::MostRecentSnapshotStats => std::option::Option::Some(2),
                    Self::PreviousImportFeaturesStats => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("BASELINE_UNSPECIFIED"),
                    Self::LatestStats => std::option::Option::Some("LATEST_STATS"),
                    Self::MostRecentSnapshotStats => {
                        std::option::Option::Some("MOST_RECENT_SNAPSHOT_STATS")
                    }
                    Self::PreviousImportFeaturesStats => {
                        std::option::Option::Some("PREVIOUS_IMPORT_FEATURES_STATS")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::default::Default for Baseline {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::fmt::Display for Baseline {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::convert::From<i32> for Baseline {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::LatestStats,
                    2 => Self::MostRecentSnapshotStats,
                    3 => Self::PreviousImportFeaturesStats,
                    _ => Self::UnknownValue(baseline::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl std::convert::From<&str> for Baseline {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "BASELINE_UNSPECIFIED" => Self::Unspecified,
                    "LATEST_STATS" => Self::LatestStats,
                    "MOST_RECENT_SNAPSHOT_STATS" => Self::MostRecentSnapshotStats,
                    "PREVIOUS_IMPORT_FEATURES_STATS" => Self::PreviousImportFeaturesStats,
                    _ => Self::UnknownValue(baseline::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl serde::ser::Serialize for Baseline {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::LatestStats => serializer.serialize_i32(1),
                    Self::MostRecentSnapshotStats => serializer.serialize_i32(2),
                    Self::PreviousImportFeaturesStats => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "featurestore_service")]
        impl<'de> serde::de::Deserialize<'de> for Baseline {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Baseline>::new(
                    ".google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis.Baseline"))
            }
        }
    }

    /// The config for Featurestore Monitoring threshold.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThresholdConfig {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub threshold: std::option::Option<
            crate::model::featurestore_monitoring_config::threshold_config::Threshold,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl ThresholdConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threshold][crate::model::featurestore_monitoring_config::ThresholdConfig::threshold].
        ///
        /// Note that all the setters affecting `threshold` are mutually
        /// exclusive.
        pub fn set_threshold<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::featurestore_monitoring_config::threshold_config::Threshold,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.threshold = v.into();
            self
        }

        /// The value of [threshold][crate::model::featurestore_monitoring_config::ThresholdConfig::threshold]
        /// if it holds a `Value`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.threshold.as_ref().and_then(|v| match v {
                crate::model::featurestore_monitoring_config::threshold_config::Threshold::Value(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [threshold][crate::model::featurestore_monitoring_config::ThresholdConfig::threshold]
        /// to hold a `Value`.
        ///
        /// Note that all the setters affecting `threshold` are
        /// mutually exclusive.
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.threshold = std::option::Option::Some(
                crate::model::featurestore_monitoring_config::threshold_config::Threshold::Value(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for ThresholdConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ThresholdConfig"
        }
    }

    /// Defines additional types related to [ThresholdConfig].
    #[cfg(feature = "featurestore_service")]
    pub mod threshold_config {
        #[allow(unused_imports)]
        use super::*;

        #[cfg(feature = "featurestore_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Threshold {
            /// Specify a threshold value that can trigger the alert.
            ///
            /// . For categorical feature, the distribution distance is calculated by
            ///   L-inifinity norm.
            /// . For numerical feature, the distribution distance is calculated by
            ///   JensenShannon divergence. Each feature must have a non-zero threshold
            ///   if they need to be monitored. Otherwise no alert will be triggered for
            ///   that feature.
            Value(f64),
        }
    }
}

/// Request message for
/// [FeaturestoreOnlineServingService.WriteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues]: crate::client::FeaturestoreOnlineServingService::write_feature_values
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteFeatureValuesRequest {
    /// Required. The resource name of the EntityType for the entities being
    /// written. Value format:
    /// `projects/{project}/locations/{location}/featurestores/
    /// {featurestore}/entityTypes/{entityType}`. For example,
    /// for a machine learning model predicting user clicks on a website, an
    /// EntityType ID could be `user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. The entities to be written. Up to 100,000 feature values can be
    /// written across all `payloads`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub payloads: std::vec::Vec<crate::model::WriteFeatureValuesPayload>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl WriteFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::WriteFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [payloads][crate::model::WriteFeatureValuesRequest::payloads].
    pub fn set_payloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WriteFeatureValuesPayload>,
    {
        use std::iter::Iterator;
        self.payloads = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for WriteFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesRequest"
    }
}

/// Contains Feature values to be written for a specific entity.
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteFeatureValuesPayload {
    /// Required. The ID of the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    /// Required. Feature values to be written, mapping from Feature ID to value.
    /// Up to 100,000 `feature_values` entries may be written across all payloads.
    /// The feature generation time, aligned by days, must be no older than five
    /// years (1825 days) and no later than one year (366 days) in the future.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub feature_values: std::collections::HashMap<std::string::String, crate::model::FeatureValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl WriteFeatureValuesPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_id][crate::model::WriteFeatureValuesPayload::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [feature_values][crate::model::WriteFeatureValuesPayload::feature_values].
    pub fn set_feature_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FeatureValue>,
    {
        use std::iter::Iterator;
        self.feature_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for WriteFeatureValuesPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesPayload"
    }
}

/// Response message for
/// [FeaturestoreOnlineServingService.WriteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues]: crate::client::FeaturestoreOnlineServingService::write_feature_values
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteFeatureValuesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl WriteFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for WriteFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesResponse"
    }
}

/// Request message for
/// [FeaturestoreOnlineServingService.ReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues]: crate::client::FeaturestoreOnlineServingService::read_feature_values
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadFeatureValuesRequest {
    /// Required. The resource name of the EntityType for the entity being read.
    /// Value format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
    /// For example, for a machine learning model predicting user clicks on a
    /// website, an EntityType ID could be `user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. ID for a specific entity. For example,
    /// for a machine learning model predicting user clicks on a website, an entity
    /// ID could be `user_123`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    /// Required. Selector choosing Features of the target EntityType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl ReadFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::ReadFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::ReadFeatureValuesRequest::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [feature_selector][crate::model::ReadFeatureValuesRequest::feature_selector].
    pub fn set_feature_selector<
        T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_selector = v.into();
        self
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for ReadFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesRequest"
    }
}

/// Response message for
/// [FeaturestoreOnlineServingService.ReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues]: crate::client::FeaturestoreOnlineServingService::read_feature_values
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadFeatureValuesResponse {
    /// Response header.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub header: std::option::Option<crate::model::read_feature_values_response::Header>,

    /// Entity view with Feature values. This may be the entity in the
    /// Featurestore if values for all Features were requested, or a projection
    /// of the entity in the Featurestore if values for only some Features were
    /// requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_view: std::option::Option<crate::model::read_feature_values_response::EntityView>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl ReadFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [header][crate::model::ReadFeatureValuesResponse::header].
    pub fn set_header<
        T: std::convert::Into<std::option::Option<crate::model::read_feature_values_response::Header>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.header = v.into();
        self
    }

    /// Sets the value of [entity_view][crate::model::ReadFeatureValuesResponse::entity_view].
    pub fn set_entity_view<
        T: std::convert::Into<
                std::option::Option<crate::model::read_feature_values_response::EntityView>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_view = v.into();
        self
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for ReadFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse"
    }
}

/// Defines additional types related to [ReadFeatureValuesResponse].
#[cfg(feature = "featurestore_online_serving_service")]
pub mod read_feature_values_response {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata for requested Features.
    #[cfg(feature = "featurestore_online_serving_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureDescriptor {
        /// Feature ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_online_serving_service")]
    impl FeatureDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::read_feature_values_response::FeatureDescriptor::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_online_serving_service")]
    impl wkt::message::Message for FeatureDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.FeatureDescriptor"
        }
    }

    /// Response header with metadata for the requested
    /// [ReadFeatureValuesRequest.entity_type][google.cloud.aiplatform.v1.ReadFeatureValuesRequest.entity_type]
    /// and Features.
    ///
    /// [google.cloud.aiplatform.v1.ReadFeatureValuesRequest.entity_type]: crate::model::ReadFeatureValuesRequest::entity_type
    #[cfg(feature = "featurestore_online_serving_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Header {
        /// The resource name of the EntityType from the
        /// [ReadFeatureValuesRequest][google.cloud.aiplatform.v1.ReadFeatureValuesRequest].
        /// Value format:
        /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
        ///
        /// [google.cloud.aiplatform.v1.ReadFeatureValuesRequest]: crate::model::ReadFeatureValuesRequest
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_type: std::string::String,

        /// List of Feature metadata corresponding to each piece of
        /// [ReadFeatureValuesResponse.EntityView.data][google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.data].
        ///
        /// [google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.data]: crate::model::read_feature_values_response::EntityView::data
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub feature_descriptors:
            std::vec::Vec<crate::model::read_feature_values_response::FeatureDescriptor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_online_serving_service")]
    impl Header {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_type][crate::model::read_feature_values_response::Header::entity_type].
        pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_type = v.into();
            self
        }

        /// Sets the value of [feature_descriptors][crate::model::read_feature_values_response::Header::feature_descriptors].
        pub fn set_feature_descriptors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::read_feature_values_response::FeatureDescriptor>,
        {
            use std::iter::Iterator;
            self.feature_descriptors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "featurestore_online_serving_service")]
    impl wkt::message::Message for Header {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.Header"
        }
    }

    /// Entity view with Feature values.
    #[cfg(feature = "featurestore_online_serving_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EntityView {
        /// ID of the requested entity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_id: std::string::String,

        /// Each piece of data holds the k
        /// requested values for one requested Feature. If no values
        /// for the requested Feature exist, the corresponding cell will be empty.
        /// This has the same size and is in the same order as the features from the
        /// header
        /// [ReadFeatureValuesResponse.header][google.cloud.aiplatform.v1.ReadFeatureValuesResponse.header].
        ///
        /// [google.cloud.aiplatform.v1.ReadFeatureValuesResponse.header]: crate::model::ReadFeatureValuesResponse::header
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub data: std::vec::Vec<crate::model::read_feature_values_response::entity_view::Data>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_online_serving_service")]
    impl EntityView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::read_feature_values_response::EntityView::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [data][crate::model::read_feature_values_response::EntityView::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::read_feature_values_response::entity_view::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "featurestore_online_serving_service")]
    impl wkt::message::Message for EntityView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView"
        }
    }

    /// Defines additional types related to [EntityView].
    #[cfg(feature = "featurestore_online_serving_service")]
    pub mod entity_view {
        #[allow(unused_imports)]
        use super::*;

        /// Container to hold value(s), successive in time, for one Feature from the
        /// request.
        #[cfg(feature = "featurestore_online_serving_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Data {
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub data: std::option::Option<
                crate::model::read_feature_values_response::entity_view::data::Data,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "featurestore_online_serving_service")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data][crate::model::read_feature_values_response::entity_view::Data::data].
            ///
            /// Note that all the setters affecting `data` are mutually
            /// exclusive.
            pub fn set_data<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::read_feature_values_response::entity_view::data::Data,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.data = v.into();
                self
            }

            /// The value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// if it holds a `Value`, `None` if the field is not set or
            /// holds a different branch.
            pub fn value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureValue>> {
                #[allow(unreachable_patterns)]
                self.data.as_ref().and_then(|v| match v {
                    crate::model::read_feature_values_response::entity_view::data::Data::Value(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// if it holds a `Values`, `None` if the field is not set or
            /// holds a different branch.
            pub fn values(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureValueList>> {
                #[allow(unreachable_patterns)]
                self.data.as_ref().and_then(|v| match v {
                    crate::model::read_feature_values_response::entity_view::data::Data::Values(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// to hold a `Value`.
            ///
            /// Note that all the setters affecting `data` are
            /// mutually exclusive.
            pub fn set_value<T: std::convert::Into<std::boxed::Box<crate::model::FeatureValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.data = std::option::Option::Some(
                    crate::model::read_feature_values_response::entity_view::data::Data::Value(
                        v.into(),
                    ),
                );
                self
            }

            /// Sets the value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// to hold a `Values`.
            ///
            /// Note that all the setters affecting `data` are
            /// mutually exclusive.
            pub fn set_values<
                T: std::convert::Into<std::boxed::Box<crate::model::FeatureValueList>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.data = std::option::Option::Some(
                    crate::model::read_feature_values_response::entity_view::data::Data::Values(
                        v.into(),
                    ),
                );
                self
            }
        }

        #[cfg(feature = "featurestore_online_serving_service")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.Data"
            }
        }

        /// Defines additional types related to [Data].
        #[cfg(feature = "featurestore_online_serving_service")]
        pub mod data {
            #[allow(unused_imports)]
            use super::*;

            #[cfg(feature = "featurestore_online_serving_service")]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Data {
                /// Feature value if a single value is requested.
                Value(std::boxed::Box<crate::model::FeatureValue>),
                /// Feature values list if values, successive in time, are requested.
                /// If the requested number of values is greater than the number of
                /// existing Feature values, nonexistent values are omitted instead of
                /// being returned as empty.
                Values(std::boxed::Box<crate::model::FeatureValueList>),
            }
        }
    }
}

/// Request message for
/// [FeaturestoreOnlineServingService.StreamingReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.StreamingReadFeatureValues].
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingReadFeatureValuesRequest {
    /// Required. The resource name of the entities' type.
    /// Value format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
    /// For example,
    /// for a machine learning model predicting user clicks on a website, an
    /// EntityType ID could be `user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. IDs of entities to read Feature values of. The maximum number of
    /// IDs is 100. For example, for a machine learning model predicting user
    /// clicks on a website, an entity ID could be `user_123`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_ids: std::vec::Vec<std::string::String>,

    /// Required. Selector choosing Features of the target EntityType. Feature IDs
    /// will be deduplicated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl StreamingReadFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::StreamingReadFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [feature_selector][crate::model::StreamingReadFeatureValuesRequest::feature_selector].
    pub fn set_feature_selector<
        T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_selector = v.into();
        self
    }

    /// Sets the value of [entity_ids][crate::model::StreamingReadFeatureValuesRequest::entity_ids].
    pub fn set_entity_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entity_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for StreamingReadFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingReadFeatureValuesRequest"
    }
}

/// Value for a feature.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureValue {
    /// Metadata of feature value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::feature_value::Metadata>,

    /// Value for the feature.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::feature_value::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl FeatureValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata][crate::model::FeatureValue::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::feature_value::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::feature_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `BoolArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BoolArray>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::BoolArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `DoubleArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DoubleArray>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::DoubleArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `Int64ArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Int64Array>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::Int64ArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `StringArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StringArray>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::StringArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `BytesValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bytes_value(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::BytesValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `StructValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn struct_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::StructValue>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::StructValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::BoolValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::Int64Value(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::StringValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `BoolArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_array_value<T: std::convert::Into<std::boxed::Box<crate::model::BoolArray>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::BoolArrayValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `DoubleArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_array_value<
        T: std::convert::Into<std::boxed::Box<crate::model::DoubleArray>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::feature_value::Value::DoubleArrayValue(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `Int64ArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_array_value<
        T: std::convert::Into<std::boxed::Box<crate::model::Int64Array>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::feature_value::Value::Int64ArrayValue(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `StringArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_array_value<
        T: std::convert::Into<std::boxed::Box<crate::model::StringArray>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::feature_value::Value::StringArrayValue(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `BytesValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bytes_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::BytesValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `StructValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_struct_value<T: std::convert::Into<std::boxed::Box<crate::model::StructValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::StructValue(v.into()));
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for FeatureValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValue"
    }
}

/// Defines additional types related to [FeatureValue].
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
pub mod feature_value {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of feature value.
    #[cfg(any(
        feature = "feature_online_store_service",
        feature = "featurestore_online_serving_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metadata {
        /// Feature generation timestamp. Typically, it is provided by user at
        /// feature ingestion time. If not, feature store
        /// will use the system timestamp when the data is ingested into feature
        /// store. For streaming ingestion, the time, aligned by days, must be no
        /// older than five years (1825 days) and no later than one year (366 days)
        /// in the future.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub generate_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "feature_online_store_service",
        feature = "featurestore_online_serving_service",
    ))]
    impl Metadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [generate_time][crate::model::feature_value::Metadata::generate_time].
        pub fn set_generate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.generate_time = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "feature_online_store_service",
        feature = "featurestore_online_serving_service",
    ))]
    impl wkt::message::Message for Metadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValue.Metadata"
        }
    }

    /// Value for the feature.
    #[cfg(any(
        feature = "feature_online_store_service",
        feature = "featurestore_online_serving_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// Bool type feature value.
        BoolValue(bool),
        /// Double type feature value.
        DoubleValue(f64),
        /// Int64 feature value.
        Int64Value(i64),
        /// String feature value.
        StringValue(std::string::String),
        /// A list of bool type feature value.
        BoolArrayValue(std::boxed::Box<crate::model::BoolArray>),
        /// A list of double type feature value.
        DoubleArrayValue(std::boxed::Box<crate::model::DoubleArray>),
        /// A list of int64 type feature value.
        Int64ArrayValue(std::boxed::Box<crate::model::Int64Array>),
        /// A list of string type feature value.
        StringArrayValue(std::boxed::Box<crate::model::StringArray>),
        /// Bytes feature value.
        BytesValue(::bytes::Bytes),
        /// A struct type feature value.
        StructValue(std::boxed::Box<crate::model::StructValue>),
    }
}

/// Struct (or object) type feature value.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StructValue {
    /// A list of field values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::StructFieldValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl StructValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::StructValue::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StructFieldValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for StructValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StructValue"
    }
}

/// One field of a Struct (or object) type feature value.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StructFieldValue {
    /// Name of the field in the struct feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The value for this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<std::boxed::Box<crate::model::FeatureValue>>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl StructFieldValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StructFieldValue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::StructFieldValue::value].
    pub fn set_value<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::FeatureValue>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for StructFieldValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StructFieldValue"
    }
}

/// Container for list of values.
#[cfg(feature = "featurestore_online_serving_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureValueList {
    /// A list of feature values. All of them should be the same data type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::FeatureValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_online_serving_service")]
impl FeatureValueList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::FeatureValueList::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_online_serving_service")]
impl wkt::message::Message for FeatureValueList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValueList"
    }
}

/// Request message for
/// [FeaturestoreService.CreateFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.CreateFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.CreateFeaturestore]: crate::client::FeaturestoreService::create_featurestore
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeaturestoreRequest {
    /// Required. The resource name of the Location to create Featurestores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Featurestore to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub featurestore: std::option::Option<crate::model::Featurestore>,

    /// Required. The ID to use for this Featurestore, which will become the final
    /// component of the Featurestore's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub featurestore_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl CreateFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeaturestoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [featurestore][crate::model::CreateFeaturestoreRequest::featurestore].
    pub fn set_featurestore<
        T: std::convert::Into<std::option::Option<crate::model::Featurestore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.featurestore = v.into();
        self
    }

    /// Sets the value of [featurestore_id][crate::model::CreateFeaturestoreRequest::featurestore_id].
    pub fn set_featurestore_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.featurestore_id = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for CreateFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.GetFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.GetFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.GetFeaturestore]: crate::client::FeaturestoreService::get_featurestore
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeaturestoreRequest {
    /// Required. The name of the Featurestore resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl GetFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeaturestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for GetFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]: crate::client::FeaturestoreService::list_featurestores
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturestoresRequest {
    /// Required. The resource name of the Location to list Featurestores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the featurestores that match the filter expression. The following
    /// fields are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
    ///   `<=`, and `>=` comparisons.
    /// * `labels`: Supports key-value equality and key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
    ///   Featurestores created or updated after 2020-01-01.
    /// * `labels.env = "prod"`
    ///   Featurestores with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of Featurestores to return. The service may return fewer
    /// than this value. If unspecified, at most 100 Featurestores will be
    /// returned. The maximum value is 100; any value greater than 100 will be
    /// coerced to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]: crate::client::FeaturestoreService::list_featurestores
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported Fields:
    ///
    /// * `create_time`
    /// * `update_time`
    /// * `online_serving_config.fixed_node_count`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ListFeaturestoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeaturestoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeaturestoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeaturestoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeaturestoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeaturestoresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListFeaturestoresRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ListFeaturestoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturestoresRequest"
    }
}

/// Response message for
/// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]: crate::client::FeaturestoreService::list_featurestores
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturestoresResponse {
    /// The Featurestores matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub featurestores: std::vec::Vec<crate::model::Featurestore>,

    /// A token, which can be sent as
    /// [ListFeaturestoresRequest.page_token][google.cloud.aiplatform.v1.ListFeaturestoresRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeaturestoresRequest.page_token]: crate::model::ListFeaturestoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ListFeaturestoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeaturestoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [featurestores][crate::model::ListFeaturestoresResponse::featurestores].
    pub fn set_featurestores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Featurestore>,
    {
        use std::iter::Iterator;
        self.featurestores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ListFeaturestoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturestoresResponse"
    }
}

#[cfg(feature = "featurestore_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeaturestoresResponse {
    type PageItem = crate::model::Featurestore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.featurestores
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeaturestoreService.UpdateFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeaturestore]: crate::client::FeaturestoreService::update_featurestore
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeaturestoreRequest {
    /// Required. The Featurestore's `name` field is used to identify the
    /// Featurestore to be updated. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub featurestore: std::option::Option<crate::model::Featurestore>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// Featurestore resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `online_serving_config.fixed_node_count`
    /// * `online_serving_config.scaling`
    /// * `online_storage_ttl_days`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl UpdateFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [featurestore][crate::model::UpdateFeaturestoreRequest::featurestore].
    pub fn set_featurestore<
        T: std::convert::Into<std::option::Option<crate::model::Featurestore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.featurestore = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeaturestoreRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for UpdateFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeaturestore]: crate::client::FeaturestoreService::delete_featurestore
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeaturestoreRequest {
    /// Required. The name of the Featurestore to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any EntityTypes and Features for this Featurestore will
    /// also be deleted. (Otherwise, the request will only work if the Featurestore
    /// has no EntityTypes.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl DeleteFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeaturestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFeaturestoreRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for DeleteFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportFeatureValuesRequest {
    /// Required. The resource name of the EntityType grouping the Features for
    /// which values are being imported. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Source column that holds entity IDs. If not provided, entity IDs are
    /// extracted from the column named entity_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id_field: std::string::String,

    /// Required. Specifications defining which Feature values to import from the
    /// entity. The request fails if no feature_specs are provided, and having
    /// multiple feature_specs for one Feature is not allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_specs: std::vec::Vec<crate::model::import_feature_values_request::FeatureSpec>,

    /// If set, data will not be imported for online serving. This
    /// is typically used for backfilling, where Feature generation timestamps are
    /// not in the timestamp range needed for online serving.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_online_serving: bool,

    /// Specifies the number of workers that are used to write data to the
    /// Featurestore. Consider the online serving capacity that you require to
    /// achieve the desired import throughput without interfering with online
    /// serving. The value must be positive, and less than or equal to 100.
    /// If not set, defaults to using 1 worker. The low count ensures minimal
    /// impact on online serving performance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub worker_count: i32,

    /// If true, API doesn't start ingestion analysis pipeline.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_ingestion_analysis: bool,

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_feature_values_request::Source>,

    /// Source of Feature timestamp for all Feature values of each entity.
    /// Timestamps must be millisecond-aligned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub feature_time_source:
        std::option::Option<crate::model::import_feature_values_request::FeatureTimeSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ImportFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::ImportFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [entity_id_field][crate::model::ImportFeatureValuesRequest::entity_id_field].
    pub fn set_entity_id_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id_field = v.into();
        self
    }

    /// Sets the value of [disable_online_serving][crate::model::ImportFeatureValuesRequest::disable_online_serving].
    pub fn set_disable_online_serving<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_online_serving = v.into();
        self
    }

    /// Sets the value of [worker_count][crate::model::ImportFeatureValuesRequest::worker_count].
    pub fn set_worker_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.worker_count = v.into();
        self
    }

    /// Sets the value of [disable_ingestion_analysis][crate::model::ImportFeatureValuesRequest::disable_ingestion_analysis].
    pub fn set_disable_ingestion_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_ingestion_analysis = v.into();
        self
    }

    /// Sets the value of [feature_specs][crate::model::ImportFeatureValuesRequest::feature_specs].
    pub fn set_feature_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::import_feature_values_request::FeatureSpec>,
    {
        use std::iter::Iterator;
        self.feature_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_feature_values_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// if it holds a `AvroSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::AvroSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::Source::AvroSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// if it holds a `BigquerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::Source::BigquerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// if it holds a `CsvSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::CsvSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::Source::CsvSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// to hold a `AvroSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_avro_source<T: std::convert::Into<std::boxed::Box<crate::model::AvroSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_feature_values_request::Source::AvroSource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// to hold a `BigquerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_bigquery_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_feature_values_request::Source::BigquerySource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// to hold a `CsvSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_csv_source<T: std::convert::Into<std::boxed::Box<crate::model::CsvSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_feature_values_request::Source::CsvSource(v.into()),
        );
        self
    }

    /// Sets the value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source].
    ///
    /// Note that all the setters affecting `feature_time_source` are mutually
    /// exclusive.
    pub fn set_feature_time_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_feature_values_request::FeatureTimeSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_time_source = v.into();
        self
    }

    /// The value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// if it holds a `FeatureTimeField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn feature_time_field(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.feature_time_source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTimeField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// if it holds a `FeatureTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn feature_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.feature_time_source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// to hold a `FeatureTimeField`.
    ///
    /// Note that all the setters affecting `feature_time_source` are
    /// mutually exclusive.
    pub fn set_feature_time_field<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_time_source = std::option::Option::Some(
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTimeField(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// to hold a `FeatureTime`.
    ///
    /// Note that all the setters affecting `feature_time_source` are
    /// mutually exclusive.
    pub fn set_feature_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_time_source = std::option::Option::Some(
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTime(v.into()),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ImportFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesRequest"
    }
}

/// Defines additional types related to [ImportFeatureValuesRequest].
#[cfg(feature = "featurestore_service")]
pub mod import_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the Feature value(s) to import.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureSpec {
        /// Required. ID of the Feature to import values of. This Feature must exist
        /// in the target EntityType, or the request will fail.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Source column to get the Feature values from. If not set, uses the column
        /// with the same name as the Feature ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_field: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl FeatureSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::import_feature_values_request::FeatureSpec::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [source_field][crate::model::import_feature_values_request::FeatureSpec::source_field].
        pub fn set_source_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_field = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for FeatureSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesRequest.FeatureSpec"
        }
    }

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        AvroSource(std::boxed::Box<crate::model::AvroSource>),
        BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        CsvSource(std::boxed::Box<crate::model::CsvSource>),
    }

    /// Source of Feature timestamp for all Feature values of each entity.
    /// Timestamps must be millisecond-aligned.
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FeatureTimeSource {
        /// Source column that holds the Feature timestamp for all Feature
        /// values in each entity.
        FeatureTimeField(std::string::String),
        /// Single Feature timestamp for all entities being imported. The
        /// timestamp must not have higher than millisecond precision.
        FeatureTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// Response message for
/// [FeaturestoreService.ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportFeatureValuesResponse {
    /// Number of entities that have been imported by the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_entity_count: i64,

    /// Number of Feature values that have been imported by the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_feature_value_count: i64,

    /// The number of rows in input source that weren't imported due to either
    ///
    /// * Not having any featureValues.
    /// * Having a null entityId.
    /// * Having a null timestamp.
    /// * Not being parsable (applicable for CSV sources).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub invalid_row_count: i64,

    /// The number rows that weren't ingested due to having feature timestamps
    /// outside the retention boundary.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub timestamp_outside_retention_rows_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ImportFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_entity_count][crate::model::ImportFeatureValuesResponse::imported_entity_count].
    pub fn set_imported_entity_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_entity_count = v.into();
        self
    }

    /// Sets the value of [imported_feature_value_count][crate::model::ImportFeatureValuesResponse::imported_feature_value_count].
    pub fn set_imported_feature_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_feature_value_count = v.into();
        self
    }

    /// Sets the value of [invalid_row_count][crate::model::ImportFeatureValuesResponse::invalid_row_count].
    pub fn set_invalid_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.invalid_row_count = v.into();
        self
    }

    /// Sets the value of [timestamp_outside_retention_rows_count][crate::model::ImportFeatureValuesResponse::timestamp_outside_retention_rows_count].
    pub fn set_timestamp_outside_retention_rows_count<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_outside_retention_rows_count = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ImportFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesResponse"
    }
}

/// Request message for
/// [FeaturestoreService.BatchReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues]: crate::client::FeaturestoreService::batch_read_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadFeatureValuesRequest {
    /// Required. The resource name of the Featurestore from which to query Feature
    /// values. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub featurestore: std::string::String,

    /// Required. Specifies output location and format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::FeatureValueDestination>,

    /// When not empty, the specified fields in the *_read_instances source will be
    /// joined as-is in the output, in addition to those fields from the
    /// Featurestore Entity.
    ///
    /// For BigQuery source, the type of the pass-through values will be
    /// automatically inferred. For CSV source, the pass-through values will be
    /// passed as opaque bytes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pass_through_fields:
        std::vec::Vec<crate::model::batch_read_feature_values_request::PassThroughField>,

    /// Required. Specifies EntityType grouping Features to read values of and
    /// settings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_type_specs:
        std::vec::Vec<crate::model::batch_read_feature_values_request::EntityTypeSpec>,

    /// Optional. Excludes Feature values with feature generation timestamp before
    /// this timestamp. If not set, retrieve oldest values kept in Feature Store.
    /// Timestamp, if present, must not have higher than millisecond precision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub read_option:
        std::option::Option<crate::model::batch_read_feature_values_request::ReadOption>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl BatchReadFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [featurestore][crate::model::BatchReadFeatureValuesRequest::featurestore].
    pub fn set_featurestore<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.featurestore = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::BatchReadFeatureValuesRequest::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::FeatureValueDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BatchReadFeatureValuesRequest::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [pass_through_fields][crate::model::BatchReadFeatureValuesRequest::pass_through_fields].
    pub fn set_pass_through_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch_read_feature_values_request::PassThroughField>,
    {
        use std::iter::Iterator;
        self.pass_through_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_type_specs][crate::model::BatchReadFeatureValuesRequest::entity_type_specs].
    pub fn set_entity_type_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch_read_feature_values_request::EntityTypeSpec>,
    {
        use std::iter::Iterator;
        self.entity_type_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option].
    ///
    /// Note that all the setters affecting `read_option` are mutually
    /// exclusive.
    pub fn set_read_option<
        T: std::convert::Into<
                std::option::Option<crate::model::batch_read_feature_values_request::ReadOption>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_option = v.into();
        self
    }

    /// The value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// if it holds a `CsvReadInstances`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_read_instances(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsvSource>> {
        #[allow(unreachable_patterns)]
        self.read_option.as_ref().and_then(|v| match v {
            crate::model::batch_read_feature_values_request::ReadOption::CsvReadInstances(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// if it holds a `BigqueryReadInstances`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_read_instances(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.read_option.as_ref().and_then(|v| match v {
            crate::model::batch_read_feature_values_request::ReadOption::BigqueryReadInstances(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// to hold a `CsvReadInstances`.
    ///
    /// Note that all the setters affecting `read_option` are
    /// mutually exclusive.
    pub fn set_csv_read_instances<
        T: std::convert::Into<std::boxed::Box<crate::model::CsvSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_option = std::option::Option::Some(
            crate::model::batch_read_feature_values_request::ReadOption::CsvReadInstances(v.into()),
        );
        self
    }

    /// Sets the value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// to hold a `BigqueryReadInstances`.
    ///
    /// Note that all the setters affecting `read_option` are
    /// mutually exclusive.
    pub fn set_bigquery_read_instances<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_option = std::option::Option::Some(
            crate::model::batch_read_feature_values_request::ReadOption::BigqueryReadInstances(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for BatchReadFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest"
    }
}

/// Defines additional types related to [BatchReadFeatureValuesRequest].
#[cfg(feature = "featurestore_service")]
pub mod batch_read_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Describe pass-through fields in read_instance source.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PassThroughField {
        /// Required. The name of the field in the CSV header or the name of the
        /// column in BigQuery table. The naming restriction is the same as
        /// [Feature.name][google.cloud.aiplatform.v1.Feature.name].
        ///
        /// [google.cloud.aiplatform.v1.Feature.name]: crate::model::Feature::name
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl PassThroughField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_name][crate::model::batch_read_feature_values_request::PassThroughField::field_name].
        pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_name = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for PassThroughField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.PassThroughField"
        }
    }

    /// Selects Features of an EntityType to read values of and specifies read
    /// settings.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EntityTypeSpec {
        /// Required. ID of the EntityType to select Features. The EntityType id is
        /// the
        /// [entity_type_id][google.cloud.aiplatform.v1.CreateEntityTypeRequest.entity_type_id]
        /// specified during EntityType creation.
        ///
        /// [google.cloud.aiplatform.v1.CreateEntityTypeRequest.entity_type_id]: crate::model::CreateEntityTypeRequest::entity_type_id
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_type_id: std::string::String,

        /// Required. Selectors choosing which Feature values to read from the
        /// EntityType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

        /// Per-Feature settings for the batch read.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub settings: std::vec::Vec<crate::model::DestinationFeatureSetting>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl EntityTypeSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_type_id][crate::model::batch_read_feature_values_request::EntityTypeSpec::entity_type_id].
        pub fn set_entity_type_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.entity_type_id = v.into();
            self
        }

        /// Sets the value of [feature_selector][crate::model::batch_read_feature_values_request::EntityTypeSpec::feature_selector].
        pub fn set_feature_selector<
            T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_selector = v.into();
            self
        }

        /// Sets the value of [settings][crate::model::batch_read_feature_values_request::EntityTypeSpec::settings].
        pub fn set_settings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::DestinationFeatureSetting>,
        {
            use std::iter::Iterator;
            self.settings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for EntityTypeSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.EntityTypeSpec"
        }
    }

    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ReadOption {
        /// Each read instance consists of exactly one read timestamp and one or more
        /// entity IDs identifying entities of the corresponding EntityTypes whose
        /// Features are requested.
        ///
        /// Each output instance contains Feature values of requested entities
        /// concatenated together as of the read time.
        ///
        /// An example read instance may be `foo_entity_id, bar_entity_id,
        /// 2020-01-01T10:00:00.123Z`.
        ///
        /// An example output instance may be `foo_entity_id, bar_entity_id,
        /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
        /// bar_entity_feature2_value`.
        ///
        /// Timestamp in each read instance must be millisecond-aligned.
        ///
        /// `csv_read_instances` are read instances stored in a plain-text CSV file.
        /// The header should be:
        /// [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
        ///
        /// The columns can be in any order.
        ///
        /// Values in the timestamp column must use the RFC 3339 format, e.g.
        /// `2012-07-30T10:43:17.123Z`.
        CsvReadInstances(std::boxed::Box<crate::model::CsvSource>),
        /// Similar to csv_read_instances, but from BigQuery source.
        BigqueryReadInstances(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// Request message for
/// [FeaturestoreService.ExportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues]: crate::client::FeaturestoreService::export_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFeatureValuesRequest {
    /// Required. The resource name of the EntityType from which to export Feature
    /// values. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. Specifies destination location and format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::FeatureValueDestination>,

    /// Required. Selects Features to export values of.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

    /// Per-Feature export settings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub settings: std::vec::Vec<crate::model::DestinationFeatureSetting>,

    /// Required. The mode in which Feature values are exported.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::export_feature_values_request::Mode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ExportFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::ExportFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportFeatureValuesRequest::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::FeatureValueDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [feature_selector][crate::model::ExportFeatureValuesRequest::feature_selector].
    pub fn set_feature_selector<
        T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_selector = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::ExportFeatureValuesRequest::settings].
    pub fn set_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DestinationFeatureSetting>,
    {
        use std::iter::Iterator;
        self.settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mode][crate::model::ExportFeatureValuesRequest::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::export_feature_values_request::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// if it holds a `SnapshotExport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn snapshot_export(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_feature_values_request::SnapshotExport>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::export_feature_values_request::Mode::SnapshotExport(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// if it holds a `FullExport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn full_export(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_feature_values_request::FullExport>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::export_feature_values_request::Mode::FullExport(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// to hold a `SnapshotExport`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_snapshot_export<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_feature_values_request::SnapshotExport>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::export_feature_values_request::Mode::SnapshotExport(v.into()),
        );
        self
    }

    /// Sets the value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// to hold a `FullExport`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_full_export<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_feature_values_request::FullExport>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::export_feature_values_request::Mode::FullExport(v.into()),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ExportFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest"
    }
}

/// Defines additional types related to [ExportFeatureValuesRequest].
#[cfg(feature = "featurestore_service")]
pub mod export_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Describes exporting the latest Feature values of all entities of the
    /// EntityType between [start_time, snapshot_time].
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SnapshotExport {
        /// Exports Feature values as of this timestamp. If not set,
        /// retrieve values as of now. Timestamp, if present, must not have higher
        /// than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_time: std::option::Option<wkt::Timestamp>,

        /// Excludes Feature values with feature generation timestamp before this
        /// timestamp. If not set, retrieve oldest values kept in Feature Store.
        /// Timestamp, if present, must not have higher than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl SnapshotExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_time][crate::model::export_feature_values_request::SnapshotExport::snapshot_time].
        pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_time = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::export_feature_values_request::SnapshotExport::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for SnapshotExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest.SnapshotExport"
        }
    }

    /// Describes exporting all historical Feature values of all entities of the
    /// EntityType between [start_time, end_time].
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FullExport {
        /// Excludes Feature values with feature generation timestamp before this
        /// timestamp. If not set, retrieve oldest values kept in Feature Store.
        /// Timestamp, if present, must not have higher than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Exports Feature values as of this timestamp. If not set,
        /// retrieve values as of now. Timestamp, if present, must not have higher
        /// than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl FullExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::export_feature_values_request::FullExport::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::export_feature_values_request::FullExport::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for FullExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest.FullExport"
        }
    }

    /// Required. The mode in which Feature values are exported.
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Exports the latest Feature values of all entities of the EntityType
        /// within a time range.
        SnapshotExport(
            std::boxed::Box<crate::model::export_feature_values_request::SnapshotExport>,
        ),
        /// Exports all historical values of all entities of the EntityType within a
        /// time range
        FullExport(std::boxed::Box<crate::model::export_feature_values_request::FullExport>),
    }
}

#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestinationFeatureSetting {
    /// Required. The ID of the Feature to apply the setting to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_id: std::string::String,

    /// Specify the field name in the export destination. If not specified,
    /// Feature ID is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_field: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl DestinationFeatureSetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_id][crate::model::DestinationFeatureSetting::feature_id].
    pub fn set_feature_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_id = v.into();
        self
    }

    /// Sets the value of [destination_field][crate::model::DestinationFeatureSetting::destination_field].
    pub fn set_destination_field<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_field = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for DestinationFeatureSetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DestinationFeatureSetting"
    }
}

/// A destination location for Feature values and format.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureValueDestination {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::feature_value_destination::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl FeatureValueDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::feature_value_destination::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::FeatureValueDestination::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feature_value_destination::Destination::BigqueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination][crate::model::FeatureValueDestination::destination]
    /// if it holds a `TfrecordDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tfrecord_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TFRecordDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feature_value_destination::Destination::TfrecordDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination][crate::model::FeatureValueDestination::destination]
    /// if it holds a `CsvDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsvDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feature_value_destination::Destination::CsvDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feature_value_destination::Destination::BigqueryDestination(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination]
    /// to hold a `TfrecordDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_tfrecord_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::TFRecordDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feature_value_destination::Destination::TfrecordDestination(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination]
    /// to hold a `CsvDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_csv_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::CsvDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feature_value_destination::Destination::CsvDestination(v.into()),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for FeatureValueDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValueDestination"
    }
}

/// Defines additional types related to [FeatureValueDestination].
#[cfg(feature = "featurestore_service")]
pub mod feature_value_destination {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Output in BigQuery format.
        /// [BigQueryDestination.output_uri][google.cloud.aiplatform.v1.BigQueryDestination.output_uri]
        /// in
        /// [FeatureValueDestination.bigquery_destination][google.cloud.aiplatform.v1.FeatureValueDestination.bigquery_destination]
        /// must refer to a table.
        ///
        /// [google.cloud.aiplatform.v1.BigQueryDestination.output_uri]: crate::model::BigQueryDestination::output_uri
        /// [google.cloud.aiplatform.v1.FeatureValueDestination.bigquery_destination]: crate::model::FeatureValueDestination::destination
        BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
        /// Output in TFRecord format.
        ///
        /// Below are the mapping from Feature value type
        /// in Featurestore to Feature value type in TFRecord:
        ///
        /// ```norust
        /// Value type in Featurestore                 | Value type in TFRecord
        /// DOUBLE, DOUBLE_ARRAY                       | FLOAT_LIST
        /// INT64, INT64_ARRAY                         | INT64_LIST
        /// STRING, STRING_ARRAY, BYTES                | BYTES_LIST
        /// true -> byte_string("true"), false -> byte_string("false")
        /// BOOL, BOOL_ARRAY (true, false)             | BYTES_LIST
        /// ```
        TfrecordDestination(std::boxed::Box<crate::model::TFRecordDestination>),
        /// Output in CSV format. Array Feature value types are not allowed in CSV
        /// format.
        CsvDestination(std::boxed::Box<crate::model::CsvDestination>),
    }
}

/// Response message for
/// [FeaturestoreService.ExportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues]: crate::client::FeaturestoreService::export_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFeatureValuesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ExportFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ExportFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesResponse"
    }
}

/// Response message for
/// [FeaturestoreService.BatchReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues]: crate::client::FeaturestoreService::batch_read_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadFeatureValuesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl BatchReadFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for BatchReadFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesResponse"
    }
}

/// Request message for
/// [FeaturestoreService.CreateEntityType][google.cloud.aiplatform.v1.FeaturestoreService.CreateEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.CreateEntityType]: crate::client::FeaturestoreService::create_entity_type
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntityTypeRequest {
    /// Required. The resource name of the Featurestore to create EntityTypes.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The EntityType to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// Required. The ID to use for the EntityType, which will become the final
    /// component of the EntityType's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within a featurestore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl CreateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntityTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::CreateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::option::Option<crate::model::EntityType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [entity_type_id][crate::model::CreateEntityTypeRequest::entity_type_id].
    pub fn set_entity_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type_id = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for CreateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.GetEntityType][google.cloud.aiplatform.v1.FeaturestoreService.GetEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.GetEntityType]: crate::client::FeaturestoreService::get_entity_type
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntityTypeRequest {
    /// Required. The name of the EntityType resource.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl GetEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for GetEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]: crate::client::FeaturestoreService::list_entity_types
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntityTypesRequest {
    /// Required. The resource name of the Featurestore to list EntityTypes.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the EntityTypes that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `labels`: Supports key-value equality as well as key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
    ///   update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
    ///   or updated after 2020-01-31T15:30:00.000000Z.
    /// * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any EntityType which has a label with 'env' as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of EntityTypes to return. The service may return fewer
    /// than this value. If unspecified, at most 1000 EntityTypes will be returned.
    /// The maximum value is 1000; any value greater than 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]: crate::client::FeaturestoreService::list_entity_types
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `entity_type_id`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ListEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntityTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntityTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntityTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntityTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEntityTypesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ListEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEntityTypesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]: crate::client::FeaturestoreService::list_entity_types
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntityTypesResponse {
    /// The EntityTypes matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_types: std::vec::Vec<crate::model::EntityType>,

    /// A token, which can be sent as
    /// [ListEntityTypesRequest.page_token][google.cloud.aiplatform.v1.ListEntityTypesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListEntityTypesRequest.page_token]: crate::model::ListEntityTypesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ListEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEntityTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entity_types][crate::model::ListEntityTypesResponse::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ListEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEntityTypesResponse"
    }
}

#[cfg(feature = "featurestore_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntityTypesResponse {
    type PageItem = crate::model::EntityType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entity_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeaturestoreService.UpdateEntityType][google.cloud.aiplatform.v1.FeaturestoreService.UpdateEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.UpdateEntityType]: crate::client::FeaturestoreService::update_entity_type
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntityTypeRequest {
    /// Required. The EntityType's `name` field is used to identify the EntityType
    /// to be updated. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// EntityType resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `description`
    /// * `labels`
    /// * `monitoring_config.snapshot_analysis.disabled`
    /// * `monitoring_config.snapshot_analysis.monitoring_interval_days`
    /// * `monitoring_config.snapshot_analysis.staleness_days`
    /// * `monitoring_config.import_features_analysis.state`
    /// * `monitoring_config.import_features_analysis.anomaly_detection_baseline`
    /// * `monitoring_config.numerical_threshold_config.value`
    /// * `monitoring_config.categorical_threshold_config.value`
    /// * `offline_storage_ttl_days`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl UpdateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::UpdateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::option::Option<crate::model::EntityType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntityTypeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for UpdateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteEntityType][google.cloud.aiplatform.v1.FeaturestoreService.DeleteEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteEntityType]: crate::client::FeaturestoreService::delete_entity_type
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntityTypeRequest {
    /// Required. The name of the EntityType to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any Features for this EntityType will also be deleted.
    /// (Otherwise, the request will only work if the EntityType has no Features.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl DeleteEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntityTypeRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for DeleteEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.CreateFeature][google.cloud.aiplatform.v1.FeaturestoreService.CreateFeature].
/// Request message for
/// [FeatureRegistryService.CreateFeature][google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeature]: crate::client::FeatureRegistryService::create_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.CreateFeature]: crate::client::FeaturestoreService::create_feature
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureRequest {
    /// Required. The resource name of the EntityType or FeatureGroup to create a
    /// Feature. Format for entity_type as parent:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// Format for feature_group as parent:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Feature to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature: std::option::Option<crate::model::Feature>,

    /// Required. The ID to use for the Feature, which will become the final
    /// component of the Feature's resource name.
    ///
    /// This value may be up to 128 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within an EntityType/FeatureGroup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl CreateFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature][crate::model::CreateFeatureRequest::feature].
    pub fn set_feature<T: std::convert::Into<std::option::Option<crate::model::Feature>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature = v.into();
        self
    }

    /// Sets the value of [feature_id][crate::model::CreateFeatureRequest::feature_id].
    pub fn set_feature_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_id = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for CreateFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureRequest"
    }
}

/// Request message for
/// [FeaturestoreService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures].
/// Request message for
/// [FeatureRegistryService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.BatchCreateFeatures].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.BatchCreateFeatures]: crate::client::FeatureRegistryService::batch_create_features
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures]: crate::client::FeaturestoreService::batch_create_features
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateFeaturesRequest {
    /// Required. The resource name of the EntityType/FeatureGroup to create the
    /// batch of Features under. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the Features to create. All
    /// Features must be created under the same parent EntityType / FeatureGroup.
    /// The `parent` field in each child request message can be omitted. If
    /// `parent` is set in a child request, then the value must match the `parent`
    /// value in this request message.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateFeatureRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl BatchCreateFeaturesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateFeaturesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateFeaturesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateFeatureRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for BatchCreateFeaturesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures]: crate::client::FeaturestoreService::batch_create_features
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateFeaturesResponse {
    /// The Features created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl BatchCreateFeaturesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [features][crate::model::BatchCreateFeaturesResponse::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for BatchCreateFeaturesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesResponse"
    }
}

/// Request message for
/// [FeaturestoreService.GetFeature][google.cloud.aiplatform.v1.FeaturestoreService.GetFeature].
/// Request message for
/// [FeatureRegistryService.GetFeature][google.cloud.aiplatform.v1.FeatureRegistryService.GetFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.GetFeature]: crate::client::FeatureRegistryService::get_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.GetFeature]: crate::client::FeaturestoreService::get_feature
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureRequest {
    /// Required. The name of the Feature resource.
    /// Format for entity_type as parent:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// Format for feature_group as parent:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl GetFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for GetFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures].
/// Request message for
/// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]: crate::client::FeatureRegistryService::list_features
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]: crate::client::FeaturestoreService::list_features
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturesRequest {
    /// Required. The resource name of the Location to list Features.
    /// Format for entity_type as parent:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// Format for feature_group as parent:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the Features that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `value_type`: Supports = and != comparisons.
    /// * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
    ///   be in RFC 3339 format.
    /// * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
    ///   be in RFC 3339 format.
    /// * `labels`: Supports key-value equality as well as key presence.
    ///
    /// Examples:
    ///
    /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
    ///   update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
    ///   or updated after 2020-01-31T15:30:00.000000Z.
    /// * `labels.active = yes AND labels.env = prod` --> Features having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any Feature which has a label with 'env' as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of Features to return. The service may return fewer
    /// than this value. If unspecified, at most 1000 Features will be returned.
    /// The maximum value is 1000; any value greater than 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]
    /// call or
    /// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]
    /// or
    /// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]: crate::client::FeatureRegistryService::list_features
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]: crate::client::FeaturestoreService::list_features
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `feature_id`
    /// * `value_type` (Not supported for FeatureRegistry Feature)
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Only applicable for Vertex AI Feature Store (Legacy).
    /// If set, return the most recent
    /// [ListFeaturesRequest.latest_stats_count][google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count]
    /// of stats for each Feature in response. Valid value is [0, 10]. If number of
    /// stats exists <
    /// [ListFeaturesRequest.latest_stats_count][google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count],
    /// return all existing stats.
    ///
    /// [google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count]: crate::model::ListFeaturesRequest::latest_stats_count
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub latest_stats_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl ListFeaturesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeaturesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeaturesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeaturesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeaturesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeaturesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListFeaturesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [latest_stats_count][crate::model::ListFeaturesRequest::latest_stats_count].
    pub fn set_latest_stats_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.latest_stats_count = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for ListFeaturesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures].
/// Response message for
/// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]: crate::client::FeatureRegistryService::list_features
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]: crate::client::FeaturestoreService::list_features
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturesResponse {
    /// The Features matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// A token, which can be sent as
    /// [ListFeaturesRequest.page_token][google.cloud.aiplatform.v1.ListFeaturesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeaturesRequest.page_token]: crate::model::ListFeaturesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl ListFeaturesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeaturesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [features][crate::model::ListFeaturesResponse::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for ListFeaturesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturesResponse"
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeaturesResponse {
    type PageItem = crate::model::Feature;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.features
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]: crate::client::FeaturestoreService::search_features
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchFeaturesRequest {
    /// Required. The resource name of the Location to search Features.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Query string that is a conjunction of field-restricted queries and/or
    /// field-restricted filters.  Field-restricted queries and filters can be
    /// combined using `AND` to form a conjunction.
    ///
    /// A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
    /// exists as a substring within Feature's FIELD. The QUERY
    /// and the FIELD are converted to a sequence of words (i.e. tokens) for
    /// comparison. This is done by:
    ///
    /// * Removing leading/trailing whitespace and tokenizing the search value.
    ///   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
    ///   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
    ///   as a wildcard that matches characters within a token.
    /// * Ignoring case.
    /// * Prepending an asterisk to the first and appending an asterisk to the
    ///   last token in QUERY.
    ///
    /// A QUERY must be either a singular token or a phrase. A phrase is one or
    /// multiple words enclosed in double quotation marks ("). With phrases, the
    /// order of the words is important. Words in the phrase must be matching in
    /// order and consecutively.
    ///
    /// Supported FIELDs for field-restricted queries:
    ///
    /// * `feature_id`
    /// * `description`
    /// * `entity_type_id`
    ///
    /// Examples:
    ///
    /// * `feature_id: foo` --> Matches a Feature with ID containing the substring
    ///   `foo` (eg. `foo`, `foofeature`, `barfoo`).
    /// * `feature_id: foo*feature` --> Matches a Feature with ID containing the
    ///   substring `foo*feature` (eg. `foobarfeature`).
    /// * `feature_id: foo AND description: bar` --> Matches a Feature with ID
    ///   containing the substring `foo` and description containing the substring
    ///   `bar`.
    ///
    /// Besides field queries, the following exact-match filters are
    /// supported. The exact-match filters do not support wildcards. Unlike
    /// field-restricted queries, exact-match filters are case-sensitive.
    ///
    /// * `feature_id`: Supports = comparisons.
    /// * `description`: Supports = comparisons. Multi-token filters should be
    ///   enclosed in quotes.
    /// * `entity_type_id`: Supports = comparisons.
    /// * `value_type`: Supports = and != comparisons.
    /// * `labels`: Supports key-value equality as well as key presence.
    /// * `featurestore_id`: Supports = comparisons.
    ///
    /// Examples:
    ///
    /// * `description = "foo bar"` --> Any Feature with description exactly equal
    ///   to `foo bar`
    /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
    /// * `labels.active = yes AND labels.env = prod` --> Features having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any Feature which has a label with `env` as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// The maximum number of Features to return. The service may return fewer
    /// than this value. If unspecified, at most 100 Features will be returned.
    /// The maximum value is 100; any value greater than 100 will be coerced to
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
    /// except `page_size`, must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]: crate::client::FeaturestoreService::search_features
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl SearchFeaturesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::SearchFeaturesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchFeaturesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchFeaturesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchFeaturesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for SearchFeaturesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchFeaturesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]: crate::client::FeaturestoreService::search_features
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchFeaturesResponse {
    /// The Features matching the request.
    ///
    /// Fields returned:
    ///
    /// * `name`
    /// * `description`
    /// * `labels`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// A token, which can be sent as
    /// [SearchFeaturesRequest.page_token][google.cloud.aiplatform.v1.SearchFeaturesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.SearchFeaturesRequest.page_token]: crate::model::SearchFeaturesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl SearchFeaturesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchFeaturesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [features][crate::model::SearchFeaturesResponse::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for SearchFeaturesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchFeaturesResponse"
    }
}

#[cfg(feature = "featurestore_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchFeaturesResponse {
    type PageItem = crate::model::Feature;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.features
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [FeaturestoreService.UpdateFeature][google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeature].
/// Request message for
/// [FeatureRegistryService.UpdateFeature][google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeature]: crate::client::FeatureRegistryService::update_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeature]: crate::client::FeaturestoreService::update_feature
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureRequest {
    /// Required. The Feature's `name` field is used to identify the Feature to be
    /// updated.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature: std::option::Option<crate::model::Feature>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// Features resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `description`
    /// * `labels`
    /// * `disable_monitoring` (Not supported for FeatureRegistryService Feature)
    /// * `point_of_contact` (Not supported for FeaturestoreService FeatureStore)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl UpdateFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature][crate::model::UpdateFeatureRequest::feature].
    pub fn set_feature<T: std::convert::Into<std::option::Option<crate::model::Feature>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for UpdateFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureRequest"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteFeature][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeature].
/// Request message for
/// [FeatureRegistryService.DeleteFeature][google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeature]: crate::client::FeatureRegistryService::delete_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeature]: crate::client::FeaturestoreService::delete_feature
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureRequest {
    /// Required. The name of the Features to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl DeleteFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for DeleteFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureRequest"
    }
}

/// Details of operations that perform create Featurestore.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeaturestoreOperationMetadata {
    /// Operation metadata for Featurestore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl CreateFeaturestoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeaturestoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for CreateFeaturestoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeaturestoreOperationMetadata"
    }
}

/// Details of operations that perform update Featurestore.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeaturestoreOperationMetadata {
    /// Operation metadata for Featurestore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl UpdateFeaturestoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeaturestoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for UpdateFeaturestoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeaturestoreOperationMetadata"
    }
}

/// Details of operations that perform import Feature values.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore import Feature values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Number of entities that have been imported by the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_entity_count: i64,

    /// Number of Feature values that have been imported by the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_feature_value_count: i64,

    /// The source URI from where Feature values are imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_uris: std::vec::Vec<std::string::String>,

    /// The number of rows in input source that weren't imported due to either
    ///
    /// * Not having any featureValues.
    /// * Having a null entityId.
    /// * Having a null timestamp.
    /// * Not being parsable (applicable for CSV sources).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub invalid_row_count: i64,

    /// The number rows that weren't ingested due to having timestamps outside the
    /// retention boundary.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub timestamp_outside_retention_rows_count: i64,

    /// List of ImportFeatureValues operations running under a single EntityType
    /// that are blocking this operation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub blocking_operation_ids: std::vec::Vec<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ImportFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ImportFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [imported_entity_count][crate::model::ImportFeatureValuesOperationMetadata::imported_entity_count].
    pub fn set_imported_entity_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_entity_count = v.into();
        self
    }

    /// Sets the value of [imported_feature_value_count][crate::model::ImportFeatureValuesOperationMetadata::imported_feature_value_count].
    pub fn set_imported_feature_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_feature_value_count = v.into();
        self
    }

    /// Sets the value of [invalid_row_count][crate::model::ImportFeatureValuesOperationMetadata::invalid_row_count].
    pub fn set_invalid_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.invalid_row_count = v.into();
        self
    }

    /// Sets the value of [timestamp_outside_retention_rows_count][crate::model::ImportFeatureValuesOperationMetadata::timestamp_outside_retention_rows_count].
    pub fn set_timestamp_outside_retention_rows_count<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_outside_retention_rows_count = v.into();
        self
    }

    /// Sets the value of [source_uris][crate::model::ImportFeatureValuesOperationMetadata::source_uris].
    pub fn set_source_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [blocking_operation_ids][crate::model::ImportFeatureValuesOperationMetadata::blocking_operation_ids].
    pub fn set_blocking_operation_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.blocking_operation_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ImportFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesOperationMetadata"
    }
}

/// Details of operations that exports Features values.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore export Feature values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl ExportFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ExportFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for ExportFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesOperationMetadata"
    }
}

/// Details of operations that batch reads Feature values.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore batch read Features values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl BatchReadFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchReadFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for BatchReadFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesOperationMetadata"
    }
}

/// Details of operations that delete Feature values.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore delete Features values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl DeleteFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeleteFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for DeleteFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesOperationMetadata"
    }
}

/// Details of operations that perform create EntityType.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntityTypeOperationMetadata {
    /// Operation metadata for EntityType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl CreateEntityTypeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateEntityTypeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for CreateEntityTypeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEntityTypeOperationMetadata"
    }
}

/// Details of operations that perform create Feature.
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureOperationMetadata {
    /// Operation metadata for Feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl CreateFeatureOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for CreateFeatureOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOperationMetadata"
    }
}

/// Details of operations that perform batch create Features.
#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateFeaturesOperationMetadata {
    /// Operation metadata for Feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl BatchCreateFeaturesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchCreateFeaturesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(any(feature = "feature_registry_service", feature = "featurestore_service",))]
impl wkt::message::Message for BatchCreateFeaturesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesOperationMetadata"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues]: crate::client::FeaturestoreService::delete_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureValuesRequest {
    /// Required. The resource name of the EntityType grouping the Features for
    /// which values are being deleted from. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Defines options to select feature values to be deleted.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub delete_option:
        std::option::Option<crate::model::delete_feature_values_request::DeleteOption>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl DeleteFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::DeleteFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option].
    ///
    /// Note that all the setters affecting `delete_option` are mutually
    /// exclusive.
    pub fn set_delete_option<
        T: std::convert::Into<
                std::option::Option<crate::model::delete_feature_values_request::DeleteOption>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_option = v.into();
        self
    }

    /// The value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// if it holds a `SelectEntity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn select_entity(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_request::SelectEntity>,
    > {
        #[allow(unreachable_patterns)]
        self.delete_option.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_request::DeleteOption::SelectEntity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// if it holds a `SelectTimeRangeAndFeature`, `None` if the field is not set or
    /// holds a different branch.
    pub fn select_time_range_and_feature(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_request::SelectTimeRangeAndFeature>,
    > {
        #[allow(unreachable_patterns)]
        self.delete_option.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_request::DeleteOption::SelectTimeRangeAndFeature(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// to hold a `SelectEntity`.
    ///
    /// Note that all the setters affecting `delete_option` are
    /// mutually exclusive.
    pub fn set_select_entity<
        T: std::convert::Into<
                std::boxed::Box<crate::model::delete_feature_values_request::SelectEntity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_option = std::option::Option::Some(
            crate::model::delete_feature_values_request::DeleteOption::SelectEntity(v.into()),
        );
        self
    }

    /// Sets the value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// to hold a `SelectTimeRangeAndFeature`.
    ///
    /// Note that all the setters affecting `delete_option` are
    /// mutually exclusive.
    pub fn set_select_time_range_and_feature<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::delete_feature_values_request::SelectTimeRangeAndFeature,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_option = std::option::Option::Some(
            crate::model::delete_feature_values_request::DeleteOption::SelectTimeRangeAndFeature(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for DeleteFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest"
    }
}

/// Defines additional types related to [DeleteFeatureValuesRequest].
#[cfg(feature = "featurestore_service")]
pub mod delete_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Message to select entity.
    /// If an entity id is selected, all the feature values corresponding to the
    /// entity id will be deleted, including the entityId.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectEntity {
        /// Required. Selectors choosing feature values of which entity id to be
        /// deleted from the EntityType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub entity_id_selector: std::option::Option<crate::model::EntityIdSelector>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl SelectEntity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id_selector][crate::model::delete_feature_values_request::SelectEntity::entity_id_selector].
        pub fn set_entity_id_selector<
            T: std::convert::Into<std::option::Option<crate::model::EntityIdSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entity_id_selector = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for SelectEntity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectEntity"
        }
    }

    /// Message to select time range and feature.
    /// Values of the selected feature generated within an inclusive time range
    /// will be deleted. Using this option permanently deletes the feature values
    /// from the specified feature IDs within the specified time range.
    /// This might include data from the online storage. If you want to retain
    /// any deleted historical data in the online storage, you must re-ingest it.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectTimeRangeAndFeature {
        /// Required. Select feature generated within a half-inclusive time range.
        /// The time range is lower inclusive and upper exclusive.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_range: std::option::Option<gtype::model::Interval>,

        /// Required. Selectors choosing which feature values to be deleted from the
        /// EntityType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

        /// If set, data will not be deleted from online storage.
        /// When time range is older than the data in online storage, setting this to
        /// be true will make the deletion have no impact on online serving.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub skip_online_storage_delete: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl SelectTimeRangeAndFeature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_range][crate::model::delete_feature_values_request::SelectTimeRangeAndFeature::time_range].
        pub fn set_time_range<
            T: std::convert::Into<std::option::Option<gtype::model::Interval>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_range = v.into();
            self
        }

        /// Sets the value of [feature_selector][crate::model::delete_feature_values_request::SelectTimeRangeAndFeature::feature_selector].
        pub fn set_feature_selector<
            T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_selector = v.into();
            self
        }

        /// Sets the value of [skip_online_storage_delete][crate::model::delete_feature_values_request::SelectTimeRangeAndFeature::skip_online_storage_delete].
        pub fn set_skip_online_storage_delete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.skip_online_storage_delete = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for SelectTimeRangeAndFeature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectTimeRangeAndFeature"
        }
    }

    /// Defines options to select feature values to be deleted.
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DeleteOption {
        /// Select feature values to be deleted by specifying entities.
        SelectEntity(std::boxed::Box<crate::model::delete_feature_values_request::SelectEntity>),
        /// Select feature values to be deleted by specifying time range and
        /// features.
        SelectTimeRangeAndFeature(
            std::boxed::Box<crate::model::delete_feature_values_request::SelectTimeRangeAndFeature>,
        ),
    }
}

/// Response message for
/// [FeaturestoreService.DeleteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues]: crate::client::FeaturestoreService::delete_feature_values
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureValuesResponse {
    /// Response based on which delete option is specified in the
    /// request
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::delete_feature_values_response::Response>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl DeleteFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response][crate::model::DeleteFeatureValuesResponse::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<
                std::option::Option<crate::model::delete_feature_values_response::Response>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// if it holds a `SelectEntity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn select_entity(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_response::SelectEntity>,
    > {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_response::Response::SelectEntity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// if it holds a `SelectTimeRangeAndFeature`, `None` if the field is not set or
    /// holds a different branch.
    pub fn select_time_range_and_feature(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_response::SelectTimeRangeAndFeature>,
    > {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_response::Response::SelectTimeRangeAndFeature(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// to hold a `SelectEntity`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_select_entity<
        T: std::convert::Into<
                std::boxed::Box<crate::model::delete_feature_values_response::SelectEntity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::delete_feature_values_response::Response::SelectEntity(v.into()),
        );
        self
    }

    /// Sets the value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// to hold a `SelectTimeRangeAndFeature`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_select_time_range_and_feature<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::delete_feature_values_response::SelectTimeRangeAndFeature,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::delete_feature_values_response::Response::SelectTimeRangeAndFeature(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for DeleteFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse"
    }
}

/// Defines additional types related to [DeleteFeatureValuesResponse].
#[cfg(feature = "featurestore_service")]
pub mod delete_feature_values_response {
    #[allow(unused_imports)]
    use super::*;

    /// Response message if the request uses the SelectEntity option.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectEntity {
        /// The count of deleted entity rows in the offline storage.
        /// Each row corresponds to the combination of an entity ID and a timestamp.
        /// One entity ID can have multiple rows in the offline storage.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub offline_storage_deleted_entity_row_count: i64,

        /// The count of deleted entities in the online storage.
        /// Each entity ID corresponds to one entity.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub online_storage_deleted_entity_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl SelectEntity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offline_storage_deleted_entity_row_count][crate::model::delete_feature_values_response::SelectEntity::offline_storage_deleted_entity_row_count].
        pub fn set_offline_storage_deleted_entity_row_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.offline_storage_deleted_entity_row_count = v.into();
            self
        }

        /// Sets the value of [online_storage_deleted_entity_count][crate::model::delete_feature_values_response::SelectEntity::online_storage_deleted_entity_count].
        pub fn set_online_storage_deleted_entity_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.online_storage_deleted_entity_count = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for SelectEntity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectEntity"
        }
    }

    /// Response message if the request uses the SelectTimeRangeAndFeature option.
    #[cfg(feature = "featurestore_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectTimeRangeAndFeature {
        /// The count of the features or columns impacted.
        /// This is the same as the feature count in the request.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub impacted_feature_count: i64,

        /// The count of modified entity rows in the offline storage.
        /// Each row corresponds to the combination of an entity ID and a timestamp.
        /// One entity ID can have multiple rows in the offline storage.
        /// Within each row, only the features specified in the request are
        /// deleted.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub offline_storage_modified_entity_row_count: i64,

        /// The count of modified entities in the online storage.
        /// Each entity ID corresponds to one entity.
        /// Within each entity, only the features specified in the request are
        /// deleted.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub online_storage_modified_entity_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "featurestore_service")]
    impl SelectTimeRangeAndFeature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [impacted_feature_count][crate::model::delete_feature_values_response::SelectTimeRangeAndFeature::impacted_feature_count].
        pub fn set_impacted_feature_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.impacted_feature_count = v.into();
            self
        }

        /// Sets the value of [offline_storage_modified_entity_row_count][crate::model::delete_feature_values_response::SelectTimeRangeAndFeature::offline_storage_modified_entity_row_count].
        pub fn set_offline_storage_modified_entity_row_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.offline_storage_modified_entity_row_count = v.into();
            self
        }

        /// Sets the value of [online_storage_modified_entity_count][crate::model::delete_feature_values_response::SelectTimeRangeAndFeature::online_storage_modified_entity_count].
        pub fn set_online_storage_modified_entity_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.online_storage_modified_entity_count = v.into();
            self
        }
    }

    #[cfg(feature = "featurestore_service")]
    impl wkt::message::Message for SelectTimeRangeAndFeature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectTimeRangeAndFeature"
        }
    }

    /// Response based on which delete option is specified in the
    /// request
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Response {
        /// Response for request specifying the entities to delete
        SelectEntity(std::boxed::Box<crate::model::delete_feature_values_response::SelectEntity>),
        /// Response for request specifying time range and feature
        SelectTimeRangeAndFeature(
            std::boxed::Box<
                crate::model::delete_feature_values_response::SelectTimeRangeAndFeature,
            >,
        ),
    }
}

/// Selector for entityId. Getting ids from the given source.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityIdSelector {
    /// Source column that holds entity IDs. If not provided, entity IDs are
    /// extracted from the column named entity_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id_field: std::string::String,

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub entity_ids_source: std::option::Option<crate::model::entity_id_selector::EntityIdsSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl EntityIdSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_id_field][crate::model::EntityIdSelector::entity_id_field].
    pub fn set_entity_id_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id_field = v.into();
        self
    }

    /// Sets the value of [entity_ids_source][crate::model::EntityIdSelector::entity_ids_source].
    ///
    /// Note that all the setters affecting `entity_ids_source` are mutually
    /// exclusive.
    pub fn set_entity_ids_source<
        T: std::convert::Into<std::option::Option<crate::model::entity_id_selector::EntityIdsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_ids_source = v.into();
        self
    }

    /// The value of [entity_ids_source][crate::model::EntityIdSelector::entity_ids_source]
    /// if it holds a `CsvSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::CsvSource>> {
        #[allow(unreachable_patterns)]
        self.entity_ids_source.as_ref().and_then(|v| match v {
            crate::model::entity_id_selector::EntityIdsSource::CsvSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_ids_source][crate::model::EntityIdSelector::entity_ids_source]
    /// to hold a `CsvSource`.
    ///
    /// Note that all the setters affecting `entity_ids_source` are
    /// mutually exclusive.
    pub fn set_csv_source<T: std::convert::Into<std::boxed::Box<crate::model::CsvSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_ids_source = std::option::Option::Some(
            crate::model::entity_id_selector::EntityIdsSource::CsvSource(v.into()),
        );
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for EntityIdSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EntityIdSelector"
    }
}

/// Defines additional types related to [EntityIdSelector].
#[cfg(feature = "featurestore_service")]
pub mod entity_id_selector {
    #[allow(unused_imports)]
    use super::*;

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[cfg(feature = "featurestore_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EntityIdsSource {
        /// Source of Csv
        CsvSource(std::boxed::Box<crate::model::CsvSource>),
    }
}

/// Request message for
/// [GenAiCacheService.CreateCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.CreateCachedContent].
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.CreateCachedContent]: crate::client::GenAiCacheService::create_cached_content
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCachedContentRequest {
    /// Required. The parent resource where the cached content will be created
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The cached content to create
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cached_content: std::option::Option<crate::model::CachedContent>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl CreateCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCachedContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cached_content][crate::model::CreateCachedContentRequest::cached_content].
    pub fn set_cached_content<
        T: std::convert::Into<std::option::Option<crate::model::CachedContent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cached_content = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for CreateCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateCachedContentRequest"
    }
}

/// Request message for
/// [GenAiCacheService.GetCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.GetCachedContent].
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.GetCachedContent]: crate::client::GenAiCacheService::get_cached_content
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCachedContentRequest {
    /// Required. The resource name referring to the cached content
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl GetCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCachedContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for GetCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetCachedContentRequest"
    }
}

/// Request message for
/// [GenAiCacheService.UpdateCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.UpdateCachedContent].
/// Only expire_time or ttl can be updated.
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.UpdateCachedContent]: crate::client::GenAiCacheService::update_cached_content
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCachedContentRequest {
    /// Required. The cached content to update
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cached_content: std::option::Option<crate::model::CachedContent>,

    /// Required. The list of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl UpdateCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cached_content][crate::model::UpdateCachedContentRequest::cached_content].
    pub fn set_cached_content<
        T: std::convert::Into<std::option::Option<crate::model::CachedContent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cached_content = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCachedContentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for UpdateCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateCachedContentRequest"
    }
}

/// Request message for
/// [GenAiCacheService.DeleteCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.DeleteCachedContent].
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.DeleteCachedContent]: crate::client::GenAiCacheService::delete_cached_content
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCachedContentRequest {
    /// Required. The resource name referring to the cached content
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl DeleteCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCachedContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for DeleteCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteCachedContentRequest"
    }
}

/// Request to list CachedContents.
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCachedContentsRequest {
    /// Required. The parent, which owns this collection of cached contents.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of cached contents to return. The service may
    /// return fewer than this value. If unspecified, some default (under maximum)
    /// number of items will be returned. The maximum value is 1000; values above
    /// 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListCachedContents` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCachedContents` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl ListCachedContentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCachedContentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCachedContentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCachedContentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for ListCachedContentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCachedContentsRequest"
    }
}

/// Response with a list of CachedContents.
#[cfg(feature = "gen_ai_cache_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCachedContentsResponse {
    /// List of cached contents.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cached_contents: std::vec::Vec<crate::model::CachedContent>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_cache_service")]
impl ListCachedContentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCachedContentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [cached_contents][crate::model::ListCachedContentsResponse::cached_contents].
    pub fn set_cached_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CachedContent>,
    {
        use std::iter::Iterator;
        self.cached_contents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "gen_ai_cache_service")]
impl wkt::message::Message for ListCachedContentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCachedContentsResponse"
    }
}

#[cfg(feature = "gen_ai_cache_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCachedContentsResponse {
    type PageItem = crate::model::CachedContent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cached_contents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [GenAiTuningService.CreateTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.CreateTuningJob].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.CreateTuningJob]: crate::client::GenAiTuningService::create_tuning_job
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTuningJobRequest {
    /// Required. The resource name of the Location to create the TuningJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The TuningJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_job: std::option::Option<crate::model::TuningJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl CreateTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTuningJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tuning_job][crate::model::CreateTuningJobRequest::tuning_job].
    pub fn set_tuning_job<T: std::convert::Into<std::option::Option<crate::model::TuningJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_job = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for CreateTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTuningJobRequest"
    }
}

/// Request message for
/// [GenAiTuningService.GetTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.GetTuningJob].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.GetTuningJob]: crate::client::GenAiTuningService::get_tuning_job
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTuningJobRequest {
    /// Required. The name of the TuningJob resource. Format:
    /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl GetTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for GetTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTuningJobRequest"
    }
}

/// Request message for
/// [GenAiTuningService.ListTuningJobs][google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs]: crate::client::GenAiTuningService::list_tuning_jobs
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTuningJobsRequest {
    /// Required. The resource name of the Location to list the TuningJobs from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListTuningJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListTuningJobsResponse.next_page_token]
    /// of the previous GenAiTuningService.ListTuningJob][] call.
    ///
    /// [google.cloud.aiplatform.v1.ListTuningJobsResponse.next_page_token]: crate::model::ListTuningJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl ListTuningJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTuningJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTuningJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTuningJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTuningJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for ListTuningJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTuningJobsRequest"
    }
}

/// Response message for
/// [GenAiTuningService.ListTuningJobs][google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs]
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs]: crate::client::GenAiTuningService::list_tuning_jobs
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTuningJobsResponse {
    /// List of TuningJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tuning_jobs: std::vec::Vec<crate::model::TuningJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListTuningJobsRequest.page_token][google.cloud.aiplatform.v1.ListTuningJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListTuningJobsRequest.page_token]: crate::model::ListTuningJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl ListTuningJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTuningJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tuning_jobs][crate::model::ListTuningJobsResponse::tuning_jobs].
    pub fn set_tuning_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TuningJob>,
    {
        use std::iter::Iterator;
        self.tuning_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for ListTuningJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTuningJobsResponse"
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTuningJobsResponse {
    type PageItem = crate::model::TuningJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tuning_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [GenAiTuningService.CancelTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.CancelTuningJob].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.CancelTuningJob]: crate::client::GenAiTuningService::cancel_tuning_job
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelTuningJobRequest {
    /// Required. The name of the TuningJob to cancel. Format:
    /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl CancelTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for CancelTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelTuningJobRequest"
    }
}

/// Request message for
/// [GenAiTuningService.RebaseTunedModel][google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel]: crate::client::GenAiTuningService::rebase_tuned_model
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebaseTunedModelRequest {
    /// Required. The resource name of the Location into which to rebase the Model.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. TunedModel reference to retrieve the legacy model information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuned_model_ref: std::option::Option<crate::model::TunedModelRef>,

    /// Optional. The TuningJob to be updated. Users can use this TuningJob field
    /// to overwrite tuning configs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_job: std::option::Option<crate::model::TuningJob>,

    /// Optional. The Google Cloud Storage location to write the artifacts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact_destination: std::option::Option<crate::model::GcsDestination>,

    /// Optional. By default, bison to gemini migration will always create new
    /// model/endpoint, but for gemini-1.0 to gemini-1.5 migration, we default
    /// deploy to the same endpoint. See details in this Section.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub deploy_to_same_endpoint: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl RebaseTunedModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RebaseTunedModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tuned_model_ref][crate::model::RebaseTunedModelRequest::tuned_model_ref].
    pub fn set_tuned_model_ref<
        T: std::convert::Into<std::option::Option<crate::model::TunedModelRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model_ref = v.into();
        self
    }

    /// Sets the value of [tuning_job][crate::model::RebaseTunedModelRequest::tuning_job].
    pub fn set_tuning_job<T: std::convert::Into<std::option::Option<crate::model::TuningJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_job = v.into();
        self
    }

    /// Sets the value of [artifact_destination][crate::model::RebaseTunedModelRequest::artifact_destination].
    pub fn set_artifact_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_destination = v.into();
        self
    }

    /// Sets the value of [deploy_to_same_endpoint][crate::model::RebaseTunedModelRequest::deploy_to_same_endpoint].
    pub fn set_deploy_to_same_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deploy_to_same_endpoint = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for RebaseTunedModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebaseTunedModelRequest"
    }
}

/// Runtime operation information for
/// [GenAiTuningService.RebaseTunedModel][google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel]: crate::client::GenAiTuningService::rebase_tuned_model
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebaseTunedModelOperationMetadata {
    /// The common part of the operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl RebaseTunedModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::RebaseTunedModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for RebaseTunedModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebaseTunedModelOperationMetadata"
    }
}

/// Represents a HyperparameterTuningJob. A HyperparameterTuningJob
/// has a Study specification and multiple CustomJobs with identical
/// CustomJob specification.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HyperparameterTuningJob {
    /// Output only. Resource name of the HyperparameterTuningJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the HyperparameterTuningJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Study configuration of the HyperparameterTuningJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study_spec: std::option::Option<crate::model::StudySpec>,

    /// Required. The desired total number of Trials.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_trial_count: i32,

    /// Required. The desired number of Trials to run in parallel.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub parallel_trial_count: i32,

    /// The number of failed Trials that need to be seen before failing
    /// the HyperparameterTuningJob.
    ///
    /// If set to 0, Vertex AI decides how many Trials must fail
    /// before the whole job fails.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_failed_trial_count: i32,

    /// Required. The spec of a trial job. The same spec applies to the CustomJobs
    /// created in all the trials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trial_job_spec: std::option::Option<crate::model::CustomJobSpec>,

    /// Output only. Trials of the HyperparameterTuningJob.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trials: std::vec::Vec<crate::model::Trial>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the HyperparameterTuningJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the HyperparameterTuningJob for the first time
    /// entered the `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the HyperparameterTuningJob entered any of the
    /// following states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`,
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the HyperparameterTuningJob was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is JOB_STATE_FAILED or
    /// JOB_STATE_CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize HyperparameterTuningJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a HyperparameterTuningJob.
    /// If this is set, then all resources created by the HyperparameterTuningJob
    /// will be encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl HyperparameterTuningJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HyperparameterTuningJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::HyperparameterTuningJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [study_spec][crate::model::HyperparameterTuningJob::study_spec].
    pub fn set_study_spec<T: std::convert::Into<std::option::Option<crate::model::StudySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.study_spec = v.into();
        self
    }

    /// Sets the value of [max_trial_count][crate::model::HyperparameterTuningJob::max_trial_count].
    pub fn set_max_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_trial_count = v.into();
        self
    }

    /// Sets the value of [parallel_trial_count][crate::model::HyperparameterTuningJob::parallel_trial_count].
    pub fn set_parallel_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.parallel_trial_count = v.into();
        self
    }

    /// Sets the value of [max_failed_trial_count][crate::model::HyperparameterTuningJob::max_failed_trial_count].
    pub fn set_max_failed_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_failed_trial_count = v.into();
        self
    }

    /// Sets the value of [trial_job_spec][crate::model::HyperparameterTuningJob::trial_job_spec].
    pub fn set_trial_job_spec<
        T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trial_job_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::HyperparameterTuningJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::HyperparameterTuningJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::HyperparameterTuningJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::HyperparameterTuningJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::HyperparameterTuningJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::HyperparameterTuningJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::HyperparameterTuningJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::HyperparameterTuningJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::HyperparameterTuningJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [trials][crate::model::HyperparameterTuningJob::trials].
    pub fn set_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.trials = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::HyperparameterTuningJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for HyperparameterTuningJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.HyperparameterTuningJob"
    }
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Index {
    /// Output only. The resource name of the Index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the Index.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// additional information about the Index, that is specific to it. Unset if
    /// the Index does not have any additional information. The schema is defined
    /// as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_uri: std::string::String,

    /// An additional information about the Index; the schema of the metadata can
    /// be found in
    /// [metadata_schema][google.cloud.aiplatform.v1.Index.metadata_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Index.metadata_schema_uri]: crate::model::Index::metadata_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. The pointers to DeployedIndexes created from this Index.
    /// An Index can be only deleted if all its DeployedIndexes had been undeployed
    /// first.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_indexes: std::vec::Vec<crate::model::DeployedIndexRef>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Indexes.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Index was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Index was most recently updated.
    /// This also includes any update to the contents of the Index.
    /// Note that Operations working on this Index may have their
    /// [Operations.metadata.generic_metadata.update_time]
    /// [google.cloud.aiplatform.v1.GenericOperationMetadata.update_time] a little
    /// after the value of this timestamp, yet that does not mean their results are
    /// not already reflected in the Index. Result of any successfully completed
    /// Operation on the Index is reflected in it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Stats of the index resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_stats: std::option::Option<crate::model::IndexStats>,

    /// Immutable. The update method to use with this Index. If not set,
    /// BATCH_UPDATE will be used by default.
    pub index_update_method: crate::model::index::IndexUpdateMethod,

    /// Immutable. Customer-managed encryption key spec for an Index. If set, this
    /// Index and all sub-resources of this Index will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Index::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Index::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Index::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [metadata_schema_uri][crate::model::Index::metadata_schema_uri].
    pub fn set_metadata_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Index::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Index::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Index::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Index::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [index_stats][crate::model::Index::index_stats].
    pub fn set_index_stats<T: std::convert::Into<std::option::Option<crate::model::IndexStats>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_stats = v.into();
        self
    }

    /// Sets the value of [index_update_method][crate::model::Index::index_update_method].
    pub fn set_index_update_method<
        T: std::convert::Into<crate::model::index::IndexUpdateMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_update_method = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Index::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Index::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Index::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [deployed_indexes][crate::model::Index::deployed_indexes].
    pub fn set_deployed_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedIndexRef>,
    {
        use std::iter::Iterator;
        self.deployed_indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Index::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Index"
    }
}

/// Defines additional types related to [Index].
#[cfg(feature = "index_service")]
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// The update method of an Index.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "index_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndexUpdateMethod {
        /// Should not be used.
        Unspecified,
        /// BatchUpdate: user can call UpdateIndex with files on Cloud Storage of
        /// Datapoints to update.
        BatchUpdate,
        /// StreamUpdate: user can call UpsertDatapoints/DeleteDatapoints to update
        /// the Index and the updates will be applied in corresponding
        /// DeployedIndexes in nearly real-time.
        StreamUpdate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndexUpdateMethod::value] or
        /// [IndexUpdateMethod::name].
        UnknownValue(index_update_method::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "index_service")]
    pub mod index_update_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "index_service")]
    impl IndexUpdateMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BatchUpdate => std::option::Option::Some(1),
                Self::StreamUpdate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INDEX_UPDATE_METHOD_UNSPECIFIED"),
                Self::BatchUpdate => std::option::Option::Some("BATCH_UPDATE"),
                Self::StreamUpdate => std::option::Option::Some("STREAM_UPDATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "index_service")]
    impl std::default::Default for IndexUpdateMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "index_service")]
    impl std::fmt::Display for IndexUpdateMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "index_service")]
    impl std::convert::From<i32> for IndexUpdateMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BatchUpdate,
                2 => Self::StreamUpdate,
                _ => Self::UnknownValue(index_update_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "index_service")]
    impl std::convert::From<&str> for IndexUpdateMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDEX_UPDATE_METHOD_UNSPECIFIED" => Self::Unspecified,
                "BATCH_UPDATE" => Self::BatchUpdate,
                "STREAM_UPDATE" => Self::StreamUpdate,
                _ => Self::UnknownValue(index_update_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "index_service")]
    impl serde::ser::Serialize for IndexUpdateMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BatchUpdate => serializer.serialize_i32(1),
                Self::StreamUpdate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "index_service")]
    impl<'de> serde::de::Deserialize<'de> for IndexUpdateMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexUpdateMethod>::new(
                ".google.cloud.aiplatform.v1.Index.IndexUpdateMethod",
            ))
        }
    }
}

/// A datapoint of Index.
#[cfg(any(feature = "index_service", feature = "match_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexDatapoint {
    /// Required. Unique identifier of the datapoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datapoint_id: std::string::String,

    /// Required. Feature embedding vector for dense index. An array of numbers
    /// with the length of [NearestNeighborSearchConfig.dimensions].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_vector: std::vec::Vec<f32>,

    /// Optional. Feature embedding vector for sparse index.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sparse_embedding: std::option::Option<crate::model::index_datapoint::SparseEmbedding>,

    /// Optional. List of Restrict of the datapoint, used to perform "restricted
    /// searches" where boolean rule are used to filter the subset of the database
    /// eligible for matching. This uses categorical tokens. See:
    /// <https://cloud.google.com/vertex-ai/docs/matching-engine/filtering>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub restricts: std::vec::Vec<crate::model::index_datapoint::Restriction>,

    /// Optional. List of Restrict of the datapoint, used to perform "restricted
    /// searches" where boolean rule are used to filter the subset of the database
    /// eligible for matching. This uses numeric comparisons.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub numeric_restricts: std::vec::Vec<crate::model::index_datapoint::NumericRestriction>,

    /// Optional. CrowdingTag of the datapoint, the number of neighbors to return
    /// in each crowding can be configured during query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crowding_tag: std::option::Option<crate::model::index_datapoint::CrowdingTag>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "index_service", feature = "match_service",))]
impl IndexDatapoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datapoint_id][crate::model::IndexDatapoint::datapoint_id].
    pub fn set_datapoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datapoint_id = v.into();
        self
    }

    /// Sets the value of [sparse_embedding][crate::model::IndexDatapoint::sparse_embedding].
    pub fn set_sparse_embedding<
        T: std::convert::Into<std::option::Option<crate::model::index_datapoint::SparseEmbedding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sparse_embedding = v.into();
        self
    }

    /// Sets the value of [crowding_tag][crate::model::IndexDatapoint::crowding_tag].
    pub fn set_crowding_tag<
        T: std::convert::Into<std::option::Option<crate::model::index_datapoint::CrowdingTag>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.crowding_tag = v.into();
        self
    }

    /// Sets the value of [feature_vector][crate::model::IndexDatapoint::feature_vector].
    pub fn set_feature_vector<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.feature_vector = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [restricts][crate::model::IndexDatapoint::restricts].
    pub fn set_restricts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index_datapoint::Restriction>,
    {
        use std::iter::Iterator;
        self.restricts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [numeric_restricts][crate::model::IndexDatapoint::numeric_restricts].
    pub fn set_numeric_restricts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index_datapoint::NumericRestriction>,
    {
        use std::iter::Iterator;
        self.numeric_restricts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "index_service", feature = "match_service",))]
impl wkt::message::Message for IndexDatapoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint"
    }
}

/// Defines additional types related to [IndexDatapoint].
#[cfg(any(feature = "index_service", feature = "match_service",))]
pub mod index_datapoint {
    #[allow(unused_imports)]
    use super::*;

    /// Feature embedding vector for sparse index. An array of numbers whose values
    /// are located in the specified dimensions.
    #[cfg(any(feature = "index_service", feature = "match_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SparseEmbedding {
        /// Required. The list of embedding values of the sparse vector.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<f32>,

        /// Required. The list of indexes for the embedding values of the sparse
        /// vector.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
        pub dimensions: std::vec::Vec<i64>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl SparseEmbedding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::index_datapoint::SparseEmbedding::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dimensions][crate::model::index_datapoint::SparseEmbedding::dimensions].
        pub fn set_dimensions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.dimensions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl wkt::message::Message for SparseEmbedding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.SparseEmbedding"
        }
    }

    /// Restriction of a datapoint which describe its attributes(tokens) from each
    /// of several attribute categories(namespaces).
    #[cfg(any(feature = "index_service", feature = "match_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Restriction {
        /// The namespace of this restriction. e.g.: color.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace: std::string::String,

        /// The attributes to allow in this namespace. e.g.: 'red'
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allow_list: std::vec::Vec<std::string::String>,

        /// The attributes to deny in this namespace. e.g.: 'blue'
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub deny_list: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl Restriction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [namespace][crate::model::index_datapoint::Restriction::namespace].
        pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.namespace = v.into();
            self
        }

        /// Sets the value of [allow_list][crate::model::index_datapoint::Restriction::allow_list].
        pub fn set_allow_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allow_list = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [deny_list][crate::model::index_datapoint::Restriction::deny_list].
        pub fn set_deny_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.deny_list = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl wkt::message::Message for Restriction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.Restriction"
        }
    }

    /// This field allows restricts to be based on numeric comparisons rather
    /// than categorical tokens.
    #[cfg(any(feature = "index_service", feature = "match_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericRestriction {
        /// The namespace of this restriction. e.g.: cost.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace: std::string::String,

        /// This MUST be specified for queries and must NOT be specified for
        /// datapoints.
        pub op: crate::model::index_datapoint::numeric_restriction::Operator,

        /// The type of Value must be consistent for all datapoints with a given
        /// namespace name. This is verified at runtime.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::index_datapoint::numeric_restriction::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl NumericRestriction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [namespace][crate::model::index_datapoint::NumericRestriction::namespace].
        pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.namespace = v.into();
            self
        }

        /// Sets the value of [op][crate::model::index_datapoint::NumericRestriction::op].
        pub fn set_op<
            T: std::convert::Into<crate::model::index_datapoint::numeric_restriction::Operator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.op = v.into();
            self
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<crate::model::index_datapoint::numeric_restriction::Value>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// if it holds a `ValueInt`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value_int(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::index_datapoint::numeric_restriction::Value::ValueInt(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// if it holds a `ValueFloat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value_float(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::index_datapoint::numeric_restriction::Value::ValueFloat(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// if it holds a `ValueDouble`, `None` if the field is not set or
        /// holds a different branch.
        pub fn value_double(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::index_datapoint::numeric_restriction::Value::ValueDouble(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// to hold a `ValueInt`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_int<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::index_datapoint::numeric_restriction::Value::ValueInt(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// to hold a `ValueFloat`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::index_datapoint::numeric_restriction::Value::ValueFloat(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// to hold a `ValueDouble`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::index_datapoint::numeric_restriction::Value::ValueDouble(v.into()),
            );
            self
        }
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl wkt::message::Message for NumericRestriction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.NumericRestriction"
        }
    }

    /// Defines additional types related to [NumericRestriction].
    #[cfg(any(feature = "index_service", feature = "match_service",))]
    pub mod numeric_restriction {
        #[allow(unused_imports)]
        use super::*;

        /// Which comparison operator to use.  Should be specified for queries only;
        /// specifying this for a datapoint is an error.
        ///
        /// Datapoints for which Operator is true relative to the query's Value
        /// field will be allowlisted.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "index_service", feature = "match_service",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operator {
            /// Default value of the enum.
            Unspecified,
            /// Datapoints are eligible iff their value is < the query's.
            Less,
            /// Datapoints are eligible iff their value is <= the query's.
            LessEqual,
            /// Datapoints are eligible iff their value is == the query's.
            Equal,
            /// Datapoints are eligible iff their value is >= the query's.
            GreaterEqual,
            /// Datapoints are eligible iff their value is > the query's.
            Greater,
            /// Datapoints are eligible iff their value is != the query's.
            NotEqual,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Operator::value] or
            /// [Operator::name].
            UnknownValue(operator::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "index_service", feature = "match_service",))]
        pub mod operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl Operator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Less => std::option::Option::Some(1),
                    Self::LessEqual => std::option::Option::Some(2),
                    Self::Equal => std::option::Option::Some(3),
                    Self::GreaterEqual => std::option::Option::Some(4),
                    Self::Greater => std::option::Option::Some(5),
                    Self::NotEqual => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                    Self::Less => std::option::Option::Some("LESS"),
                    Self::LessEqual => std::option::Option::Some("LESS_EQUAL"),
                    Self::Equal => std::option::Option::Some("EQUAL"),
                    Self::GreaterEqual => std::option::Option::Some("GREATER_EQUAL"),
                    Self::Greater => std::option::Option::Some("GREATER"),
                    Self::NotEqual => std::option::Option::Some("NOT_EQUAL"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl std::default::Default for Operator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl std::fmt::Display for Operator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl std::convert::From<i32> for Operator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Less,
                    2 => Self::LessEqual,
                    3 => Self::Equal,
                    4 => Self::GreaterEqual,
                    5 => Self::Greater,
                    6 => Self::NotEqual,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl std::convert::From<&str> for Operator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "LESS" => Self::Less,
                    "LESS_EQUAL" => Self::LessEqual,
                    "EQUAL" => Self::Equal,
                    "GREATER_EQUAL" => Self::GreaterEqual,
                    "GREATER" => Self::Greater,
                    "NOT_EQUAL" => Self::NotEqual,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl serde::ser::Serialize for Operator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Less => serializer.serialize_i32(1),
                    Self::LessEqual => serializer.serialize_i32(2),
                    Self::Equal => serializer.serialize_i32(3),
                    Self::GreaterEqual => serializer.serialize_i32(4),
                    Self::Greater => serializer.serialize_i32(5),
                    Self::NotEqual => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "index_service", feature = "match_service",))]
        impl<'de> serde::de::Deserialize<'de> for Operator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                    ".google.cloud.aiplatform.v1.IndexDatapoint.NumericRestriction.Operator",
                ))
            }
        }

        /// The type of Value must be consistent for all datapoints with a given
        /// namespace name. This is verified at runtime.
        #[cfg(any(feature = "index_service", feature = "match_service",))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// Represents 64 bit integer.
            ValueInt(i64),
            /// Represents 32 bit float.
            ValueFloat(f32),
            /// Represents 64 bit float.
            ValueDouble(f64),
        }
    }

    /// Crowding tag is a constraint on a neighbor list produced by nearest
    /// neighbor search requiring that no more than some value k' of the k
    /// neighbors returned have the same value of crowding_attribute.
    #[cfg(any(feature = "index_service", feature = "match_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CrowdingTag {
        /// The attribute value used for crowding.  The maximum number of neighbors
        /// to return per crowding attribute value
        /// (per_crowding_attribute_num_neighbors) is configured per-query. This
        /// field is ignored if per_crowding_attribute_num_neighbors is larger than
        /// the total number of neighbors to return for a given query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub crowding_attribute: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl CrowdingTag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [crowding_attribute][crate::model::index_datapoint::CrowdingTag::crowding_attribute].
        pub fn set_crowding_attribute<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.crowding_attribute = v.into();
            self
        }
    }

    #[cfg(any(feature = "index_service", feature = "match_service",))]
    impl wkt::message::Message for CrowdingTag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.CrowdingTag"
        }
    }
}

/// Stats of the Index.
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexStats {
    /// Output only. The number of dense vectors in the Index.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub vectors_count: i64,

    /// Output only. The number of sparse vectors in the Index.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sparse_vectors_count: i64,

    /// Output only. The number of shards in the Index.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub shards_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl IndexStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vectors_count][crate::model::IndexStats::vectors_count].
    pub fn set_vectors_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.vectors_count = v.into();
        self
    }

    /// Sets the value of [sparse_vectors_count][crate::model::IndexStats::sparse_vectors_count].
    pub fn set_sparse_vectors_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sparse_vectors_count = v.into();
        self
    }

    /// Sets the value of [shards_count][crate::model::IndexStats::shards_count].
    pub fn set_shards_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shards_count = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for IndexStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexStats"
    }
}

/// Indexes are deployed into it. An IndexEndpoint can have multiple
/// DeployedIndexes.
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexEndpoint {
    /// Output only. The resource name of the IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the IndexEndpoint.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The indexes deployed in this endpoint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_indexes: std::vec::Vec<crate::model::DeployedIndex>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your IndexEndpoints.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this IndexEndpoint was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this IndexEndpoint was last updated.
    /// This timestamp is not updated when the endpoint's DeployedIndexes are
    /// updated, e.g. due to updates of the original Indexes they are the
    /// deployments of.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The full name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
    /// to which the IndexEndpoint should be peered.
    ///
    /// Private services access must already be configured for the network. If left
    /// unspecified, the Endpoint is not peered with any network.
    ///
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] and
    /// [private_service_connect_config][google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]
    /// are mutually exclusive.
    ///
    /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
    /// `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in '12345', and {network} is
    /// network name.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    /// [google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]: crate::model::IndexEndpoint::private_service_connect_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Deprecated: If true, expose the IndexEndpoint via private service
    /// connect.
    ///
    /// Only one of the fields,
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] or
    /// [enable_private_service_connect][google.cloud.aiplatform.v1.IndexEndpoint.enable_private_service_connect],
    /// can be set.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.enable_private_service_connect]: crate::model::IndexEndpoint::enable_private_service_connect
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub enable_private_service_connect: bool,

    /// Optional. Configuration for private service connect.
    ///
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] and
    /// [private_service_connect_config][google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]
    /// are mutually exclusive.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    /// [google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]: crate::model::IndexEndpoint::private_service_connect_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_service_connect_config:
        std::option::Option<crate::model::PrivateServiceConnectConfig>,

    /// Optional. If true, the deployed index will be accessible through public
    /// endpoint.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub public_endpoint_enabled: bool,

    /// Output only. If
    /// [public_endpoint_enabled][google.cloud.aiplatform.v1.IndexEndpoint.public_endpoint_enabled]
    /// is true, this field will be populated with the domain name to use for this
    /// index endpoint.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.public_endpoint_enabled]: crate::model::IndexEndpoint::public_endpoint_enabled
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_endpoint_domain_name: std::string::String,

    /// Immutable. Customer-managed encryption key spec for an IndexEndpoint. If
    /// set, this IndexEndpoint and all sub-resources of this IndexEndpoint will be
    /// secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl IndexEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IndexEndpoint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IndexEndpoint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::IndexEndpoint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::IndexEndpoint::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::IndexEndpoint::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::IndexEndpoint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [network][crate::model::IndexEndpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [enable_private_service_connect][crate::model::IndexEndpoint::enable_private_service_connect].
    #[deprecated]
    pub fn set_enable_private_service_connect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_service_connect = v.into();
        self
    }

    /// Sets the value of [private_service_connect_config][crate::model::IndexEndpoint::private_service_connect_config].
    pub fn set_private_service_connect_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateServiceConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_service_connect_config = v.into();
        self
    }

    /// Sets the value of [public_endpoint_enabled][crate::model::IndexEndpoint::public_endpoint_enabled].
    pub fn set_public_endpoint_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.public_endpoint_enabled = v.into();
        self
    }

    /// Sets the value of [public_endpoint_domain_name][crate::model::IndexEndpoint::public_endpoint_domain_name].
    pub fn set_public_endpoint_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_endpoint_domain_name = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::IndexEndpoint::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::IndexEndpoint::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::IndexEndpoint::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [deployed_indexes][crate::model::IndexEndpoint::deployed_indexes].
    pub fn set_deployed_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedIndex>,
    {
        use std::iter::Iterator;
        self.deployed_indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::IndexEndpoint::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for IndexEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexEndpoint"
    }
}

/// A deployment of an Index. IndexEndpoints contain one or more DeployedIndexes.
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedIndex {
    /// Required. The user specified ID of the DeployedIndex.
    /// The ID can be up to 128 characters long and must start with a letter and
    /// only contain letters, numbers, and underscores.
    /// The ID must be unique within the project it is created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Required. The name of the Index this is the deployment of.
    /// We may refer to this Index as the DeployedIndex's "original" Index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// The display name of the DeployedIndex. If not provided upon creation,
    /// the Index's display_name is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp when the DeployedIndex was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides paths for users to send requests directly to the
    /// deployed index services running on Cloud via private services access. This
    /// field is populated if
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] is configured.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_endpoints: std::option::Option<crate::model::IndexPrivateEndpoints>,

    /// Output only. The DeployedIndex may depend on various data on its original
    /// Index. Additionally when certain changes to the original Index are being
    /// done (e.g. when what the Index contains is being changed) the DeployedIndex
    /// may be asynchronously updated in the background to reflect these changes.
    /// If this timestamp's value is at least the
    /// [Index.update_time][google.cloud.aiplatform.v1.Index.update_time] of the
    /// original Index, it means that this DeployedIndex and the original Index are
    /// in sync. If this timestamp is older, then to see which updates this
    /// DeployedIndex already contains (and which it does not), one must
    /// [list][google.longrunning.Operations.ListOperations] the operations that
    /// are running on the original Index. Only the successfully completed
    /// Operations with
    /// [update_time][google.cloud.aiplatform.v1.GenericOperationMetadata.update_time]
    /// equal or before this sync time are contained in this DeployedIndex.
    ///
    /// [google.cloud.aiplatform.v1.GenericOperationMetadata.update_time]: crate::model::GenericOperationMetadata::update_time
    /// [google.cloud.aiplatform.v1.Index.update_time]: crate::model::Index::update_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_sync_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A description of resources that the DeployedIndex uses, which to
    /// large degree are decided by Vertex AI, and optionally allows only a modest
    /// additional configuration.
    /// If min_replica_count is not set, the default value is 2 (we don't provide
    /// SLA when min_replica_count=1). If max_replica_count is not set, the
    /// default value is min_replica_count. The max allowed replica count is
    /// 1000.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automatic_resources: std::option::Option<crate::model::AutomaticResources>,

    /// Optional. A description of resources that are dedicated to the
    /// DeployedIndex, and that need a higher degree of manual configuration. The
    /// field min_replica_count must be set to a value strictly greater than 0, or
    /// else validation will fail. We don't provide SLA when min_replica_count=1.
    /// If max_replica_count is not set, the default value is min_replica_count.
    /// The max allowed replica count is 1000.
    ///
    /// Available machine types for SMALL shard:
    /// e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
    ///
    /// Available machine types for MEDIUM shard:
    /// e2-standard-16 and all machine types available for LARGE shard.
    ///
    /// Available machine types for LARGE shard:
    /// e2-highmem-16, n2d-standard-32.
    ///
    /// n1-standard-16 and n1-standard-32 are still available, but we recommend
    /// e2-standard-16 and e2-highmem-16 for cost efficiency.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_resources: std::option::Option<crate::model::DedicatedResources>,

    /// Optional. If true, private endpoint's access logs are sent to Cloud
    /// Logging.
    ///
    /// These logs are like standard server access logs, containing
    /// information like timestamp and latency for each MatchRequest.
    ///
    /// Note that logs may incur a cost, especially if the deployed
    /// index receives a high queries per second rate (QPS).
    /// Estimate your costs before enabling this option.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_access_logging: bool,

    /// Optional. If set, the authentication is enabled for the private endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index_auth_config: std::option::Option<crate::model::DeployedIndexAuthConfig>,

    /// Optional. A list of reserved ip ranges under the VPC network that can be
    /// used for this DeployedIndex.
    ///
    /// If set, we will deploy the index within the provided ip ranges. Otherwise,
    /// the index might be deployed to any ip ranges under the provided VPC
    /// network.
    ///
    /// The value should be the name of the address
    /// (<https://cloud.google.com/compute/docs/reference/rest/v1/addresses>)
    /// Example: ['vertex-ai-ip-range'].
    ///
    /// For more information about subnets and network IP ranges, please see
    /// <https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    /// Optional. The deployment group can be no longer than 64 characters (eg:
    /// 'test', 'prod'). If not set, we will use the 'default' deployment group.
    ///
    /// Creating `deployment_groups` with `reserved_ip_ranges` is a recommended
    /// practice when the peered network has multiple peering ranges. This creates
    /// your deployments from predictable IP spaces for easier traffic
    /// administration. Also, one deployment_group (except 'default') can only be
    /// used with the same reserved_ip_ranges which means if the deployment_group
    /// has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or
    /// [d, e] is disallowed.
    ///
    /// Note: we only support up to 5 deployment groups(not including 'default').
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_group: std::string::String,

    /// Optional. If set for PSC deployed index, PSC connection will be
    /// automatically created after deployment is done and the endpoint information
    /// is populated in private_endpoints.psc_automated_endpoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_automation_configs: std::vec::Vec<crate::model::PSCAutomationConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl DeployedIndex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::DeployedIndex::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [index][crate::model::DeployedIndex::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeployedIndex::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployedIndex::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [private_endpoints][crate::model::DeployedIndex::private_endpoints].
    pub fn set_private_endpoints<
        T: std::convert::Into<std::option::Option<crate::model::IndexPrivateEndpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoints = v.into();
        self
    }

    /// Sets the value of [index_sync_time][crate::model::DeployedIndex::index_sync_time].
    pub fn set_index_sync_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_sync_time = v.into();
        self
    }

    /// Sets the value of [automatic_resources][crate::model::DeployedIndex::automatic_resources].
    pub fn set_automatic_resources<
        T: std::convert::Into<std::option::Option<crate::model::AutomaticResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automatic_resources = v.into();
        self
    }

    /// Sets the value of [dedicated_resources][crate::model::DeployedIndex::dedicated_resources].
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::option::Option<crate::model::DedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_resources = v.into();
        self
    }

    /// Sets the value of [enable_access_logging][crate::model::DeployedIndex::enable_access_logging].
    pub fn set_enable_access_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_access_logging = v.into();
        self
    }

    /// Sets the value of [deployed_index_auth_config][crate::model::DeployedIndex::deployed_index_auth_config].
    pub fn set_deployed_index_auth_config<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndexAuthConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_auth_config = v.into();
        self
    }

    /// Sets the value of [deployment_group][crate::model::DeployedIndex::deployment_group].
    pub fn set_deployment_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_group = v.into();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::DeployedIndex::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_automation_configs][crate::model::DeployedIndex::psc_automation_configs].
    pub fn set_psc_automation_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PSCAutomationConfig>,
    {
        use std::iter::Iterator;
        self.psc_automation_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for DeployedIndex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndex"
    }
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedIndexAuthConfig {
    /// Defines the authentication provider that the DeployedIndex uses.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auth_provider: std::option::Option<crate::model::deployed_index_auth_config::AuthProvider>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl DeployedIndexAuthConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_provider][crate::model::DeployedIndexAuthConfig::auth_provider].
    pub fn set_auth_provider<
        T: std::convert::Into<
                std::option::Option<crate::model::deployed_index_auth_config::AuthProvider>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_provider = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for DeployedIndexAuthConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexAuthConfig"
    }
}

/// Defines additional types related to [DeployedIndexAuthConfig].
#[cfg(feature = "index_endpoint_service")]
pub mod deployed_index_auth_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for an authentication provider, including support for
    /// [JSON Web Token
    /// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
    #[cfg(feature = "index_endpoint_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AuthProvider {
        /// The list of JWT
        /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
        /// that are allowed to access. A JWT containing any of these audiences will
        /// be accepted.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub audiences: std::vec::Vec<std::string::String>,

        /// A list of allowed JWT issuers. Each entry must be a valid Google
        /// service account, in the following format:
        ///
        /// `service-account-name@project-id.iam.gserviceaccount.com`
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allowed_issuers: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "index_endpoint_service")]
    impl AuthProvider {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [audiences][crate::model::deployed_index_auth_config::AuthProvider::audiences].
        pub fn set_audiences<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.audiences = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allowed_issuers][crate::model::deployed_index_auth_config::AuthProvider::allowed_issuers].
        pub fn set_allowed_issuers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_issuers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "index_endpoint_service")]
    impl wkt::message::Message for AuthProvider {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexAuthConfig.AuthProvider"
        }
    }
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
/// To send request via private service access, use match_grpc_address.
/// To send request via private service connect, use service_attachment.
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexPrivateEndpoints {
    /// Output only. The ip address used to send match gRPC requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub match_grpc_address: std::string::String,

    /// Output only. The name of the service attachment resource. Populated if
    /// private service connect is enabled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. PscAutomatedEndpoints is populated if private service connect
    /// is enabled if PscAutomatedConfig is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_automated_endpoints: std::vec::Vec<crate::model::PscAutomatedEndpoints>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl IndexPrivateEndpoints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [match_grpc_address][crate::model::IndexPrivateEndpoints::match_grpc_address].
    pub fn set_match_grpc_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_grpc_address = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::IndexPrivateEndpoints::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_automated_endpoints][crate::model::IndexPrivateEndpoints::psc_automated_endpoints].
    pub fn set_psc_automated_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscAutomatedEndpoints>,
    {
        use std::iter::Iterator;
        self.psc_automated_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for IndexPrivateEndpoints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexPrivateEndpoints"
    }
}

/// Request message for
/// [IndexEndpointService.CreateIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint]: crate::client::IndexEndpointService::create_index_endpoint
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexEndpointRequest {
    /// Required. The resource name of the Location to create the IndexEndpoint in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The IndexEndpoint to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_endpoint: std::option::Option<crate::model::IndexEndpoint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl CreateIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexEndpointRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index_endpoint][crate::model::CreateIndexEndpointRequest::index_endpoint].
    pub fn set_index_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::IndexEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_endpoint = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for CreateIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexEndpointRequest"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.CreateIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint]: crate::client::IndexEndpointService::create_index_endpoint
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexEndpointOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl CreateIndexEndpointOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateIndexEndpointOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for CreateIndexEndpointOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexEndpointOperationMetadata"
    }
}

/// Request message for
/// [IndexEndpointService.GetIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.GetIndexEndpoint]
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.GetIndexEndpoint]: crate::client::IndexEndpointService::get_index_endpoint
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexEndpointRequest {
    /// Required. The name of the IndexEndpoint resource.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl GetIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for GetIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetIndexEndpointRequest"
    }
}

/// Request message for
/// [IndexEndpointService.ListIndexEndpoints][google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]: crate::client::IndexEndpointService::list_index_endpoints
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexEndpointsRequest {
    /// Required. The resource name of the Location from which to list the
    /// IndexEndpoints. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `index_endpoint` supports = and !=. `index_endpoint` represents the
    ///   IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
    ///   [resourcename][google.cloud.aiplatform.v1.IndexEndpoint.name].
    /// * `display_name` supports =, != and regex()
    ///   (uses [re2](https://github.com/google/re2/wiki/Syntax) syntax)
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* or labels:key - key existence
    ///   A key including a space must be quoted. `labels."a key"`.
    ///
    /// Some examples:
    ///
    /// * `index_endpoint="1"`
    /// * `display_name="myDisplayName"`
    /// * `regex(display_name, "^A") -> The display name starts with an A.
    /// * `labels.myKey="myValue"`
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.name]: crate::model::IndexEndpoint::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListIndexEndpointsResponse.next_page_token][google.cloud.aiplatform.v1.ListIndexEndpointsResponse.next_page_token]
    /// of the previous
    /// [IndexEndpointService.ListIndexEndpoints][google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]: crate::client::IndexEndpointService::list_index_endpoints
    /// [google.cloud.aiplatform.v1.ListIndexEndpointsResponse.next_page_token]: crate::model::ListIndexEndpointsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl ListIndexEndpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexEndpointsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexEndpointsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexEndpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexEndpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListIndexEndpointsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for ListIndexEndpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexEndpointsRequest"
    }
}

/// Response message for
/// [IndexEndpointService.ListIndexEndpoints][google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]: crate::client::IndexEndpointService::list_index_endpoints
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexEndpointsResponse {
    /// List of IndexEndpoints in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_endpoints: std::vec::Vec<crate::model::IndexEndpoint>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListIndexEndpointsRequest.page_token][google.cloud.aiplatform.v1.ListIndexEndpointsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListIndexEndpointsRequest.page_token]: crate::model::ListIndexEndpointsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl ListIndexEndpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexEndpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [index_endpoints][crate::model::ListIndexEndpointsResponse::index_endpoints].
    pub fn set_index_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexEndpoint>,
    {
        use std::iter::Iterator;
        self.index_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for ListIndexEndpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexEndpointsResponse"
    }
}

#[cfg(feature = "index_endpoint_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIndexEndpointsResponse {
    type PageItem = crate::model::IndexEndpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.index_endpoints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [IndexEndpointService.UpdateIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.UpdateIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UpdateIndexEndpoint]: crate::client::IndexEndpointService::update_index_endpoint
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIndexEndpointRequest {
    /// Required. The IndexEndpoint which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_endpoint: std::option::Option<crate::model::IndexEndpoint>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl UpdateIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::UpdateIndexEndpointRequest::index_endpoint].
    pub fn set_index_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::IndexEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIndexEndpointRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for UpdateIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexEndpointRequest"
    }
}

/// Request message for
/// [IndexEndpointService.DeleteIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.DeleteIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeleteIndexEndpoint]: crate::client::IndexEndpointService::delete_index_endpoint
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexEndpointRequest {
    /// Required. The name of the IndexEndpoint resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl DeleteIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for DeleteIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteIndexEndpointRequest"
    }
}

/// Request message for
/// [IndexEndpointService.DeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex]: crate::client::IndexEndpointService::deploy_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIndexRequest {
    /// Required. The name of the IndexEndpoint resource into which to deploy an
    /// Index. Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Required. The DeployedIndex to be created within the IndexEndpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl DeployIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::DeployIndexRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index][crate::model::DeployIndexRequest::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for DeployIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexRequest"
    }
}

/// Response message for
/// [IndexEndpointService.DeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex]: crate::client::IndexEndpointService::deploy_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIndexResponse {
    /// The DeployedIndex that had been deployed in the IndexEndpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl DeployIndexResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_index][crate::model::DeployIndexResponse::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for DeployIndexResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexResponse"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.DeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex]: crate::client::IndexEndpointService::deploy_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The unique index id specified by user
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl DeployIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeployIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::DeployIndexOperationMetadata::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for DeployIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexEndpointService.UndeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex]: crate::client::IndexEndpointService::undeploy_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIndexRequest {
    /// Required. The name of the IndexEndpoint resource from which to undeploy an
    /// Index. Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Required. The ID of the DeployedIndex to be undeployed from the
    /// IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl UndeployIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::UndeployIndexRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::UndeployIndexRequest::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for UndeployIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexRequest"
    }
}

/// Response message for
/// [IndexEndpointService.UndeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex]: crate::client::IndexEndpointService::undeploy_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIndexResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl UndeployIndexResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for UndeployIndexResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexResponse"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.UndeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex]: crate::client::IndexEndpointService::undeploy_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl UndeployIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UndeployIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for UndeployIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexEndpointService.MutateDeployedIndex][google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex]: crate::client::IndexEndpointService::mutate_deployed_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedIndexRequest {
    /// Required. The name of the IndexEndpoint resource into which to deploy an
    /// Index. Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Required. The DeployedIndex to be updated within the IndexEndpoint.
    /// Currently, the updatable fields are
    /// [DeployedIndex.automatic_resources][google.cloud.aiplatform.v1.DeployedIndex.automatic_resources]
    /// and
    /// [DeployedIndex.dedicated_resources][google.cloud.aiplatform.v1.DeployedIndex.dedicated_resources]
    ///
    /// [google.cloud.aiplatform.v1.DeployedIndex.automatic_resources]: crate::model::DeployedIndex::automatic_resources
    /// [google.cloud.aiplatform.v1.DeployedIndex.dedicated_resources]: crate::model::DeployedIndex::dedicated_resources
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl MutateDeployedIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::MutateDeployedIndexRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index][crate::model::MutateDeployedIndexRequest::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for MutateDeployedIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexRequest"
    }
}

/// Response message for
/// [IndexEndpointService.MutateDeployedIndex][google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex]: crate::client::IndexEndpointService::mutate_deployed_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedIndexResponse {
    /// The DeployedIndex that had been updated in the IndexEndpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl MutateDeployedIndexResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_index][crate::model::MutateDeployedIndexResponse::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for MutateDeployedIndexResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexResponse"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.MutateDeployedIndex][google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex]: crate::client::IndexEndpointService::mutate_deployed_index
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The unique index id specified by user
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl MutateDeployedIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::MutateDeployedIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::MutateDeployedIndexOperationMetadata::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for MutateDeployedIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexService.CreateIndex][google.cloud.aiplatform.v1.IndexService.CreateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.CreateIndex]: crate::client::IndexService::create_index
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Required. The resource name of the Location to create the Index in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Index to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexRequest"
    }
}

/// Runtime operation information for
/// [IndexService.CreateIndex][google.cloud.aiplatform.v1.IndexService.CreateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.CreateIndex]: crate::client::IndexService::create_index
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The operation metadata with regard to Matching Engine Index operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nearest_neighbor_search_operation_metadata:
        std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl CreateIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [nearest_neighbor_search_operation_metadata][crate::model::CreateIndexOperationMetadata::nearest_neighbor_search_operation_metadata].
    pub fn set_nearest_neighbor_search_operation_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nearest_neighbor_search_operation_metadata = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for CreateIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexService.GetIndex][google.cloud.aiplatform.v1.IndexService.GetIndex]
///
/// [google.cloud.aiplatform.v1.IndexService.GetIndex]: crate::client::IndexService::get_index
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Required. The name of the Index resource.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetIndexRequest"
    }
}

/// Request message for
/// [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes].
///
/// [google.cloud.aiplatform.v1.IndexService.ListIndexes]: crate::client::IndexService::list_indexes
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Required. The resource name of the Location from which to list the Indexes.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListIndexesResponse.next_page_token][google.cloud.aiplatform.v1.ListIndexesResponse.next_page_token]
    /// of the previous
    /// [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.IndexService.ListIndexes]: crate::client::IndexService::list_indexes
    /// [google.cloud.aiplatform.v1.ListIndexesResponse.next_page_token]: crate::model::ListIndexesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListIndexesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexesRequest"
    }
}

/// Response message for
/// [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes].
///
/// [google.cloud.aiplatform.v1.IndexService.ListIndexes]: crate::client::IndexService::list_indexes
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// List of indexes in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListIndexesRequest.page_token][google.cloud.aiplatform.v1.ListIndexesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListIndexesRequest.page_token]: crate::model::ListIndexesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexesResponse"
    }
}

#[cfg(feature = "index_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [IndexService.UpdateIndex][google.cloud.aiplatform.v1.IndexService.UpdateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.UpdateIndex]: crate::client::IndexService::update_index
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIndexRequest {
    /// Required. The Index which updates the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,

    /// The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl UpdateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::UpdateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIndexRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for UpdateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexRequest"
    }
}

/// Runtime operation information for
/// [IndexService.UpdateIndex][google.cloud.aiplatform.v1.IndexService.UpdateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.UpdateIndex]: crate::client::IndexService::update_index
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The operation metadata with regard to Matching Engine Index operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nearest_neighbor_search_operation_metadata:
        std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl UpdateIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [nearest_neighbor_search_operation_metadata][crate::model::UpdateIndexOperationMetadata::nearest_neighbor_search_operation_metadata].
    pub fn set_nearest_neighbor_search_operation_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nearest_neighbor_search_operation_metadata = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for UpdateIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexService.DeleteIndex][google.cloud.aiplatform.v1.IndexService.DeleteIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.DeleteIndex]: crate::client::IndexService::delete_index
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Required. The name of the Index resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteIndexRequest"
    }
}

/// Request message for
/// [IndexService.UpsertDatapoints][google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]: crate::client::IndexService::upsert_datapoints
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpsertDatapointsRequest {
    /// Required. The name of the Index resource to be updated.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// A list of datapoints to be created/updated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datapoints: std::vec::Vec<crate::model::IndexDatapoint>,

    /// Optional. Update mask is used to specify the fields to be overwritten in
    /// the datapoints by the update. The fields specified in the update_mask are
    /// relative to each IndexDatapoint inside datapoints, not the full request.
    ///
    /// Updatable fields:
    ///
    /// * Use `all_restricts` to update both restricts and numeric_restricts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl UpsertDatapointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::UpsertDatapointsRequest::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpsertDatapointsRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [datapoints][crate::model::UpsertDatapointsRequest::datapoints].
    pub fn set_datapoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexDatapoint>,
    {
        use std::iter::Iterator;
        self.datapoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for UpsertDatapointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpsertDatapointsRequest"
    }
}

/// Response message for
/// [IndexService.UpsertDatapoints][google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]: crate::client::IndexService::upsert_datapoints
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpsertDatapointsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl UpsertDatapointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for UpsertDatapointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpsertDatapointsResponse"
    }
}

/// Request message for
/// [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]: crate::client::IndexService::remove_datapoints
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveDatapointsRequest {
    /// Required. The name of the Index resource to be updated.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// A list of datapoint ids to be deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datapoint_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl RemoveDatapointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::RemoveDatapointsRequest::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [datapoint_ids][crate::model::RemoveDatapointsRequest::datapoint_ids].
    pub fn set_datapoint_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.datapoint_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for RemoveDatapointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveDatapointsRequest"
    }
}

/// Response message for
/// [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]: crate::client::IndexService::remove_datapoints
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveDatapointsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl RemoveDatapointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for RemoveDatapointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveDatapointsResponse"
    }
}

/// Runtime operation metadata with regard to Matching Engine Index.
#[cfg(feature = "index_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NearestNeighborSearchOperationMetadata {
    /// The validation stats of the content (per file) to be inserted or
    /// updated on the Matching Engine Index resource. Populated if
    /// contentsDeltaUri is provided as part of
    /// [Index.metadata][google.cloud.aiplatform.v1.Index.metadata]. Please note
    /// that, currently for those files that are broken or has unsupported file
    /// format, we will not have the stats for those files.
    ///
    /// [google.cloud.aiplatform.v1.Index.metadata]: crate::model::Index::metadata
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_validation_stats: std::vec::Vec<
        crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats,
    >,

    /// The ingested data size in bytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub data_bytes_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_service")]
impl NearestNeighborSearchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_bytes_count][crate::model::NearestNeighborSearchOperationMetadata::data_bytes_count].
    pub fn set_data_bytes_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_bytes_count = v.into();
        self
    }

    /// Sets the value of [content_validation_stats][crate::model::NearestNeighborSearchOperationMetadata::content_validation_stats].
    pub fn set_content_validation_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats,
            >,
    {
        use std::iter::Iterator;
        self.content_validation_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "index_service")]
impl wkt::message::Message for NearestNeighborSearchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata"
    }
}

/// Defines additional types related to [NearestNeighborSearchOperationMetadata].
#[cfg(feature = "index_service")]
pub mod nearest_neighbor_search_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "index_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RecordError {
        /// The error type of this record.
        pub error_type:
            crate::model::nearest_neighbor_search_operation_metadata::record_error::RecordErrorType,

        /// A human-readable message that is shown to the user to help them fix the
        /// error. Note that this message may change from time to time, your code
        /// should check against error_type as the source of truth.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        /// Cloud Storage URI pointing to the original file in user's bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_gcs_uri: std::string::String,

        /// Empty if the embedding id is failed to parse.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub embedding_id: std::string::String,

        /// The original content of this record.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub raw_record: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "index_service")]
    impl RecordError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_type][crate::model::nearest_neighbor_search_operation_metadata::RecordError::error_type].
        pub fn set_error_type<T: std::convert::Into<crate::model::nearest_neighbor_search_operation_metadata::record_error::RecordErrorType>>(mut self, v: T) -> Self{
            self.error_type = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::nearest_neighbor_search_operation_metadata::RecordError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [source_gcs_uri][crate::model::nearest_neighbor_search_operation_metadata::RecordError::source_gcs_uri].
        pub fn set_source_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_gcs_uri = v.into();
            self
        }

        /// Sets the value of [embedding_id][crate::model::nearest_neighbor_search_operation_metadata::RecordError::embedding_id].
        pub fn set_embedding_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.embedding_id = v.into();
            self
        }

        /// Sets the value of [raw_record][crate::model::nearest_neighbor_search_operation_metadata::RecordError::raw_record].
        pub fn set_raw_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.raw_record = v.into();
            self
        }
    }

    #[cfg(feature = "index_service")]
    impl wkt::message::Message for RecordError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.RecordError"
        }
    }

    /// Defines additional types related to [RecordError].
    #[cfg(feature = "index_service")]
    pub mod record_error {
        #[allow(unused_imports)]
        use super::*;

        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "index_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum RecordErrorType {
            /// Default, shall not be used.
            ErrorTypeUnspecified,
            /// The record is empty.
            EmptyLine,
            /// Invalid json format.
            InvalidJsonSyntax,
            /// Invalid csv format.
            InvalidCsvSyntax,
            /// Invalid avro format.
            InvalidAvroSyntax,
            /// The embedding id is not valid.
            InvalidEmbeddingId,
            /// The size of the dense embedding vectors does not match with the
            /// specified dimension.
            EmbeddingSizeMismatch,
            /// The `namespace` field is missing.
            NamespaceMissing,
            /// Generic catch-all error. Only used for validation failure where the
            /// root cause cannot be easily retrieved programmatically.
            ParsingError,
            /// There are multiple restricts with the same `namespace` value.
            DuplicateNamespace,
            /// Numeric restrict has operator specified in datapoint.
            OpInDatapoint,
            /// Numeric restrict has multiple values specified.
            MultipleValues,
            /// Numeric restrict has invalid numeric value specified.
            InvalidNumericValue,
            /// File is not in UTF_8 format.
            InvalidEncoding,
            /// Error parsing sparse dimensions field.
            InvalidSparseDimensions,
            /// Token restrict value is invalid.
            InvalidTokenValue,
            /// Invalid sparse embedding.
            InvalidSparseEmbedding,
            /// Invalid dense embedding.
            InvalidEmbedding,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [RecordErrorType::value] or
            /// [RecordErrorType::name].
            UnknownValue(record_error_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "index_service")]
        pub mod record_error_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "index_service")]
        impl RecordErrorType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::ErrorTypeUnspecified => std::option::Option::Some(0),
                    Self::EmptyLine => std::option::Option::Some(1),
                    Self::InvalidJsonSyntax => std::option::Option::Some(2),
                    Self::InvalidCsvSyntax => std::option::Option::Some(3),
                    Self::InvalidAvroSyntax => std::option::Option::Some(4),
                    Self::InvalidEmbeddingId => std::option::Option::Some(5),
                    Self::EmbeddingSizeMismatch => std::option::Option::Some(6),
                    Self::NamespaceMissing => std::option::Option::Some(7),
                    Self::ParsingError => std::option::Option::Some(8),
                    Self::DuplicateNamespace => std::option::Option::Some(9),
                    Self::OpInDatapoint => std::option::Option::Some(10),
                    Self::MultipleValues => std::option::Option::Some(11),
                    Self::InvalidNumericValue => std::option::Option::Some(12),
                    Self::InvalidEncoding => std::option::Option::Some(13),
                    Self::InvalidSparseDimensions => std::option::Option::Some(14),
                    Self::InvalidTokenValue => std::option::Option::Some(15),
                    Self::InvalidSparseEmbedding => std::option::Option::Some(16),
                    Self::InvalidEmbedding => std::option::Option::Some(17),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::ErrorTypeUnspecified => {
                        std::option::Option::Some("ERROR_TYPE_UNSPECIFIED")
                    }
                    Self::EmptyLine => std::option::Option::Some("EMPTY_LINE"),
                    Self::InvalidJsonSyntax => std::option::Option::Some("INVALID_JSON_SYNTAX"),
                    Self::InvalidCsvSyntax => std::option::Option::Some("INVALID_CSV_SYNTAX"),
                    Self::InvalidAvroSyntax => std::option::Option::Some("INVALID_AVRO_SYNTAX"),
                    Self::InvalidEmbeddingId => std::option::Option::Some("INVALID_EMBEDDING_ID"),
                    Self::EmbeddingSizeMismatch => {
                        std::option::Option::Some("EMBEDDING_SIZE_MISMATCH")
                    }
                    Self::NamespaceMissing => std::option::Option::Some("NAMESPACE_MISSING"),
                    Self::ParsingError => std::option::Option::Some("PARSING_ERROR"),
                    Self::DuplicateNamespace => std::option::Option::Some("DUPLICATE_NAMESPACE"),
                    Self::OpInDatapoint => std::option::Option::Some("OP_IN_DATAPOINT"),
                    Self::MultipleValues => std::option::Option::Some("MULTIPLE_VALUES"),
                    Self::InvalidNumericValue => std::option::Option::Some("INVALID_NUMERIC_VALUE"),
                    Self::InvalidEncoding => std::option::Option::Some("INVALID_ENCODING"),
                    Self::InvalidSparseDimensions => {
                        std::option::Option::Some("INVALID_SPARSE_DIMENSIONS")
                    }
                    Self::InvalidTokenValue => std::option::Option::Some("INVALID_TOKEN_VALUE"),
                    Self::InvalidSparseEmbedding => {
                        std::option::Option::Some("INVALID_SPARSE_EMBEDDING")
                    }
                    Self::InvalidEmbedding => std::option::Option::Some("INVALID_EMBEDDING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "index_service")]
        impl std::default::Default for RecordErrorType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "index_service")]
        impl std::fmt::Display for RecordErrorType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "index_service")]
        impl std::convert::From<i32> for RecordErrorType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::ErrorTypeUnspecified,
                    1 => Self::EmptyLine,
                    2 => Self::InvalidJsonSyntax,
                    3 => Self::InvalidCsvSyntax,
                    4 => Self::InvalidAvroSyntax,
                    5 => Self::InvalidEmbeddingId,
                    6 => Self::EmbeddingSizeMismatch,
                    7 => Self::NamespaceMissing,
                    8 => Self::ParsingError,
                    9 => Self::DuplicateNamespace,
                    10 => Self::OpInDatapoint,
                    11 => Self::MultipleValues,
                    12 => Self::InvalidNumericValue,
                    13 => Self::InvalidEncoding,
                    14 => Self::InvalidSparseDimensions,
                    15 => Self::InvalidTokenValue,
                    16 => Self::InvalidSparseEmbedding,
                    17 => Self::InvalidEmbedding,
                    _ => Self::UnknownValue(record_error_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "index_service")]
        impl std::convert::From<&str> for RecordErrorType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ERROR_TYPE_UNSPECIFIED" => Self::ErrorTypeUnspecified,
                    "EMPTY_LINE" => Self::EmptyLine,
                    "INVALID_JSON_SYNTAX" => Self::InvalidJsonSyntax,
                    "INVALID_CSV_SYNTAX" => Self::InvalidCsvSyntax,
                    "INVALID_AVRO_SYNTAX" => Self::InvalidAvroSyntax,
                    "INVALID_EMBEDDING_ID" => Self::InvalidEmbeddingId,
                    "EMBEDDING_SIZE_MISMATCH" => Self::EmbeddingSizeMismatch,
                    "NAMESPACE_MISSING" => Self::NamespaceMissing,
                    "PARSING_ERROR" => Self::ParsingError,
                    "DUPLICATE_NAMESPACE" => Self::DuplicateNamespace,
                    "OP_IN_DATAPOINT" => Self::OpInDatapoint,
                    "MULTIPLE_VALUES" => Self::MultipleValues,
                    "INVALID_NUMERIC_VALUE" => Self::InvalidNumericValue,
                    "INVALID_ENCODING" => Self::InvalidEncoding,
                    "INVALID_SPARSE_DIMENSIONS" => Self::InvalidSparseDimensions,
                    "INVALID_TOKEN_VALUE" => Self::InvalidTokenValue,
                    "INVALID_SPARSE_EMBEDDING" => Self::InvalidSparseEmbedding,
                    "INVALID_EMBEDDING" => Self::InvalidEmbedding,
                    _ => Self::UnknownValue(record_error_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "index_service")]
        impl serde::ser::Serialize for RecordErrorType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::ErrorTypeUnspecified => serializer.serialize_i32(0),
                    Self::EmptyLine => serializer.serialize_i32(1),
                    Self::InvalidJsonSyntax => serializer.serialize_i32(2),
                    Self::InvalidCsvSyntax => serializer.serialize_i32(3),
                    Self::InvalidAvroSyntax => serializer.serialize_i32(4),
                    Self::InvalidEmbeddingId => serializer.serialize_i32(5),
                    Self::EmbeddingSizeMismatch => serializer.serialize_i32(6),
                    Self::NamespaceMissing => serializer.serialize_i32(7),
                    Self::ParsingError => serializer.serialize_i32(8),
                    Self::DuplicateNamespace => serializer.serialize_i32(9),
                    Self::OpInDatapoint => serializer.serialize_i32(10),
                    Self::MultipleValues => serializer.serialize_i32(11),
                    Self::InvalidNumericValue => serializer.serialize_i32(12),
                    Self::InvalidEncoding => serializer.serialize_i32(13),
                    Self::InvalidSparseDimensions => serializer.serialize_i32(14),
                    Self::InvalidTokenValue => serializer.serialize_i32(15),
                    Self::InvalidSparseEmbedding => serializer.serialize_i32(16),
                    Self::InvalidEmbedding => serializer.serialize_i32(17),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "index_service")]
        impl<'de> serde::de::Deserialize<'de> for RecordErrorType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<RecordErrorType>::new(
                    ".google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.RecordError.RecordErrorType"))
            }
        }
    }

    #[cfg(feature = "index_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ContentValidationStats {
        /// Cloud Storage URI pointing to the original file in user's bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_gcs_uri: std::string::String,

        /// Number of records in this file that were successfully processed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub valid_record_count: i64,

        /// Number of records in this file we skipped due to validate errors.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub invalid_record_count: i64,

        /// The detail information of the partial failures encountered for those
        /// invalid records that couldn't be parsed.
        /// Up to 50 partial errors will be reported.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub partial_errors:
            std::vec::Vec<crate::model::nearest_neighbor_search_operation_metadata::RecordError>,

        /// Number of sparse records in this file that were successfully processed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub valid_sparse_record_count: i64,

        /// Number of sparse records in this file we skipped due to validate errors.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub invalid_sparse_record_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "index_service")]
    impl ContentValidationStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_gcs_uri][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::source_gcs_uri].
        pub fn set_source_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_gcs_uri = v.into();
            self
        }

        /// Sets the value of [valid_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::valid_record_count].
        pub fn set_valid_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.valid_record_count = v.into();
            self
        }

        /// Sets the value of [invalid_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::invalid_record_count].
        pub fn set_invalid_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.invalid_record_count = v.into();
            self
        }

        /// Sets the value of [valid_sparse_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::valid_sparse_record_count].
        pub fn set_valid_sparse_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.valid_sparse_record_count = v.into();
            self
        }

        /// Sets the value of [invalid_sparse_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::invalid_sparse_record_count].
        pub fn set_invalid_sparse_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.invalid_sparse_record_count = v.into();
            self
        }

        /// Sets the value of [partial_errors][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::partial_errors].
        pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::nearest_neighbor_search_operation_metadata::RecordError,
                >,
        {
            use std::iter::Iterator;
            self.partial_errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "index_service")]
    impl wkt::message::Message for ContentValidationStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.ContentValidationStats"
        }
    }
}

/// The storage details for Avro input content.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvroSource {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_source: std::option::Option<crate::model::GcsSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl AvroSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_source][crate::model::AvroSource::gcs_source].
    pub fn set_gcs_source<T: std::convert::Into<std::option::Option<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_source = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for AvroSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AvroSource"
    }
}

/// The storage details for CSV input content.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsvSource {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_source: std::option::Option<crate::model::GcsSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl CsvSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_source][crate::model::CsvSource::gcs_source].
    pub fn set_gcs_source<T: std::convert::Into<std::option::Option<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_source = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for CsvSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CsvSource"
    }
}

/// The Google Cloud Storage location for the input content.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "featurestore_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
    feature = "vertex_rag_data_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsSource {
    /// Required. Google Cloud Storage URI(-s) to the input file(s). May contain
    /// wildcards. For more information on wildcards, see
    /// <https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uris: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "featurestore_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
    feature = "vertex_rag_data_service",
))]
impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uris][crate::model::GcsSource::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "featurestore_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "prediction_service",
    feature = "vertex_rag_data_service",
))]
impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GcsSource"
    }
}

/// The Google Cloud Storage location where the output is to be written to.
#[cfg(any(
    feature = "dataset_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "vertex_rag_data_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. Google Cloud Storage URI to output directory. If the uri doesn't
    /// end with
    /// '/', a '/' will be automatically appended. The directory is created if it
    /// doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "vertex_rag_data_service",
))]
impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::GcsDestination::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "model_service",
    feature = "pipeline_service",
    feature = "vertex_rag_data_service",
))]
impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GcsDestination"
    }
}

/// The BigQuery location for the input content.
#[cfg(any(
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "job_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQuerySource {
    /// Required. BigQuery URI to a table, up to 2000 characters long.
    /// Accepted forms:
    ///
    /// * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "job_service",
))]
impl BigQuerySource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uri][crate::model::BigQuerySource::input_uri].
    pub fn set_input_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_uri = v.into();
        self
    }
}

#[cfg(any(
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "job_service",
))]
impl wkt::message::Message for BigQuerySource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BigQuerySource"
    }
}

/// The BigQuery location for the output content.
#[cfg(any(
    feature = "endpoint_service",
    feature = "featurestore_service",
    feature = "job_service",
    feature = "pipeline_service",
    feature = "vertex_rag_data_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDestination {
    /// Required. BigQuery URI to a project or table, up to 2000 characters long.
    ///
    /// When only the project is specified, the Dataset and Table is created.
    /// When the full table reference is specified, the Dataset must exist and
    /// table must not exist.
    ///
    /// Accepted forms:
    ///
    /// * BigQuery path. For example:
    ///   `bq://projectId` or `bq://projectId.bqDatasetId` or
    ///   `bq://projectId.bqDatasetId.bqTableId`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "endpoint_service",
    feature = "featurestore_service",
    feature = "job_service",
    feature = "pipeline_service",
    feature = "vertex_rag_data_service",
))]
impl BigQueryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::BigQueryDestination::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

#[cfg(any(
    feature = "endpoint_service",
    feature = "featurestore_service",
    feature = "job_service",
    feature = "pipeline_service",
    feature = "vertex_rag_data_service",
))]
impl wkt::message::Message for BigQueryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BigQueryDestination"
    }
}

/// The storage details for CSV output content.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsvDestination {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_destination: std::option::Option<crate::model::GcsDestination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl CsvDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::CsvDestination::gcs_destination].
    pub fn set_gcs_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_destination = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for CsvDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CsvDestination"
    }
}

/// The storage details for TFRecord output content.
#[cfg(feature = "featurestore_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TFRecordDestination {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_destination: std::option::Option<crate::model::GcsDestination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "featurestore_service")]
impl TFRecordDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::TFRecordDestination::gcs_destination].
    pub fn set_gcs_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_destination = v.into();
        self
    }
}

#[cfg(feature = "featurestore_service")]
impl wkt::message::Message for TFRecordDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TFRecordDestination"
    }
}

/// The Container Registry location for the container image.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerRegistryDestination {
    /// Required. Container Registry URI of a container image.
    /// Only Google Container Registry and Artifact Registry are supported now.
    /// Accepted forms:
    ///
    /// * Google Container Registry path. For example:
    ///   `gcr.io/projectId/imageName:tag`.
    ///
    /// * Artifact Registry path. For example:
    ///   `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`.
    ///
    ///
    /// If a tag is not specified, "latest" will be used as the default tag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ContainerRegistryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::ContainerRegistryDestination::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ContainerRegistryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ContainerRegistryDestination"
    }
}

/// The Google Drive location for the input content.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleDriveSource {
    /// Required. Google Drive resource IDs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_ids: std::vec::Vec<crate::model::google_drive_source::ResourceId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl GoogleDriveSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_ids][crate::model::GoogleDriveSource::resource_ids].
    pub fn set_resource_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::google_drive_source::ResourceId>,
    {
        use std::iter::Iterator;
        self.resource_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for GoogleDriveSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleDriveSource"
    }
}

/// Defines additional types related to [GoogleDriveSource].
#[cfg(feature = "vertex_rag_data_service")]
pub mod google_drive_source {
    #[allow(unused_imports)]
    use super::*;

    /// The type and ID of the Google Drive resource.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceId {
        /// Required. The type of the Google Drive resource.
        pub resource_type: crate::model::google_drive_source::resource_id::ResourceType,

        /// Required. The ID of the Google Drive resource.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub resource_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl ResourceId {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_type][crate::model::google_drive_source::ResourceId::resource_type].
        pub fn set_resource_type<
            T: std::convert::Into<crate::model::google_drive_source::resource_id::ResourceType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// Sets the value of [resource_id][crate::model::google_drive_source::ResourceId::resource_id].
        pub fn set_resource_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource_id = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for ResourceId {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GoogleDriveSource.ResourceId"
        }
    }

    /// Defines additional types related to [ResourceId].
    #[cfg(feature = "vertex_rag_data_service")]
    pub mod resource_id {
        #[allow(unused_imports)]
        use super::*;

        /// The type of the Google Drive resource.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "vertex_rag_data_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ResourceType {
            /// Unspecified resource type.
            Unspecified,
            /// File resource type.
            File,
            /// Folder resource type.
            Folder,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ResourceType::value] or
            /// [ResourceType::name].
            UnknownValue(resource_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "vertex_rag_data_service")]
        pub mod resource_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl ResourceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::File => std::option::Option::Some(1),
                    Self::Folder => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("RESOURCE_TYPE_UNSPECIFIED"),
                    Self::File => std::option::Option::Some("RESOURCE_TYPE_FILE"),
                    Self::Folder => std::option::Option::Some("RESOURCE_TYPE_FOLDER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl std::default::Default for ResourceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl std::fmt::Display for ResourceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl std::convert::From<i32> for ResourceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::File,
                    2 => Self::Folder,
                    _ => Self::UnknownValue(resource_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl std::convert::From<&str> for ResourceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "RESOURCE_TYPE_FILE" => Self::File,
                    "RESOURCE_TYPE_FOLDER" => Self::Folder,
                    _ => Self::UnknownValue(resource_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl serde::ser::Serialize for ResourceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::File => serializer.serialize_i32(1),
                    Self::Folder => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl<'de> serde::de::Deserialize<'de> for ResourceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceType>::new(
                    ".google.cloud.aiplatform.v1.GoogleDriveSource.ResourceId.ResourceType",
                ))
            }
        }
    }
}

/// The input content is encapsulated and uploaded in the request.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectUploadSource {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl DirectUploadSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for DirectUploadSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectUploadSource"
    }
}

/// The Slack source for the ImportRagFilesRequest.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SlackSource {
    /// Required. The Slack channels.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub channels: std::vec::Vec<crate::model::slack_source::SlackChannels>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl SlackSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channels][crate::model::SlackSource::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slack_source::SlackChannels>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for SlackSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource"
    }
}

/// Defines additional types related to [SlackSource].
#[cfg(feature = "vertex_rag_data_service")]
pub mod slack_source {
    #[allow(unused_imports)]
    use super::*;

    /// SlackChannels contains the Slack channels and corresponding access token.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlackChannels {
        /// Required. The Slack channel IDs.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub channels: std::vec::Vec<crate::model::slack_source::slack_channels::SlackChannel>,

        /// Required. The SecretManager secret version resource name (e.g.
        /// projects/{project}/secrets/{secret}/versions/{version}) storing the
        /// Slack channel access token that has access to the slack channel IDs.
        /// See: <https://api.slack.com/tutorials/tracks/getting-a-token>.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub api_key_config: std::option::Option<crate::model::api_auth::ApiKeyConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl SlackChannels {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [api_key_config][crate::model::slack_source::SlackChannels::api_key_config].
        pub fn set_api_key_config<
            T: std::convert::Into<std::option::Option<crate::model::api_auth::ApiKeyConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.api_key_config = v.into();
            self
        }

        /// Sets the value of [channels][crate::model::slack_source::SlackChannels::channels].
        pub fn set_channels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::slack_source::slack_channels::SlackChannel>,
        {
            use std::iter::Iterator;
            self.channels = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for SlackChannels {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource.SlackChannels"
        }
    }

    /// Defines additional types related to [SlackChannels].
    #[cfg(feature = "vertex_rag_data_service")]
    pub mod slack_channels {
        #[allow(unused_imports)]
        use super::*;

        /// SlackChannel contains the Slack channel ID and the time range to import.
        #[cfg(feature = "vertex_rag_data_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SlackChannel {
            /// Required. The Slack channel ID.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub channel_id: std::string::String,

            /// Optional. The starting timestamp for messages to import.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub start_time: std::option::Option<wkt::Timestamp>,

            /// Optional. The ending timestamp for messages to import.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub end_time: std::option::Option<wkt::Timestamp>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl SlackChannel {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [channel_id][crate::model::slack_source::slack_channels::SlackChannel::channel_id].
            pub fn set_channel_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.channel_id = v.into();
                self
            }

            /// Sets the value of [start_time][crate::model::slack_source::slack_channels::SlackChannel::start_time].
            pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.start_time = v.into();
                self
            }

            /// Sets the value of [end_time][crate::model::slack_source::slack_channels::SlackChannel::end_time].
            pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.end_time = v.into();
                self
            }
        }

        #[cfg(feature = "vertex_rag_data_service")]
        impl wkt::message::Message for SlackChannel {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource.SlackChannels.SlackChannel"
            }
        }
    }
}

/// The Jira source for the ImportRagFilesRequest.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JiraSource {
    /// Required. The Jira queries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jira_queries: std::vec::Vec<crate::model::jira_source::JiraQueries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl JiraSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jira_queries][crate::model::JiraSource::jira_queries].
    pub fn set_jira_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::jira_source::JiraQueries>,
    {
        use std::iter::Iterator;
        self.jira_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for JiraSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.JiraSource"
    }
}

/// Defines additional types related to [JiraSource].
#[cfg(feature = "vertex_rag_data_service")]
pub mod jira_source {
    #[allow(unused_imports)]
    use super::*;

    /// JiraQueries contains the Jira queries and corresponding authentication.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct JiraQueries {
        /// A list of Jira projects to import in their entirety.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub projects: std::vec::Vec<std::string::String>,

        /// A list of custom Jira queries to import. For information about JQL (Jira
        /// Query Language), see
        /// <https://support.atlassian.com/jira-service-management-cloud/docs/use-advanced-search-with-jira-query-language-jql/>
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub custom_queries: std::vec::Vec<std::string::String>,

        /// Required. The Jira email address.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub email: std::string::String,

        /// Required. The Jira server URI.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub server_uri: std::string::String,

        /// Required. The SecretManager secret version resource name (e.g.
        /// projects/{project}/secrets/{secret}/versions/{version}) storing the
        /// Jira API key. See [Manage API tokens for your Atlassian
        /// account](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub api_key_config: std::option::Option<crate::model::api_auth::ApiKeyConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl JiraQueries {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [email][crate::model::jira_source::JiraQueries::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }

        /// Sets the value of [server_uri][crate::model::jira_source::JiraQueries::server_uri].
        pub fn set_server_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.server_uri = v.into();
            self
        }

        /// Sets the value of [api_key_config][crate::model::jira_source::JiraQueries::api_key_config].
        pub fn set_api_key_config<
            T: std::convert::Into<std::option::Option<crate::model::api_auth::ApiKeyConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.api_key_config = v.into();
            self
        }

        /// Sets the value of [projects][crate::model::jira_source::JiraQueries::projects].
        pub fn set_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.projects = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [custom_queries][crate::model::jira_source::JiraQueries::custom_queries].
        pub fn set_custom_queries<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.custom_queries = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for JiraQueries {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.JiraSource.JiraQueries"
        }
    }
}

/// The SharePointSources to pass to ImportRagFiles.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SharePointSources {
    /// The SharePoint sources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub share_point_sources: std::vec::Vec<crate::model::share_point_sources::SharePointSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl SharePointSources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [share_point_sources][crate::model::SharePointSources::share_point_sources].
    pub fn set_share_point_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::share_point_sources::SharePointSource>,
    {
        use std::iter::Iterator;
        self.share_point_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for SharePointSources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SharePointSources"
    }
}

/// Defines additional types related to [SharePointSources].
#[cfg(feature = "vertex_rag_data_service")]
pub mod share_point_sources {
    #[allow(unused_imports)]
    use super::*;

    /// An individual SharePointSource.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SharePointSource {
        /// The Application ID for the app registered in Microsoft Azure Portal.
        /// The application must also be configured with MS Graph permissions
        /// "Files.ReadAll", "Sites.ReadAll" and BrowserSiteLists.Read.All.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub client_id: std::string::String,

        /// The application secret for the app registered in Azure.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub client_secret: std::option::Option<crate::model::api_auth::ApiKeyConfig>,

        /// Unique identifier of the Azure Active Directory Instance.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tenant_id: std::string::String,

        /// The name of the SharePoint site to download from. This can be the site
        /// name or the site id.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub sharepoint_site_name: std::string::String,

        /// Output only. The SharePoint file id. Output only.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub file_id: std::string::String,

        /// The SharePoint folder source. If not provided, uses "root".
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub folder_source: std::option::Option<
            crate::model::share_point_sources::share_point_source::FolderSource,
        >,

        /// The SharePoint drive source.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub drive_source:
            std::option::Option<crate::model::share_point_sources::share_point_source::DriveSource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl SharePointSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::share_point_sources::SharePointSource::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::share_point_sources::SharePointSource::client_secret].
        pub fn set_client_secret<
            T: std::convert::Into<std::option::Option<crate::model::api_auth::ApiKeyConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.client_secret = v.into();
            self
        }

        /// Sets the value of [tenant_id][crate::model::share_point_sources::SharePointSource::tenant_id].
        pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tenant_id = v.into();
            self
        }

        /// Sets the value of [sharepoint_site_name][crate::model::share_point_sources::SharePointSource::sharepoint_site_name].
        pub fn set_sharepoint_site_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sharepoint_site_name = v.into();
            self
        }

        /// Sets the value of [file_id][crate::model::share_point_sources::SharePointSource::file_id].
        pub fn set_file_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.file_id = v.into();
            self
        }

        /// Sets the value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source].
        ///
        /// Note that all the setters affecting `folder_source` are mutually
        /// exclusive.
        pub fn set_folder_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::share_point_sources::share_point_source::FolderSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.folder_source = v.into();
            self
        }

        /// The value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// if it holds a `SharepointFolderPath`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sharepoint_folder_path(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.folder_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderPath(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// if it holds a `SharepointFolderId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sharepoint_folder_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.folder_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderId(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// to hold a `SharepointFolderPath`.
        ///
        /// Note that all the setters affecting `folder_source` are
        /// mutually exclusive.
        pub fn set_sharepoint_folder_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.folder_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderPath(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// to hold a `SharepointFolderId`.
        ///
        /// Note that all the setters affecting `folder_source` are
        /// mutually exclusive.
        pub fn set_sharepoint_folder_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.folder_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderId(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source].
        ///
        /// Note that all the setters affecting `drive_source` are mutually
        /// exclusive.
        pub fn set_drive_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::share_point_sources::share_point_source::DriveSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.drive_source = v.into();
            self
        }

        /// The value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// if it holds a `DriveName`, `None` if the field is not set or
        /// holds a different branch.
        pub fn drive_name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.drive_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::DriveSource::DriveName(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// if it holds a `DriveId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn drive_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.drive_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::DriveSource::DriveId(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// to hold a `DriveName`.
        ///
        /// Note that all the setters affecting `drive_source` are
        /// mutually exclusive.
        pub fn set_drive_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.drive_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::DriveSource::DriveName(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// to hold a `DriveId`.
        ///
        /// Note that all the setters affecting `drive_source` are
        /// mutually exclusive.
        pub fn set_drive_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.drive_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::DriveSource::DriveId(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for SharePointSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SharePointSources.SharePointSource"
        }
    }

    /// Defines additional types related to [SharePointSource].
    #[cfg(feature = "vertex_rag_data_service")]
    pub mod share_point_source {
        #[allow(unused_imports)]
        use super::*;

        /// The SharePoint folder source. If not provided, uses "root".
        #[cfg(feature = "vertex_rag_data_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum FolderSource {
            /// The path of the SharePoint folder to download from.
            SharepointFolderPath(std::string::String),
            /// The ID of the SharePoint folder to download from.
            SharepointFolderId(std::string::String),
        }

        /// The SharePoint drive source.
        #[cfg(feature = "vertex_rag_data_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DriveSource {
            /// The name of the drive to download from.
            DriveName(std::string::String),
            /// The ID of the drive to download from.
            DriveId(std::string::String),
        }
    }
}

/// Request message for
/// [JobService.CreateCustomJob][google.cloud.aiplatform.v1.JobService.CreateCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateCustomJob]: crate::client::JobService::create_custom_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomJobRequest {
    /// Required. The resource name of the Location to create the CustomJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The CustomJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_job: std::option::Option<crate::model::CustomJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CreateCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_job][crate::model::CreateCustomJobRequest::custom_job].
    pub fn set_custom_job<T: std::convert::Into<std::option::Option<crate::model::CustomJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_job = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CreateCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateCustomJobRequest"
    }
}

/// Request message for
/// [JobService.GetCustomJob][google.cloud.aiplatform.v1.JobService.GetCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetCustomJob]: crate::client::JobService::get_custom_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomJobRequest {
    /// Required. The name of the CustomJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetCustomJobRequest"
    }
}

/// Request message for
/// [JobService.ListCustomJobs][google.cloud.aiplatform.v1.JobService.ListCustomJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListCustomJobs]: crate::client::JobService::list_custom_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomJobsRequest {
    /// Required. The resource name of the Location to list the CustomJobs from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListCustomJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListCustomJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListCustomJobs][google.cloud.aiplatform.v1.JobService.ListCustomJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListCustomJobs]: crate::client::JobService::list_custom_jobs
    /// [google.cloud.aiplatform.v1.ListCustomJobsResponse.next_page_token]: crate::model::ListCustomJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListCustomJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListCustomJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListCustomJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCustomJobsRequest"
    }
}

/// Response message for
/// [JobService.ListCustomJobs][google.cloud.aiplatform.v1.JobService.ListCustomJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListCustomJobs]: crate::client::JobService::list_custom_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomJobsResponse {
    /// List of CustomJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_jobs: std::vec::Vec<crate::model::CustomJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListCustomJobsRequest.page_token][google.cloud.aiplatform.v1.ListCustomJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListCustomJobsRequest.page_token]: crate::model::ListCustomJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListCustomJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [custom_jobs][crate::model::ListCustomJobsResponse::custom_jobs].
    pub fn set_custom_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomJob>,
    {
        use std::iter::Iterator;
        self.custom_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListCustomJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCustomJobsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomJobsResponse {
    type PageItem = crate::model::CustomJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.DeleteCustomJob][google.cloud.aiplatform.v1.JobService.DeleteCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteCustomJob]: crate::client::JobService::delete_custom_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomJobRequest {
    /// Required. The name of the CustomJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DeleteCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DeleteCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteCustomJobRequest"
    }
}

/// Request message for
/// [JobService.CancelCustomJob][google.cloud.aiplatform.v1.JobService.CancelCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelCustomJob]: crate::client::JobService::cancel_custom_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelCustomJobRequest {
    /// Required. The name of the CustomJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CancelCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCustomJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CancelCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelCustomJobRequest"
    }
}

/// Request message for
/// [JobService.CreateDataLabelingJob][google.cloud.aiplatform.v1.JobService.CreateDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateDataLabelingJob]: crate::client::JobService::create_data_labeling_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataLabelingJobRequest {
    /// Required. The parent of the DataLabelingJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DataLabelingJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_labeling_job: std::option::Option<crate::model::DataLabelingJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CreateDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataLabelingJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_labeling_job][crate::model::CreateDataLabelingJobRequest::data_labeling_job].
    pub fn set_data_labeling_job<
        T: std::convert::Into<std::option::Option<crate::model::DataLabelingJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_labeling_job = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CreateDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.GetDataLabelingJob][google.cloud.aiplatform.v1.JobService.GetDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetDataLabelingJob]: crate::client::JobService::get_data_labeling_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataLabelingJobRequest {
    /// Required. The name of the DataLabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataLabelingJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.ListDataLabelingJobs][google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs]: crate::client::JobService::list_data_labeling_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataLabelingJobsRequest {
    /// Required. The parent of the DataLabelingJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read. FieldMask represents a set of
    /// symbolic field paths. For example, the mask can be `paths: "name"`. The
    /// "name" here is a field in DataLabelingJob.
    /// If this field is not set, all fields of the DataLabelingJob are returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order by
    /// default.
    /// Use `desc` after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListDataLabelingJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataLabelingJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataLabelingJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataLabelingJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataLabelingJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDataLabelingJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataLabelingJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListDataLabelingJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataLabelingJobsRequest"
    }
}

/// Response message for
/// [JobService.ListDataLabelingJobs][google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs]: crate::client::JobService::list_data_labeling_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataLabelingJobsResponse {
    /// A list of DataLabelingJobs that matches the specified filter in the
    /// request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_labeling_jobs: std::vec::Vec<crate::model::DataLabelingJob>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListDataLabelingJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDataLabelingJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [data_labeling_jobs][crate::model::ListDataLabelingJobsResponse::data_labeling_jobs].
    pub fn set_data_labeling_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataLabelingJob>,
    {
        use std::iter::Iterator;
        self.data_labeling_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListDataLabelingJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataLabelingJobsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataLabelingJobsResponse {
    type PageItem = crate::model::DataLabelingJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_labeling_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.DeleteDataLabelingJob][google.cloud.aiplatform.v1.JobService.DeleteDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteDataLabelingJob]: crate::client::JobService::delete_data_labeling_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataLabelingJobRequest {
    /// Required. The name of the DataLabelingJob to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DeleteDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataLabelingJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DeleteDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.CancelDataLabelingJob][google.cloud.aiplatform.v1.JobService.CancelDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelDataLabelingJob]: crate::client::JobService::cancel_data_labeling_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelDataLabelingJobRequest {
    /// Required. The name of the DataLabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CancelDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDataLabelingJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CancelDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.CreateHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.CreateHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateHyperparameterTuningJob]: crate::client::JobService::create_hyperparameter_tuning_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateHyperparameterTuningJobRequest {
    /// Required. The resource name of the Location to create the
    /// HyperparameterTuningJob in. Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The HyperparameterTuningJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hyperparameter_tuning_job: std::option::Option<crate::model::HyperparameterTuningJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CreateHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateHyperparameterTuningJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [hyperparameter_tuning_job][crate::model::CreateHyperparameterTuningJobRequest::hyperparameter_tuning_job].
    pub fn set_hyperparameter_tuning_job<
        T: std::convert::Into<std::option::Option<crate::model::HyperparameterTuningJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyperparameter_tuning_job = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CreateHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.GetHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.GetHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetHyperparameterTuningJob]: crate::client::JobService::get_hyperparameter_tuning_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetHyperparameterTuningJobRequest {
    /// Required. The name of the HyperparameterTuningJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetHyperparameterTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.ListHyperparameterTuningJobs][google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]: crate::client::JobService::list_hyperparameter_tuning_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHyperparameterTuningJobsRequest {
    /// Required. The resource name of the Location to list the
    /// HyperparameterTuningJobs from. Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListHyperparameterTuningJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListHyperparameterTuningJobs][google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]: crate::client::JobService::list_hyperparameter_tuning_jobs
    /// [google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse.next_page_token]: crate::model::ListHyperparameterTuningJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListHyperparameterTuningJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHyperparameterTuningJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListHyperparameterTuningJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHyperparameterTuningJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHyperparameterTuningJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListHyperparameterTuningJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListHyperparameterTuningJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest"
    }
}

/// Response message for
/// [JobService.ListHyperparameterTuningJobs][google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]: crate::client::JobService::list_hyperparameter_tuning_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHyperparameterTuningJobsResponse {
    /// List of HyperparameterTuningJobs in the requested page.
    /// [HyperparameterTuningJob.trials][google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]
    /// of the jobs will be not be returned.
    ///
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]: crate::model::HyperparameterTuningJob::trials
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hyperparameter_tuning_jobs: std::vec::Vec<crate::model::HyperparameterTuningJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListHyperparameterTuningJobsRequest.page_token][google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest.page_token]: crate::model::ListHyperparameterTuningJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListHyperparameterTuningJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListHyperparameterTuningJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [hyperparameter_tuning_jobs][crate::model::ListHyperparameterTuningJobsResponse::hyperparameter_tuning_jobs].
    pub fn set_hyperparameter_tuning_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HyperparameterTuningJob>,
    {
        use std::iter::Iterator;
        self.hyperparameter_tuning_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListHyperparameterTuningJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListHyperparameterTuningJobsResponse {
    type PageItem = crate::model::HyperparameterTuningJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hyperparameter_tuning_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.DeleteHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.DeleteHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteHyperparameterTuningJob]: crate::client::JobService::delete_hyperparameter_tuning_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteHyperparameterTuningJobRequest {
    /// Required. The name of the HyperparameterTuningJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DeleteHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteHyperparameterTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DeleteHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.CancelHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.CancelHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelHyperparameterTuningJob]: crate::client::JobService::cancel_hyperparameter_tuning_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelHyperparameterTuningJobRequest {
    /// Required. The name of the HyperparameterTuningJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CancelHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelHyperparameterTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CancelHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.CreateNasJob][google.cloud.aiplatform.v1.JobService.CreateNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateNasJob]: crate::client::JobService::create_nas_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNasJobRequest {
    /// Required. The resource name of the Location to create the NasJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NasJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nas_job: std::option::Option<crate::model::NasJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CreateNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNasJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [nas_job][crate::model::CreateNasJobRequest::nas_job].
    pub fn set_nas_job<T: std::convert::Into<std::option::Option<crate::model::NasJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.nas_job = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CreateNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNasJobRequest"
    }
}

/// Request message for
/// [JobService.GetNasJob][google.cloud.aiplatform.v1.JobService.GetNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetNasJob]: crate::client::JobService::get_nas_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNasJobRequest {
    /// Required. The name of the NasJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNasJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNasJobRequest"
    }
}

/// Request message for
/// [JobService.ListNasJobs][google.cloud.aiplatform.v1.JobService.ListNasJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListNasJobs]: crate::client::JobService::list_nas_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasJobsRequest {
    /// Required. The resource name of the Location to list the NasJobs
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListNasJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListNasJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListNasJobs][google.cloud.aiplatform.v1.JobService.ListNasJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListNasJobs]: crate::client::JobService::list_nas_jobs
    /// [google.cloud.aiplatform.v1.ListNasJobsResponse.next_page_token]: crate::model::ListNasJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListNasJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNasJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNasJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNasJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNasJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListNasJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListNasJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasJobsRequest"
    }
}

/// Response message for
/// [JobService.ListNasJobs][google.cloud.aiplatform.v1.JobService.ListNasJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListNasJobs]: crate::client::JobService::list_nas_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasJobsResponse {
    /// List of NasJobs in the requested page.
    /// [NasJob.nas_job_output][google.cloud.aiplatform.v1.NasJob.nas_job_output]
    /// of the jobs will not be returned.
    ///
    /// [google.cloud.aiplatform.v1.NasJob.nas_job_output]: crate::model::NasJob::nas_job_output
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nas_jobs: std::vec::Vec<crate::model::NasJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListNasJobsRequest.page_token][google.cloud.aiplatform.v1.ListNasJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNasJobsRequest.page_token]: crate::model::ListNasJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListNasJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNasJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [nas_jobs][crate::model::ListNasJobsResponse::nas_jobs].
    pub fn set_nas_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NasJob>,
    {
        use std::iter::Iterator;
        self.nas_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListNasJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasJobsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNasJobsResponse {
    type PageItem = crate::model::NasJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nas_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.DeleteNasJob][google.cloud.aiplatform.v1.JobService.DeleteNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteNasJob]: crate::client::JobService::delete_nas_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNasJobRequest {
    /// Required. The name of the NasJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DeleteNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNasJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DeleteNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNasJobRequest"
    }
}

/// Request message for
/// [JobService.CancelNasJob][google.cloud.aiplatform.v1.JobService.CancelNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelNasJob]: crate::client::JobService::cancel_nas_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelNasJobRequest {
    /// Required. The name of the NasJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CancelNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelNasJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CancelNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelNasJobRequest"
    }
}

/// Request message for
/// [JobService.GetNasTrialDetail][google.cloud.aiplatform.v1.JobService.GetNasTrialDetail].
///
/// [google.cloud.aiplatform.v1.JobService.GetNasTrialDetail]: crate::client::JobService::get_nas_trial_detail
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNasTrialDetailRequest {
    /// Required. The name of the NasTrialDetail resource.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetNasTrialDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNasTrialDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetNasTrialDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNasTrialDetailRequest"
    }
}

/// Request message for
/// [JobService.ListNasTrialDetails][google.cloud.aiplatform.v1.JobService.ListNasTrialDetails].
///
/// [google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]: crate::client::JobService::list_nas_trial_details
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasTrialDetailsRequest {
    /// Required. The name of the NasJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListNasTrialDetailsResponse.next_page_token][google.cloud.aiplatform.v1.ListNasTrialDetailsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListNasTrialDetails][google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]: crate::client::JobService::list_nas_trial_details
    /// [google.cloud.aiplatform.v1.ListNasTrialDetailsResponse.next_page_token]: crate::model::ListNasTrialDetailsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListNasTrialDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNasTrialDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNasTrialDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNasTrialDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListNasTrialDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasTrialDetailsRequest"
    }
}

/// Response message for
/// [JobService.ListNasTrialDetails][google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]
///
/// [google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]: crate::client::JobService::list_nas_trial_details
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasTrialDetailsResponse {
    /// List of top NasTrials in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nas_trial_details: std::vec::Vec<crate::model::NasTrialDetail>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListNasTrialDetailsRequest.page_token][google.cloud.aiplatform.v1.ListNasTrialDetailsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNasTrialDetailsRequest.page_token]: crate::model::ListNasTrialDetailsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListNasTrialDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNasTrialDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [nas_trial_details][crate::model::ListNasTrialDetailsResponse::nas_trial_details].
    pub fn set_nas_trial_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NasTrialDetail>,
    {
        use std::iter::Iterator;
        self.nas_trial_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListNasTrialDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasTrialDetailsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNasTrialDetailsResponse {
    type PageItem = crate::model::NasTrialDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nas_trial_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.CreateBatchPredictionJob][google.cloud.aiplatform.v1.JobService.CreateBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateBatchPredictionJob]: crate::client::JobService::create_batch_prediction_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBatchPredictionJobRequest {
    /// Required. The resource name of the Location to create the
    /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The BatchPredictionJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub batch_prediction_job: std::option::Option<crate::model::BatchPredictionJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CreateBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBatchPredictionJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [batch_prediction_job][crate::model::CreateBatchPredictionJobRequest::batch_prediction_job].
    pub fn set_batch_prediction_job<
        T: std::convert::Into<std::option::Option<crate::model::BatchPredictionJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.batch_prediction_job = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CreateBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.GetBatchPredictionJob][google.cloud.aiplatform.v1.JobService.GetBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetBatchPredictionJob]: crate::client::JobService::get_batch_prediction_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBatchPredictionJobRequest {
    /// Required. The name of the BatchPredictionJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBatchPredictionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.ListBatchPredictionJobs][google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]: crate::client::JobService::list_batch_prediction_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBatchPredictionJobsRequest {
    /// Required. The resource name of the Location to list the BatchPredictionJobs
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `model_display_name` supports `=`, `!=` comparisons.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListBatchPredictionJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListBatchPredictionJobs][google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]: crate::client::JobService::list_batch_prediction_jobs
    /// [google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse.next_page_token]: crate::model::ListBatchPredictionJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListBatchPredictionJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBatchPredictionJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBatchPredictionJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBatchPredictionJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBatchPredictionJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListBatchPredictionJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListBatchPredictionJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest"
    }
}

/// Response message for
/// [JobService.ListBatchPredictionJobs][google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]: crate::client::JobService::list_batch_prediction_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBatchPredictionJobsResponse {
    /// List of BatchPredictionJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub batch_prediction_jobs: std::vec::Vec<crate::model::BatchPredictionJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListBatchPredictionJobsRequest.page_token][google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest.page_token]: crate::model::ListBatchPredictionJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListBatchPredictionJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBatchPredictionJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [batch_prediction_jobs][crate::model::ListBatchPredictionJobsResponse::batch_prediction_jobs].
    pub fn set_batch_prediction_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BatchPredictionJob>,
    {
        use std::iter::Iterator;
        self.batch_prediction_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListBatchPredictionJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBatchPredictionJobsResponse {
    type PageItem = crate::model::BatchPredictionJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.batch_prediction_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.DeleteBatchPredictionJob][google.cloud.aiplatform.v1.JobService.DeleteBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteBatchPredictionJob]: crate::client::JobService::delete_batch_prediction_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBatchPredictionJobRequest {
    /// Required. The name of the BatchPredictionJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DeleteBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBatchPredictionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DeleteBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.CancelBatchPredictionJob][google.cloud.aiplatform.v1.JobService.CancelBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelBatchPredictionJob]: crate::client::JobService::cancel_batch_prediction_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelBatchPredictionJobRequest {
    /// Required. The name of the BatchPredictionJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CancelBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelBatchPredictionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CancelBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.CreateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob]: crate::client::JobService::create_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateModelDeploymentMonitoringJobRequest {
    /// Required. The parent of the ModelDeploymentMonitoringJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ModelDeploymentMonitoringJob to create
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_deployment_monitoring_job:
        std::option::Option<crate::model::ModelDeploymentMonitoringJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl CreateModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateModelDeploymentMonitoringJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::CreateModelDeploymentMonitoringJobRequest::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<
        T: std::convert::Into<std::option::Option<crate::model::ModelDeploymentMonitoringJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for CreateModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies].
///
/// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesRequest {

    /// Required. ModelDeploymentMonitoring Job resource name.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_deployment_monitoring_job: std::string::String,

    /// Required. The DeployedModel ID of the
    /// [ModelDeploymentMonitoringObjectiveConfig.deployed_model_id].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// The feature display name. If specified, only return the stats belonging to
    /// this feature. Format:
    /// [ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name][google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name],
    /// example: "user_destination".
    ///
    /// [google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name]: crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::feature_display_name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_display_name: std::string::String,

    /// Required. Objectives of the stats to retrieve.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub objectives: std::vec::Vec<crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective>,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token received from a previous
    /// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The earliest timestamp of stats being generated.
    /// If not set, indicates fetching stats till the earliest possible one.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp of stats being generated.
    /// If not set, indicates feching stats till the latest possible one.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl SearchModelDeploymentMonitoringStatsAnomaliesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [feature_display_name][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::feature_display_name].
    pub fn set_feature_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_display_name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [objectives][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::objectives].
    pub fn set_objectives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective>
    {
        use std::iter::Iterator;
        self.objectives = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for SearchModelDeploymentMonitoringStatsAnomaliesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest"
    }
}

/// Defines additional types related to [SearchModelDeploymentMonitoringStatsAnomaliesRequest].
#[cfg(feature = "job_service")]
pub mod search_model_deployment_monitoring_stats_anomalies_request {
    #[allow(unused_imports)]
    use super::*;

    /// Stats requested for specific objective.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StatsAnomaliesObjective {
        #[serde(rename = "type")]
        pub r#type: crate::model::ModelDeploymentMonitoringObjectiveType,

        /// If set, all attribution scores between
        /// [SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time][google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time]
        /// and
        /// [SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time][google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time]
        /// are fetched, and page token doesn't take effect in this case. Only used
        /// to retrieve attribution score for the top Features which has the highest
        /// attribution score in the latest monitoring run.
        ///
        /// [google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time]: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::end_time
        /// [google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time]: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::start_time
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub top_feature_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl StatsAnomaliesObjective {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::ModelDeploymentMonitoringObjectiveType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [top_feature_count][crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective::top_feature_count].
        pub fn set_top_feature_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.top_feature_count = v.into();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for StatsAnomaliesObjective {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.StatsAnomaliesObjective"
        }
    }
}

/// Response message for
/// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies].
///
/// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    /// Stats retrieved for requested objectives.
    /// There are at most 1000
    /// [ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats][google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats]
    /// in the response.
    ///
    /// [google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats]: crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::prediction_stats
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub monitoring_stats: std::vec::Vec<crate::model::ModelMonitoringStatsAnomalies>,

    /// The page token that can be used by the next
    /// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [monitoring_stats][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse::monitoring_stats].
    pub fn set_monitoring_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelMonitoringStatsAnomalies>,
    {
        use std::iter::Iterator;
        self.monitoring_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse
    for SearchModelDeploymentMonitoringStatsAnomaliesResponse
{
    type PageItem = crate::model::ModelMonitoringStatsAnomalies;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.monitoring_stats
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.GetModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.GetModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetModelDeploymentMonitoringJob]: crate::client::JobService::get_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the ModelDeploymentMonitoringJob.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl GetModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for GetModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.ListModelDeploymentMonitoringJobs][google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs]: crate::client::JobService::list_model_deployment_monitoring_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelDeploymentMonitoringJobsRequest {
    /// Required. The parent of the ModelDeploymentMonitoringJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListModelDeploymentMonitoringJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelDeploymentMonitoringJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelDeploymentMonitoringJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelDeploymentMonitoringJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelDeploymentMonitoringJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelDeploymentMonitoringJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListModelDeploymentMonitoringJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsRequest"
    }
}

/// Response message for
/// [JobService.ListModelDeploymentMonitoringJobs][google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs]: crate::client::JobService::list_model_deployment_monitoring_jobs
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelDeploymentMonitoringJobsResponse {
    /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
    /// in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_deployment_monitoring_jobs: std::vec::Vec<crate::model::ModelDeploymentMonitoringJob>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ListModelDeploymentMonitoringJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelDeploymentMonitoringJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_jobs][crate::model::ListModelDeploymentMonitoringJobsResponse::model_deployment_monitoring_jobs].
    pub fn set_model_deployment_monitoring_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelDeploymentMonitoringJob>,
    {
        use std::iter::Iterator;
        self.model_deployment_monitoring_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ListModelDeploymentMonitoringJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsResponse"
    }
}

#[cfg(feature = "job_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelDeploymentMonitoringJobsResponse {
    type PageItem = crate::model::ModelDeploymentMonitoringJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.model_deployment_monitoring_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [JobService.UpdateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob]: crate::client::JobService::update_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelDeploymentMonitoringJobRequest {
    /// Required. The model monitoring configuration which replaces the resource on
    /// the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_deployment_monitoring_job:
        std::option::Option<crate::model::ModelDeploymentMonitoringJob>,

    /// Required. The update mask is used to specify the fields to be overwritten
    /// in the ModelDeploymentMonitoringJob resource by the update. The fields
    /// specified in the update_mask are relative to the resource, not the full
    /// request. A field will be overwritten if it is in the mask. If the user does
    /// not provide a mask then only the non-empty fields present in the request
    /// will be overwritten. Set the update_mask to `*` to override all fields. For
    /// the objective config, the user can either provide the update mask for
    /// model_deployment_monitoring_objective_configs or any combination of its
    /// nested fields, such as:
    /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
    ///
    /// Updatable fields:
    ///
    /// * `display_name`
    /// * `model_deployment_monitoring_schedule_config`
    /// * `model_monitoring_alert_config`
    /// * `logging_sampling_strategy`
    /// * `labels`
    /// * `log_ttl`
    /// * `enable_monitoring_pipeline_logs`
    ///   .  and
    /// * `model_deployment_monitoring_objective_configs`
    ///   .  or
    /// * `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
    /// * `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
    /// * `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl UpdateModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::UpdateModelDeploymentMonitoringJobRequest::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<
        T: std::convert::Into<std::option::Option<crate::model::ModelDeploymentMonitoringJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateModelDeploymentMonitoringJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for UpdateModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.DeleteModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.DeleteModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteModelDeploymentMonitoringJob]: crate::client::JobService::delete_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the model monitoring job to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl DeleteModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for DeleteModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.PauseModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.PauseModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.PauseModelDeploymentMonitoringJob]: crate::client::JobService::pause_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the ModelDeploymentMonitoringJob to pause.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl PauseModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for PauseModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PauseModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.ResumeModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.ResumeModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.ResumeModelDeploymentMonitoringJob]: crate::client::JobService::resume_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the ModelDeploymentMonitoringJob to resume.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ResumeModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ResumeModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResumeModelDeploymentMonitoringJobRequest"
    }
}

/// Runtime operation information for
/// [JobService.UpdateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob]: crate::client::JobService::update_model_deployment_monitoring_job
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelDeploymentMonitoringJobOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl UpdateModelDeploymentMonitoringJobOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateModelDeploymentMonitoringJobOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for UpdateModelDeploymentMonitoringJobOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobOperationMetadata"
    }
}

/// A subgraph of the overall lineage graph. Event edges connect Artifact and
/// Execution nodes.
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LineageSubgraph {
    /// The Artifact nodes in the subgraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub artifacts: std::vec::Vec<crate::model::Artifact>,

    /// The Execution nodes in the subgraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<crate::model::Execution>,

    /// The Event edges between Artifacts and Executions in the subgraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl LineageSubgraph {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifacts][crate::model::LineageSubgraph::artifacts].
    pub fn set_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>,
    {
        use std::iter::Iterator;
        self.artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [executions][crate::model::LineageSubgraph::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Execution>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [events][crate::model::LineageSubgraph::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for LineageSubgraph {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LineageSubgraph"
    }
}

/// Request message for ComputeTokens RPC call.
#[cfg(feature = "llm_utility_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeTokensRequest {
    /// Required. The name of the Endpoint requested to get lists of tokens and
    /// token ids.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. The instances that are the input to token computing API call.
    /// Schema is identical to the prediction schema of the text model, even for
    /// the non-text models, like chat models, or Codey models.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// Optional. The name of the publisher model requested to serve the
    /// prediction. Format:
    /// projects/{project}/locations/{location}/publishers/*/models/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. Input content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "llm_utility_service")]
impl ComputeTokensRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::ComputeTokensRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [model][crate::model::ComputeTokensRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ComputeTokensRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [contents][crate::model::ComputeTokensRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "llm_utility_service")]
impl wkt::message::Message for ComputeTokensRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ComputeTokensRequest"
    }
}

/// Tokens info with a list of tokens and the corresponding list of token ids.
#[cfg(feature = "llm_utility_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TokensInfo {
    /// A list of tokens from the input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub tokens: std::vec::Vec<::bytes::Bytes>,

    /// A list of token ids from the input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub token_ids: std::vec::Vec<i64>,

    /// Optional. Optional fields for the role from the corresponding Content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "llm_utility_service")]
impl TokensInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::TokensInfo::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [tokens][crate::model::TokensInfo::tokens].
    pub fn set_tokens<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.tokens = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [token_ids][crate::model::TokensInfo::token_ids].
    pub fn set_token_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.token_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "llm_utility_service")]
impl wkt::message::Message for TokensInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TokensInfo"
    }
}

/// Response message for ComputeTokens RPC call.
#[cfg(feature = "llm_utility_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeTokensResponse {
    /// Lists of tokens info from the input. A ComputeTokensRequest could have
    /// multiple instances with a prompt in each instance. We also need to return
    /// lists of tokens info for the request with multiple instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tokens_info: std::vec::Vec<crate::model::TokensInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "llm_utility_service")]
impl ComputeTokensResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tokens_info][crate::model::ComputeTokensResponse::tokens_info].
    pub fn set_tokens_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TokensInfo>,
    {
        use std::iter::Iterator;
        self.tokens_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "llm_utility_service")]
impl wkt::message::Message for ComputeTokensResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ComputeTokensResponse"
    }
}

/// Specification of a single machine.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineSpec {
    /// Immutable. The type of the machine.
    ///
    /// See the [list of machine types supported for
    /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
    ///
    /// See the [list of machine types supported for custom
    /// training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
    ///
    /// For [DeployedModel][google.cloud.aiplatform.v1.DeployedModel] this field is
    /// optional, and the default value is `n1-standard-2`. For
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob] or as
    /// part of [WorkerPoolSpec][google.cloud.aiplatform.v1.WorkerPoolSpec] this
    /// field is required.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
    /// [google.cloud.aiplatform.v1.WorkerPoolSpec]: crate::model::WorkerPoolSpec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Immutable. The type of accelerator(s) that may be attached to the machine
    /// as per
    /// [accelerator_count][google.cloud.aiplatform.v1.MachineSpec.accelerator_count].
    ///
    /// [google.cloud.aiplatform.v1.MachineSpec.accelerator_count]: crate::model::MachineSpec::accelerator_count
    pub accelerator_type: crate::model::AcceleratorType,

    /// The number of accelerators to attach to the machine.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub accelerator_count: i32,

    /// Immutable. The topology of the TPUs. Corresponds to the TPU topologies
    /// available from GKE. (Example: tpu_topology: "2x2x1").
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tpu_topology: std::string::String,

    /// Optional. Immutable. Configuration controlling how this resource pool
    /// consumes reservation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl MachineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::MachineSpec::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::MachineSpec::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<crate::model::AcceleratorType>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [accelerator_count][crate::model::MachineSpec::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }

    /// Sets the value of [tpu_topology][crate::model::MachineSpec::tpu_topology].
    pub fn set_tpu_topology<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tpu_topology = v.into();
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::MachineSpec::reservation_affinity].
    pub fn set_reservation_affinity<
        T: std::convert::Into<std::option::Option<crate::model::ReservationAffinity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reservation_affinity = v.into();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl wkt::message::Message for MachineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MachineSpec"
    }
}

/// A description of resources that are dedicated to a DeployedModel, and
/// that need a higher degree of manual configuration.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DedicatedResources {
    /// Required. Immutable. The specification of a single machine used by the
    /// prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Required. Immutable. The minimum number of machine replicas this
    /// DeployedModel will be always deployed on. This value must be greater than
    /// or equal to 1.
    ///
    /// If traffic against the DeployedModel increases, it may dynamically be
    /// deployed onto more replicas, and as traffic decreases, some of these extra
    /// replicas may be freed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_replica_count: i32,

    /// Immutable. The maximum number of replicas this DeployedModel may be
    /// deployed on when the traffic against it increases. If the requested value
    /// is too large, the deployment will error, but if deployment succeeds then
    /// the ability to scale the model to that many replicas is guaranteed (barring
    /// service outages). If traffic against the DeployedModel increases beyond
    /// what its replicas at maximum may handle, a portion of the traffic will be
    /// dropped. If this value is not provided, will use
    /// [min_replica_count][google.cloud.aiplatform.v1.DedicatedResources.min_replica_count]
    /// as the default value.
    ///
    /// The value of this field impacts the charge against Vertex CPU and GPU
    /// quotas. Specifically, you will be charged for (max_replica_count *
    /// number of cores in the selected machine type) and (max_replica_count *
    /// number of GPUs per replica in the selected machine type).
    ///
    /// [google.cloud.aiplatform.v1.DedicatedResources.min_replica_count]: crate::model::DedicatedResources::min_replica_count
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_replica_count: i32,

    /// Optional. Number of required available replicas for the deployment to
    /// succeed. This field is only needed when partial model deployment/mutation
    /// is desired. If set, the model deploy/mutate operation will succeed once
    /// available_replica_count reaches required_replica_count, and the rest of
    /// the replicas will be retried. If not set, the default
    /// required_replica_count will be min_replica_count.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub required_replica_count: i32,

    /// Immutable. The metric specifications that overrides a resource
    /// utilization metric (CPU utilization, accelerator's duty cycle, and so on)
    /// target value (default to 60 if not set). At most one entry is allowed per
    /// metric.
    ///
    /// If
    /// [machine_spec.accelerator_count][google.cloud.aiplatform.v1.MachineSpec.accelerator_count]
    /// is above 0, the autoscaling will be based on both CPU utilization and
    /// accelerator's duty cycle metrics and scale up when either metrics exceeds
    /// its target value while scale down if both metrics are under their target
    /// value. The default target value is 60 for both metrics.
    ///
    /// If
    /// [machine_spec.accelerator_count][google.cloud.aiplatform.v1.MachineSpec.accelerator_count]
    /// is 0, the autoscaling will be based on CPU utilization metric only with
    /// default target value 60 if not explicitly set.
    ///
    /// For example, in the case of Online Prediction, if you want to override
    /// target CPU utilization to 80, you should set
    /// [autoscaling_metric_specs.metric_name][google.cloud.aiplatform.v1.AutoscalingMetricSpec.metric_name]
    /// to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
    /// [autoscaling_metric_specs.target][google.cloud.aiplatform.v1.AutoscalingMetricSpec.target]
    /// to `80`.
    ///
    /// [google.cloud.aiplatform.v1.AutoscalingMetricSpec.metric_name]: crate::model::AutoscalingMetricSpec::metric_name
    /// [google.cloud.aiplatform.v1.AutoscalingMetricSpec.target]: crate::model::AutoscalingMetricSpec::target
    /// [google.cloud.aiplatform.v1.MachineSpec.accelerator_count]: crate::model::MachineSpec::accelerator_count
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autoscaling_metric_specs: std::vec::Vec<crate::model::AutoscalingMetricSpec>,

    /// Optional. If true, schedule the deployment workload on [spot
    /// VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub spot: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
impl DedicatedResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_spec][crate::model::DedicatedResources::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [min_replica_count][crate::model::DedicatedResources::min_replica_count].
    pub fn set_min_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_replica_count = v.into();
        self
    }

    /// Sets the value of [max_replica_count][crate::model::DedicatedResources::max_replica_count].
    pub fn set_max_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_replica_count = v.into();
        self
    }

    /// Sets the value of [required_replica_count][crate::model::DedicatedResources::required_replica_count].
    pub fn set_required_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.required_replica_count = v.into();
        self
    }

    /// Sets the value of [spot][crate::model::DedicatedResources::spot].
    pub fn set_spot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.spot = v.into();
        self
    }

    /// Sets the value of [autoscaling_metric_specs][crate::model::DedicatedResources::autoscaling_metric_specs].
    pub fn set_autoscaling_metric_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutoscalingMetricSpec>,
    {
        use std::iter::Iterator;
        self.autoscaling_metric_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
impl wkt::message::Message for DedicatedResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DedicatedResources"
    }
}

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
/// Each Model supporting these resources documents its specific guidelines.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomaticResources {
    /// Immutable. The minimum number of replicas this DeployedModel will be always
    /// deployed on. If traffic against it increases, it may dynamically be
    /// deployed onto more replicas up to
    /// [max_replica_count][google.cloud.aiplatform.v1.AutomaticResources.max_replica_count],
    /// and as traffic decreases, some of these extra replicas may be freed. If the
    /// requested value is too large, the deployment will error.
    ///
    /// [google.cloud.aiplatform.v1.AutomaticResources.max_replica_count]: crate::model::AutomaticResources::max_replica_count
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_replica_count: i32,

    /// Immutable. The maximum number of replicas this DeployedModel may be
    /// deployed on when the traffic against it increases. If the requested value
    /// is too large, the deployment will error, but if deployment succeeds then
    /// the ability to scale the model to that many replicas is guaranteed (barring
    /// service outages). If traffic against the DeployedModel increases beyond
    /// what its replicas at maximum may handle, a portion of the traffic will be
    /// dropped. If this value is not provided, a no upper bound for scaling under
    /// heavy traffic will be assume, though Vertex AI may be unable to scale
    /// beyond certain replica number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_replica_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
impl AutomaticResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_replica_count][crate::model::AutomaticResources::min_replica_count].
    pub fn set_min_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_replica_count = v.into();
        self
    }

    /// Sets the value of [max_replica_count][crate::model::AutomaticResources::max_replica_count].
    pub fn set_max_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_replica_count = v.into();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
impl wkt::message::Message for AutomaticResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AutomaticResources"
    }
}

/// A description of resources that are used for performing batch operations, are
/// dedicated to a Model, and need manual configuration.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDedicatedResources {
    /// Required. Immutable. The specification of a single machine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Immutable. The number of machine replicas used at the start of the batch
    /// operation. If not set, Vertex AI decides starting number, not greater than
    /// [max_replica_count][google.cloud.aiplatform.v1.BatchDedicatedResources.max_replica_count]
    ///
    /// [google.cloud.aiplatform.v1.BatchDedicatedResources.max_replica_count]: crate::model::BatchDedicatedResources::max_replica_count
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub starting_replica_count: i32,

    /// Immutable. The maximum number of machine replicas the batch operation may
    /// be scaled to. The default value is 10.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_replica_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl BatchDedicatedResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_spec][crate::model::BatchDedicatedResources::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [starting_replica_count][crate::model::BatchDedicatedResources::starting_replica_count].
    pub fn set_starting_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.starting_replica_count = v.into();
        self
    }

    /// Sets the value of [max_replica_count][crate::model::BatchDedicatedResources::max_replica_count].
    pub fn set_max_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_replica_count = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for BatchDedicatedResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDedicatedResources"
    }
}

/// Statistics information about resource consumption.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourcesConsumed {
    /// Output only. The number of replica hours used. Note that many replicas may
    /// run in parallel, and additionally any given work may be queued for some
    /// time. Therefore this value is not strictly related to wall time.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub replica_hours: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ResourcesConsumed {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replica_hours][crate::model::ResourcesConsumed::replica_hours].
    pub fn set_replica_hours<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.replica_hours = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ResourcesConsumed {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourcesConsumed"
    }
}

/// Represents the spec of disk options.
#[cfg(any(feature = "job_service", feature = "persistent_resource_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskSpec {
    /// Type of the boot disk (default is "pd-ssd").
    /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive) or
    /// "pd-standard" (Persistent Disk Hard Disk Drive).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub boot_disk_type: std::string::String,

    /// Size in GB of the boot disk (default is 100GB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub boot_disk_size_gb: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "job_service", feature = "persistent_resource_service",))]
impl DiskSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [boot_disk_type][crate::model::DiskSpec::boot_disk_type].
    pub fn set_boot_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.boot_disk_type = v.into();
        self
    }

    /// Sets the value of [boot_disk_size_gb][crate::model::DiskSpec::boot_disk_size_gb].
    pub fn set_boot_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.boot_disk_size_gb = v.into();
        self
    }
}

#[cfg(any(feature = "job_service", feature = "persistent_resource_service",))]
impl wkt::message::Message for DiskSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DiskSpec"
    }
}

/// Represents the spec of [persistent
/// disk][<https://cloud.google.com/compute/docs/disks/persistent-disks>] options.
#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersistentDiskSpec {
    /// Type of the disk (default is "pd-standard").
    /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive)
    /// "pd-standard" (Persistent Disk Hard Disk Drive)
    /// "pd-balanced" (Balanced Persistent Disk)
    /// "pd-extreme" (Extreme Persistent Disk)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_type: std::string::String,

    /// Size in GB of the disk (default is 100GB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_size_gb: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl PersistentDiskSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_type][crate::model::PersistentDiskSpec::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::PersistentDiskSpec::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl wkt::message::Message for PersistentDiskSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PersistentDiskSpec"
    }
}

/// Represents a mount configuration for Network File System (NFS) to mount.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsMount {
    /// Required. IP address of the NFS server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server: std::string::String,

    /// Required. Source path exported from NFS server.
    /// Has to start with '/', and combined with the ip address, it indicates
    /// the source mount path in the form of `server:path`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Required. Destination mount path. The NFS will be mounted for the user
    /// under /mnt/nfs/<mount_point>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mount_point: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl NfsMount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [server][crate::model::NfsMount::server].
    pub fn set_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server = v.into();
        self
    }

    /// Sets the value of [path][crate::model::NfsMount::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [mount_point][crate::model::NfsMount::mount_point].
    pub fn set_mount_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_point = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for NfsMount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NfsMount"
    }
}

/// The metric specification that defines the target resource utilization
/// (CPU utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingMetricSpec {
    /// Required. The resource metric name.
    /// Supported metrics:
    ///
    /// * For Online Prediction:
    /// * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
    /// * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric_name: std::string::String,

    /// The target resource utilization in percentage (1% - 100%) for the given
    /// metric; once the real usage deviates from the target by a certain
    /// percentage, the machine replicas change. The default value is 60
    /// (representing 60%) if not provided.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub target: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
impl AutoscalingMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::AutoscalingMetricSpec::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::AutoscalingMetricSpec::target].
    pub fn set_target<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "model_garden_service",
))]
impl wkt::message::Message for AutoscalingMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AutoscalingMetricSpec"
    }
}

/// A set of Shielded Instance options.
/// See [Images using supported Shielded VM
/// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShieldedVmConfig {
    /// Defines whether the instance has [Secure
    /// Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot)
    /// enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_secure_boot: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ShieldedVmConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedVmConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_secure_boot = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ShieldedVmConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ShieldedVmConfig"
    }
}

/// Manual batch tuning parameters.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManualBatchTuningParameters {
    /// Immutable. The number of the records (e.g. instances) of the operation
    /// given in each batch to a machine replica. Machine type, and size of a
    /// single record should be considered when setting this parameter, higher
    /// value speeds up the batch operation's execution, but too high value will
    /// result in a whole batch not fitting in a machine's memory, and the whole
    /// operation will fail.
    /// The default value is 64.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub batch_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ManualBatchTuningParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [batch_size][crate::model::ManualBatchTuningParameters::batch_size].
    pub fn set_batch_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.batch_size = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ManualBatchTuningParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ManualBatchTuningParameters"
    }
}

/// The request message for
/// [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
///
/// [google.cloud.aiplatform.v1.MatchService.FindNeighbors]: crate::client::MatchService::find_neighbors
#[cfg(feature = "match_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FindNeighborsRequest {
    /// Required. The name of the index endpoint.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// The ID of the DeployedIndex that will serve the request. This request is
    /// sent to a specific IndexEndpoint, as per the IndexEndpoint.network. That
    /// IndexEndpoint also has IndexEndpoint.deployed_indexes, and each such index
    /// has a DeployedIndex.id field.
    /// The value of the field below must equal one of the DeployedIndex.id
    /// fields of the IndexEndpoint that is being called for this request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    /// The list of queries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub queries: std::vec::Vec<crate::model::find_neighbors_request::Query>,

    /// If set to true, the full datapoints (including all vector values and
    /// restricts) of the nearest neighbors are returned.
    /// Note that returning full datapoint will significantly increase the
    /// latency and cost of the query.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub return_full_datapoint: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "match_service")]
impl FindNeighborsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::FindNeighborsRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::FindNeighborsRequest::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }

    /// Sets the value of [return_full_datapoint][crate::model::FindNeighborsRequest::return_full_datapoint].
    pub fn set_return_full_datapoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_full_datapoint = v.into();
        self
    }

    /// Sets the value of [queries][crate::model::FindNeighborsRequest::queries].
    pub fn set_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::find_neighbors_request::Query>,
    {
        use std::iter::Iterator;
        self.queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "match_service")]
impl wkt::message::Message for FindNeighborsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest"
    }
}

/// Defines additional types related to [FindNeighborsRequest].
#[cfg(feature = "match_service")]
pub mod find_neighbors_request {
    #[allow(unused_imports)]
    use super::*;

    /// A query to find a number of the nearest neighbors (most similar vectors)
    /// of a vector.
    #[cfg(feature = "match_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Query {
        /// Required. The datapoint/vector whose nearest neighbors should be searched
        /// for.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub datapoint: std::option::Option<crate::model::IndexDatapoint>,

        /// The number of nearest neighbors to be retrieved from database for each
        /// query. If not set, will use the default from the service configuration
        /// (<https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config>).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub neighbor_count: i32,

        /// Crowding is a constraint on a neighbor list produced by nearest neighbor
        /// search requiring that no more than some value k' of the k neighbors
        /// returned have the same value of crowding_attribute.
        /// It's used for improving result diversity.
        /// This field is the maximum number of matches with the same crowding tag.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub per_crowding_attribute_neighbor_count: i32,

        /// The number of neighbors to find via approximate search before
        /// exact reordering is performed. If not set, the default value from scam
        /// config is used; if set, this value must be > 0.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub approximate_neighbor_count: i32,

        /// The fraction of the number of leaves to search, set at query time allows
        /// user to tune search performance. This value increase result in both
        /// search accuracy and latency increase. The value should be between 0.0
        /// and 1.0. If not set or set to 0.0, query uses the default value specified
        /// in
        /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub fraction_leaf_nodes_to_search_override: f64,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub ranking: std::option::Option<crate::model::find_neighbors_request::query::Ranking>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "match_service")]
    impl Query {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [datapoint][crate::model::find_neighbors_request::Query::datapoint].
        pub fn set_datapoint<
            T: std::convert::Into<std::option::Option<crate::model::IndexDatapoint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.datapoint = v.into();
            self
        }

        /// Sets the value of [neighbor_count][crate::model::find_neighbors_request::Query::neighbor_count].
        pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.neighbor_count = v.into();
            self
        }

        /// Sets the value of [per_crowding_attribute_neighbor_count][crate::model::find_neighbors_request::Query::per_crowding_attribute_neighbor_count].
        pub fn set_per_crowding_attribute_neighbor_count<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.per_crowding_attribute_neighbor_count = v.into();
            self
        }

        /// Sets the value of [approximate_neighbor_count][crate::model::find_neighbors_request::Query::approximate_neighbor_count].
        pub fn set_approximate_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.approximate_neighbor_count = v.into();
            self
        }

        /// Sets the value of [fraction_leaf_nodes_to_search_override][crate::model::find_neighbors_request::Query::fraction_leaf_nodes_to_search_override].
        pub fn set_fraction_leaf_nodes_to_search_override<T: std::convert::Into<f64>>(
            mut self,
            v: T,
        ) -> Self {
            self.fraction_leaf_nodes_to_search_override = v.into();
            self
        }

        /// Sets the value of [ranking][crate::model::find_neighbors_request::Query::ranking].
        ///
        /// Note that all the setters affecting `ranking` are mutually
        /// exclusive.
        pub fn set_ranking<
            T: std::convert::Into<
                    std::option::Option<crate::model::find_neighbors_request::query::Ranking>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking = v.into();
            self
        }

        /// The value of [ranking][crate::model::find_neighbors_request::Query::ranking]
        /// if it holds a `Rrf`, `None` if the field is not set or
        /// holds a different branch.
        pub fn rrf(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::find_neighbors_request::query::Rrf>>
        {
            #[allow(unreachable_patterns)]
            self.ranking.as_ref().and_then(|v| match v {
                crate::model::find_neighbors_request::query::Ranking::Rrf(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [ranking][crate::model::find_neighbors_request::Query::ranking]
        /// to hold a `Rrf`.
        ///
        /// Note that all the setters affecting `ranking` are
        /// mutually exclusive.
        pub fn set_rrf<
            T: std::convert::Into<std::boxed::Box<crate::model::find_neighbors_request::query::Rrf>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking = std::option::Option::Some(
                crate::model::find_neighbors_request::query::Ranking::Rrf(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "match_service")]
    impl wkt::message::Message for Query {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest.Query"
        }
    }

    /// Defines additional types related to [Query].
    #[cfg(feature = "match_service")]
    pub mod query {
        #[allow(unused_imports)]
        use super::*;

        /// Parameters for RRF algorithm that combines search results.
        #[cfg(feature = "match_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Rrf {
            /// Required. Users can provide an alpha value to give more weight to dense
            /// vs sparse results. For example, if the alpha is 0, we only return
            /// sparse and if the alpha is 1, we only return dense.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub alpha: f32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "match_service")]
        impl Rrf {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [alpha][crate::model::find_neighbors_request::query::Rrf::alpha].
            pub fn set_alpha<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.alpha = v.into();
                self
            }
        }

        #[cfg(feature = "match_service")]
        impl wkt::message::Message for Rrf {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest.Query.RRF"
            }
        }

        #[cfg(feature = "match_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Ranking {
            /// Optional. Represents RRF algorithm that combines search results.
            Rrf(std::boxed::Box<crate::model::find_neighbors_request::query::Rrf>),
        }
    }
}

/// The response message for
/// [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
///
/// [google.cloud.aiplatform.v1.MatchService.FindNeighbors]: crate::client::MatchService::find_neighbors
#[cfg(feature = "match_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FindNeighborsResponse {
    /// The nearest neighbors of the query datapoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nearest_neighbors: std::vec::Vec<crate::model::find_neighbors_response::NearestNeighbors>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "match_service")]
impl FindNeighborsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nearest_neighbors][crate::model::FindNeighborsResponse::nearest_neighbors].
    pub fn set_nearest_neighbors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::find_neighbors_response::NearestNeighbors>,
    {
        use std::iter::Iterator;
        self.nearest_neighbors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "match_service")]
impl wkt::message::Message for FindNeighborsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse"
    }
}

/// Defines additional types related to [FindNeighborsResponse].
#[cfg(feature = "match_service")]
pub mod find_neighbors_response {
    #[allow(unused_imports)]
    use super::*;

    /// A neighbor of the query vector.
    #[cfg(feature = "match_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Neighbor {
        /// The datapoint of the neighbor.
        /// Note that full datapoints are returned only when "return_full_datapoint"
        /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
        /// fields are populated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub datapoint: std::option::Option<crate::model::IndexDatapoint>,

        /// The distance between the neighbor and the dense embedding query.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub distance: f64,

        /// The distance between the neighbor and the query sparse_embedding.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub sparse_distance: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "match_service")]
    impl Neighbor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [datapoint][crate::model::find_neighbors_response::Neighbor::datapoint].
        pub fn set_datapoint<
            T: std::convert::Into<std::option::Option<crate::model::IndexDatapoint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.datapoint = v.into();
            self
        }

        /// Sets the value of [distance][crate::model::find_neighbors_response::Neighbor::distance].
        pub fn set_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.distance = v.into();
            self
        }

        /// Sets the value of [sparse_distance][crate::model::find_neighbors_response::Neighbor::sparse_distance].
        pub fn set_sparse_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.sparse_distance = v.into();
            self
        }
    }

    #[cfg(feature = "match_service")]
    impl wkt::message::Message for Neighbor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse.Neighbor"
        }
    }

    /// Nearest neighbors for one query.
    #[cfg(feature = "match_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NearestNeighbors {
        /// The ID of the query datapoint.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// All its neighbors.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub neighbors: std::vec::Vec<crate::model::find_neighbors_response::Neighbor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "match_service")]
    impl NearestNeighbors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::find_neighbors_response::NearestNeighbors::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [neighbors][crate::model::find_neighbors_response::NearestNeighbors::neighbors].
        pub fn set_neighbors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::find_neighbors_response::Neighbor>,
        {
            use std::iter::Iterator;
            self.neighbors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "match_service")]
    impl wkt::message::Message for NearestNeighbors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse.NearestNeighbors"
        }
    }
}

/// The request message for
/// [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
///
/// [google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints]: crate::client::MatchService::read_index_datapoints
#[cfg(feature = "match_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadIndexDatapointsRequest {
    /// Required. The name of the index endpoint.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// The ID of the DeployedIndex that will serve the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    /// IDs of the datapoints to be searched for.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "match_service")]
impl ReadIndexDatapointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::ReadIndexDatapointsRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::ReadIndexDatapointsRequest::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }

    /// Sets the value of [ids][crate::model::ReadIndexDatapointsRequest::ids].
    pub fn set_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "match_service")]
impl wkt::message::Message for ReadIndexDatapointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadIndexDatapointsRequest"
    }
}

/// The response message for
/// [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
///
/// [google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints]: crate::client::MatchService::read_index_datapoints
#[cfg(feature = "match_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadIndexDatapointsResponse {
    /// The result list of datapoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datapoints: std::vec::Vec<crate::model::IndexDatapoint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "match_service")]
impl ReadIndexDatapointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datapoints][crate::model::ReadIndexDatapointsResponse::datapoints].
    pub fn set_datapoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexDatapoint>,
    {
        use std::iter::Iterator;
        self.datapoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "match_service")]
impl wkt::message::Message for ReadIndexDatapointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadIndexDatapointsResponse"
    }
}

/// Instance of a general MetadataSchema.
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataSchema {
    /// Output only. The resource name of the MetadataSchema.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The version of the MetadataSchema. The version's format must match
    /// the following regular expression: `^[0-9]+[.][0-9]+[.][0-9]+$`, which would
    /// allow to order/compare different versions. Example: 1.0.0, 1.0.1, etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Required. The raw YAML string representation of the MetadataSchema. The
    /// combination of [MetadataSchema.version] and the schema name given by
    /// `title` in [MetadataSchema.schema] must be unique within a MetadataStore.
    ///
    /// The schema is defined as an OpenAPI 3.0.2
    /// [MetadataSchema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// The type of the MetadataSchema. This is a property that identifies which
    /// metadata types will use the MetadataSchema.
    pub schema_type: crate::model::metadata_schema::MetadataSchemaType,

    /// Output only. Timestamp when this MetadataSchema was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Description of the Metadata Schema
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl MetadataSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MetadataSchema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::MetadataSchema::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::MetadataSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::MetadataSchema::schema_type].
    pub fn set_schema_type<
        T: std::convert::Into<crate::model::metadata_schema::MetadataSchemaType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MetadataSchema::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MetadataSchema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for MetadataSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetadataSchema"
    }
}

/// Defines additional types related to [MetadataSchema].
#[cfg(feature = "metadata_service")]
pub mod metadata_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the type of the MetadataSchema.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "metadata_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetadataSchemaType {
        /// Unspecified type for the MetadataSchema.
        Unspecified,
        /// A type indicating that the MetadataSchema will be used by Artifacts.
        ArtifactType,
        /// A typee indicating that the MetadataSchema will be used by Executions.
        ExecutionType,
        /// A state indicating that the MetadataSchema will be used by Contexts.
        ContextType,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetadataSchemaType::value] or
        /// [MetadataSchemaType::name].
        UnknownValue(metadata_schema_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "metadata_service")]
    pub mod metadata_schema_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "metadata_service")]
    impl MetadataSchemaType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ArtifactType => std::option::Option::Some(1),
                Self::ExecutionType => std::option::Option::Some(2),
                Self::ContextType => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METADATA_SCHEMA_TYPE_UNSPECIFIED"),
                Self::ArtifactType => std::option::Option::Some("ARTIFACT_TYPE"),
                Self::ExecutionType => std::option::Option::Some("EXECUTION_TYPE"),
                Self::ContextType => std::option::Option::Some("CONTEXT_TYPE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::default::Default for MetadataSchemaType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::fmt::Display for MetadataSchemaType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::convert::From<i32> for MetadataSchemaType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ArtifactType,
                2 => Self::ExecutionType,
                3 => Self::ContextType,
                _ => Self::UnknownValue(metadata_schema_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl std::convert::From<&str> for MetadataSchemaType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METADATA_SCHEMA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ARTIFACT_TYPE" => Self::ArtifactType,
                "EXECUTION_TYPE" => Self::ExecutionType,
                "CONTEXT_TYPE" => Self::ContextType,
                _ => Self::UnknownValue(metadata_schema_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl serde::ser::Serialize for MetadataSchemaType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ArtifactType => serializer.serialize_i32(1),
                Self::ExecutionType => serializer.serialize_i32(2),
                Self::ContextType => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "metadata_service")]
    impl<'de> serde::de::Deserialize<'de> for MetadataSchemaType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetadataSchemaType>::new(
                ".google.cloud.aiplatform.v1.MetadataSchema.MetadataSchemaType",
            ))
        }
    }
}

/// Request message for
/// [MetadataService.CreateMetadataStore][google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore]: crate::client::MetadataService::create_metadata_store
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataStoreRequest {
    /// Required. The resource name of the Location where the MetadataStore should
    /// be created.
    /// Format: `projects/{project}/locations/{location}/`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The MetadataStore to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_store: std::option::Option<crate::model::MetadataStore>,

    /// The {metadatastore} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    /// If not provided, the MetadataStore's ID will be a UUID generated by the
    /// service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all MetadataStores in the parent Location.
    /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
    /// if the caller can't view the preexisting MetadataStore.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_store_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl CreateMetadataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMetadataStoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metadata_store][crate::model::CreateMetadataStoreRequest::metadata_store].
    pub fn set_metadata_store<
        T: std::convert::Into<std::option::Option<crate::model::MetadataStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store = v.into();
        self
    }

    /// Sets the value of [metadata_store_id][crate::model::CreateMetadataStoreRequest::metadata_store_id].
    pub fn set_metadata_store_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store_id = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for CreateMetadataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataStoreRequest"
    }
}

/// Details of operations that perform
/// [MetadataService.CreateMetadataStore][google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore]: crate::client::MetadataService::create_metadata_store
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataStoreOperationMetadata {
    /// Operation metadata for creating a MetadataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl CreateMetadataStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateMetadataStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for CreateMetadataStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataStoreOperationMetadata"
    }
}

/// Request message for
/// [MetadataService.GetMetadataStore][google.cloud.aiplatform.v1.MetadataService.GetMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetMetadataStore]: crate::client::MetadataService::get_metadata_store
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetadataStoreRequest {
    /// Required. The resource name of the MetadataStore to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl GetMetadataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetadataStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for GetMetadataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetMetadataStoreRequest"
    }
}

/// Request message for
/// [MetadataService.ListMetadataStores][google.cloud.aiplatform.v1.MetadataService.ListMetadataStores].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]: crate::client::MetadataService::list_metadata_stores
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataStoresRequest {
    /// Required. The Location whose MetadataStores should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Metadata Stores to return. The service may return
    /// fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListMetadataStores][google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]: crate::client::MetadataService::list_metadata_stores
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListMetadataStoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMetadataStoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetadataStoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetadataStoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListMetadataStoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataStoresRequest"
    }
}

/// Response message for
/// [MetadataService.ListMetadataStores][google.cloud.aiplatform.v1.MetadataService.ListMetadataStores].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]: crate::client::MetadataService::list_metadata_stores
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataStoresResponse {
    /// The MetadataStores found for the Location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metadata_stores: std::vec::Vec<crate::model::MetadataStore>,

    /// A token, which can be sent as
    /// [ListMetadataStoresRequest.page_token][google.cloud.aiplatform.v1.ListMetadataStoresRequest.page_token]
    /// to retrieve the next page. If this field is not populated, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListMetadataStoresRequest.page_token]: crate::model::ListMetadataStoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListMetadataStoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMetadataStoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata_stores][crate::model::ListMetadataStoresResponse::metadata_stores].
    pub fn set_metadata_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetadataStore>,
    {
        use std::iter::Iterator;
        self.metadata_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListMetadataStoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataStoresResponse"
    }
}

#[cfg(feature = "metadata_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMetadataStoresResponse {
    type PageItem = crate::model::MetadataStore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metadata_stores
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [MetadataService.DeleteMetadataStore][google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore]: crate::client::MetadataService::delete_metadata_store
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMetadataStoreRequest {
    /// Required. The resource name of the MetadataStore to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Deprecated: Field is no longer supported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl DeleteMetadataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMetadataStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteMetadataStoreRequest::force].
    #[deprecated]
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for DeleteMetadataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteMetadataStoreRequest"
    }
}

/// Details of operations that perform
/// [MetadataService.DeleteMetadataStore][google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore]: crate::client::MetadataService::delete_metadata_store
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMetadataStoreOperationMetadata {
    /// Operation metadata for deleting a MetadataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl DeleteMetadataStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeleteMetadataStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for DeleteMetadataStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteMetadataStoreOperationMetadata"
    }
}

/// Request message for
/// [MetadataService.CreateArtifact][google.cloud.aiplatform.v1.MetadataService.CreateArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateArtifact]: crate::client::MetadataService::create_artifact
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateArtifactRequest {
    /// Required. The resource name of the MetadataStore where the Artifact should
    /// be created.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Artifact to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact: std::option::Option<crate::model::Artifact>,

    /// The {artifact} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    /// If not provided, the Artifact's ID will be a UUID generated by the service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all Artifacts in the parent MetadataStore. (Otherwise
    /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
    /// caller can't view the preexisting Artifact.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl CreateArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateArtifactRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [artifact][crate::model::CreateArtifactRequest::artifact].
    pub fn set_artifact<T: std::convert::Into<std::option::Option<crate::model::Artifact>>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [artifact_id][crate::model::CreateArtifactRequest::artifact_id].
    pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_id = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for CreateArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.GetArtifact][google.cloud.aiplatform.v1.MetadataService.GetArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetArtifact]: crate::client::MetadataService::get_artifact
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetArtifactRequest {
    /// Required. The resource name of the Artifact to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl GetArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetArtifactRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for GetArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.ListArtifacts][google.cloud.aiplatform.v1.MetadataService.ListArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListArtifacts]: crate::client::MetadataService::list_artifacts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListArtifactsRequest {
    /// Required. The MetadataStore whose Artifacts should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Artifacts to return. The service may return fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListArtifacts][google.cloud.aiplatform.v1.MetadataService.ListArtifacts]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListArtifacts]: crate::client::MetadataService::list_artifacts
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter specifying the boolean condition for the Artifacts to satisfy in
    /// order to be part of the result set.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// The supported set of filters include the following:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`.
    ///   Supported fields include: `name`, `display_name`, `uri`, `state`,
    ///   `schema_title`, `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`.
    ///   For example: `metadata.field_1.number_value = 10.0`
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    /// * **Context based filtering**:
    ///   To filter Artifacts based on the contexts to which they belong, use the
    ///   function operator with the full resource name
    ///   `in_context(<context-name>)`.
    ///   For example:
    ///   `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
    ///
    /// Each of the above supported filter types can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// How the list of messages is ordered. Specify the values to order by and an
    /// ordering operation. The default sorting order is ascending. To specify
    /// descending order for a field, users append a " desc" suffix; for example:
    /// "foo desc, bar".
    /// Subfields are specified with a `.` character, such as foo.bar.
    /// see <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListArtifactsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListArtifactsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListArtifactsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListArtifactsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListArtifactsRequest"
    }
}

/// Response message for
/// [MetadataService.ListArtifacts][google.cloud.aiplatform.v1.MetadataService.ListArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListArtifacts]: crate::client::MetadataService::list_artifacts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListArtifactsResponse {
    /// The Artifacts retrieved from the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub artifacts: std::vec::Vec<crate::model::Artifact>,

    /// A token, which can be sent as
    /// [ListArtifactsRequest.page_token][google.cloud.aiplatform.v1.ListArtifactsRequest.page_token]
    /// to retrieve the next page.
    /// If this field is not populated, there are no subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListArtifactsRequest.page_token]: crate::model::ListArtifactsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListArtifactsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [artifacts][crate::model::ListArtifactsResponse::artifacts].
    pub fn set_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>,
    {
        use std::iter::Iterator;
        self.artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListArtifactsResponse"
    }
}

#[cfg(feature = "metadata_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListArtifactsResponse {
    type PageItem = crate::model::Artifact;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.artifacts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [MetadataService.UpdateArtifact][google.cloud.aiplatform.v1.MetadataService.UpdateArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.UpdateArtifact]: crate::client::MetadataService::update_artifact
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateArtifactRequest {
    /// Required. The Artifact containing updates.
    /// The Artifact's [Artifact.name][google.cloud.aiplatform.v1.Artifact.name]
    /// field is used to identify the Artifact to be updated. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    ///
    /// [google.cloud.aiplatform.v1.Artifact.name]: crate::model::Artifact::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact: std::option::Option<crate::model::Artifact>,

    /// Optional. A FieldMask indicating which fields should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Artifact][google.cloud.aiplatform.v1.Artifact] is
    /// not found, a new [Artifact][google.cloud.aiplatform.v1.Artifact] is
    /// created.
    ///
    /// [google.cloud.aiplatform.v1.Artifact]: crate::model::Artifact
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl UpdateArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact][crate::model::UpdateArtifactRequest::artifact].
    pub fn set_artifact<T: std::convert::Into<std::option::Option<crate::model::Artifact>>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateArtifactRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateArtifactRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for UpdateArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.DeleteArtifact][google.cloud.aiplatform.v1.MetadataService.DeleteArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteArtifact]: crate::client::MetadataService::delete_artifact
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteArtifactRequest {
    /// Required. The resource name of the Artifact to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The etag of the Artifact to delete.
    /// If this is provided, it must match the server's etag. Otherwise, the
    /// request will fail with a FAILED_PRECONDITION.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl DeleteArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteArtifactRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteArtifactRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for DeleteArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.PurgeArtifacts][google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts]: crate::client::MetadataService::purge_artifacts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeArtifactsRequest {
    /// Required. The metadata store to purge Artifacts from.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A required filter matching the Artifacts to be purged.
    /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Flag to indicate to actually perform the purge.
    /// If `force` is set to false, the method will return a sample of
    /// Artifact names that would be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeArtifactsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeArtifactsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsRequest"
    }
}

/// Response message for
/// [MetadataService.PurgeArtifacts][google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts]: crate::client::MetadataService::purge_artifacts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeArtifactsResponse {
    /// The number of Artifacts that this request deleted (or, if `force` is false,
    /// the number of Artifacts that will be deleted). This can be an estimate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub purge_count: i64,

    /// A sample of the Artifact names that will be deleted.
    /// Only populated if `force` is set to false. The maximum number of samples is
    /// 100 (it is possible to return fewer).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeArtifactsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeArtifactsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsResponse"
    }
}

/// Details of operations that perform
/// [MetadataService.PurgeArtifacts][google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts]: crate::client::MetadataService::purge_artifacts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeArtifactsMetadata {
    /// Operation metadata for purging Artifacts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeArtifactsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::PurgeArtifactsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeArtifactsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsMetadata"
    }
}

/// Request message for
/// [MetadataService.CreateContext][google.cloud.aiplatform.v1.MetadataService.CreateContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateContext]: crate::client::MetadataService::create_context
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateContextRequest {
    /// Required. The resource name of the MetadataStore where the Context should
    /// be created. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Context to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::Context>,

    /// The {context} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
    /// If not provided, the Context's ID will be a UUID generated by the service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all Contexts in the parent MetadataStore. (Otherwise
    /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
    /// caller can't view the preexisting Context.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl CreateContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateContextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CreateContextRequest::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::Context>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [context_id][crate::model::CreateContextRequest::context_id].
    pub fn set_context_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context_id = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for CreateContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateContextRequest"
    }
}

/// Request message for
/// [MetadataService.GetContext][google.cloud.aiplatform.v1.MetadataService.GetContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetContext]: crate::client::MetadataService::get_context
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetContextRequest {
    /// Required. The resource name of the Context to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl GetContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for GetContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetContextRequest"
    }
}

/// Request message for
/// [MetadataService.ListContexts][google.cloud.aiplatform.v1.MetadataService.ListContexts]
///
/// [google.cloud.aiplatform.v1.MetadataService.ListContexts]: crate::client::MetadataService::list_contexts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListContextsRequest {
    /// Required. The MetadataStore whose Contexts should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Contexts to return. The service may return fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListContexts][google.cloud.aiplatform.v1.MetadataService.ListContexts]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListContexts]: crate::client::MetadataService::list_contexts
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter specifying the boolean condition for the Contexts to satisfy in
    /// order to be part of the result set.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// Following are the supported set of filters:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`.
    ///   Supported fields include: `name`, `display_name`, `schema_title`,
    ///   `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`.
    ///
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`.
    ///   For example: `metadata.field_1.number_value = 10.0`.
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    ///
    /// * **Parent Child filtering**:
    ///   To filter Contexts based on parent-child relationship use the HAS
    ///   operator as follows:
    ///
    ///
    /// ```norust
    /// parent_contexts:
    /// "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
    /// child_contexts:
    /// "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
    /// ```
    ///
    /// Each of the above supported filters can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// How the list of messages is ordered. Specify the values to order by and an
    /// ordering operation. The default sorting order is ascending. To specify
    /// descending order for a field, users append a " desc" suffix; for example:
    /// "foo desc, bar".
    /// Subfields are specified with a `.` character, such as foo.bar.
    /// see <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListContextsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListContextsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListContextsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListContextsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListContextsRequest"
    }
}

/// Response message for
/// [MetadataService.ListContexts][google.cloud.aiplatform.v1.MetadataService.ListContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListContexts]: crate::client::MetadataService::list_contexts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListContextsResponse {
    /// The Contexts retrieved from the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contexts: std::vec::Vec<crate::model::Context>,

    /// A token, which can be sent as
    /// [ListContextsRequest.page_token][google.cloud.aiplatform.v1.ListContextsRequest.page_token]
    /// to retrieve the next page.
    /// If this field is not populated, there are no subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListContextsRequest.page_token]: crate::model::ListContextsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListContextsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [contexts][crate::model::ListContextsResponse::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListContextsResponse"
    }
}

#[cfg(feature = "metadata_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListContextsResponse {
    type PageItem = crate::model::Context;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.contexts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [MetadataService.UpdateContext][google.cloud.aiplatform.v1.MetadataService.UpdateContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.UpdateContext]: crate::client::MetadataService::update_context
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateContextRequest {
    /// Required. The Context containing updates.
    /// The Context's [Context.name][google.cloud.aiplatform.v1.Context.name] field
    /// is used to identify the Context to be updated. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    ///
    /// [google.cloud.aiplatform.v1.Context.name]: crate::model::Context::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::Context>,

    /// Optional. A FieldMask indicating which fields should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Context][google.cloud.aiplatform.v1.Context] is
    /// not found, a new [Context][google.cloud.aiplatform.v1.Context] is created.
    ///
    /// [google.cloud.aiplatform.v1.Context]: crate::model::Context
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl UpdateContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::UpdateContextRequest::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::Context>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateContextRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateContextRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for UpdateContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateContextRequest"
    }
}

/// Request message for
/// [MetadataService.DeleteContext][google.cloud.aiplatform.v1.MetadataService.DeleteContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteContext]: crate::client::MetadataService::delete_context
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteContextRequest {
    /// Required. The resource name of the Context to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The force deletion semantics is still undefined.
    /// Users should not use this field.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    /// Optional. The etag of the Context to delete.
    /// If this is provided, it must match the server's etag. Otherwise, the
    /// request will fail with a FAILED_PRECONDITION.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl DeleteContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteContextRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteContextRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for DeleteContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteContextRequest"
    }
}

/// Request message for
/// [MetadataService.PurgeContexts][google.cloud.aiplatform.v1.MetadataService.PurgeContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeContexts]: crate::client::MetadataService::purge_contexts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeContextsRequest {
    /// Required. The metadata store to purge Contexts from.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A required filter matching the Contexts to be purged.
    /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Flag to indicate to actually perform the purge.
    /// If `force` is set to false, the method will return a sample of
    /// Context names that would be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeContextsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeContextsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsRequest"
    }
}

/// Response message for
/// [MetadataService.PurgeContexts][google.cloud.aiplatform.v1.MetadataService.PurgeContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeContexts]: crate::client::MetadataService::purge_contexts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeContextsResponse {
    /// The number of Contexts that this request deleted (or, if `force` is false,
    /// the number of Contexts that will be deleted). This can be an estimate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub purge_count: i64,

    /// A sample of the Context names that will be deleted.
    /// Only populated if `force` is set to false. The maximum number of samples is
    /// 100 (it is possible to return fewer).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeContextsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeContextsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsResponse"
    }
}

/// Details of operations that perform
/// [MetadataService.PurgeContexts][google.cloud.aiplatform.v1.MetadataService.PurgeContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeContexts]: crate::client::MetadataService::purge_contexts
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeContextsMetadata {
    /// Operation metadata for purging Contexts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeContextsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::PurgeContextsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeContextsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsMetadata"
    }
}

/// Request message for
/// [MetadataService.AddContextArtifactsAndExecutions][google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions]: crate::client::MetadataService::add_context_artifacts_and_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextArtifactsAndExecutionsRequest {
    /// Required. The resource name of the Context that the Artifacts and
    /// Executions belong to. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    /// The resource names of the Artifacts to attribute to the Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub artifacts: std::vec::Vec<std::string::String>,

    /// The resource names of the Executions to associate with the
    /// Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl AddContextArtifactsAndExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::AddContextArtifactsAndExecutionsRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [artifacts][crate::model::AddContextArtifactsAndExecutionsRequest::artifacts].
    pub fn set_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [executions][crate::model::AddContextArtifactsAndExecutionsRequest::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for AddContextArtifactsAndExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsRequest"
    }
}

/// Response message for
/// [MetadataService.AddContextArtifactsAndExecutions][google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions]: crate::client::MetadataService::add_context_artifacts_and_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextArtifactsAndExecutionsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl AddContextArtifactsAndExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for AddContextArtifactsAndExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsResponse"
    }
}

/// Request message for
/// [MetadataService.AddContextChildren][google.cloud.aiplatform.v1.MetadataService.AddContextChildren].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextChildren]: crate::client::MetadataService::add_context_children
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextChildrenRequest {
    /// Required. The resource name of the parent Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    /// The resource names of the child Contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_contexts: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl AddContextChildrenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::AddContextChildrenRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [child_contexts][crate::model::AddContextChildrenRequest::child_contexts].
    pub fn set_child_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for AddContextChildrenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextChildrenRequest"
    }
}

/// Response message for
/// [MetadataService.AddContextChildren][google.cloud.aiplatform.v1.MetadataService.AddContextChildren].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextChildren]: crate::client::MetadataService::add_context_children
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextChildrenResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl AddContextChildrenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for AddContextChildrenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextChildrenResponse"
    }
}

/// Request message for
/// [MetadataService.DeleteContextChildrenRequest][].
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveContextChildrenRequest {
    /// Required. The resource name of the parent Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    /// The resource names of the child Contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_contexts: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl RemoveContextChildrenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::RemoveContextChildrenRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [child_contexts][crate::model::RemoveContextChildrenRequest::child_contexts].
    pub fn set_child_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for RemoveContextChildrenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveContextChildrenRequest"
    }
}

/// Response message for
/// [MetadataService.RemoveContextChildren][google.cloud.aiplatform.v1.MetadataService.RemoveContextChildren].
///
/// [google.cloud.aiplatform.v1.MetadataService.RemoveContextChildren]: crate::client::MetadataService::remove_context_children
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveContextChildrenResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl RemoveContextChildrenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for RemoveContextChildrenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveContextChildrenResponse"
    }
}

/// Request message for
/// [MetadataService.QueryContextLineageSubgraph][google.cloud.aiplatform.v1.MetadataService.QueryContextLineageSubgraph].
///
/// [google.cloud.aiplatform.v1.MetadataService.QueryContextLineageSubgraph]: crate::client::MetadataService::query_context_lineage_subgraph
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryContextLineageSubgraphRequest {
    /// Required. The resource name of the Context whose Artifacts and Executions
    /// should be retrieved as a LineageSubgraph.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    ///
    /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
    /// the number of Executions, or the number of Events that would be returned
    /// for the Context exceeds 1000.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl QueryContextLineageSubgraphRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::QueryContextLineageSubgraphRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for QueryContextLineageSubgraphRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryContextLineageSubgraphRequest"
    }
}

/// Request message for
/// [MetadataService.CreateExecution][google.cloud.aiplatform.v1.MetadataService.CreateExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateExecution]: crate::client::MetadataService::create_execution
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateExecutionRequest {
    /// Required. The resource name of the MetadataStore where the Execution should
    /// be created.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Execution to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution: std::option::Option<crate::model::Execution>,

    /// The {execution} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    /// If not provided, the Execution's ID will be a UUID generated by the
    /// service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all Executions in the parent MetadataStore.
    /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
    /// if the caller can't view the preexisting Execution.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl CreateExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExecutionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::CreateExecutionRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::option::Option<crate::model::Execution>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [execution_id][crate::model::CreateExecutionRequest::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for CreateExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.GetExecution][google.cloud.aiplatform.v1.MetadataService.GetExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetExecution]: crate::client::MetadataService::get_execution
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetExecutionRequest {
    /// Required. The resource name of the Execution to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl GetExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for GetExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.ListExecutions][google.cloud.aiplatform.v1.MetadataService.ListExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListExecutions]: crate::client::MetadataService::list_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExecutionsRequest {
    /// Required. The MetadataStore whose Executions should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Executions to return. The service may return fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListExecutions][google.cloud.aiplatform.v1.MetadataService.ListExecutions]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with an
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListExecutions]: crate::client::MetadataService::list_executions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter specifying the boolean condition for the Executions to satisfy in
    /// order to be part of the result set.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// Following are the supported set of filters:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`.
    ///   Supported fields include: `name`, `display_name`, `state`,
    ///   `schema_title`, `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`.
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`
    ///   For example: `metadata.field_1.number_value = 10.0`
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    /// * **Context based filtering**:
    ///   To filter Executions based on the contexts to which they belong use
    ///   the function operator with the full resource name:
    ///   `in_context(<context-name>)`.
    ///   For example:
    ///   `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
    ///
    /// Each of the above supported filters can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// How the list of messages is ordered. Specify the values to order by and an
    /// ordering operation. The default sorting order is ascending. To specify
    /// descending order for a field, users append a " desc" suffix; for example:
    /// "foo desc, bar".
    /// Subfields are specified with a `.` character, such as foo.bar.
    /// see <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExecutionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExecutionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExecutionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExecutionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListExecutionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListExecutionsRequest"
    }
}

/// Response message for
/// [MetadataService.ListExecutions][google.cloud.aiplatform.v1.MetadataService.ListExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListExecutions]: crate::client::MetadataService::list_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExecutionsResponse {
    /// The Executions retrieved from the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<crate::model::Execution>,

    /// A token, which can be sent as
    /// [ListExecutionsRequest.page_token][google.cloud.aiplatform.v1.ListExecutionsRequest.page_token]
    /// to retrieve the next page.
    /// If this field is not populated, there are no subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListExecutionsRequest.page_token]: crate::model::ListExecutionsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListExecutionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [executions][crate::model::ListExecutionsResponse::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Execution>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListExecutionsResponse"
    }
}

#[cfg(feature = "metadata_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExecutionsResponse {
    type PageItem = crate::model::Execution;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.executions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [MetadataService.UpdateExecution][google.cloud.aiplatform.v1.MetadataService.UpdateExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.UpdateExecution]: crate::client::MetadataService::update_execution
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExecutionRequest {
    /// Required. The Execution containing updates.
    /// The Execution's [Execution.name][google.cloud.aiplatform.v1.Execution.name]
    /// field is used to identify the Execution to be updated. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    ///
    /// [google.cloud.aiplatform.v1.Execution.name]: crate::model::Execution::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution: std::option::Option<crate::model::Execution>,

    /// Optional. A FieldMask indicating which fields should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Execution][google.cloud.aiplatform.v1.Execution]
    /// is not found, a new [Execution][google.cloud.aiplatform.v1.Execution] is
    /// created.
    ///
    /// [google.cloud.aiplatform.v1.Execution]: crate::model::Execution
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl UpdateExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution][crate::model::UpdateExecutionRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::option::Option<crate::model::Execution>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExecutionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateExecutionRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for UpdateExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.DeleteExecution][google.cloud.aiplatform.v1.MetadataService.DeleteExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteExecution]: crate::client::MetadataService::delete_execution
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteExecutionRequest {
    /// Required. The resource name of the Execution to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The etag of the Execution to delete.
    /// If this is provided, it must match the server's etag. Otherwise, the
    /// request will fail with a FAILED_PRECONDITION.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl DeleteExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteExecutionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for DeleteExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.PurgeExecutions][google.cloud.aiplatform.v1.MetadataService.PurgeExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeExecutions]: crate::client::MetadataService::purge_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeExecutionsRequest {
    /// Required. The metadata store to purge Executions from.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A required filter matching the Executions to be purged.
    /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Flag to indicate to actually perform the purge.
    /// If `force` is set to false, the method will return a sample of
    /// Execution names that would be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeExecutionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeExecutionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeExecutionsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsRequest"
    }
}

/// Response message for
/// [MetadataService.PurgeExecutions][google.cloud.aiplatform.v1.MetadataService.PurgeExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeExecutions]: crate::client::MetadataService::purge_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeExecutionsResponse {
    /// The number of Executions that this request deleted (or, if `force` is
    /// false, the number of Executions that will be deleted). This can be an
    /// estimate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub purge_count: i64,

    /// A sample of the Execution names that will be deleted.
    /// Only populated if `force` is set to false. The maximum number of samples is
    /// 100 (it is possible to return fewer).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeExecutionsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeExecutionsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsResponse"
    }
}

/// Details of operations that perform
/// [MetadataService.PurgeExecutions][google.cloud.aiplatform.v1.MetadataService.PurgeExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeExecutions]: crate::client::MetadataService::purge_executions
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeExecutionsMetadata {
    /// Operation metadata for purging Executions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl PurgeExecutionsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::PurgeExecutionsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for PurgeExecutionsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsMetadata"
    }
}

/// Request message for
/// [MetadataService.AddExecutionEvents][google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents]: crate::client::MetadataService::add_execution_events
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddExecutionEventsRequest {
    /// Required. The resource name of the Execution that the Events connect
    /// Artifacts with.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,

    /// The Events to create and add.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl AddExecutionEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution][crate::model::AddExecutionEventsRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [events][crate::model::AddExecutionEventsRequest::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for AddExecutionEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddExecutionEventsRequest"
    }
}

/// Response message for
/// [MetadataService.AddExecutionEvents][google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents]: crate::client::MetadataService::add_execution_events
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddExecutionEventsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl AddExecutionEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for AddExecutionEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddExecutionEventsResponse"
    }
}

/// Request message for
/// [MetadataService.QueryExecutionInputsAndOutputs][google.cloud.aiplatform.v1.MetadataService.QueryExecutionInputsAndOutputs].
///
/// [google.cloud.aiplatform.v1.MetadataService.QueryExecutionInputsAndOutputs]: crate::client::MetadataService::query_execution_inputs_and_outputs
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryExecutionInputsAndOutputsRequest {
    /// Required. The resource name of the Execution whose input and output
    /// Artifacts should be retrieved as a LineageSubgraph. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl QueryExecutionInputsAndOutputsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution][crate::model::QueryExecutionInputsAndOutputsRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for QueryExecutionInputsAndOutputsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryExecutionInputsAndOutputsRequest"
    }
}

/// Request message for
/// [MetadataService.CreateMetadataSchema][google.cloud.aiplatform.v1.MetadataService.CreateMetadataSchema].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateMetadataSchema]: crate::client::MetadataService::create_metadata_schema
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataSchemaRequest {
    /// Required. The resource name of the MetadataStore where the MetadataSchema
    /// should be created. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The MetadataSchema to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_schema: std::option::Option<crate::model::MetadataSchema>,

    /// The {metadata_schema} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
    /// If not provided, the MetadataStore's ID will be a UUID generated by the
    /// service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all MetadataSchemas in the parent Location.
    /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
    /// if the caller can't view the preexisting MetadataSchema.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl CreateMetadataSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMetadataSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metadata_schema][crate::model::CreateMetadataSchemaRequest::metadata_schema].
    pub fn set_metadata_schema<
        T: std::convert::Into<std::option::Option<crate::model::MetadataSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema = v.into();
        self
    }

    /// Sets the value of [metadata_schema_id][crate::model::CreateMetadataSchemaRequest::metadata_schema_id].
    pub fn set_metadata_schema_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_id = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for CreateMetadataSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataSchemaRequest"
    }
}

/// Request message for
/// [MetadataService.GetMetadataSchema][google.cloud.aiplatform.v1.MetadataService.GetMetadataSchema].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetMetadataSchema]: crate::client::MetadataService::get_metadata_schema
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetadataSchemaRequest {
    /// Required. The resource name of the MetadataSchema to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl GetMetadataSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetadataSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for GetMetadataSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetMetadataSchemaRequest"
    }
}

/// Request message for
/// [MetadataService.ListMetadataSchemas][google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]: crate::client::MetadataService::list_metadata_schemas
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataSchemasRequest {
    /// Required. The MetadataStore whose MetadataSchemas should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of MetadataSchemas to return. The service may return
    /// fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListMetadataSchemas][google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]
    /// call. Provide this to retrieve the next page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]: crate::client::MetadataService::list_metadata_schemas
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A query to filter available MetadataSchemas for matching results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListMetadataSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMetadataSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetadataSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetadataSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMetadataSchemasRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListMetadataSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataSchemasRequest"
    }
}

/// Response message for
/// [MetadataService.ListMetadataSchemas][google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]: crate::client::MetadataService::list_metadata_schemas
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataSchemasResponse {
    /// The MetadataSchemas found for the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metadata_schemas: std::vec::Vec<crate::model::MetadataSchema>,

    /// A token, which can be sent as
    /// [ListMetadataSchemasRequest.page_token][google.cloud.aiplatform.v1.ListMetadataSchemasRequest.page_token]
    /// to retrieve the next page. If this field is not populated, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListMetadataSchemasRequest.page_token]: crate::model::ListMetadataSchemasRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl ListMetadataSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMetadataSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata_schemas][crate::model::ListMetadataSchemasResponse::metadata_schemas].
    pub fn set_metadata_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetadataSchema>,
    {
        use std::iter::Iterator;
        self.metadata_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for ListMetadataSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataSchemasResponse"
    }
}

#[cfg(feature = "metadata_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMetadataSchemasResponse {
    type PageItem = crate::model::MetadataSchema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metadata_schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [MetadataService.QueryArtifactLineageSubgraph][google.cloud.aiplatform.v1.MetadataService.QueryArtifactLineageSubgraph].
///
/// [google.cloud.aiplatform.v1.MetadataService.QueryArtifactLineageSubgraph]: crate::client::MetadataService::query_artifact_lineage_subgraph
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryArtifactLineageSubgraphRequest {
    /// Required. The resource name of the Artifact whose Lineage needs to be
    /// retrieved as a LineageSubgraph. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    ///
    /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
    /// the number of Executions, or the number of Events that would be returned
    /// for the Context exceeds 1000.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact: std::string::String,

    /// Specifies the size of the lineage graph in terms of number of hops from the
    /// specified artifact.
    /// Negative Value: INVALID_ARGUMENT error is returned
    /// 0: Only input artifact is returned.
    /// No value: Transitive closure is performed to return the complete graph.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_hops: i32,

    /// Filter specifying the boolean condition for the Artifacts to satisfy in
    /// order to be part of the Lineage Subgraph.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// The supported set of filters include the following:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`
    ///   Supported fields include: `name`, `display_name`, `uri`, `state`,
    ///   `schema_title`, `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`.
    ///   For example: `metadata.field_1.number_value = 10.0`
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    ///
    /// Each of the above supported filter types can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl QueryArtifactLineageSubgraphRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact][crate::model::QueryArtifactLineageSubgraphRequest::artifact].
    pub fn set_artifact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [max_hops][crate::model::QueryArtifactLineageSubgraphRequest::max_hops].
    pub fn set_max_hops<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_hops = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::QueryArtifactLineageSubgraphRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for QueryArtifactLineageSubgraphRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryArtifactLineageSubgraphRequest"
    }
}

/// Instance of a metadata store. Contains a set of metadata that can be
/// queried.
#[cfg(feature = "metadata_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataStore {
    /// Output only. The resource name of the MetadataStore instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this MetadataStore was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this MetadataStore was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Customer-managed encryption key spec for a Metadata Store. If set, this
    /// Metadata Store and all sub-resources of this Metadata Store are secured
    /// using this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Description of the MetadataStore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. State information of the MetadataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state: std::option::Option<crate::model::metadata_store::MetadataStoreState>,

    /// Optional. Dataplex integration settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_config: std::option::Option<crate::model::metadata_store::DataplexConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "metadata_service")]
impl MetadataStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MetadataStore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MetadataStore::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MetadataStore::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::MetadataStore::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MetadataStore::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MetadataStore::state].
    pub fn set_state<
        T: std::convert::Into<std::option::Option<crate::model::metadata_store::MetadataStoreState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [dataplex_config][crate::model::MetadataStore::dataplex_config].
    pub fn set_dataplex_config<
        T: std::convert::Into<std::option::Option<crate::model::metadata_store::DataplexConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_config = v.into();
        self
    }
}

#[cfg(feature = "metadata_service")]
impl wkt::message::Message for MetadataStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore"
    }
}

/// Defines additional types related to [MetadataStore].
#[cfg(feature = "metadata_service")]
pub mod metadata_store {
    #[allow(unused_imports)]
    use super::*;

    /// Represents state information for a MetadataStore.
    #[cfg(feature = "metadata_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetadataStoreState {
        /// The disk utilization of the MetadataStore in bytes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub disk_utilization_bytes: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "metadata_service")]
    impl MetadataStoreState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_utilization_bytes][crate::model::metadata_store::MetadataStoreState::disk_utilization_bytes].
        pub fn set_disk_utilization_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.disk_utilization_bytes = v.into();
            self
        }
    }

    #[cfg(feature = "metadata_service")]
    impl wkt::message::Message for MetadataStoreState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore.MetadataStoreState"
        }
    }

    /// Represents Dataplex integration settings.
    #[cfg(feature = "metadata_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataplexConfig {
        /// Optional. Whether or not Data Lineage synchronization is enabled for
        /// Vertex Pipelines.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled_pipelines_lineage: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "metadata_service")]
    impl DataplexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled_pipelines_lineage][crate::model::metadata_store::DataplexConfig::enabled_pipelines_lineage].
        pub fn set_enabled_pipelines_lineage<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled_pipelines_lineage = v.into();
            self
        }
    }

    #[cfg(feature = "metadata_service")]
    impl wkt::message::Message for DataplexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore.DataplexConfig"
        }
    }
}

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigratableResource {
    /// Output only. Timestamp when the last migration attempt on this
    /// MigratableResource started. Will not be set if there's no migration attempt
    /// on this MigratableResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_migrate_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this MigratableResource was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::migratable_resource::Resource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl MigratableResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_migrate_time][crate::model::MigratableResource::last_migrate_time].
    pub fn set_last_migrate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_migrate_time = v.into();
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigratableResource::last_update_time].
    pub fn set_last_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_update_time = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource].
    ///
    /// Note that all the setters affecting `resource` are mutually
    /// exclusive.
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::migratable_resource::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `MlEngineModelVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ml_engine_model_version(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migratable_resource::MlEngineModelVersion>,
    > {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::MlEngineModelVersion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `AutomlModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automl_model(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::migratable_resource::AutomlModel>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::AutomlModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `AutomlDataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automl_dataset(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::migratable_resource::AutomlDataset>>
    {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::AutomlDataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `DataLabelingDataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_labeling_dataset(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::migratable_resource::DataLabelingDataset>>
    {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::DataLabelingDataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `MlEngineModelVersion`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_ml_engine_model_version<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migratable_resource::MlEngineModelVersion>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::MlEngineModelVersion(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `AutomlModel`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_automl_model<
        T: std::convert::Into<std::boxed::Box<crate::model::migratable_resource::AutomlModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::AutomlModel(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `AutomlDataset`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_automl_dataset<
        T: std::convert::Into<std::boxed::Box<crate::model::migratable_resource::AutomlDataset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::AutomlDataset(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `DataLabelingDataset`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_data_labeling_dataset<
        T: std::convert::Into<std::boxed::Box<crate::model::migratable_resource::DataLabelingDataset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::DataLabelingDataset(v.into()),
        );
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for MigratableResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource"
    }
}

/// Defines additional types related to [MigratableResource].
#[cfg(feature = "migration_service")]
pub mod migratable_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Represents one model Version in ml.googleapis.com.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MlEngineModelVersion {
        /// The ml.googleapis.com endpoint that this model Version currently lives
        /// in.
        /// Example values:
        ///
        /// * ml.googleapis.com
        /// * us-centrall-ml.googleapis.com
        /// * europe-west4-ml.googleapis.com
        /// * asia-east1-ml.googleapis.com
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Full resource name of ml engine model Version.
        /// Format: `projects/{project}/models/{model}/versions/{version}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl MlEngineModelVersion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::migratable_resource::MlEngineModelVersion::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [version][crate::model::migratable_resource::MlEngineModelVersion::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for MlEngineModelVersion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.MlEngineModelVersion"
        }
    }

    /// Represents one Model in automl.googleapis.com.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutomlModel {
        /// Full resource name of automl Model.
        /// Format:
        /// `projects/{project}/locations/{location}/models/{model}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// The Model's display name in automl.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_display_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl AutomlModel {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::migratable_resource::AutomlModel::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_display_name][crate::model::migratable_resource::AutomlModel::model_display_name].
        pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_display_name = v.into();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for AutomlModel {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.AutomlModel"
        }
    }

    /// Represents one Dataset in automl.googleapis.com.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutomlDataset {
        /// Full resource name of automl Dataset.
        /// Format:
        /// `projects/{project}/locations/{location}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// The Dataset's display name in automl.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl AutomlDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migratable_resource::AutomlDataset::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migratable_resource::AutomlDataset::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for AutomlDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.AutomlDataset"
        }
    }

    /// Represents one Dataset in datalabeling.googleapis.com.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataLabelingDataset {
        /// Full resource name of data labeling Dataset.
        /// Format:
        /// `projects/{project}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// The Dataset's display name in datalabeling.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,

        /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
        /// the data labeling Dataset.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub data_labeling_annotated_datasets: std::vec::Vec<
            crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl DataLabelingDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migratable_resource::DataLabelingDataset::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migratable_resource::DataLabelingDataset::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }

        /// Sets the value of [data_labeling_annotated_datasets][crate::model::migratable_resource::DataLabelingDataset::data_labeling_annotated_datasets].
        pub fn set_data_labeling_annotated_datasets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset>
        {
            use std::iter::Iterator;
            self.data_labeling_annotated_datasets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for DataLabelingDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset"
        }
    }

    /// Defines additional types related to [DataLabelingDataset].
    #[cfg(feature = "migration_service")]
    pub mod data_labeling_dataset {
        #[allow(unused_imports)]
        use super::*;

        /// Represents one AnnotatedDataset in datalabeling.googleapis.com.
        #[cfg(feature = "migration_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DataLabelingAnnotatedDataset {
            /// Full resource name of data labeling AnnotatedDataset.
            /// Format:
            /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub annotated_dataset: std::string::String,

            /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub annotated_dataset_display_name: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "migration_service")]
        impl DataLabelingAnnotatedDataset {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [annotated_dataset][crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset::annotated_dataset].
            pub fn set_annotated_dataset<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.annotated_dataset = v.into();
                self
            }

            /// Sets the value of [annotated_dataset_display_name][crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset::annotated_dataset_display_name].
            pub fn set_annotated_dataset_display_name<
                T: std::convert::Into<std::string::String>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.annotated_dataset_display_name = v.into();
                self
            }
        }

        #[cfg(feature = "migration_service")]
        impl wkt::message::Message for DataLabelingAnnotatedDataset {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset.DataLabelingAnnotatedDataset"
            }
        }
    }

    #[cfg(feature = "migration_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Resource {
        /// Output only. Represents one Version in ml.googleapis.com.
        MlEngineModelVersion(
            std::boxed::Box<crate::model::migratable_resource::MlEngineModelVersion>,
        ),
        /// Output only. Represents one Model in automl.googleapis.com.
        AutomlModel(std::boxed::Box<crate::model::migratable_resource::AutomlModel>),
        /// Output only. Represents one Dataset in automl.googleapis.com.
        AutomlDataset(std::boxed::Box<crate::model::migratable_resource::AutomlDataset>),
        /// Output only. Represents one Dataset in datalabeling.googleapis.com.
        DataLabelingDataset(
            std::boxed::Box<crate::model::migratable_resource::DataLabelingDataset>,
        ),
    }
}

/// Request message for
/// [MigrationService.SearchMigratableResources][google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources]: crate::client::MigrationService::search_migratable_resources
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchMigratableResourcesRequest {
    /// Required. The location that the migratable resources should be searched
    /// from. It's the Vertex AI location that the resources can be migrated to,
    /// not the resources' original location. Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard page size.
    /// The default and maximum value is 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter for your search. You can use the following types of filters:
    ///
    /// * Resource type filters. The following strings filter for a specific type
    ///   of [MigratableResource][google.cloud.aiplatform.v1.MigratableResource]:
    ///   * `ml_engine_model_version:*`
    ///   * `automl_model:*`
    ///   * `automl_dataset:*`
    ///   * `data_labeling_dataset:*`
    /// * "Migrated or not" filters. The following strings filter for resources
    ///   that either have or have not already been migrated:
    ///   * `last_migrate_time:*` filters for migrated resources.
    ///   * `NOT last_migrate_time:*` filters for not yet migrated resources.
    ///
    /// [google.cloud.aiplatform.v1.MigratableResource]: crate::model::MigratableResource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl SearchMigratableResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchMigratableResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchMigratableResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchMigratableResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchMigratableResourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for SearchMigratableResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchMigratableResourcesRequest"
    }
}

/// Response message for
/// [MigrationService.SearchMigratableResources][google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources]: crate::client::MigrationService::search_migratable_resources
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchMigratableResourcesResponse {
    /// All migratable resources that can be migrated to the
    /// location specified in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migratable_resources: std::vec::Vec<crate::model::MigratableResource>,

    /// The standard next-page token.
    /// The migratable_resources may not fill page_size in
    /// SearchMigratableResourcesRequest even when there are subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl SearchMigratableResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchMigratableResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [migratable_resources][crate::model::SearchMigratableResourcesResponse::migratable_resources].
    pub fn set_migratable_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigratableResource>,
    {
        use std::iter::Iterator;
        self.migratable_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for SearchMigratableResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchMigratableResourcesResponse"
    }
}

#[cfg(feature = "migration_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchMigratableResourcesResponse {
    type PageItem = crate::model::MigratableResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migratable_resources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources]: crate::client::MigrationService::batch_migrate_resources
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchMigrateResourcesRequest {
    /// Required. The location of the migrated resource will live in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request messages specifying the resources to migrate.
    /// They must be in the same location as the destination.
    /// Up to 50 resources can be migrated in one batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migrate_resource_requests: std::vec::Vec<crate::model::MigrateResourceRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl BatchMigrateResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchMigrateResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migrate_resource_requests][crate::model::BatchMigrateResourcesRequest::migrate_resource_requests].
    pub fn set_migrate_resource_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrateResourceRequest>,
    {
        use std::iter::Iterator;
        self.migrate_resource_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for BatchMigrateResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesRequest"
    }
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrateResourceRequest {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::migrate_resource_request::Request>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl MigrateResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::migrate_resource_request::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateMlEngineModelVersionConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migrate_ml_engine_model_version_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateMlEngineModelVersionConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateAutomlModelConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migrate_automl_model_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlModelConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateAutomlModelConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateAutomlDatasetConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migrate_automl_dataset_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlDatasetConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateAutomlDatasetConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateDataLabelingDatasetConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migrate_data_labeling_dataset_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateDataLabelingDatasetConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateMlEngineModelVersionConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_ml_engine_model_version_config<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateMlEngineModelVersionConfig(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateAutomlModelConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_automl_model_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlModelConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateAutomlModelConfig(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateAutomlDatasetConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_automl_dataset_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlDatasetConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateAutomlDatasetConfig(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateDataLabelingDatasetConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_data_labeling_dataset_config<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateDataLabelingDatasetConfig(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for MigrateResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest"
    }
}

/// Defines additional types related to [MigrateResourceRequest].
#[cfg(feature = "migration_service")]
pub mod migrate_resource_request {
    #[allow(unused_imports)]
    use super::*;

    /// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateMlEngineModelVersionConfig {
        /// Required. The ml.googleapis.com endpoint that this model version should
        /// be migrated from. Example values:
        ///
        /// * ml.googleapis.com
        ///
        /// * us-centrall-ml.googleapis.com
        ///
        /// * europe-west4-ml.googleapis.com
        ///
        /// * asia-east1-ml.googleapis.com
        ///
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Required. Full resource name of ml engine model version.
        /// Format: `projects/{project}/models/{model}/versions/{version}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_version: std::string::String,

        /// Required. Display name of the model in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_display_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl MigrateMlEngineModelVersionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [model_version][crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig::model_version].
        pub fn set_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_version = v.into();
            self
        }

        /// Sets the value of [model_display_name][crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig::model_display_name].
        pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_display_name = v.into();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for MigrateMlEngineModelVersionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateMlEngineModelVersionConfig"
        }
    }

    /// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateAutomlModelConfig {
        /// Required. Full resource name of automl Model.
        /// Format:
        /// `projects/{project}/locations/{location}/models/{model}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// Optional. Display name of the model in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_display_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl MigrateAutomlModelConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::migrate_resource_request::MigrateAutomlModelConfig::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_display_name][crate::model::migrate_resource_request::MigrateAutomlModelConfig::model_display_name].
        pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_display_name = v.into();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for MigrateAutomlModelConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlModelConfig"
        }
    }

    /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
    /// Dataset.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateAutomlDatasetConfig {
        /// Required. Full resource name of automl Dataset.
        /// Format:
        /// `projects/{project}/locations/{location}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// Required. Display name of the Dataset in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl MigrateAutomlDatasetConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migrate_resource_request::MigrateAutomlDatasetConfig::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migrate_resource_request::MigrateAutomlDatasetConfig::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for MigrateAutomlDatasetConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlDatasetConfig"
        }
    }

    /// Config for migrating Dataset in datalabeling.googleapis.com to Vertex
    /// AI's Dataset.
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateDataLabelingDatasetConfig {

        /// Required. Full resource name of data labeling Dataset.
        /// Format:
        /// `projects/{project}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// Optional. Display name of the Dataset in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,

        /// Optional. Configs for migrating AnnotatedDataset in
        /// datalabeling.googleapis.com to Vertex AI's SavedQuery. The specified
        /// AnnotatedDatasets have to belong to the datalabeling Dataset.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub migrate_data_labeling_annotated_dataset_configs: std::vec::Vec<crate::model::migrate_resource_request::migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl MigrateDataLabelingDatasetConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }

        /// Sets the value of [migrate_data_labeling_annotated_dataset_configs][crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig::migrate_data_labeling_annotated_dataset_configs].
        pub fn set_migrate_data_labeling_annotated_dataset_configs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migrate_resource_request::migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig>
        {
            use std::iter::Iterator;
            self.migrate_data_labeling_annotated_dataset_configs =
                v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for MigrateDataLabelingDatasetConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig"
        }
    }

    /// Defines additional types related to [MigrateDataLabelingDatasetConfig].
    #[cfg(feature = "migration_service")]
    pub mod migrate_data_labeling_dataset_config {
        #[allow(unused_imports)]
        use super::*;

        /// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
        /// Vertex AI's SavedQuery.
        #[cfg(feature = "migration_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MigrateDataLabelingAnnotatedDatasetConfig {
            /// Required. Full resource name of data labeling AnnotatedDataset.
            /// Format:
            /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub annotated_dataset: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "migration_service")]
        impl MigrateDataLabelingAnnotatedDatasetConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [annotated_dataset][crate::model::migrate_resource_request::migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig::annotated_dataset].
            pub fn set_annotated_dataset<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.annotated_dataset = v.into();
                self
            }
        }

        #[cfg(feature = "migration_service")]
        impl wkt::message::Message for MigrateDataLabelingAnnotatedDatasetConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig"
            }
        }
    }

    #[cfg(feature = "migration_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
        MigrateMlEngineModelVersionConfig(
            std::boxed::Box<
                crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig,
            >,
        ),
        /// Config for migrating Model in automl.googleapis.com to Vertex AI's
        /// Model.
        MigrateAutomlModelConfig(
            std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlModelConfig>,
        ),
        /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
        /// Dataset.
        MigrateAutomlDatasetConfig(
            std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlDatasetConfig>,
        ),
        /// Config for migrating Dataset in datalabeling.googleapis.com to
        /// Vertex AI's Dataset.
        MigrateDataLabelingDatasetConfig(
            std::boxed::Box<
                crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig,
            >,
        ),
    }
}

/// Response message for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources]: crate::client::MigrationService::batch_migrate_resources
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchMigrateResourcesResponse {
    /// Successfully migrated resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migrate_resource_responses: std::vec::Vec<crate::model::MigrateResourceResponse>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl BatchMigrateResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrate_resource_responses][crate::model::BatchMigrateResourcesResponse::migrate_resource_responses].
    pub fn set_migrate_resource_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrateResourceResponse>,
    {
        use std::iter::Iterator;
        self.migrate_resource_responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for BatchMigrateResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesResponse"
    }
}

/// Describes a successfully migrated resource.
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrateResourceResponse {
    /// Before migration, the identifier in ml.googleapis.com,
    /// automl.googleapis.com or datalabeling.googleapis.com.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migratable_resource: std::option::Option<crate::model::MigratableResource>,

    /// After migration, the resource name in Vertex AI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub migrated_resource:
        std::option::Option<crate::model::migrate_resource_response::MigratedResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl MigrateResourceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migratable_resource][crate::model::MigrateResourceResponse::migratable_resource].
    pub fn set_migratable_resource<
        T: std::convert::Into<std::option::Option<crate::model::MigratableResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migratable_resource = v.into();
        self
    }

    /// Sets the value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource].
    ///
    /// Note that all the setters affecting `migrated_resource` are mutually
    /// exclusive.
    pub fn set_migrated_resource<
        T: std::convert::Into<
                std::option::Option<crate::model::migrate_resource_response::MigratedResource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migrated_resource = v.into();
        self
    }

    /// The value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// if it holds a `Dataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dataset(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.migrated_resource.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_response::MigratedResource::Dataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// if it holds a `Model`, `None` if the field is not set or
    /// holds a different branch.
    pub fn model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.migrated_resource.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_response::MigratedResource::Model(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// to hold a `Dataset`.
    ///
    /// Note that all the setters affecting `migrated_resource` are
    /// mutually exclusive.
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrated_resource = std::option::Option::Some(
            crate::model::migrate_resource_response::MigratedResource::Dataset(v.into()),
        );
        self
    }

    /// Sets the value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// to hold a `Model`.
    ///
    /// Note that all the setters affecting `migrated_resource` are
    /// mutually exclusive.
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrated_resource = std::option::Option::Some(
            crate::model::migrate_resource_response::MigratedResource::Model(v.into()),
        );
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for MigrateResourceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceResponse"
    }
}

/// Defines additional types related to [MigrateResourceResponse].
#[cfg(feature = "migration_service")]
pub mod migrate_resource_response {
    #[allow(unused_imports)]
    use super::*;

    /// After migration, the resource name in Vertex AI.
    #[cfg(feature = "migration_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MigratedResource {
        /// Migrated Dataset's resource name.
        Dataset(std::string::String),
        /// Migrated Model's resource name.
        Model(std::string::String),
    }
}

/// Runtime operation information for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources]: crate::client::MigrationService::batch_migrate_resources
#[cfg(feature = "migration_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchMigrateResourcesOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Partial results that reflect the latest migration operation progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_results:
        std::vec::Vec<crate::model::batch_migrate_resources_operation_metadata::PartialResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "migration_service")]
impl BatchMigrateResourcesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchMigrateResourcesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [partial_results][crate::model::BatchMigrateResourcesOperationMetadata::partial_results].
    pub fn set_partial_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::batch_migrate_resources_operation_metadata::PartialResult,
            >,
    {
        use std::iter::Iterator;
        self.partial_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "migration_service")]
impl wkt::message::Message for BatchMigrateResourcesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata"
    }
}

/// Defines additional types related to [BatchMigrateResourcesOperationMetadata].
#[cfg(feature = "migration_service")]
pub mod batch_migrate_resources_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a partial result in batch migration operation for one
    /// [MigrateResourceRequest][google.cloud.aiplatform.v1.MigrateResourceRequest].
    ///
    /// [google.cloud.aiplatform.v1.MigrateResourceRequest]: crate::model::MigrateResourceRequest
    #[cfg(feature = "migration_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PartialResult {
        /// It's the same as the value in
        /// [BatchMigrateResourcesRequest.migrate_resource_requests][google.cloud.aiplatform.v1.BatchMigrateResourcesRequest.migrate_resource_requests].
        ///
        /// [google.cloud.aiplatform.v1.BatchMigrateResourcesRequest.migrate_resource_requests]: crate::model::BatchMigrateResourcesRequest::migrate_resource_requests
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub request: std::option::Option<crate::model::MigrateResourceRequest>,

        /// If the resource's migration is ongoing, none of the result will be set.
        /// If the resource's migration is finished, either error or one of the
        /// migrated resource name will be filled.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub result: std::option::Option<
            crate::model::batch_migrate_resources_operation_metadata::partial_result::Result,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "migration_service")]
    impl PartialResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [request][crate::model::batch_migrate_resources_operation_metadata::PartialResult::request].
        pub fn set_request<
            T: std::convert::Into<std::option::Option<crate::model::MigrateResourceRequest>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request = v.into();
            self
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result].
        ///
        /// Note that all the setters affecting `result` are mutually
        /// exclusive.
        pub fn set_result<T: std::convert::Into<std::option::Option<crate::model::batch_migrate_resources_operation_metadata::partial_result::Result>>>(mut self, v: T) -> Self
        {
            self.result = v.into();
            self
        }

        /// The value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// if it holds a `Error`, `None` if the field is not set or
        /// holds a different branch.
        pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Error(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// if it holds a `Model`, `None` if the field is not set or
        /// holds a different branch.
        pub fn model(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Model(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// if it holds a `Dataset`, `None` if the field is not set or
        /// holds a different branch.
        pub fn dataset(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Dataset(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// to hold a `Error`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.result = std::option::Option::Some(
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Error(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// to hold a `Model`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.result = std::option::Option::Some(
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Model(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// to hold a `Dataset`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.result = std::option::Option::Some(
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Dataset(
                    v.into()
                )
            );
            self
        }
    }

    #[cfg(feature = "migration_service")]
    impl wkt::message::Message for PartialResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata.PartialResult"
        }
    }

    /// Defines additional types related to [PartialResult].
    #[cfg(feature = "migration_service")]
    pub mod partial_result {
        #[allow(unused_imports)]
        use super::*;

        /// If the resource's migration is ongoing, none of the result will be set.
        /// If the resource's migration is finished, either error or one of the
        /// migrated resource name will be filled.
        #[cfg(feature = "migration_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Result {
            /// The error result of the migration request in case of failure.
            Error(std::boxed::Box<rpc::model::Status>),
            /// Migrated model resource name.
            Model(std::string::String),
            /// Migrated dataset resource name.
            Dataset(std::string::String),
        }
    }
}

/// A trained machine learning Model.
#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Model {
    /// The resource name of the Model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The version ID of the model.
    /// A new version is committed when a new model version is uploaded or
    /// trained under an existing model id. It is an auto-incrementing decimal
    /// number in string representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_id: std::string::String,

    /// User provided version aliases so that a model version can be referenced via
    /// alias (i.e.
    /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
    /// instead of auto-generated version id (i.e.
    /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
    /// The format is [a-z][a-zA-Z0-9-]{0,126}[a-z0-9] to distinguish from
    /// version_id. A default version alias will be created for the first version
    /// of the model, and there must be exactly one default version alias for a
    /// model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version_aliases: std::vec::Vec<std::string::String>,

    /// Output only. Timestamp when this version was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this version was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The display name of the Model.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The description of this version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_description: std::string::String,

    /// The default checkpoint id of a model version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_checkpoint_id: std::string::String,

    /// The schemata that describe formats of the Model's predictions and
    /// explanations as given and returned via
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// and
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
    ///
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_schemata: std::option::Option<crate::model::PredictSchemata>,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// additional information about the Model, that is specific to it. Unset if
    /// the Model does not have any additional information. The schema is defined
    /// as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI, if no
    /// additional metadata is needed, this field is set to an empty string.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_uri: std::string::String,

    /// Immutable. An additional information about the Model; the schema of the
    /// metadata can be found in
    /// [metadata_schema][google.cloud.aiplatform.v1.Model.metadata_schema_uri].
    /// Unset if the Model does not have any additional information.
    ///
    /// [google.cloud.aiplatform.v1.Model.metadata_schema_uri]: crate::model::Model::metadata_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. The formats in which this Model may be exported. If empty,
    /// this Model is not available for export.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_export_formats: std::vec::Vec<crate::model::model::ExportFormat>,

    /// Output only. The resource name of the TrainingPipeline that uploaded this
    /// Model, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_pipeline: std::string::String,

    /// Optional. This field is populated if the model is produced by a pipeline
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pipeline_job: std::string::String,

    /// Input only. The specification of the container that is to be used when
    /// deploying this Model. The specification is ingested upon
    /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel],
    /// and all binaries it contains are copied and stored internally by Vertex AI.
    /// Not required for AutoML Models.
    ///
    /// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_spec: std::option::Option<crate::model::ModelContainerSpec>,

    /// Immutable. The path to the directory containing the Model artifact and any
    /// of its supporting files. Not required for AutoML Models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_uri: std::string::String,

    /// Output only. When this Model is deployed, its prediction resources are
    /// described by the `prediction_resources` field of the
    /// [Endpoint.deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
    /// object. Because not all Models support all resource configuration types,
    /// the configuration types this Model supports are listed here. If no
    /// configuration types are listed, the Model cannot be deployed to an
    /// [Endpoint][google.cloud.aiplatform.v1.Endpoint] and does not support
    /// online predictions
    /// ([PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// or
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain]).
    /// Such a Model can serve predictions by using a
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob], if it
    /// has at least one entry each in
    /// [supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats]
    /// and
    /// [supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.Endpoint]: crate::model::Endpoint
    /// [google.cloud.aiplatform.v1.Endpoint.deployed_models]: crate::model::Endpoint::deployed_models
    /// [google.cloud.aiplatform.v1.Model.supported_input_storage_formats]: crate::model::Model::supported_input_storage_formats
    /// [google.cloud.aiplatform.v1.Model.supported_output_storage_formats]: crate::model::Model::supported_output_storage_formats
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_deployment_resources_types:
        std::vec::Vec<crate::model::model::DeploymentResourcesType>,

    /// Output only. The formats this Model supports in
    /// [BatchPredictionJob.input_config][google.cloud.aiplatform.v1.BatchPredictionJob.input_config].
    /// If
    /// [PredictSchemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// exists, the instances should be given as per that schema.
    ///
    /// The possible formats are:
    ///
    /// * `jsonl`
    ///   The JSON Lines format, where each instance is a single line. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `csv`
    ///   The CSV format, where each instance is a single comma-separated line.
    ///   The first line in the file is the header, containing comma-separated field
    ///   names. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `tf-record`
    ///   The TFRecord format, where each instance is a single record in tfrecord
    ///   syntax. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `tf-record-gzip`
    ///   Similar to `tf-record`, but the file is gzipped. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `bigquery`
    ///   Each instance is a single row in BigQuery. Uses
    ///   [BigQuerySource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.bigquery_source].
    ///
    /// * `file-list`
    ///   Each line of the file is the location of an instance to process, uses
    ///   `gcs_source` field of the
    ///   [InputConfig][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig]
    ///   object.
    ///
    ///
    /// If this Model doesn't support any of these formats it means it cannot be
    /// used with a
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    /// However, if it has
    /// [supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types],
    /// it could serve online predictions by using
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// or
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig]: crate::model::batch_prediction_job::InputConfig
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.bigquery_source]: crate::model::batch_prediction_job::InputConfig::source
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source]: crate::model::batch_prediction_job::InputConfig::source
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.input_config]: crate::model::BatchPredictionJob::input_config
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_input_storage_formats: std::vec::Vec<std::string::String>,

    /// Output only. The formats this Model supports in
    /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
    /// If both
    /// [PredictSchemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// and
    /// [PredictSchemata.prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]
    /// exist, the predictions are returned together with their instances. In other
    /// words, the prediction has the original instance data first, followed by the
    /// actual prediction content (as per the schema).
    ///
    /// The possible formats are:
    ///
    /// * `jsonl`
    ///   The JSON Lines format, where each prediction is a single line. Uses
    ///   [GcsDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination].
    ///
    /// * `csv`
    ///   The CSV format, where each prediction is a single comma-separated line.
    ///   The first line in the file is the header, containing comma-separated field
    ///   names. Uses
    ///   [GcsDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination].
    ///
    /// * `bigquery`
    ///   Each prediction is a single row in a BigQuery table, uses
    ///   [BigQueryDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.bigquery_destination]
    ///   .
    ///
    ///
    /// If this Model doesn't support any of these formats it means it cannot be
    /// used with a
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    /// However, if it has
    /// [supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types],
    /// it could serve online predictions by using
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// or
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.bigquery_destination]: crate::model::batch_prediction_job::OutputConfig::destination
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination]: crate::model::batch_prediction_job::OutputConfig::destination
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]: crate::model::PredictSchemata::prediction_schema_uri
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_output_storage_formats: std::vec::Vec<std::string::String>,

    /// Output only. Timestamp when this Model was uploaded into Vertex AI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Model was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The pointers to DeployedModels created from this Model. Note
    /// that Model could have been deployed to Endpoints in different Locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_models: std::vec::Vec<crate::model::DeployedModelRef>,

    /// The default explanation specification for this Model.
    ///
    /// The Model can be used for
    /// [requesting
    /// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] after
    /// being [deployed][google.cloud.aiplatform.v1.EndpointService.DeployModel] if
    /// it is populated. The Model can be used for [batch
    /// explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
    /// if it is populated.
    ///
    /// All fields of the explanation_spec can be overridden by
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// of
    /// [DeployModelRequest.deployed_model][google.cloud.aiplatform.v1.DeployModelRequest.deployed_model],
    /// or
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// of [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    ///
    /// If the default explanation specification is not set for this Model, this
    /// Model can still be used for
    /// [requesting
    /// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] by
    /// setting
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// of
    /// [DeployModelRequest.deployed_model][google.cloud.aiplatform.v1.DeployModelRequest.deployed_model]
    /// and for [batch
    /// explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
    /// by setting
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// of [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]: crate::model::BatchPredictionJob::explanation_spec
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]: crate::model::BatchPredictionJob::generate_explanation
    /// [google.cloud.aiplatform.v1.DeployModelRequest.deployed_model]: crate::model::DeployModelRequest::deployed_model
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Models.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Stats of data used for training or evaluating the Model.
    ///
    /// Only populated when the Model is trained by a TrainingPipeline with
    /// [data_input_config][google.cloud.aiplatform.v1.TrainingPipeline.input_data_config].
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.input_data_config]: crate::model::TrainingPipeline::input_data_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_stats: std::option::Option<crate::model::model::DataStats>,

    /// Customer-managed encryption key spec for a Model. If set, this
    /// Model and all sub-resources of this Model will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Source of a model. It can either be automl training pipeline,
    /// custom training pipeline, BigQuery ML, or saved and tuned from Genie or
    /// Model Garden.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_source_info: std::option::Option<crate::model::ModelSourceInfo>,

    /// Output only. If this Model is a copy of another Model, this contains info
    /// about the original.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_model_info: std::option::Option<crate::model::model::OriginalModelInfo>,

    /// Output only. The resource name of the Artifact that was created in
    /// MetadataStore when creating the Model. The Artifact resource name pattern
    /// is
    /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_artifact: std::string::String,

    /// Optional. User input field to specify the base model source. Currently it
    /// only supports specifing the Model Garden models and Genie models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_model_source: std::option::Option<crate::model::model::BaseModelSource>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Model::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::Model::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [version_create_time][crate::model::Model::version_create_time].
    pub fn set_version_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_create_time = v.into();
        self
    }

    /// Sets the value of [version_update_time][crate::model::Model::version_update_time].
    pub fn set_version_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Model::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Model::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version_description][crate::model::Model::version_description].
    pub fn set_version_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_description = v.into();
        self
    }

    /// Sets the value of [default_checkpoint_id][crate::model::Model::default_checkpoint_id].
    pub fn set_default_checkpoint_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_checkpoint_id = v.into();
        self
    }

    /// Sets the value of [predict_schemata][crate::model::Model::predict_schemata].
    pub fn set_predict_schemata<
        T: std::convert::Into<std::option::Option<crate::model::PredictSchemata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_schemata = v.into();
        self
    }

    /// Sets the value of [metadata_schema_uri][crate::model::Model::metadata_schema_uri].
    pub fn set_metadata_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Model::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [training_pipeline][crate::model::Model::training_pipeline].
    pub fn set_training_pipeline<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_pipeline = v.into();
        self
    }

    /// Sets the value of [pipeline_job][crate::model::Model::pipeline_job].
    pub fn set_pipeline_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_job = v.into();
        self
    }

    /// Sets the value of [container_spec][crate::model::Model::container_spec].
    pub fn set_container_spec<
        T: std::convert::Into<std::option::Option<crate::model::ModelContainerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container_spec = v.into();
        self
    }

    /// Sets the value of [artifact_uri][crate::model::Model::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Model::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Model::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [explanation_spec][crate::model::Model::explanation_spec].
    pub fn set_explanation_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Model::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [data_stats][crate::model::Model::data_stats].
    pub fn set_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::model::DataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_stats = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Model::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [model_source_info][crate::model::Model::model_source_info].
    pub fn set_model_source_info<
        T: std::convert::Into<std::option::Option<crate::model::ModelSourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_source_info = v.into();
        self
    }

    /// Sets the value of [original_model_info][crate::model::Model::original_model_info].
    pub fn set_original_model_info<
        T: std::convert::Into<std::option::Option<crate::model::model::OriginalModelInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_model_info = v.into();
        self
    }

    /// Sets the value of [metadata_artifact][crate::model::Model::metadata_artifact].
    pub fn set_metadata_artifact<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_artifact = v.into();
        self
    }

    /// Sets the value of [base_model_source][crate::model::Model::base_model_source].
    pub fn set_base_model_source<
        T: std::convert::Into<std::option::Option<crate::model::model::BaseModelSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_model_source = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Model::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Model::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::Model::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_export_formats][crate::model::Model::supported_export_formats].
    pub fn set_supported_export_formats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::ExportFormat>,
    {
        use std::iter::Iterator;
        self.supported_export_formats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_deployment_resources_types][crate::model::Model::supported_deployment_resources_types].
    pub fn set_supported_deployment_resources_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::DeploymentResourcesType>,
    {
        use std::iter::Iterator;
        self.supported_deployment_resources_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_input_storage_formats][crate::model::Model::supported_input_storage_formats].
    pub fn set_supported_input_storage_formats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_input_storage_formats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_output_storage_formats][crate::model::Model::supported_output_storage_formats].
    pub fn set_supported_output_storage_formats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_output_storage_formats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployed_models][crate::model::Model::deployed_models].
    pub fn set_deployed_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModelRef>,
    {
        use std::iter::Iterator;
        self.deployed_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Model::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Model"
    }
}

/// Defines additional types related to [Model].
#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
pub mod model {
    #[allow(unused_imports)]
    use super::*;

    /// Represents export format supported by the Model.
    /// All formats export to Google Cloud Storage.
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExportFormat {
        /// Output only. The ID of the export format.
        /// The possible format IDs are:
        ///
        /// * `tflite`
        ///   Used for Android mobile devices.
        ///
        /// * `edgetpu-tflite`
        ///   Used for [Edge TPU](https://cloud.google.com/edge-tpu/) devices.
        ///
        /// * `tf-saved-model`
        ///   A tensorflow model in SavedModel format.
        ///
        /// * `tf-js`
        ///   A [TensorFlow.js](https://www.tensorflow.org/js) model that can be used
        ///   in the browser and in Node.js using JavaScript.
        ///
        /// * `core-ml`
        ///   Used for iOS mobile devices.
        ///
        /// * `custom-trained`
        ///   A Model that was uploaded or trained by custom code.
        ///
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Output only. The content of this Model that may be exported.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub exportable_contents:
            std::vec::Vec<crate::model::model::export_format::ExportableContent>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl ExportFormat {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::model::ExportFormat::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [exportable_contents][crate::model::model::ExportFormat::exportable_contents].
        pub fn set_exportable_contents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::export_format::ExportableContent>,
        {
            use std::iter::Iterator;
            self.exportable_contents = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for ExportFormat {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.ExportFormat"
        }
    }

    /// Defines additional types related to [ExportFormat].
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    pub mod export_format {
        #[allow(unused_imports)]
        use super::*;

        /// The Model content that can be exported.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ExportableContent {
            /// Should not be used.
            Unspecified,
            /// Model artifact and any of its supported files. Will be exported to the
            /// location specified by the `artifactDestination` field of the
            /// [ExportModelRequest.output_config][google.cloud.aiplatform.v1.ExportModelRequest.output_config]
            /// object.
            ///
            /// [google.cloud.aiplatform.v1.ExportModelRequest.output_config]: crate::model::ExportModelRequest::output_config
            Artifact,
            /// The container image that is to be used when deploying this Model. Will
            /// be exported to the location specified by the `imageDestination` field
            /// of the
            /// [ExportModelRequest.output_config][google.cloud.aiplatform.v1.ExportModelRequest.output_config]
            /// object.
            ///
            /// [google.cloud.aiplatform.v1.ExportModelRequest.output_config]: crate::model::ExportModelRequest::output_config
            Image,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ExportableContent::value] or
            /// [ExportableContent::name].
            UnknownValue(exportable_content::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        pub mod exportable_content {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl ExportableContent {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Artifact => std::option::Option::Some(1),
                    Self::Image => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("EXPORTABLE_CONTENT_UNSPECIFIED")
                    }
                    Self::Artifact => std::option::Option::Some("ARTIFACT"),
                    Self::Image => std::option::Option::Some("IMAGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::default::Default for ExportableContent {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::fmt::Display for ExportableContent {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::convert::From<i32> for ExportableContent {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Artifact,
                    2 => Self::Image,
                    _ => Self::UnknownValue(exportable_content::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl std::convert::From<&str> for ExportableContent {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "EXPORTABLE_CONTENT_UNSPECIFIED" => Self::Unspecified,
                    "ARTIFACT" => Self::Artifact,
                    "IMAGE" => Self::Image,
                    _ => Self::UnknownValue(exportable_content::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl serde::ser::Serialize for ExportableContent {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Artifact => serializer.serialize_i32(1),
                    Self::Image => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        impl<'de> serde::de::Deserialize<'de> for ExportableContent {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExportableContent>::new(
                    ".google.cloud.aiplatform.v1.Model.ExportFormat.ExportableContent",
                ))
            }
        }
    }

    /// Stats of data used for train or evaluate the Model.
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataStats {
        /// Number of DataItems that were used for training this Model.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub training_data_items_count: i64,

        /// Number of DataItems that were used for validating this Model during
        /// training.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub validation_data_items_count: i64,

        /// Number of DataItems that were used for evaluating this Model. If the
        /// Model is evaluated multiple times, this will be the number of test
        /// DataItems used by the first evaluation. If the Model is not evaluated,
        /// the number is 0.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub test_data_items_count: i64,

        /// Number of Annotations that are used for training this Model.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub training_annotations_count: i64,

        /// Number of Annotations that are used for validating this Model during
        /// training.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub validation_annotations_count: i64,

        /// Number of Annotations that are used for evaluating this Model. If the
        /// Model is evaluated multiple times, this will be the number of test
        /// Annotations used by the first evaluation. If the Model is not evaluated,
        /// the number is 0.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub test_annotations_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl DataStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_data_items_count][crate::model::model::DataStats::training_data_items_count].
        pub fn set_training_data_items_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.training_data_items_count = v.into();
            self
        }

        /// Sets the value of [validation_data_items_count][crate::model::model::DataStats::validation_data_items_count].
        pub fn set_validation_data_items_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.validation_data_items_count = v.into();
            self
        }

        /// Sets the value of [test_data_items_count][crate::model::model::DataStats::test_data_items_count].
        pub fn set_test_data_items_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.test_data_items_count = v.into();
            self
        }

        /// Sets the value of [training_annotations_count][crate::model::model::DataStats::training_annotations_count].
        pub fn set_training_annotations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.training_annotations_count = v.into();
            self
        }

        /// Sets the value of [validation_annotations_count][crate::model::model::DataStats::validation_annotations_count].
        pub fn set_validation_annotations_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.validation_annotations_count = v.into();
            self
        }

        /// Sets the value of [test_annotations_count][crate::model::model::DataStats::test_annotations_count].
        pub fn set_test_annotations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.test_annotations_count = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for DataStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.DataStats"
        }
    }

    /// Contains information about the original Model if this Model is a copy.
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OriginalModelInfo {
        /// Output only. The resource name of the Model this Model is a copy of,
        /// including the revision. Format:
        /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl OriginalModelInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::model::OriginalModelInfo::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for OriginalModelInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.OriginalModelInfo"
        }
    }

    /// User input field to specify the base model source. Currently it only
    /// supports specifing the Model Garden models and Genie models.
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BaseModelSource {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::model::base_model_source::Source>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl BaseModelSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::model::BaseModelSource::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<std::option::Option<crate::model::model::base_model_source::Source>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::model::BaseModelSource::source]
        /// if it holds a `ModelGardenSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn model_garden_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::ModelGardenSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::model::base_model_source::Source::ModelGardenSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [source][crate::model::model::BaseModelSource::source]
        /// if it holds a `GenieSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn genie_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GenieSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::model::base_model_source::Source::GenieSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::model::BaseModelSource::source]
        /// to hold a `ModelGardenSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_model_garden_source<
            T: std::convert::Into<std::boxed::Box<crate::model::ModelGardenSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::model::base_model_source::Source::ModelGardenSource(v.into()),
            );
            self
        }

        /// Sets the value of [source][crate::model::model::BaseModelSource::source]
        /// to hold a `GenieSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_genie_source<
            T: std::convert::Into<std::boxed::Box<crate::model::GenieSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::model::base_model_source::Source::GenieSource(v.into()),
            );
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for BaseModelSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.BaseModelSource"
        }
    }

    /// Defines additional types related to [BaseModelSource].
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    pub mod base_model_source {
        #[allow(unused_imports)]
        use super::*;

        #[cfg(any(
            feature = "dataset_service",
            feature = "model_service",
            feature = "pipeline_service",
        ))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// Source information of Model Garden models.
            ModelGardenSource(std::boxed::Box<crate::model::ModelGardenSource>),
            /// Information about the base model of Genie models.
            GenieSource(std::boxed::Box<crate::model::GenieSource>),
        }
    }

    /// Identifies a type of Model's prediction resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeploymentResourcesType {
        /// Should not be used.
        Unspecified,
        /// Resources that are dedicated to the
        /// [DeployedModel][google.cloud.aiplatform.v1.DeployedModel], and that need
        /// a higher degree of manual configuration.
        ///
        /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
        DedicatedResources,
        /// Resources that to large degree are decided by Vertex AI, and require
        /// only a modest additional configuration.
        AutomaticResources,
        /// Resources that can be shared by multiple
        /// [DeployedModels][google.cloud.aiplatform.v1.DeployedModel]. A
        /// pre-configured
        /// [DeploymentResourcePool][google.cloud.aiplatform.v1.DeploymentResourcePool]
        /// is required.
        ///
        /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
        /// [google.cloud.aiplatform.v1.DeploymentResourcePool]: crate::model::DeploymentResourcePool
        SharedResources,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeploymentResourcesType::value] or
        /// [DeploymentResourcesType::name].
        UnknownValue(deployment_resources_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    pub mod deployment_resources_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl DeploymentResourcesType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DedicatedResources => std::option::Option::Some(1),
                Self::AutomaticResources => std::option::Option::Some(2),
                Self::SharedResources => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED")
                }
                Self::DedicatedResources => std::option::Option::Some("DEDICATED_RESOURCES"),
                Self::AutomaticResources => std::option::Option::Some("AUTOMATIC_RESOURCES"),
                Self::SharedResources => std::option::Option::Some("SHARED_RESOURCES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::default::Default for DeploymentResourcesType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::fmt::Display for DeploymentResourcesType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::convert::From<i32> for DeploymentResourcesType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DedicatedResources,
                2 => Self::AutomaticResources,
                3 => Self::SharedResources,
                _ => Self::UnknownValue(deployment_resources_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::convert::From<&str> for DeploymentResourcesType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DEDICATED_RESOURCES" => Self::DedicatedResources,
                "AUTOMATIC_RESOURCES" => Self::AutomaticResources,
                "SHARED_RESOURCES" => Self::SharedResources,
                _ => Self::UnknownValue(deployment_resources_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl serde::ser::Serialize for DeploymentResourcesType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DedicatedResources => serializer.serialize_i32(1),
                Self::AutomaticResources => serializer.serialize_i32(2),
                Self::SharedResources => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for DeploymentResourcesType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<DeploymentResourcesType>::new(
                    ".google.cloud.aiplatform.v1.Model.DeploymentResourcesType",
                ),
            )
        }
    }
}

/// Contains information about the Large Model.
#[cfg(feature = "model_garden_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LargeModelReference {
    /// Required. The unique name of the large Foundation or pre-built model. Like
    /// "chat-bison", "text-bison". Or model name with version ID, like
    /// "chat-bison@001", "text-bison@005", etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_garden_service")]
impl LargeModelReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LargeModelReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "model_garden_service")]
impl wkt::message::Message for LargeModelReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LargeModelReference"
    }
}

/// Contains information about the source of the models generated from Model
/// Garden.
#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelGardenSource {
    /// Required. The model garden source model resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_model_name: std::string::String,

    /// Optional. The model garden source model version ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_id: std::string::String,

    /// Optional. Whether to avoid pulling the model from the HF cache.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_hf_model_cache: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl ModelGardenSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_model_name][crate::model::ModelGardenSource::public_model_name].
    pub fn set_public_model_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_model_name = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::ModelGardenSource::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [skip_hf_model_cache][crate::model::ModelGardenSource::skip_hf_model_cache].
    pub fn set_skip_hf_model_cache<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_hf_model_cache = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for ModelGardenSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelGardenSource"
    }
}

/// Contains information about the source of the models generated from Generative
/// AI Studio.
#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenieSource {
    /// Required. The public base model URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_model_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl GenieSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_model_uri][crate::model::GenieSource::base_model_uri].
    pub fn set_base_model_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_model_uri = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for GenieSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenieSource"
    }
}

/// Contains the schemata used in Model's predictions and explanations via
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict],
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain]
/// and [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
/// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictSchemata {
    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// the format of a single instance, which are used in
    /// [PredictRequest.instances][google.cloud.aiplatform.v1.PredictRequest.instances],
    /// [ExplainRequest.instances][google.cloud.aiplatform.v1.ExplainRequest.instances]
    /// and
    /// [BatchPredictionJob.input_config][google.cloud.aiplatform.v1.BatchPredictionJob.input_config].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.input_config]: crate::model::BatchPredictionJob::input_config
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.PredictRequest.instances]: crate::model::PredictRequest::instances
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_schema_uri: std::string::String,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// the parameters of prediction and explanation via
    /// [PredictRequest.parameters][google.cloud.aiplatform.v1.PredictRequest.parameters],
    /// [ExplainRequest.parameters][google.cloud.aiplatform.v1.ExplainRequest.parameters]
    /// and
    /// [BatchPredictionJob.model_parameters][google.cloud.aiplatform.v1.BatchPredictionJob.model_parameters].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI, if no
    /// parameters are supported, then it is set to an empty string.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model_parameters]: crate::model::BatchPredictionJob::model_parameters
    /// [google.cloud.aiplatform.v1.ExplainRequest.parameters]: crate::model::ExplainRequest::parameters
    /// [google.cloud.aiplatform.v1.PredictRequest.parameters]: crate::model::PredictRequest::parameters
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parameters_schema_uri: std::string::String,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// the format of a single prediction produced by this Model, which are
    /// returned via
    /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions],
    /// [ExplainResponse.explanations][google.cloud.aiplatform.v1.ExplainResponse.explanations],
    /// and
    /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    /// [google.cloud.aiplatform.v1.ExplainResponse.explanations]: crate::model::ExplainResponse::explanations
    /// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub prediction_schema_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl PredictSchemata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_schema_uri][crate::model::PredictSchemata::instance_schema_uri].
    pub fn set_instance_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_schema_uri = v.into();
        self
    }

    /// Sets the value of [parameters_schema_uri][crate::model::PredictSchemata::parameters_schema_uri].
    pub fn set_parameters_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters_schema_uri = v.into();
        self
    }

    /// Sets the value of [prediction_schema_uri][crate::model::PredictSchemata::prediction_schema_uri].
    pub fn set_prediction_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_schema_uri = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for PredictSchemata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictSchemata"
    }
}

/// Specification of a container for serving predictions. Some fields in this
/// message correspond to fields in the [Kubernetes Container v1 core
/// specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelContainerSpec {
    /// Required. Immutable. URI of the Docker image to be used as the custom
    /// container for serving predictions. This URI must identify an image in
    /// Artifact Registry or Container Registry. Learn more about the [container
    /// publishing
    /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
    /// including permissions requirements for the Vertex AI Service Agent.
    ///
    /// The container image is ingested upon
    /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel],
    /// stored internally, and this original path is afterwards not used.
    ///
    /// To learn about the requirements for the Docker image itself, see
    /// [Custom container
    /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
    ///
    /// You can use the URI to one of Vertex AI's [pre-built container images for
    /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
    /// in this field.
    ///
    /// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Immutable. Specifies the command that runs when the container starts. This
    /// overrides the container's
    /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
    /// Specify this field as an array of executable and arguments, similar to a
    /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form.
    ///
    /// If you do not specify this field, then the container's `ENTRYPOINT` runs,
    /// in conjunction with the
    /// [args][google.cloud.aiplatform.v1.ModelContainerSpec.args] field or the
    /// container's [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
    /// if either exists. If this field is not specified and the container does not
    /// have an `ENTRYPOINT`, then refer to the Docker documentation about [how
    /// `CMD` and `ENTRYPOINT`
    /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
    ///
    /// If you specify this field, then you can also specify the `args` field to
    /// provide additional arguments for this command. However, if you specify this
    /// field, then the container's `CMD` is ignored. See the
    /// [Kubernetes documentation about how the
    /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
    /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
    ///
    /// In this field, you can reference [environment variables set by Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
    /// and environment variables set in the
    /// [env][google.cloud.aiplatform.v1.ModelContainerSpec.env] field. You cannot
    /// reference environment variables set in the Docker image. In order for
    /// environment variables to be expanded, reference them by using the following
    /// syntax: \<code\>$(\<var\>VARIABLE_NAME\</var\>)\</code\> Note that this differs
    /// from Bash variable expansion, which does not use parentheses. If a variable
    /// cannot be resolved, the reference in the input string is used unchanged. To
    /// avoid variable expansion, you can escape this syntax with `$$`; for
    /// example: \<code\>$$(\<var\>VARIABLE_NAME\</var\>)\</code\> This field corresponds
    /// to the `command` field of the Kubernetes Containers [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    ///
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.args]: crate::model::ModelContainerSpec::args
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.env]: crate::model::ModelContainerSpec::env
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub command: std::vec::Vec<std::string::String>,

    /// Immutable. Specifies arguments for the command that runs when the container
    /// starts. This overrides the container's
    /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
    /// this field as an array of executable and arguments, similar to a Docker
    /// `CMD`'s "default parameters" form.
    ///
    /// If you don't specify this field but do specify the
    /// [command][google.cloud.aiplatform.v1.ModelContainerSpec.command] field,
    /// then the command from the `command` field runs without any additional
    /// arguments. See the [Kubernetes documentation about how the `command` and
    /// `args` fields interact with a container's `ENTRYPOINT` and
    /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
    ///
    /// If you don't specify this field and don't specify the `command` field,
    /// then the container's
    /// [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
    /// `CMD` determine what runs based on their default behavior. See the Docker
    /// documentation about [how `CMD` and `ENTRYPOINT`
    /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
    ///
    /// In this field, you can reference [environment variables
    /// set by Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
    /// and environment variables set in the
    /// [env][google.cloud.aiplatform.v1.ModelContainerSpec.env] field. You cannot
    /// reference environment variables set in the Docker image. In order for
    /// environment variables to be expanded, reference them by using the following
    /// syntax: \<code\>$(\<var\>VARIABLE_NAME\</var\>)\</code\> Note that this differs
    /// from Bash variable expansion, which does not use parentheses. If a variable
    /// cannot be resolved, the reference in the input string is used unchanged. To
    /// avoid variable expansion, you can escape this syntax with `$$`; for
    /// example: \<code\>$$(\<var\>VARIABLE_NAME\</var\>)\</code\> This field corresponds
    /// to the `args` field of the Kubernetes Containers [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    ///
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.command]: crate::model::ModelContainerSpec::command
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.env]: crate::model::ModelContainerSpec::env
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Immutable. List of environment variables to set in the container. After the
    /// container starts running, code running in the container can read these
    /// environment variables.
    ///
    /// Additionally, the
    /// [command][google.cloud.aiplatform.v1.ModelContainerSpec.command] and
    /// [args][google.cloud.aiplatform.v1.ModelContainerSpec.args] fields can
    /// reference these variables. Later entries in this list can also reference
    /// earlier entries. For example, the following example sets the variable
    /// `VAR_2` to have the value `foo bar`:
    ///
    /// ```norust
    /// [
    ///   {
    ///     "name": "VAR_1",
    ///     "value": "foo"
    ///   },
    ///   {
    ///     "name": "VAR_2",
    ///     "value": "$(VAR_1) bar"
    ///   }
    /// ]
    /// ```
    ///
    /// If you switch the order of the variables in the example, then the expansion
    /// does not occur.
    ///
    /// This field corresponds to the `env` field of the Kubernetes Containers
    /// [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    ///
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.args]: crate::model::ModelContainerSpec::args
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.command]: crate::model::ModelContainerSpec::command
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    /// Immutable. List of ports to expose from the container. Vertex AI sends any
    /// prediction requests that it receives to the first port on this list. Vertex
    /// AI also sends
    /// [liveness and health
    /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
    /// to this port.
    ///
    /// If you do not specify this field, it defaults to following value:
    ///
    /// ```norust
    /// [
    ///   {
    ///     "containerPort": 8080
    ///   }
    /// ]
    /// ```
    ///
    /// Vertex AI does not use ports other than the first one listed. This field
    /// corresponds to the `ports` field of the Kubernetes Containers
    /// [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ports: std::vec::Vec<crate::model::Port>,

    /// Immutable. HTTP path on the container to send prediction requests to.
    /// Vertex AI forwards requests sent using
    /// [projects.locations.endpoints.predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// to this path on the container's IP address and port. Vertex AI then returns
    /// the container's response in the API response.
    ///
    /// For example, if you set this field to `/foo`, then when Vertex AI
    /// receives a prediction request, it forwards the request body in a POST
    /// request to the `/foo` path on the port of your container specified by the
    /// first value of this `ModelContainerSpec`'s
    /// [ports][google.cloud.aiplatform.v1.ModelContainerSpec.ports] field.
    ///
    /// If you don't specify this field, it defaults to the following value when
    /// you [deploy this Model to an
    /// Endpoint][google.cloud.aiplatform.v1.EndpointService.DeployModel]:
    /// \<code\>/v1/endpoints/\<var\>ENDPOINT\</var\>/deployedModels/\<var\>DEPLOYED_MODEL\</var\>:predict\</code\>
    /// The placeholders in this value are replaced as follows:
    ///
    /// * \<var\>ENDPOINT\</var\>: The last segment (following `endpoints/`)of the
    ///   Endpoint.name][] field of the Endpoint where this Model has been
    ///   deployed. (Vertex AI makes this value available to your container code
    ///   as the [`AIP_ENDPOINT_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    /// * \<var\>DEPLOYED_MODEL\</var\>:
    ///   [DeployedModel.id][google.cloud.aiplatform.v1.DeployedModel.id] of the
    ///   `DeployedModel`.
    ///   (Vertex AI makes this value available to your container code
    ///   as the [`AIP_DEPLOYED_MODEL_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.id]: crate::model::DeployedModel::id
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.ports]: crate::model::ModelContainerSpec::ports
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predict_route: std::string::String,

    /// Immutable. HTTP path on the container to send health checks to. Vertex AI
    /// intermittently sends GET requests to this path on the container's IP
    /// address and port to check that the container is healthy. Read more about
    /// [health
    /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
    ///
    /// For example, if you set this field to `/bar`, then Vertex AI
    /// intermittently sends a GET request to the `/bar` path on the port of your
    /// container specified by the first value of this `ModelContainerSpec`'s
    /// [ports][google.cloud.aiplatform.v1.ModelContainerSpec.ports] field.
    ///
    /// If you don't specify this field, it defaults to the following value when
    /// you [deploy this Model to an
    /// Endpoint][google.cloud.aiplatform.v1.EndpointService.DeployModel]:
    /// \<code\>/v1/endpoints/\<var\>ENDPOINT\</var\>/deployedModels/\<var\>DEPLOYED_MODEL\</var\>:predict\</code\>
    /// The placeholders in this value are replaced as follows:
    ///
    /// * \<var\>ENDPOINT\</var\>: The last segment (following `endpoints/`)of the
    ///   Endpoint.name][] field of the Endpoint where this Model has been
    ///   deployed. (Vertex AI makes this value available to your container code
    ///   as the [`AIP_ENDPOINT_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    /// * \<var\>DEPLOYED_MODEL\</var\>:
    ///   [DeployedModel.id][google.cloud.aiplatform.v1.DeployedModel.id] of the
    ///   `DeployedModel`.
    ///   (Vertex AI makes this value available to your container code as the
    ///   [`AIP_DEPLOYED_MODEL_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.id]: crate::model::DeployedModel::id
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.ports]: crate::model::ModelContainerSpec::ports
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_route: std::string::String,

    /// Immutable. List of ports to expose from the container. Vertex AI sends gRPC
    /// prediction requests that it receives to the first port on this list. Vertex
    /// AI also sends liveness and health checks to this port.
    ///
    /// If you do not specify this field, gRPC requests to the container will be
    /// disabled.
    ///
    /// Vertex AI does not use ports other than the first one listed. This field
    /// corresponds to the `ports` field of the Kubernetes Containers v1 core API.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grpc_ports: std::vec::Vec<crate::model::Port>,

    /// Immutable. Deployment timeout.
    /// Limit for deployment timeout is 2 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_timeout: std::option::Option<wkt::Duration>,

    /// Immutable. The amount of the VM memory to reserve as the shared memory for
    /// the model in megabytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub shared_memory_size_mb: i64,

    /// Immutable. Specification for Kubernetes startup probe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub startup_probe: std::option::Option<crate::model::Probe>,

    /// Immutable. Specification for Kubernetes readiness probe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub health_probe: std::option::Option<crate::model::Probe>,

    /// Immutable. Specification for Kubernetes liveness probe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub liveness_probe: std::option::Option<crate::model::Probe>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl ModelContainerSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_uri][crate::model::ModelContainerSpec::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [predict_route][crate::model::ModelContainerSpec::predict_route].
    pub fn set_predict_route<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predict_route = v.into();
        self
    }

    /// Sets the value of [health_route][crate::model::ModelContainerSpec::health_route].
    pub fn set_health_route<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.health_route = v.into();
        self
    }

    /// Sets the value of [deployment_timeout][crate::model::ModelContainerSpec::deployment_timeout].
    pub fn set_deployment_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_timeout = v.into();
        self
    }

    /// Sets the value of [shared_memory_size_mb][crate::model::ModelContainerSpec::shared_memory_size_mb].
    pub fn set_shared_memory_size_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shared_memory_size_mb = v.into();
        self
    }

    /// Sets the value of [startup_probe][crate::model::ModelContainerSpec::startup_probe].
    pub fn set_startup_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.startup_probe = v.into();
        self
    }

    /// Sets the value of [health_probe][crate::model::ModelContainerSpec::health_probe].
    pub fn set_health_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_probe = v.into();
        self
    }

    /// Sets the value of [liveness_probe][crate::model::ModelContainerSpec::liveness_probe].
    pub fn set_liveness_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.liveness_probe = v.into();
        self
    }

    /// Sets the value of [command][crate::model::ModelContainerSpec::command].
    pub fn set_command<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.command = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::ModelContainerSpec::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::ModelContainerSpec::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ports][crate::model::ModelContainerSpec::ports].
    pub fn set_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Port>,
    {
        use std::iter::Iterator;
        self.ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grpc_ports][crate::model::ModelContainerSpec::grpc_ports].
    pub fn set_grpc_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Port>,
    {
        use std::iter::Iterator;
        self.grpc_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for ModelContainerSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelContainerSpec"
    }
}

/// Represents a network port in a container.
#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Port {
    /// The number of the port to expose on the pod's IP address.
    /// Must be a valid port number, between 1 and 65535 inclusive.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub container_port: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl Port {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_port][crate::model::Port::container_port].
    pub fn set_container_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.container_port = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for Port {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Port"
    }
}

/// Detail description of the source information of the model.
#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelSourceInfo {
    /// Type of the model source.
    pub source_type: crate::model::model_source_info::ModelSourceType,

    /// If this Model is copy of another Model. If true then
    /// [source_type][google.cloud.aiplatform.v1.ModelSourceInfo.source_type]
    /// pertains to the original.
    ///
    /// [google.cloud.aiplatform.v1.ModelSourceInfo.source_type]: crate::model::ModelSourceInfo::source_type
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub copy: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl ModelSourceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::ModelSourceInfo::source_type].
    pub fn set_source_type<
        T: std::convert::Into<crate::model::model_source_info::ModelSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::ModelSourceInfo::copy].
    pub fn set_copy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.copy = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for ModelSourceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelSourceInfo"
    }
}

/// Defines additional types related to [ModelSourceInfo].
#[cfg(any(
    feature = "dataset_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
pub mod model_source_info {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the model.
    /// Different from `objective` field, this `ModelSourceType` enum
    /// indicates the source from which the model was accessed or obtained,
    /// whereas the `objective` indicates the overall aim or function of this
    /// model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelSourceType {
        /// Should not be used.
        Unspecified,
        /// The Model is uploaded by automl training pipeline.
        Automl,
        /// The Model is uploaded by user or custom training pipeline.
        Custom,
        /// The Model is registered and sync'ed from BigQuery ML.
        Bqml,
        /// The Model is saved or tuned from Model Garden.
        ModelGarden,
        /// The Model is saved or tuned from Genie.
        Genie,
        /// The Model is uploaded by text embedding finetuning pipeline.
        CustomTextEmbedding,
        /// The Model is saved or tuned from Marketplace.
        Marketplace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelSourceType::value] or
        /// [ModelSourceType::name].
        UnknownValue(model_source_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    pub mod model_source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl ModelSourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automl => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::Bqml => std::option::Option::Some(3),
                Self::ModelGarden => std::option::Option::Some(4),
                Self::Genie => std::option::Option::Some(5),
                Self::CustomTextEmbedding => std::option::Option::Some(6),
                Self::Marketplace => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_SOURCE_TYPE_UNSPECIFIED"),
                Self::Automl => std::option::Option::Some("AUTOML"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::Bqml => std::option::Option::Some("BQML"),
                Self::ModelGarden => std::option::Option::Some("MODEL_GARDEN"),
                Self::Genie => std::option::Option::Some("GENIE"),
                Self::CustomTextEmbedding => std::option::Option::Some("CUSTOM_TEXT_EMBEDDING"),
                Self::Marketplace => std::option::Option::Some("MARKETPLACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::default::Default for ModelSourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::fmt::Display for ModelSourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::convert::From<i32> for ModelSourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automl,
                2 => Self::Custom,
                3 => Self::Bqml,
                4 => Self::ModelGarden,
                5 => Self::Genie,
                6 => Self::CustomTextEmbedding,
                7 => Self::Marketplace,
                _ => Self::UnknownValue(model_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl std::convert::From<&str> for ModelSourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOML" => Self::Automl,
                "CUSTOM" => Self::Custom,
                "BQML" => Self::Bqml,
                "MODEL_GARDEN" => Self::ModelGarden,
                "GENIE" => Self::Genie,
                "CUSTOM_TEXT_EMBEDDING" => Self::CustomTextEmbedding,
                "MARKETPLACE" => Self::Marketplace,
                _ => Self::UnknownValue(model_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl serde::ser::Serialize for ModelSourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automl => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::Bqml => serializer.serialize_i32(3),
                Self::ModelGarden => serializer.serialize_i32(4),
                Self::Genie => serializer.serialize_i32(5),
                Self::CustomTextEmbedding => serializer.serialize_i32(6),
                Self::Marketplace => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ModelSourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelSourceType>::new(
                ".google.cloud.aiplatform.v1.ModelSourceInfo.ModelSourceType",
            ))
        }
    }
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Probe {
    /// How often (in seconds) to perform the probe. Default to 10 seconds.
    /// Minimum value is 1. Must be less than timeout_seconds.
    ///
    /// Maps to Kubernetes probe argument 'periodSeconds'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub period_seconds: i32,

    /// Number of seconds after which the probe times out. Defaults to 1 second.
    /// Minimum value is 1. Must be greater or equal to period_seconds.
    ///
    /// Maps to Kubernetes probe argument 'timeoutSeconds'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub timeout_seconds: i32,

    /// Number of consecutive failures before the probe is considered failed.
    /// Defaults to 3. Minimum value is 1.
    ///
    /// Maps to Kubernetes probe argument 'failureThreshold'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub failure_threshold: i32,

    /// Number of consecutive successes before the probe is considered successful.
    /// Defaults to 1. Minimum value is 1.
    ///
    /// Maps to Kubernetes probe argument 'successThreshold'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub success_threshold: i32,

    /// Number of seconds to wait before starting the probe. Defaults to 0.
    /// Minimum value is 0.
    ///
    /// Maps to Kubernetes probe argument 'initialDelaySeconds'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub initial_delay_seconds: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub probe_type: std::option::Option<crate::model::probe::ProbeType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl Probe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [period_seconds][crate::model::Probe::period_seconds].
    pub fn set_period_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.period_seconds = v.into();
        self
    }

    /// Sets the value of [timeout_seconds][crate::model::Probe::timeout_seconds].
    pub fn set_timeout_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_seconds = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::Probe::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::Probe::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [initial_delay_seconds][crate::model::Probe::initial_delay_seconds].
    pub fn set_initial_delay_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_delay_seconds = v.into();
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type].
    ///
    /// Note that all the setters affecting `probe_type` are mutually
    /// exclusive.
    pub fn set_probe_type<
        T: std::convert::Into<std::option::Option<crate::model::probe::ProbeType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = v.into();
        self
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `Exec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exec(&self) -> std::option::Option<&std::boxed::Box<crate::model::probe::ExecAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::Exec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `HttpGet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_get(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::probe::HttpGetAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::HttpGet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `Grpc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn grpc(&self) -> std::option::Option<&std::boxed::Box<crate::model::probe::GrpcAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::Grpc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `TcpSocket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tcp_socket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::probe::TcpSocketAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::TcpSocket(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `Exec`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_exec<T: std::convert::Into<std::boxed::Box<crate::model::probe::ExecAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = std::option::Option::Some(crate::model::probe::ProbeType::Exec(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `HttpGet`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_http_get<
        T: std::convert::Into<std::boxed::Box<crate::model::probe::HttpGetAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::HttpGet(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `Grpc`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_grpc<T: std::convert::Into<std::boxed::Box<crate::model::probe::GrpcAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = std::option::Option::Some(crate::model::probe::ProbeType::Grpc(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `TcpSocket`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_tcp_socket<
        T: std::convert::Into<std::boxed::Box<crate::model::probe::TcpSocketAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::TcpSocket(v.into()));
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
impl wkt::message::Message for Probe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Probe"
    }
}

/// Defines additional types related to [Probe].
#[cfg(any(
    feature = "dataset_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "model_service",
    feature = "pipeline_service",
))]
pub mod probe {
    #[allow(unused_imports)]
    use super::*;

    /// ExecAction specifies a command to execute.
    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExecAction {
        /// Command is the command line to execute inside the container, the working
        /// directory for the command is root ('/') in the container's filesystem.
        /// The command is simply exec'd, it is not run inside a shell, so
        /// traditional shell instructions ('|', etc) won't work. To use a shell, you
        /// need to explicitly call out to that shell. Exit status of 0 is treated as
        /// live/healthy and non-zero is unhealthy.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub command: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl ExecAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [command][crate::model::probe::ExecAction::command].
        pub fn set_command<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.command = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for ExecAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.ExecAction"
        }
    }

    /// HttpGetAction describes an action based on HTTP Get requests.
    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpGetAction {
        /// Path to access on the HTTP server.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        /// Number of the port to access on the container.
        /// Number must be in the range 1 to 65535.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub port: i32,

        /// Host name to connect to, defaults to the model serving container's IP.
        /// You probably want to set "Host" in httpHeaders instead.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub host: std::string::String,

        /// Scheme to use for connecting to the host.
        /// Defaults to HTTP. Acceptable values are "HTTP" or "HTTPS".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub scheme: std::string::String,

        /// Custom headers to set in the request. HTTP allows repeated headers.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub http_headers: std::vec::Vec<crate::model::probe::HttpHeader>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl HttpGetAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::probe::HttpGetAction::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [port][crate::model::probe::HttpGetAction::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [host][crate::model::probe::HttpGetAction::host].
        pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.host = v.into();
            self
        }

        /// Sets the value of [scheme][crate::model::probe::HttpGetAction::scheme].
        pub fn set_scheme<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scheme = v.into();
            self
        }

        /// Sets the value of [http_headers][crate::model::probe::HttpGetAction::http_headers].
        pub fn set_http_headers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::probe::HttpHeader>,
        {
            use std::iter::Iterator;
            self.http_headers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for HttpGetAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.HttpGetAction"
        }
    }

    /// GrpcAction checks the health of a container using a gRPC service.
    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GrpcAction {
        /// Port number of the gRPC service. Number must be in the range 1 to 65535.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub port: i32,

        /// Service is the name of the service to place in the gRPC
        /// HealthCheckRequest (see
        /// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>).
        ///
        /// If this is not specified, the default behavior is defined by gRPC.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl GrpcAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [port][crate::model::probe::GrpcAction::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [service][crate::model::probe::GrpcAction::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for GrpcAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.GrpcAction"
        }
    }

    /// TcpSocketAction probes the health of a container by opening a TCP socket
    /// connection.
    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TcpSocketAction {
        /// Number of the port to access on the container.
        /// Number must be in the range 1 to 65535.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub port: i32,

        /// Optional: Host name to connect to, defaults to the model serving
        /// container's IP.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub host: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl TcpSocketAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [port][crate::model::probe::TcpSocketAction::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [host][crate::model::probe::TcpSocketAction::host].
        pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.host = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for TcpSocketAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.TcpSocketAction"
        }
    }

    /// HttpHeader describes a custom header to be used in HTTP probes
    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpHeader {
        /// The header field name.
        /// This will be canonicalized upon output, so case-variant names will be
        /// understood as the same header.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The header field value
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl HttpHeader {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::probe::HttpHeader::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::probe::HttpHeader::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    impl wkt::message::Message for HttpHeader {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.HttpHeader"
        }
    }

    #[cfg(any(
        feature = "dataset_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "model_service",
        feature = "pipeline_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ProbeType {
        /// ExecAction probes the health of a container by executing a command.
        Exec(std::boxed::Box<crate::model::probe::ExecAction>),
        /// HttpGetAction probes the health of a container by sending an HTTP GET
        /// request.
        HttpGet(std::boxed::Box<crate::model::probe::HttpGetAction>),
        /// GrpcAction probes the health of a container by sending a gRPC request.
        Grpc(std::boxed::Box<crate::model::probe::GrpcAction>),
        /// TcpSocketAction probes the health of a container by opening a TCP socket
        /// connection.
        TcpSocket(std::boxed::Box<crate::model::probe::TcpSocketAction>),
    }
}

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint. It will analyze the logged training & prediction data to detect any
/// abnormal behaviors.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringJob {
    /// Output only. Resource name of a ModelDeploymentMonitoringJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the ModelDeploymentMonitoringJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    /// Display name of a ModelDeploymentMonitoringJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Endpoint resource name.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Output only. The detailed state of the monitoring job.
    /// When the job is still creating, the state will be 'PENDING'.
    /// Once the job is successfully created, the state will be 'RUNNING'.
    /// Pause the job, the state will be 'PAUSED'.
    /// Resume the job, the state will return to 'RUNNING'.
    pub state: crate::model::JobState,

    /// Output only. Schedule state when the monitoring job is in Running state.
    pub schedule_state: crate::model::model_deployment_monitoring_job::MonitoringScheduleState,

    /// Output only. Latest triggered monitoring pipeline metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_monitoring_pipeline_metadata: std::option::Option<
        crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata,
    >,

    /// Required. The config for monitoring objectives. This is a per DeployedModel
    /// config. Each DeployedModel needs to be configured separately.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_deployment_monitoring_objective_configs:
        std::vec::Vec<crate::model::ModelDeploymentMonitoringObjectiveConfig>,

    /// Required. Schedule config for running the monitoring job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_deployment_monitoring_schedule_config:
        std::option::Option<crate::model::ModelDeploymentMonitoringScheduleConfig>,

    /// Required. Sample Strategy for logging.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_sampling_strategy: std::option::Option<crate::model::SamplingStrategy>,

    /// Alert config for model monitoring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_monitoring_alert_config:
        std::option::Option<crate::model::ModelMonitoringAlertConfig>,

    /// YAML schema file uri describing the format of a single instance,
    /// which are given to format this Endpoint's prediction (and explanation).
    /// If not set, we will generate predict schema from collected predict
    /// requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predict_instance_schema_uri: std::string::String,

    /// Sample Predict instance, same format as
    /// [PredictRequest.instances][google.cloud.aiplatform.v1.PredictRequest.instances],
    /// this can be set as a replacement of
    /// [ModelDeploymentMonitoringJob.predict_instance_schema_uri][google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri].
    /// If not set, we will generate predict schema from collected predict
    /// requests.
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri]: crate::model::ModelDeploymentMonitoringJob::predict_instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictRequest.instances]: crate::model::PredictRequest::instances
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_predict_instance: std::option::Option<wkt::Value>,

    /// YAML schema file uri describing the format of a single instance that you
    /// want Tensorflow Data Validation (TFDV) to analyze.
    ///
    /// If this field is empty, all the feature data types are inferred from
    /// [predict_instance_schema_uri][google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri],
    /// meaning that TFDV will use the data in the exact format(data type) as
    /// prediction request/response.
    /// If there are any data type differences between predict instance and TFDV
    /// instance, this field can be used to override the schema.
    /// For models trained with Vertex AI, this field must be set as all the
    /// fields in predict instance formatted as string.
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri]: crate::model::ModelDeploymentMonitoringJob::predict_instance_schema_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub analysis_instance_schema_uri: std::string::String,

    /// Output only. The created bigquery tables for the job under customer
    /// project. Customer could do their own query & analysis. There could be 4 log
    /// tables in maximum:
    ///
    /// . Training data logging predict request/response
    /// . Serving data logging predict request/response
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bigquery_tables: std::vec::Vec<crate::model::ModelDeploymentMonitoringBigQueryTable>,

    /// The TTL of BigQuery tables in user projects which stores logs.
    /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
    /// day). e.g. { second: 3600} indicates ttl = 1 day.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub log_ttl: std::option::Option<wkt::Duration>,

    /// The labels with user-defined metadata to organize your
    /// ModelDeploymentMonitoringJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this ModelDeploymentMonitoringJob was updated
    /// most recently.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this monitoring pipeline will be scheduled to
    /// run for the next round.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_schedule_time: std::option::Option<wkt::Timestamp>,

    /// Stats anomalies base folder path.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stats_anomalies_base_directory: std::option::Option<crate::model::GcsDestination>,

    /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If
    /// set, this ModelDeploymentMonitoringJob and all sub-resources of this
    /// ModelDeploymentMonitoringJob will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// If true, the scheduled monitoring pipeline logs are sent to
    /// Google Cloud Logging, including pipeline status and anomalies detected.
    /// Please note the logs incur cost, which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging#pricing).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_monitoring_pipeline_logs: bool,

    /// Output only. Only populated when the job's state is `JOB_STATE_FAILED` or
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelDeploymentMonitoringJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModelDeploymentMonitoringJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ModelDeploymentMonitoringJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::ModelDeploymentMonitoringJob::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ModelDeploymentMonitoringJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schedule_state][crate::model::ModelDeploymentMonitoringJob::schedule_state].
    pub fn set_schedule_state<
        T: std::convert::Into<crate::model::model_deployment_monitoring_job::MonitoringScheduleState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_state = v.into();
        self
    }

    /// Sets the value of [latest_monitoring_pipeline_metadata][crate::model::ModelDeploymentMonitoringJob::latest_monitoring_pipeline_metadata].
    pub fn set_latest_monitoring_pipeline_metadata<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_monitoring_pipeline_metadata = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_schedule_config][crate::model::ModelDeploymentMonitoringJob::model_deployment_monitoring_schedule_config].
    pub fn set_model_deployment_monitoring_schedule_config<
        T: std::convert::Into<
                std::option::Option<crate::model::ModelDeploymentMonitoringScheduleConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_schedule_config = v.into();
        self
    }

    /// Sets the value of [logging_sampling_strategy][crate::model::ModelDeploymentMonitoringJob::logging_sampling_strategy].
    pub fn set_logging_sampling_strategy<
        T: std::convert::Into<std::option::Option<crate::model::SamplingStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_sampling_strategy = v.into();
        self
    }

    /// Sets the value of [model_monitoring_alert_config][crate::model::ModelDeploymentMonitoringJob::model_monitoring_alert_config].
    pub fn set_model_monitoring_alert_config<
        T: std::convert::Into<std::option::Option<crate::model::ModelMonitoringAlertConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_monitoring_alert_config = v.into();
        self
    }

    /// Sets the value of [predict_instance_schema_uri][crate::model::ModelDeploymentMonitoringJob::predict_instance_schema_uri].
    pub fn set_predict_instance_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predict_instance_schema_uri = v.into();
        self
    }

    /// Sets the value of [sample_predict_instance][crate::model::ModelDeploymentMonitoringJob::sample_predict_instance].
    pub fn set_sample_predict_instance<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sample_predict_instance = v.into();
        self
    }

    /// Sets the value of [analysis_instance_schema_uri][crate::model::ModelDeploymentMonitoringJob::analysis_instance_schema_uri].
    pub fn set_analysis_instance_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_instance_schema_uri = v.into();
        self
    }

    /// Sets the value of [log_ttl][crate::model::ModelDeploymentMonitoringJob::log_ttl].
    pub fn set_log_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.log_ttl = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ModelDeploymentMonitoringJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ModelDeploymentMonitoringJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [next_schedule_time][crate::model::ModelDeploymentMonitoringJob::next_schedule_time].
    pub fn set_next_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_schedule_time = v.into();
        self
    }

    /// Sets the value of [stats_anomalies_base_directory][crate::model::ModelDeploymentMonitoringJob::stats_anomalies_base_directory].
    pub fn set_stats_anomalies_base_directory<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stats_anomalies_base_directory = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::ModelDeploymentMonitoringJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [enable_monitoring_pipeline_logs][crate::model::ModelDeploymentMonitoringJob::enable_monitoring_pipeline_logs].
    pub fn set_enable_monitoring_pipeline_logs<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_monitoring_pipeline_logs = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ModelDeploymentMonitoringJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ModelDeploymentMonitoringJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ModelDeploymentMonitoringJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_objective_configs][crate::model::ModelDeploymentMonitoringJob::model_deployment_monitoring_objective_configs].
    pub fn set_model_deployment_monitoring_objective_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelDeploymentMonitoringObjectiveConfig>,
    {
        use std::iter::Iterator;
        self.model_deployment_monitoring_objective_configs =
            v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bigquery_tables][crate::model::ModelDeploymentMonitoringJob::bigquery_tables].
    pub fn set_bigquery_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelDeploymentMonitoringBigQueryTable>,
    {
        use std::iter::Iterator;
        self.bigquery_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::ModelDeploymentMonitoringJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelDeploymentMonitoringJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob"
    }
}

/// Defines additional types related to [ModelDeploymentMonitoringJob].
#[cfg(feature = "job_service")]
pub mod model_deployment_monitoring_job {
    #[allow(unused_imports)]
    use super::*;

    /// All metadata of most recent monitoring pipelines.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LatestMonitoringPipelineMetadata {
        /// The time that most recent monitoring pipelines that is related to this
        /// run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub run_time: std::option::Option<wkt::Timestamp>,

        /// The status of the most recent monitoring pipeline.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl LatestMonitoringPipelineMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [run_time][crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata::run_time].
        pub fn set_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.run_time = v.into();
            self
        }

        /// Sets the value of [status][crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for LatestMonitoringPipelineMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.LatestMonitoringPipelineMetadata"
        }
    }

    /// The state to Specify the monitoring pipeline.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MonitoringScheduleState {
        /// Unspecified state.
        Unspecified,
        /// The pipeline is picked up and wait to run.
        Pending,
        /// The pipeline is offline and will be scheduled for next run.
        Offline,
        /// The pipeline is running.
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MonitoringScheduleState::value] or
        /// [MonitoringScheduleState::name].
        UnknownValue(monitoring_schedule_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "job_service")]
    pub mod monitoring_schedule_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "job_service")]
    impl MonitoringScheduleState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::Running => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MONITORING_SCHEDULE_STATE_UNSPECIFIED")
                }
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::default::Default for MonitoringScheduleState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "job_service")]
    impl std::fmt::Display for MonitoringScheduleState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<i32> for MonitoringScheduleState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Offline,
                3 => Self::Running,
                _ => Self::UnknownValue(monitoring_schedule_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<&str> for MonitoringScheduleState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MONITORING_SCHEDULE_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "OFFLINE" => Self::Offline,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(monitoring_schedule_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl serde::ser::Serialize for MonitoringScheduleState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::Running => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl<'de> serde::de::Deserialize<'de> for MonitoringScheduleState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MonitoringScheduleState>::new(
                ".google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.MonitoringScheduleState"))
        }
    }
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name
/// as well as some information of the logs stored in this table.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringBigQueryTable {
    /// The source of log.
    pub log_source: crate::model::model_deployment_monitoring_big_query_table::LogSource,

    /// The type of log.
    pub log_type: crate::model::model_deployment_monitoring_big_query_table::LogType,

    /// The created BigQuery table to store logs. Customer could do their own query
    /// & analysis. Format:
    /// `bq://<project_id>.model_deployment_monitoring_<endpoint_id>.<tolower(log_source)>_<tolower(log_type)>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bigquery_table_path: std::string::String,

    /// Output only. The schema version of the request/response logging BigQuery
    /// table. Default to v1 if unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_response_logging_schema_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelDeploymentMonitoringBigQueryTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_source][crate::model::ModelDeploymentMonitoringBigQueryTable::log_source].
    pub fn set_log_source<
        T: std::convert::Into<crate::model::model_deployment_monitoring_big_query_table::LogSource>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_source = v.into();
        self
    }

    /// Sets the value of [log_type][crate::model::ModelDeploymentMonitoringBigQueryTable::log_type].
    pub fn set_log_type<
        T: std::convert::Into<crate::model::model_deployment_monitoring_big_query_table::LogType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_type = v.into();
        self
    }

    /// Sets the value of [bigquery_table_path][crate::model::ModelDeploymentMonitoringBigQueryTable::bigquery_table_path].
    pub fn set_bigquery_table_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_table_path = v.into();
        self
    }

    /// Sets the value of [request_response_logging_schema_version][crate::model::ModelDeploymentMonitoringBigQueryTable::request_response_logging_schema_version].
    pub fn set_request_response_logging_schema_version<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_response_logging_schema_version = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelDeploymentMonitoringBigQueryTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringBigQueryTable"
    }
}

/// Defines additional types related to [ModelDeploymentMonitoringBigQueryTable].
#[cfg(feature = "job_service")]
pub mod model_deployment_monitoring_big_query_table {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates where does the log come from.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogSource {
        /// Unspecified source.
        Unspecified,
        /// Logs coming from Training dataset.
        Training,
        /// Logs coming from Serving traffic.
        Serving,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogSource::value] or
        /// [LogSource::name].
        UnknownValue(log_source::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "job_service")]
    pub mod log_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "job_service")]
    impl LogSource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Training => std::option::Option::Some(1),
                Self::Serving => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOG_SOURCE_UNSPECIFIED"),
                Self::Training => std::option::Option::Some("TRAINING"),
                Self::Serving => std::option::Option::Some("SERVING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::default::Default for LogSource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "job_service")]
    impl std::fmt::Display for LogSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<i32> for LogSource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Training,
                2 => Self::Serving,
                _ => Self::UnknownValue(log_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<&str> for LogSource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOG_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "TRAINING" => Self::Training,
                "SERVING" => Self::Serving,
                _ => Self::UnknownValue(log_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl serde::ser::Serialize for LogSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Training => serializer.serialize_i32(1),
                Self::Serving => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl<'de> serde::de::Deserialize<'de> for LogSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogSource>::new(
                ".google.cloud.aiplatform.v1.ModelDeploymentMonitoringBigQueryTable.LogSource",
            ))
        }
    }

    /// Indicates what type of traffic does the log belong to.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogType {
        /// Unspecified type.
        Unspecified,
        /// Predict logs.
        Predict,
        /// Explain logs.
        Explain,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogType::value] or
        /// [LogType::name].
        UnknownValue(log_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "job_service")]
    pub mod log_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "job_service")]
    impl LogType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Predict => std::option::Option::Some(1),
                Self::Explain => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOG_TYPE_UNSPECIFIED"),
                Self::Predict => std::option::Option::Some("PREDICT"),
                Self::Explain => std::option::Option::Some("EXPLAIN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::default::Default for LogType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "job_service")]
    impl std::fmt::Display for LogType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<i32> for LogType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Predict,
                2 => Self::Explain,
                _ => Self::UnknownValue(log_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<&str> for LogType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOG_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PREDICT" => Self::Predict,
                "EXPLAIN" => Self::Explain,
                _ => Self::UnknownValue(log_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl serde::ser::Serialize for LogType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Predict => serializer.serialize_i32(1),
                Self::Explain => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl<'de> serde::de::Deserialize<'de> for LogType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogType>::new(
                ".google.cloud.aiplatform.v1.ModelDeploymentMonitoringBigQueryTable.LogType",
            ))
        }
    }
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringObjectiveConfig {
    /// The DeployedModel ID of the objective config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// The objective config of for the modelmonitoring job of this deployed model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub objective_config: std::option::Option<crate::model::ModelMonitoringObjectiveConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelDeploymentMonitoringObjectiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model_id][crate::model::ModelDeploymentMonitoringObjectiveConfig::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [objective_config][crate::model::ModelDeploymentMonitoringObjectiveConfig::objective_config].
    pub fn set_objective_config<
        T: std::convert::Into<std::option::Option<crate::model::ModelMonitoringObjectiveConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.objective_config = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelDeploymentMonitoringObjectiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveConfig"
    }
}

/// The config for scheduling monitoring job.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringScheduleConfig {
    /// Required. The model monitoring job scheduling interval. It will be rounded
    /// up to next full hour. This defines how often the monitoring jobs are
    /// triggered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitor_interval: std::option::Option<wkt::Duration>,

    /// The time window of the prediction data being included in each prediction
    /// dataset. This window specifies how long the data should be collected from
    /// historical model results for each run. If not set,
    /// [ModelDeploymentMonitoringScheduleConfig.monitor_interval][google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig.monitor_interval]
    /// will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and
    /// the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
    /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
    /// monitoring statistics.
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig.monitor_interval]: crate::model::ModelDeploymentMonitoringScheduleConfig::monitor_interval
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitor_window: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelDeploymentMonitoringScheduleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monitor_interval][crate::model::ModelDeploymentMonitoringScheduleConfig::monitor_interval].
    pub fn set_monitor_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitor_interval = v.into();
        self
    }

    /// Sets the value of [monitor_window][crate::model::ModelDeploymentMonitoringScheduleConfig::monitor_window].
    pub fn set_monitor_window<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitor_window = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelDeploymentMonitoringScheduleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig"
    }
}

/// Statistics and anomalies generated by Model Monitoring.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMonitoringStatsAnomalies {
    /// Model Monitoring Objective those stats and anomalies belonging to.
    pub objective: crate::model::ModelDeploymentMonitoringObjectiveType,

    /// Deployed Model ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// Number of anomalies within all stats.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub anomaly_count: i32,

    /// A list of historical Stats and Anomalies generated for all Features.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_stats: std::vec::Vec<
        crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelMonitoringStatsAnomalies {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objective][crate::model::ModelMonitoringStatsAnomalies::objective].
    pub fn set_objective<
        T: std::convert::Into<crate::model::ModelDeploymentMonitoringObjectiveType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.objective = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::ModelMonitoringStatsAnomalies::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [anomaly_count][crate::model::ModelMonitoringStatsAnomalies::anomaly_count].
    pub fn set_anomaly_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.anomaly_count = v.into();
        self
    }

    /// Sets the value of [feature_stats][crate::model::ModelMonitoringStatsAnomalies::feature_stats].
    pub fn set_feature_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies,
            >,
    {
        use std::iter::Iterator;
        self.feature_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelMonitoringStatsAnomalies {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies"
    }
}

/// Defines additional types related to [ModelMonitoringStatsAnomalies].
#[cfg(feature = "job_service")]
pub mod model_monitoring_stats_anomalies {
    #[allow(unused_imports)]
    use super::*;

    /// Historical Stats (and Anomalies) for a specific Feature.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureHistoricStatsAnomalies {
        /// Display Name of the Feature.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub feature_display_name: std::string::String,

        /// Threshold for anomaly detection.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threshold: std::option::Option<crate::model::ThresholdConfig>,

        /// Stats calculated for the Training Dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub training_stats: std::option::Option<crate::model::FeatureStatsAnomaly>,

        /// A list of historical stats generated by different time window's
        /// Prediction Dataset.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub prediction_stats: std::vec::Vec<crate::model::FeatureStatsAnomaly>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl FeatureHistoricStatsAnomalies {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [feature_display_name][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::feature_display_name].
        pub fn set_feature_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.feature_display_name = v.into();
            self
        }

        /// Sets the value of [threshold][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::threshold].
        pub fn set_threshold<
            T: std::convert::Into<std::option::Option<crate::model::ThresholdConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.threshold = v.into();
            self
        }

        /// Sets the value of [training_stats][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::training_stats].
        pub fn set_training_stats<
            T: std::convert::Into<std::option::Option<crate::model::FeatureStatsAnomaly>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.training_stats = v.into();
            self
        }

        /// Sets the value of [prediction_stats][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::prediction_stats].
        pub fn set_prediction_stats<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FeatureStatsAnomaly>,
        {
            use std::iter::Iterator;
            self.prediction_stats = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for FeatureHistoricStatsAnomalies {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies"
        }
    }
}

/// A collection of metrics calculated by comparing Model's predictions on all of
/// the test data against annotations from the test data.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelEvaluation {
    /// Output only. The resource name of the ModelEvaluation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the ModelEvaluation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Points to a YAML file stored on Google Cloud Storage describing the
    /// [metrics][google.cloud.aiplatform.v1.ModelEvaluation.metrics] of this
    /// ModelEvaluation. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluation.metrics]: crate::model::ModelEvaluation::metrics
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metrics_schema_uri: std::string::String,

    /// Evaluation metrics of the Model. The schema of the metrics is stored in
    /// [metrics_schema_uri][google.cloud.aiplatform.v1.ModelEvaluation.metrics_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluation.metrics_schema_uri]: crate::model::ModelEvaluation::metrics_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metrics: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this ModelEvaluation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// All possible
    /// [dimensions][google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.dimension]
    /// of ModelEvaluationSlices. The dimensions can be used as the filter of the
    /// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]
    /// request, in the form of `slice.dimension = <dimension>`.
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.dimension]: crate::model::model_evaluation_slice::Slice::dimension
    /// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub slice_dimensions: std::vec::Vec<std::string::String>,

    /// Points to a YAML file stored on Google Cloud Storage describing
    /// [EvaluatedDataItemView.data_item_payload][] and
    /// [EvaluatedAnnotation.data_item_payload][google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// This field is not populated if there are neither EvaluatedDataItemViews nor
    /// EvaluatedAnnotations under this ModelEvaluation.
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload]: crate::model::EvaluatedAnnotation::data_item_payload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_item_schema_uri: std::string::String,

    /// Points to a YAML file stored on Google Cloud Storage describing
    /// [EvaluatedDataItemView.predictions][],
    /// [EvaluatedDataItemView.ground_truths][],
    /// [EvaluatedAnnotation.predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions],
    /// and
    /// [EvaluatedAnnotation.ground_truths][google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// This field is not populated if there are neither EvaluatedDataItemViews nor
    /// EvaluatedAnnotations under this ModelEvaluation.
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths]: crate::model::EvaluatedAnnotation::ground_truths
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]: crate::model::EvaluatedAnnotation::predictions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_schema_uri: std::string::String,

    /// Aggregated explanation metrics for the Model's prediction output over the
    /// data this ModelEvaluation uses. This field is populated only if the Model
    /// is evaluated with explanations, and only for AutoML tabular Models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_explanation: std::option::Option<crate::model::ModelExplanation>,

    /// Describes the values of
    /// [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] that are used
    /// for explaining the predicted values on the evaluated data.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationSpec]: crate::model::ExplanationSpec
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explanation_specs:
        std::vec::Vec<crate::model::model_evaluation::ModelEvaluationExplanationSpec>,

    /// The metadata of the ModelEvaluation.
    /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains a
    /// structured value with keys of "pipeline_job_id", "evaluation_dataset_type",
    /// "evaluation_dataset_path", "row_based_metrics_path".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ModelEvaluation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModelEvaluation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ModelEvaluation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [metrics_schema_uri][crate::model::ModelEvaluation::metrics_schema_uri].
    pub fn set_metrics_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics_schema_uri = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::ModelEvaluation::metrics].
    pub fn set_metrics<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ModelEvaluation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [data_item_schema_uri][crate::model::ModelEvaluation::data_item_schema_uri].
    pub fn set_data_item_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item_schema_uri = v.into();
        self
    }

    /// Sets the value of [annotation_schema_uri][crate::model::ModelEvaluation::annotation_schema_uri].
    pub fn set_annotation_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_schema_uri = v.into();
        self
    }

    /// Sets the value of [model_explanation][crate::model::ModelEvaluation::model_explanation].
    pub fn set_model_explanation<
        T: std::convert::Into<std::option::Option<crate::model::ModelExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_explanation = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ModelEvaluation::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [slice_dimensions][crate::model::ModelEvaluation::slice_dimensions].
    pub fn set_slice_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.slice_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [explanation_specs][crate::model::ModelEvaluation::explanation_specs].
    pub fn set_explanation_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model_evaluation::ModelEvaluationExplanationSpec>,
    {
        use std::iter::Iterator;
        self.explanation_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ModelEvaluation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluation"
    }
}

/// Defines additional types related to [ModelEvaluation].
#[cfg(feature = "model_service")]
pub mod model_evaluation {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "model_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ModelEvaluationExplanationSpec {
        /// Explanation type.
        ///
        /// For AutoML Image Classification models, possible values are:
        ///
        /// * `image-integrated-gradients`
        /// * `image-xrai`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub explanation_type: std::string::String,

        /// Explanation spec details.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_service")]
    impl ModelEvaluationExplanationSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [explanation_type][crate::model::model_evaluation::ModelEvaluationExplanationSpec::explanation_type].
        pub fn set_explanation_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.explanation_type = v.into();
            self
        }

        /// Sets the value of [explanation_spec][crate::model::model_evaluation::ModelEvaluationExplanationSpec::explanation_spec].
        pub fn set_explanation_spec<
            T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.explanation_spec = v.into();
            self
        }
    }

    #[cfg(feature = "model_service")]
    impl wkt::message::Message for ModelEvaluationExplanationSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluation.ModelEvaluationExplanationSpec"
        }
    }
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelEvaluationSlice {
    /// Output only. The resource name of the ModelEvaluationSlice.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The slice of the test data that is used to evaluate the Model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub slice: std::option::Option<crate::model::model_evaluation_slice::Slice>,

    /// Output only. Points to a YAML file stored on Google Cloud Storage
    /// describing the
    /// [metrics][google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics] of this
    /// ModelEvaluationSlice. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics]: crate::model::ModelEvaluationSlice::metrics
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metrics_schema_uri: std::string::String,

    /// Output only. Sliced evaluation metrics of the Model. The schema of the
    /// metrics is stored in
    /// [metrics_schema_uri][google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics_schema_uri]: crate::model::ModelEvaluationSlice::metrics_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metrics: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this ModelEvaluationSlice was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Aggregated explanation metrics for the Model's prediction
    /// output over the data this ModelEvaluation uses. This field is populated
    /// only if the Model is evaluated with explanations, and only for tabular
    /// Models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_explanation: std::option::Option<crate::model::ModelExplanation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ModelEvaluationSlice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModelEvaluationSlice::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slice][crate::model::ModelEvaluationSlice::slice].
    pub fn set_slice<
        T: std::convert::Into<std::option::Option<crate::model::model_evaluation_slice::Slice>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.slice = v.into();
        self
    }

    /// Sets the value of [metrics_schema_uri][crate::model::ModelEvaluationSlice::metrics_schema_uri].
    pub fn set_metrics_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics_schema_uri = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::ModelEvaluationSlice::metrics].
    pub fn set_metrics<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ModelEvaluationSlice::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [model_explanation][crate::model::ModelEvaluationSlice::model_explanation].
    pub fn set_model_explanation<
        T: std::convert::Into<std::option::Option<crate::model::ModelExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_explanation = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ModelEvaluationSlice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice"
    }
}

/// Defines additional types related to [ModelEvaluationSlice].
#[cfg(feature = "model_service")]
pub mod model_evaluation_slice {
    #[allow(unused_imports)]
    use super::*;

    /// Definition of a slice.
    #[cfg(feature = "model_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Slice {
        /// Output only. The dimension of the slice.
        /// Well-known dimensions are:
        ///
        /// * `annotationSpec`: This slice is on the test data that has either
        ///   ground truth or prediction with
        ///   [AnnotationSpec.display_name][google.cloud.aiplatform.v1.AnnotationSpec.display_name]
        ///   equals to
        ///   [value][google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.value].
        /// * `slice`: This slice is a user customized slice defined by its
        ///   SliceSpec.
        ///
        /// [google.cloud.aiplatform.v1.AnnotationSpec.display_name]: crate::model::AnnotationSpec::display_name
        /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.value]: crate::model::model_evaluation_slice::Slice::value
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dimension: std::string::String,

        /// Output only. The value of the dimension in this slice.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        /// Output only. Specification for how the data was sliced.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub slice_spec: std::option::Option<crate::model::model_evaluation_slice::slice::SliceSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_service")]
    impl Slice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dimension][crate::model::model_evaluation_slice::Slice::dimension].
        pub fn set_dimension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dimension = v.into();
            self
        }

        /// Sets the value of [value][crate::model::model_evaluation_slice::Slice::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [slice_spec][crate::model::model_evaluation_slice::Slice::slice_spec].
        pub fn set_slice_spec<
            T: std::convert::Into<
                    std::option::Option<crate::model::model_evaluation_slice::slice::SliceSpec>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.slice_spec = v.into();
            self
        }
    }

    #[cfg(feature = "model_service")]
    impl wkt::message::Message for Slice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice"
        }
    }

    /// Defines additional types related to [Slice].
    #[cfg(feature = "model_service")]
    pub mod slice {
        #[allow(unused_imports)]
        use super::*;

        /// Specification for how the data should be sliced.
        #[cfg(feature = "model_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SliceSpec {
            /// Mapping configuration for this SliceSpec.
            /// The key is the name of the feature.
            /// By default, the key will be prefixed by "instance" as a dictionary
            /// prefix for Vertex Batch Predictions output format.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub configs: std::collections::HashMap<
                std::string::String,
                crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_service")]
        impl SliceSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [configs][crate::model::model_evaluation_slice::slice::SliceSpec::configs].
            pub fn set_configs<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<
                        crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig,
                    >,
            {
                use std::iter::Iterator;
                self.configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        #[cfg(feature = "model_service")]
        impl wkt::message::Message for SliceSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec"
            }
        }

        /// Defines additional types related to [SliceSpec].
        #[cfg(feature = "model_service")]
        pub mod slice_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Specification message containing the config for this SliceSpec.
            /// When `kind` is selected as `value` and/or `range`, only a single slice
            /// will be computed.
            /// When `all_values` is present, a separate slice will be computed for
            /// each possible label/value for the corresponding key in `config`.
            /// Examples, with feature zip_code with values 12345, 23334, 88888 and
            /// feature country with values "US", "Canada", "Mexico" in the dataset:
            ///
            /// Example 1:
            ///
            /// ```norust
            /// {
            ///   "zip_code": { "value": { "float_value": 12345.0 } }
            /// }
            /// ```
            ///
            /// A single slice for any data with zip_code 12345 in the dataset.
            ///
            /// Example 2:
            ///
            /// ```norust
            /// {
            ///   "zip_code": { "range": { "low": 12345, "high": 20000 } }
            /// }
            /// ```
            ///
            /// A single slice containing data where the zip_codes between 12345 and
            /// 20000 For this example, data with the zip_code of 12345 will be in this
            /// slice.
            ///
            /// Example 3:
            ///
            /// ```norust
            /// {
            ///   "zip_code": { "range": { "low": 10000, "high": 20000 } },
            ///   "country": { "value": { "string_value": "US" } }
            /// }
            /// ```
            ///
            /// A single slice containing data where the zip_codes between 10000 and
            /// 20000 has the country "US". For this example, data with the zip_code of
            /// 12345 and country "US" will be in this slice.
            ///
            /// Example 4:
            ///
            /// ```norust
            /// { "country": {"all_values": { "value": true } } }
            /// ```
            ///
            /// Three slices are computed, one for each unique country in the dataset.
            ///
            /// Example 5:
            ///
            /// ```norust
            /// {
            ///   "country": { "all_values": { "value": true } },
            ///   "zip_code": { "value": { "float_value": 12345.0 } }
            /// }
            /// ```
            ///
            /// Three slices are computed, one for each unique country in the dataset
            /// where the zip_code is also 12345. For this example, data with zip_code
            /// 12345 and country "US" will be in one slice, zip_code 12345 and country
            /// "Canada" in another slice, and zip_code 12345 and country "Mexico" in
            /// another slice, totaling 3 slices.
            #[cfg(feature = "model_service")]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct SliceConfig {
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub kind: std::option::Option<
                    crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind,
                >,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "model_service")]
            impl SliceConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind].
                ///
                /// Note that all the setters affecting `kind` are mutually
                /// exclusive.
                pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind>>>(mut self, v: T) -> Self
                {
                    self.kind = v.into();
                    self
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// if it holds a `Value`, `None` if the field is not set or
                /// holds a different branch.
                pub fn value(
                    &self,
                ) -> std::option::Option<
                    &std::boxed::Box<
                        crate::model::model_evaluation_slice::slice::slice_spec::Value,
                    >,
                > {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Value(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// if it holds a `Range`, `None` if the field is not set or
                /// holds a different branch.
                pub fn range(
                    &self,
                ) -> std::option::Option<
                    &std::boxed::Box<
                        crate::model::model_evaluation_slice::slice::slice_spec::Range,
                    >,
                > {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Range(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// if it holds a `AllValues`, `None` if the field is not set or
                /// holds a different branch.
                pub fn all_values(&self) -> std::option::Option<&std::boxed::Box<wkt::BoolValue>> {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::AllValues(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// to hold a `Value`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_value<
                    T: std::convert::Into<
                            std::boxed::Box<
                                crate::model::model_evaluation_slice::slice::slice_spec::Value,
                            >,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Value(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// to hold a `Range`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_range<
                    T: std::convert::Into<
                            std::boxed::Box<
                                crate::model::model_evaluation_slice::slice::slice_spec::Range,
                            >,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Range(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// to hold a `AllValues`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_all_values<T: std::convert::Into<std::boxed::Box<wkt::BoolValue>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::AllValues(
                            v.into()
                        )
                    );
                    self
                }
            }

            #[cfg(feature = "model_service")]
            impl wkt::message::Message for SliceConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.SliceConfig"
                }
            }

            /// Defines additional types related to [SliceConfig].
            #[cfg(feature = "model_service")]
            pub mod slice_config {
                #[allow(unused_imports)]
                use super::*;

                #[cfg(feature = "model_service")]
                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Kind {
                    /// A unique specific value for a given feature.
                    /// Example: `{ "value": { "string_value": "12345" } }`
                    Value(
                        std::boxed::Box<
                            crate::model::model_evaluation_slice::slice::slice_spec::Value,
                        >,
                    ),
                    /// A range of values for a numerical feature.
                    /// Example: `{"range":{"low":10000.0,"high":50000.0}}`
                    /// will capture 12345 and 23334 in the slice.
                    Range(
                        std::boxed::Box<
                            crate::model::model_evaluation_slice::slice::slice_spec::Range,
                        >,
                    ),
                    /// If all_values is set to true, then all possible labels of the keyed
                    /// feature will have another slice computed.
                    /// Example: `{"all_values":{"value":true}}`
                    AllValues(std::boxed::Box<wkt::BoolValue>),
                }
            }

            /// A range of values for slice(s).
            /// `low` is inclusive, `high` is exclusive.
            #[cfg(feature = "model_service")]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Range {
                /// Inclusive low value for the range.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub low: f32,

                /// Exclusive high value for the range.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub high: f32,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "model_service")]
            impl Range {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [low][crate::model::model_evaluation_slice::slice::slice_spec::Range::low].
                pub fn set_low<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.low = v.into();
                    self
                }

                /// Sets the value of [high][crate::model::model_evaluation_slice::slice::slice_spec::Range::high].
                pub fn set_high<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.high = v.into();
                    self
                }
            }

            #[cfg(feature = "model_service")]
            impl wkt::message::Message for Range {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Range"
                }
            }

            /// Single value that supports strings and floats.
            #[cfg(feature = "model_service")]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Value {
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub kind: std::option::Option<
                    crate::model::model_evaluation_slice::slice::slice_spec::value::Kind,
                >,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "model_service")]
            impl Value {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind].
                ///
                /// Note that all the setters affecting `kind` are mutually
                /// exclusive.
                pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::model_evaluation_slice::slice::slice_spec::value::Kind>>>(mut self, v: T) -> Self
                {
                    self.kind = v.into();
                    self
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// if it holds a `StringValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn string_value(&self) -> std::option::Option<&std::string::String> {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::StringValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// if it holds a `FloatValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn float_value(&self) -> std::option::Option<&f32> {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::FloatValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// to hold a `StringValue`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_string_value<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::StringValue(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// to hold a `FloatValue`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_float_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::FloatValue(
                            v.into()
                        )
                    );
                    self
                }
            }

            #[cfg(feature = "model_service")]
            impl wkt::message::Message for Value {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Value"
                }
            }

            /// Defines additional types related to [Value].
            #[cfg(feature = "model_service")]
            pub mod value {
                #[allow(unused_imports)]
                use super::*;

                #[cfg(feature = "model_service")]
                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Kind {
                    /// String type.
                    StringValue(std::string::String),
                    /// Float type.
                    FloatValue(f32),
                }
            }
        }
    }
}

/// Request message for
/// [ModelGardenService.GetPublisherModel][google.cloud.aiplatform.v1.ModelGardenService.GetPublisherModel]
///
/// [google.cloud.aiplatform.v1.ModelGardenService.GetPublisherModel]: crate::client::ModelGardenService::get_publisher_model
#[cfg(feature = "model_garden_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPublisherModelRequest {
    /// Required. The name of the PublisherModel resource.
    /// Format:
    /// `publishers/{publisher}/models/{publisher_model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The IETF BCP-47 language code representing the language in which
    /// the publisher model's text information should be written in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Optional. PublisherModel view specifying which fields to read.
    pub view: crate::model::PublisherModelView,

    /// Optional. Boolean indicates whether the requested model is a Hugging Face
    /// model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub is_hugging_face_model: bool,

    /// Optional. Token used to access Hugging Face gated models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hugging_face_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_garden_service")]
impl GetPublisherModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPublisherModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetPublisherModelRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetPublisherModelRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::PublisherModelView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [is_hugging_face_model][crate::model::GetPublisherModelRequest::is_hugging_face_model].
    pub fn set_is_hugging_face_model<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_hugging_face_model = v.into();
        self
    }

    /// Sets the value of [hugging_face_token][crate::model::GetPublisherModelRequest::hugging_face_token].
    pub fn set_hugging_face_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.hugging_face_token = v.into();
        self
    }
}

#[cfg(feature = "model_garden_service")]
impl wkt::message::Message for GetPublisherModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPublisherModelRequest"
    }
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMonitoringObjectiveConfig {
    /// Training dataset for models. This field has to be set only if
    /// TrainingPredictionSkewDetectionConfig is specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_dataset:
        std::option::Option<crate::model::model_monitoring_objective_config::TrainingDataset>,

    /// The config for skew between training data and prediction data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_prediction_skew_detection_config: std::option::Option<
        crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig,
    >,

    /// The config for drift of prediction data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction_drift_detection_config: std::option::Option<
        crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig,
    >,

    /// The config for integrating with Vertex Explainable AI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_config:
        std::option::Option<crate::model::model_monitoring_objective_config::ExplanationConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelMonitoringObjectiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_dataset][crate::model::ModelMonitoringObjectiveConfig::training_dataset].
    pub fn set_training_dataset<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::model_monitoring_objective_config::TrainingDataset,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_dataset = v.into();
        self
    }

    /// Sets the value of [training_prediction_skew_detection_config][crate::model::ModelMonitoringObjectiveConfig::training_prediction_skew_detection_config].
    pub fn set_training_prediction_skew_detection_config<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig>>>(mut self, v: T) -> Self{
        self.training_prediction_skew_detection_config = v.into();
        self
    }

    /// Sets the value of [prediction_drift_detection_config][crate::model::ModelMonitoringObjectiveConfig::prediction_drift_detection_config].
    pub fn set_prediction_drift_detection_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_drift_detection_config = v.into();
        self
    }

    /// Sets the value of [explanation_config][crate::model::ModelMonitoringObjectiveConfig::explanation_config].
    pub fn set_explanation_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::model_monitoring_objective_config::ExplanationConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_config = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelMonitoringObjectiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig"
    }
}

/// Defines additional types related to [ModelMonitoringObjectiveConfig].
#[cfg(feature = "job_service")]
pub mod model_monitoring_objective_config {
    #[allow(unused_imports)]
    use super::*;

    /// Training Dataset information.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrainingDataset {
        /// Data format of the dataset, only applicable if the input is from
        /// Google Cloud Storage.
        /// The possible formats are:
        ///
        /// "tf-record"
        /// The source file is a TFRecord file.
        ///
        /// "csv"
        /// The source file is a CSV file.
        /// "jsonl"
        /// The source file is a JSONL file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_format: std::string::String,

        /// The target field name the model is to predict.
        /// This field will be excluded when doing Predict and (or) Explain for the
        /// training data.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target_field: std::string::String,

        /// Strategy to sample data from Training Dataset.
        /// If not set, we process the whole dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub logging_sampling_strategy: std::option::Option<crate::model::SamplingStrategy>,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub data_source: std::option::Option<
            crate::model::model_monitoring_objective_config::training_dataset::DataSource,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl TrainingDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_format][crate::model::model_monitoring_objective_config::TrainingDataset::data_format].
        pub fn set_data_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_format = v.into();
            self
        }

        /// Sets the value of [target_field][crate::model::model_monitoring_objective_config::TrainingDataset::target_field].
        pub fn set_target_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_field = v.into();
            self
        }

        /// Sets the value of [logging_sampling_strategy][crate::model::model_monitoring_objective_config::TrainingDataset::logging_sampling_strategy].
        pub fn set_logging_sampling_strategy<
            T: std::convert::Into<std::option::Option<crate::model::SamplingStrategy>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.logging_sampling_strategy = v.into();
            self
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source].
        ///
        /// Note that all the setters affecting `data_source` are mutually
        /// exclusive.
        pub fn set_data_source<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::training_dataset::DataSource>>>(mut self, v: T) -> Self
        {
            self.data_source = v.into();
            self
        }

        /// The value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// if it holds a `Dataset`, `None` if the field is not set or
        /// holds a different branch.
        pub fn dataset(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.data_source.as_ref().and_then(|v| match v {
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::Dataset(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// if it holds a `GcsSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
            #[allow(unreachable_patterns)]
            self.data_source.as_ref().and_then(|v| match v {
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::GcsSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// if it holds a `BigquerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bigquery_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
            #[allow(unreachable_patterns)]
            self.data_source.as_ref().and_then(|v| match v {
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::BigquerySource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// to hold a `Dataset`.
        ///
        /// Note that all the setters affecting `data_source` are
        /// mutually exclusive.
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_source = std::option::Option::Some(
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::Dataset(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// to hold a `GcsSource`.
        ///
        /// Note that all the setters affecting `data_source` are
        /// mutually exclusive.
        pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_source = std::option::Option::Some(
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::GcsSource(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// to hold a `BigquerySource`.
        ///
        /// Note that all the setters affecting `data_source` are
        /// mutually exclusive.
        pub fn set_bigquery_source<
            T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_source = std::option::Option::Some(
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::BigquerySource(
                    v.into()
                )
            );
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for TrainingDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingDataset"
        }
    }

    /// Defines additional types related to [TrainingDataset].
    #[cfg(feature = "job_service")]
    pub mod training_dataset {
        #[allow(unused_imports)]
        use super::*;

        #[cfg(feature = "job_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DataSource {
            /// The resource name of the Dataset used to train this Model.
            Dataset(std::string::String),
            /// The Google Cloud Storage uri of the unmanaged Dataset used to train
            /// this Model.
            GcsSource(std::boxed::Box<crate::model::GcsSource>),
            /// The BigQuery table of the unmanaged Dataset used to train this
            /// Model.
            BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        }
    }

    /// The config for Training & Prediction data skew detection. It specifies the
    /// training dataset sources and the skew detection parameters.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrainingPredictionSkewDetectionConfig {
        /// Key is the feature name and value is the threshold. If a feature needs to
        /// be monitored for skew, a value threshold must be configured for that
        /// feature. The threshold here is against feature distribution distance
        /// between the training and prediction feature.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub skew_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Key is the feature name and value is the threshold. The threshold here is
        /// against attribution score distance between the training and prediction
        /// feature.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub attribution_score_skew_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Skew anomaly detection threshold used by all features.
        /// When the per-feature thresholds are not set, this field can be used to
        /// specify a threshold for all features.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub default_skew_threshold: std::option::Option<crate::model::ThresholdConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl TrainingPredictionSkewDetectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_skew_threshold][crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig::default_skew_threshold].
        pub fn set_default_skew_threshold<
            T: std::convert::Into<std::option::Option<crate::model::ThresholdConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.default_skew_threshold = v.into();
            self
        }

        /// Sets the value of [skew_thresholds][crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig::skew_thresholds].
        pub fn set_skew_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.skew_thresholds = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [attribution_score_skew_thresholds][crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig::attribution_score_skew_thresholds].
        pub fn set_attribution_score_skew_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.attribution_score_skew_thresholds =
                v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for TrainingPredictionSkewDetectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig"
        }
    }

    /// The config for Prediction data drift detection.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PredictionDriftDetectionConfig {
        /// Key is the feature name and value is the threshold. If a feature needs to
        /// be monitored for drift, a value threshold must be configured for that
        /// feature. The threshold here is against feature distribution distance
        /// between different time windws.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub drift_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Key is the feature name and value is the threshold. The threshold here is
        /// against attribution score distance between different time windows.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub attribution_score_drift_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Drift anomaly detection threshold used by all features.
        /// When the per-feature thresholds are not set, this field can be used to
        /// specify a threshold for all features.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub default_drift_threshold: std::option::Option<crate::model::ThresholdConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl PredictionDriftDetectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_drift_threshold][crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig::default_drift_threshold].
        pub fn set_default_drift_threshold<
            T: std::convert::Into<std::option::Option<crate::model::ThresholdConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.default_drift_threshold = v.into();
            self
        }

        /// Sets the value of [drift_thresholds][crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig::drift_thresholds].
        pub fn set_drift_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.drift_thresholds = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [attribution_score_drift_thresholds][crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig::attribution_score_drift_thresholds].
        pub fn set_attribution_score_drift_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.attribution_score_drift_thresholds =
                v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for PredictionDriftDetectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig"
        }
    }

    /// The config for integrating with Vertex Explainable AI. Only applicable if
    /// the Model has explanation_spec populated.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExplanationConfig {

        /// If want to analyze the Vertex Explainable AI feature attribute scores or
        /// not. If set to true, Vertex AI will log the feature attributions from
        /// explain response and do the skew/drift detection for them.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable_feature_attributes: bool,

        /// Predictions generated by the BatchPredictionJob using baseline dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub explanation_baseline: std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl ExplanationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_feature_attributes][crate::model::model_monitoring_objective_config::ExplanationConfig::enable_feature_attributes].
        pub fn set_enable_feature_attributes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_feature_attributes = v.into();
            self
        }

        /// Sets the value of [explanation_baseline][crate::model::model_monitoring_objective_config::ExplanationConfig::explanation_baseline].
        pub fn set_explanation_baseline<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline>>>(mut self, v: T) -> Self{
            self.explanation_baseline = v.into();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for ExplanationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig"
        }
    }

    /// Defines additional types related to [ExplanationConfig].
    #[cfg(feature = "job_service")]
    pub mod explanation_config {
        #[allow(unused_imports)]
        use super::*;

        /// Output from
        /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob] for
        /// Model Monitoring baseline dataset, which can be used to generate baseline
        /// attribution scores.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
        #[cfg(feature = "job_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ExplanationBaseline {

            /// The storage format of the predictions generated BatchPrediction job.
            pub prediction_format: crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::PredictionFormat,

            /// The configuration specifying of BatchExplain job output. This can be
            /// used to generate the baseline of feature attribution scores.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub destination: std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "job_service")]
        impl ExplanationBaseline {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [prediction_format][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::prediction_format].
            pub fn set_prediction_format<T: std::convert::Into<crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::PredictionFormat>>(mut self, v: T) -> Self{
                self.prediction_format = v.into();
                self
            }

            /// Sets the value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination].
            ///
            /// Note that all the setters affecting `destination` are mutually
            /// exclusive.
            pub fn set_destination<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination>>>(mut self, v: T) -> Self
            {
                self.destination = v.into();
                self
            }

            /// The value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// if it holds a `Gcs`, `None` if the field is not set or
            /// holds a different branch.
            pub fn gcs(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
                #[allow(unreachable_patterns)]
                self.destination.as_ref().and_then(|v| match v {
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Gcs(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// if it holds a `Bigquery`, `None` if the field is not set or
            /// holds a different branch.
            pub fn bigquery(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>>
            {
                #[allow(unreachable_patterns)]
                self.destination.as_ref().and_then(|v| match v {
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Bigquery(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// to hold a `Gcs`.
            ///
            /// Note that all the setters affecting `destination` are
            /// mutually exclusive.
            pub fn set_gcs<T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>>(
                mut self,
                v: T,
            ) -> Self {
                self.destination = std::option::Option::Some(
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Gcs(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// to hold a `Bigquery`.
            ///
            /// Note that all the setters affecting `destination` are
            /// mutually exclusive.
            pub fn set_bigquery<
                T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.destination = std::option::Option::Some(
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Bigquery(
                        v.into()
                    )
                );
                self
            }
        }

        #[cfg(feature = "job_service")]
        impl wkt::message::Message for ExplanationBaseline {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline"
            }
        }

        /// Defines additional types related to [ExplanationBaseline].
        #[cfg(feature = "job_service")]
        pub mod explanation_baseline {
            #[allow(unused_imports)]
            use super::*;

            /// The storage format of the predictions generated BatchPrediction job.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(feature = "job_service")]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum PredictionFormat {
                /// Should not be set.
                Unspecified,
                /// Predictions are in JSONL files.
                Jsonl,
                /// Predictions are in BigQuery.
                Bigquery,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [PredictionFormat::value] or
                /// [PredictionFormat::name].
                UnknownValue(prediction_format::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(feature = "job_service")]
            pub mod prediction_format {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(feature = "job_service")]
            impl PredictionFormat {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Jsonl => std::option::Option::Some(2),
                        Self::Bigquery => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("PREDICTION_FORMAT_UNSPECIFIED")
                        }
                        Self::Jsonl => std::option::Option::Some("JSONL"),
                        Self::Bigquery => std::option::Option::Some("BIGQUERY"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl std::default::Default for PredictionFormat {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(feature = "job_service")]
            impl std::fmt::Display for PredictionFormat {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(feature = "job_service")]
            impl std::convert::From<i32> for PredictionFormat {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        2 => Self::Jsonl,
                        3 => Self::Bigquery,
                        _ => Self::UnknownValue(prediction_format::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl std::convert::From<&str> for PredictionFormat {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "PREDICTION_FORMAT_UNSPECIFIED" => Self::Unspecified,
                        "JSONL" => Self::Jsonl,
                        "BIGQUERY" => Self::Bigquery,
                        _ => Self::UnknownValue(prediction_format::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl serde::ser::Serialize for PredictionFormat {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Jsonl => serializer.serialize_i32(2),
                        Self::Bigquery => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl<'de> serde::de::Deserialize<'de> for PredictionFormat {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<PredictionFormat>::new(
                        ".google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline.PredictionFormat"))
                }
            }

            /// The configuration specifying of BatchExplain job output. This can be
            /// used to generate the baseline of feature attribution scores.
            #[cfg(feature = "job_service")]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Destination {
                /// Cloud Storage location for BatchExplain output.
                Gcs(std::boxed::Box<crate::model::GcsDestination>),
                /// BigQuery location for BatchExplain output.
                Bigquery(std::boxed::Box<crate::model::BigQueryDestination>),
            }
        }
    }
}

/// The alert config for model monitoring.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMonitoringAlertConfig {
    /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
    /// payload encoded from proto
    /// [ModelMonitoringStatsAnomalies][google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies].
    /// This can be further synced to Pub/Sub or any other services supported by
    /// Cloud Logging.
    ///
    /// [google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies]: crate::model::ModelMonitoringStatsAnomalies
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_logging: bool,

    /// Resource names of the NotificationChannels to send alert.
    /// Must be of the format
    /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notification_channels: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub alert: std::option::Option<crate::model::model_monitoring_alert_config::Alert>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ModelMonitoringAlertConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_logging][crate::model::ModelMonitoringAlertConfig::enable_logging].
    pub fn set_enable_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_logging = v.into();
        self
    }

    /// Sets the value of [notification_channels][crate::model::ModelMonitoringAlertConfig::notification_channels].
    pub fn set_notification_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.notification_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [alert][crate::model::ModelMonitoringAlertConfig::alert].
    ///
    /// Note that all the setters affecting `alert` are mutually
    /// exclusive.
    pub fn set_alert<
        T: std::convert::Into<std::option::Option<crate::model::model_monitoring_alert_config::Alert>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert = v.into();
        self
    }

    /// The value of [alert][crate::model::ModelMonitoringAlertConfig::alert]
    /// if it holds a `EmailAlertConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email_alert_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::model_monitoring_alert_config::EmailAlertConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.alert.as_ref().and_then(|v| match v {
            crate::model::model_monitoring_alert_config::Alert::EmailAlertConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alert][crate::model::ModelMonitoringAlertConfig::alert]
    /// to hold a `EmailAlertConfig`.
    ///
    /// Note that all the setters affecting `alert` are
    /// mutually exclusive.
    pub fn set_email_alert_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::model_monitoring_alert_config::EmailAlertConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert = std::option::Option::Some(
            crate::model::model_monitoring_alert_config::Alert::EmailAlertConfig(v.into()),
        );
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ModelMonitoringAlertConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringAlertConfig"
    }
}

/// Defines additional types related to [ModelMonitoringAlertConfig].
#[cfg(feature = "job_service")]
pub mod model_monitoring_alert_config {
    #[allow(unused_imports)]
    use super::*;

    /// The config for email alert.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EmailAlertConfig {
        /// The email addresses to send the alert.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub user_emails: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl EmailAlertConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user_emails][crate::model::model_monitoring_alert_config::EmailAlertConfig::user_emails].
        pub fn set_user_emails<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.user_emails = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for EmailAlertConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringAlertConfig.EmailAlertConfig"
        }
    }

    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Alert {
        /// Email alert config.
        EmailAlertConfig(
            std::boxed::Box<crate::model::model_monitoring_alert_config::EmailAlertConfig>,
        ),
    }
}

/// The config for feature monitoring threshold.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThresholdConfig {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub threshold: std::option::Option<crate::model::threshold_config::Threshold>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl ThresholdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threshold][crate::model::ThresholdConfig::threshold].
    ///
    /// Note that all the setters affecting `threshold` are mutually
    /// exclusive.
    pub fn set_threshold<
        T: std::convert::Into<std::option::Option<crate::model::threshold_config::Threshold>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threshold = v.into();
        self
    }

    /// The value of [threshold][crate::model::ThresholdConfig::threshold]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.threshold.as_ref().and_then(|v| match v {
            crate::model::threshold_config::Threshold::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [threshold][crate::model::ThresholdConfig::threshold]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `threshold` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.threshold =
            std::option::Option::Some(crate::model::threshold_config::Threshold::Value(v.into()));
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for ThresholdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ThresholdConfig"
    }
}

/// Defines additional types related to [ThresholdConfig].
#[cfg(feature = "job_service")]
pub mod threshold_config {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Threshold {
        /// Specify a threshold value that can trigger the alert.
        /// If this threshold config is for feature distribution distance:
        ///
        /// . For categorical feature, the distribution distance is calculated by
        ///   L-inifinity norm.
        /// . For numerical feature, the distribution distance is calculated by
        ///   JensenShannon divergence.
        ///   Each feature must have a non-zero threshold if they need to be monitored.
        ///   Otherwise no alert will be triggered for that feature.
        Value(f64),
    }
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SamplingStrategy {
    /// Random sample config. Will support more sampling strategies later.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub random_sample_config:
        std::option::Option<crate::model::sampling_strategy::RandomSampleConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl SamplingStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [random_sample_config][crate::model::SamplingStrategy::random_sample_config].
    pub fn set_random_sample_config<
        T: std::convert::Into<
                std::option::Option<crate::model::sampling_strategy::RandomSampleConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.random_sample_config = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for SamplingStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SamplingStrategy"
    }
}

/// Defines additional types related to [SamplingStrategy].
#[cfg(feature = "job_service")]
pub mod sampling_strategy {
    #[allow(unused_imports)]
    use super::*;

    /// Requests are randomly selected.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RandomSampleConfig {
        /// Sample rate (0, 1]
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub sample_rate: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl RandomSampleConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sample_rate][crate::model::sampling_strategy::RandomSampleConfig::sample_rate].
        pub fn set_sample_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.sample_rate = v.into();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for RandomSampleConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SamplingStrategy.RandomSampleConfig"
        }
    }
}

/// Request message for
/// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel].
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadModelRequest {
    /// Required. The resource name of the Location into which to upload the Model.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The resource name of the model into which to upload the version.
    /// Only specify this field when uploading a new version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_model: std::string::String,

    /// Optional. The ID to use for the uploaded Model, which will become the final
    /// component of the model resource name.
    ///
    /// This value may be up to 63 characters, and valid characters are
    /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Required. The Model to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,

    /// Optional. The user-provided custom service account to use to do the model
    /// upload. If empty, [Vertex AI Service
    /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
    /// will be used to access resources needed to upload the model. This account
    /// must belong to the target project where the model is uploaded to, i.e., the
    /// project specified in the `parent` field of this request and have necessary
    /// read permissions (to Google Cloud Storage, Artifact Registry, etc.).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UploadModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UploadModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [parent_model][crate::model::UploadModelRequest::parent_model].
    pub fn set_parent_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::UploadModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::UploadModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::UploadModelRequest::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UploadModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelRequest"
    }
}

/// Details of
/// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadModelOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UploadModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UploadModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UploadModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelOperationMetadata"
    }
}

/// Response message of
/// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadModelResponse {
    /// The name of the uploaded Model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the model that is uploaded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UploadModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UploadModelResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::UploadModelResponse::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UploadModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelResponse"
    }
}

/// Request message for
/// [ModelService.GetModel][google.cloud.aiplatform.v1.ModelService.GetModel].
///
/// [google.cloud.aiplatform.v1.ModelService.GetModel]: crate::client::ModelService::get_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. The name of the Model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    ///
    /// In order to retrieve a specific version of the model, also provide
    /// the version ID or version alias.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// If no version ID or alias is specified, the "default" version will be
    /// returned. The "default" version alias is created for the first version of
    /// the model, and can be moved to other versions later on. There will be
    /// exactly one default version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelRequest"
    }
}

/// Request message for
/// [ModelService.ListModels][google.cloud.aiplatform.v1.ModelService.ListModels].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModels]: crate::client::ModelService::list_models
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. The resource name of the Location to list the Models from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. For field names
    /// both snake_case and camelCase are supported.
    ///
    /// * `model` supports = and !=. `model` represents the Model ID,
    ///   i.e. the last segment of the Model's [resource
    ///   name][google.cloud.aiplatform.v1.Model.name].
    /// * `display_name` supports = and !=
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    /// * `base_model_name` only supports =
    ///
    /// Some examples:
    ///
    /// * `model=1234`
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    /// * `baseModelName="text-bison"`
    ///
    /// [google.cloud.aiplatform.v1.Model.name]: crate::model::Model::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListModelsResponse.next_page_token][google.cloud.aiplatform.v1.ListModelsResponse.next_page_token]
    /// of the previous
    /// [ModelService.ListModels][google.cloud.aiplatform.v1.ModelService.ListModels]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelsResponse.next_page_token]: crate::model::ListModelsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModels]: crate::client::ModelService::list_models
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListModelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelsRequest"
    }
}

/// Response message for
/// [ModelService.ListModels][google.cloud.aiplatform.v1.ModelService.ListModels]
///
/// [google.cloud.aiplatform.v1.ModelService.ListModels]: crate::client::ModelService::list_models
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// List of Models in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListModelsRequest.page_token][google.cloud.aiplatform.v1.ListModelsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelsRequest.page_token]: crate::model::ListModelsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelsResponse"
    }
}

#[cfg(feature = "model_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ModelService.ListModelVersions][google.cloud.aiplatform.v1.ModelService.ListModelVersions].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersions]: crate::client::ModelService::list_model_versions
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionsRequest {
    /// Required. The name of the model to list versions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [next_page_token][google.cloud.aiplatform.v1.ListModelVersionsResponse.next_page_token]
    /// of the previous
    /// [ListModelVersions][google.cloud.aiplatform.v1.ModelService.ListModelVersions]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionsResponse.next_page_token]: crate::model::ListModelVersionsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelVersions]: crate::client::ModelService::list_model_versions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// An expression for filtering the results of the request. For field names
    /// both snake_case and camelCase are supported.
    ///
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    ///
    /// Some examples:
    ///
    /// * `labels.myKey="myValue"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `update_time asc, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListModelVersionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelVersionsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListModelVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionsRequest"
    }
}

/// Response message for
/// [ModelService.ListModelVersions][google.cloud.aiplatform.v1.ModelService.ListModelVersions]
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersions]: crate::client::ModelService::list_model_versions
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionsResponse {
    /// List of Model versions in the requested page.
    /// In the returned Model name field, version ID instead of regvision tag will
    /// be included.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListModelVersionsRequest.page_token][google.cloud.aiplatform.v1.ListModelVersionsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionsRequest.page_token]: crate::model::ListModelVersionsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelVersionsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionsResponse"
    }
}

#[cfg(feature = "model_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelVersionsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ModelService.ListModelVersionCheckpoints][google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]: crate::client::ModelService::list_model_version_checkpoints
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionCheckpointsRequest {
    /// Required. The name of the model version to list checkpoints for.
    /// `projects/{project}/locations/{location}/models/{model}@{version}`
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// If no version ID or alias is specified, the latest version will be
    /// used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [next_page_token][google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse.next_page_token]
    /// of the previous
    /// [ListModelVersionCheckpoints][google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse.next_page_token]: crate::model::ListModelVersionCheckpointsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]: crate::client::ModelService::list_model_version_checkpoints
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelVersionCheckpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListModelVersionCheckpointsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelVersionCheckpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelVersionCheckpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelVersionCheckpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest"
    }
}

/// A proto representation of a Spanner-stored ModelVersionCheckpoint.
/// The meaning of the fields is equivalent to their in-Spanner counterparts.
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelVersionCheckpoint {
    /// The ID of the checkpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub checkpoint_id: std::string::String,

    /// The epoch of the checkpoint.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub epoch: i64,

    /// The step of the checkpoint.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub step: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ModelVersionCheckpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checkpoint_id][crate::model::ModelVersionCheckpoint::checkpoint_id].
    pub fn set_checkpoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.checkpoint_id = v.into();
        self
    }

    /// Sets the value of [epoch][crate::model::ModelVersionCheckpoint::epoch].
    pub fn set_epoch<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.epoch = v.into();
        self
    }

    /// Sets the value of [step][crate::model::ModelVersionCheckpoint::step].
    pub fn set_step<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ModelVersionCheckpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelVersionCheckpoint"
    }
}

/// Response message for
/// [ModelService.ListModelVersionCheckpoints][google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]: crate::client::ModelService::list_model_version_checkpoints
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionCheckpointsResponse {
    /// List of Model Version checkpoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub checkpoints: std::vec::Vec<crate::model::ModelVersionCheckpoint>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListModelVersionCheckpointsRequest.page_token][google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest.page_token]: crate::model::ListModelVersionCheckpointsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelVersionCheckpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelVersionCheckpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [checkpoints][crate::model::ListModelVersionCheckpointsResponse::checkpoints].
    pub fn set_checkpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelVersionCheckpoint>,
    {
        use std::iter::Iterator;
        self.checkpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelVersionCheckpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse"
    }
}

#[cfg(feature = "model_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelVersionCheckpointsResponse {
    type PageItem = crate::model::ModelVersionCheckpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.checkpoints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ModelService.UpdateModel][google.cloud.aiplatform.v1.ModelService.UpdateModel].
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateModel]: crate::client::ModelService::update_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelRequest {
    /// Required. The Model which replaces the resource on the server.
    /// When Model Versioning is enabled, the model.name will be used to determine
    /// whether to update the model or model version.
    ///
    /// . model.name with the @ value, e.g. models/123@1, refers to a version
    ///   specific update.
    /// . model.name without the @ value, e.g. models/123, refers to a model
    ///   update.
    /// . model.name with @-, e.g. models/123@-, refers to a model update.
    /// . Supported model fields: display_name, description; supported
    ///   version-specific fields: version_description. Labels are supported in both
    ///   scenarios. Both the model labels and the version labels are merged when a
    ///   model is returned. When updating labels, if the request is for
    ///   model-specific update, model label gets updated. Otherwise, version labels
    ///   get updated.
    /// . A model name or model version name fields update mismatch will cause a
    ///   precondition error.
    /// . One request cannot update both the model and the version fields. You
    ///   must update them separately.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UpdateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UpdateModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateModelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UpdateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelRequest"
    }
}

/// Request message for
/// [ModelService.UpdateExplanationDataset][google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset].
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]: crate::client::ModelService::update_explanation_dataset
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExplanationDatasetRequest {
    /// Required. The resource name of the Model to update.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// The example config containing the location of the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub examples: std::option::Option<crate::model::Examples>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UpdateExplanationDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UpdateExplanationDatasetRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [examples][crate::model::UpdateExplanationDatasetRequest::examples].
    pub fn set_examples<T: std::convert::Into<std::option::Option<crate::model::Examples>>>(
        mut self,
        v: T,
    ) -> Self {
        self.examples = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UpdateExplanationDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetRequest"
    }
}

/// Runtime operation information for
/// [ModelService.UpdateExplanationDataset][google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset].
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]: crate::client::ModelService::update_explanation_dataset
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExplanationDatasetOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UpdateExplanationDatasetOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateExplanationDatasetOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UpdateExplanationDatasetOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetOperationMetadata"
    }
}

/// Request message for
/// [ModelService.DeleteModel][google.cloud.aiplatform.v1.ModelService.DeleteModel].
///
/// [google.cloud.aiplatform.v1.ModelService.DeleteModel]: crate::client::ModelService::delete_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. The name of the Model resource to be deleted.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelRequest"
    }
}

/// Request message for
/// [ModelService.DeleteModelVersion][google.cloud.aiplatform.v1.ModelService.DeleteModelVersion].
///
/// [google.cloud.aiplatform.v1.ModelService.DeleteModelVersion]: crate::client::ModelService::delete_model_version
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelVersionRequest {
    /// Required. The name of the model version to be deleted, with a version ID
    /// explicitly included.
    ///
    /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl DeleteModelVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for DeleteModelVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelVersionRequest"
    }
}

/// Request message for
/// [ModelService.MergeVersionAliases][google.cloud.aiplatform.v1.ModelService.MergeVersionAliases].
///
/// [google.cloud.aiplatform.v1.ModelService.MergeVersionAliases]: crate::client::ModelService::merge_version_aliases
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MergeVersionAliasesRequest {
    /// Required. The name of the model version to merge aliases, with a version ID
    /// explicitly included.
    ///
    /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The set of version aliases to merge.
    /// The alias should be at most 128 characters, and match
    /// `[a-z][a-zA-Z0-9-]{0,126}[a-z-0-9]`.
    /// Add the `-` prefix to an alias means removing that alias from the version.
    /// `-` is NOT counted in the 128 characters. Example: `-golden` means removing
    /// the `golden` alias from the version.
    ///
    /// There is NO ordering in aliases, which means
    ///
    /// ) The aliases returned from GetModel API might not have the exactly same
    ///   order from this MergeVersionAliases API. 2) Adding and deleting the same
    ///   alias in the request is not recommended, and the 2 operations will be
    ///   cancelled out.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version_aliases: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl MergeVersionAliasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MergeVersionAliasesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::MergeVersionAliasesRequest::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for MergeVersionAliasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MergeVersionAliasesRequest"
    }
}

/// Request message for
/// [ModelService.ExportModel][google.cloud.aiplatform.v1.ModelService.ExportModel].
///
/// [google.cloud.aiplatform.v1.ModelService.ExportModel]: crate::client::ModelService::export_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelRequest {
    /// Required. The resource name of the Model to export.
    /// The resource name may contain version id or version alias to specify the
    /// version, if no version is specified, the default version will be exported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The desired output location and configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::export_model_request::OutputConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ExportModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::ExportModelRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::export_model_request::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ExportModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelRequest"
    }
}

/// Defines additional types related to [ExportModelRequest].
#[cfg(feature = "model_service")]
pub mod export_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Output configuration for the Model export.
    #[cfg(feature = "model_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputConfig {
        /// The ID of the format in which the Model must be exported. Each Model
        /// lists the [export formats it
        /// supports][google.cloud.aiplatform.v1.Model.supported_export_formats]. If
        /// no value is provided here, then the first from the list of the Model's
        /// supported formats is used by default.
        ///
        /// [google.cloud.aiplatform.v1.Model.supported_export_formats]: crate::model::Model::supported_export_formats
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub export_format_id: std::string::String,

        /// The Cloud Storage location where the Model artifact is to be
        /// written to. Under the directory given as the destination a new one with
        /// name "`model-export-<model-display-name>-<timestamp-of-export-call>`",
        /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format,
        /// will be created. Inside, the Model and any of its supporting files
        /// will be written.
        /// This field should only be set when the `exportableContent` field of the
        /// [Model.supported_export_formats] object contains `ARTIFACT`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub artifact_destination: std::option::Option<crate::model::GcsDestination>,

        /// The Google Container Registry or Artifact Registry uri where the
        /// Model container image will be copied to.
        /// This field should only be set when the `exportableContent` field of the
        /// [Model.supported_export_formats] object contains `IMAGE`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub image_destination: std::option::Option<crate::model::ContainerRegistryDestination>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_service")]
    impl OutputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [export_format_id][crate::model::export_model_request::OutputConfig::export_format_id].
        pub fn set_export_format_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.export_format_id = v.into();
            self
        }

        /// Sets the value of [artifact_destination][crate::model::export_model_request::OutputConfig::artifact_destination].
        pub fn set_artifact_destination<
            T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.artifact_destination = v.into();
            self
        }

        /// Sets the value of [image_destination][crate::model::export_model_request::OutputConfig::image_destination].
        pub fn set_image_destination<
            T: std::convert::Into<std::option::Option<crate::model::ContainerRegistryDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.image_destination = v.into();
            self
        }
    }

    #[cfg(feature = "model_service")]
    impl wkt::message::Message for OutputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig"
        }
    }
}

/// Details of
/// [ModelService.ExportModel][google.cloud.aiplatform.v1.ModelService.ExportModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.ExportModel]: crate::client::ModelService::export_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Output only. Information further describing the output of this Model
    /// export.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_info: std::option::Option<crate::model::export_model_operation_metadata::OutputInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ExportModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ExportModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [output_info][crate::model::ExportModelOperationMetadata::output_info].
    pub fn set_output_info<
        T: std::convert::Into<
                std::option::Option<crate::model::export_model_operation_metadata::OutputInfo>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_info = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ExportModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelOperationMetadata"
    }
}

/// Defines additional types related to [ExportModelOperationMetadata].
#[cfg(feature = "model_service")]
pub mod export_model_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Further describes the output of the ExportModel. Supplements
    /// [ExportModelRequest.OutputConfig][google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig].
    ///
    /// [google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig]: crate::model::export_model_request::OutputConfig
    #[cfg(feature = "model_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputInfo {
        /// Output only. If the Model artifact is being exported to Google Cloud
        /// Storage this is the full path of the directory created, into which the
        /// Model files are being written to.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub artifact_output_uri: std::string::String,

        /// Output only. If the Model image is being exported to Google Container
        /// Registry or Artifact Registry this is the full path of the image created.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub image_output_uri: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_service")]
    impl OutputInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [artifact_output_uri][crate::model::export_model_operation_metadata::OutputInfo::artifact_output_uri].
        pub fn set_artifact_output_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.artifact_output_uri = v.into();
            self
        }

        /// Sets the value of [image_output_uri][crate::model::export_model_operation_metadata::OutputInfo::image_output_uri].
        pub fn set_image_output_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.image_output_uri = v.into();
            self
        }
    }

    #[cfg(feature = "model_service")]
    impl wkt::message::Message for OutputInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelOperationMetadata.OutputInfo"
        }
    }
}

/// Response message of
/// [ModelService.UpdateExplanationDataset][google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]: crate::client::ModelService::update_explanation_dataset
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExplanationDatasetResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl UpdateExplanationDatasetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for UpdateExplanationDatasetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetResponse"
    }
}

/// Response message of
/// [ModelService.ExportModel][google.cloud.aiplatform.v1.ModelService.ExportModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.ExportModel]: crate::client::ModelService::export_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ExportModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ExportModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelResponse"
    }
}

/// Request message for
/// [ModelService.CopyModel][google.cloud.aiplatform.v1.ModelService.CopyModel].
///
/// [google.cloud.aiplatform.v1.ModelService.CopyModel]: crate::client::ModelService::copy_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyModelRequest {
    /// Required. The resource name of the Location into which to copy the Model.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource name of the Model to copy. That Model must be in the
    /// same Project. Format:
    /// `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_model: std::string::String,

    /// Customer-managed encryption key options. If this is set,
    /// then the Model copy will be encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// If both fields are unset, a new Model will be created with a generated ID.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination_model: std::option::Option<crate::model::copy_model_request::DestinationModel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl CopyModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CopyModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_model][crate::model::CopyModelRequest::source_model].
    pub fn set_source_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_model = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::CopyModelRequest::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [destination_model][crate::model::CopyModelRequest::destination_model].
    ///
    /// Note that all the setters affecting `destination_model` are mutually
    /// exclusive.
    pub fn set_destination_model<
        T: std::convert::Into<std::option::Option<crate::model::copy_model_request::DestinationModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_model = v.into();
        self
    }

    /// The value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// if it holds a `ModelId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn model_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination_model.as_ref().and_then(|v| match v {
            crate::model::copy_model_request::DestinationModel::ModelId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// if it holds a `ParentModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn parent_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination_model.as_ref().and_then(|v| match v {
            crate::model::copy_model_request::DestinationModel::ParentModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// to hold a `ModelId`.
    ///
    /// Note that all the setters affecting `destination_model` are
    /// mutually exclusive.
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_model = std::option::Option::Some(
            crate::model::copy_model_request::DestinationModel::ModelId(v.into()),
        );
        self
    }

    /// Sets the value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// to hold a `ParentModel`.
    ///
    /// Note that all the setters affecting `destination_model` are
    /// mutually exclusive.
    pub fn set_parent_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_model = std::option::Option::Some(
            crate::model::copy_model_request::DestinationModel::ParentModel(v.into()),
        );
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for CopyModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelRequest"
    }
}

/// Defines additional types related to [CopyModelRequest].
#[cfg(feature = "model_service")]
pub mod copy_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// If both fields are unset, a new Model will be created with a generated ID.
    #[cfg(feature = "model_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DestinationModel {
        /// Optional. Copy source_model into a new Model with this ID. The ID will
        /// become the final component of the model resource name.
        ///
        /// This value may be up to 63 characters, and valid characters are
        /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
        ModelId(std::string::String),
        /// Optional. Specify this field to copy source_model into this existing
        /// Model as a new version. Format:
        /// `projects/{project}/locations/{location}/models/{model}`
        ParentModel(std::string::String),
    }
}

/// Details of
/// [ModelService.CopyModel][google.cloud.aiplatform.v1.ModelService.CopyModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.CopyModel]: crate::client::ModelService::copy_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyModelOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl CopyModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CopyModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for CopyModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelOperationMetadata"
    }
}

/// Response message of
/// [ModelService.CopyModel][google.cloud.aiplatform.v1.ModelService.CopyModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.CopyModel]: crate::client::ModelService::copy_model
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyModelResponse {
    /// The name of the copied Model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the model that is copied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl CopyModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::CopyModelResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::CopyModelResponse::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for CopyModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelResponse"
    }
}

/// Request message for
/// [ModelService.ImportModelEvaluation][google.cloud.aiplatform.v1.ModelService.ImportModelEvaluation]
///
/// [google.cloud.aiplatform.v1.ModelService.ImportModelEvaluation]: crate::client::ModelService::import_model_evaluation
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportModelEvaluationRequest {
    /// Required. The name of the parent model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Model evaluation resource to be imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_evaluation: std::option::Option<crate::model::ModelEvaluation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ImportModelEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportModelEvaluationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_evaluation][crate::model::ImportModelEvaluationRequest::model_evaluation].
    pub fn set_model_evaluation<
        T: std::convert::Into<std::option::Option<crate::model::ModelEvaluation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_evaluation = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ImportModelEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportModelEvaluationRequest"
    }
}

/// Request message for
/// [ModelService.BatchImportModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]: crate::client::ModelService::batch_import_model_evaluation_slices
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportModelEvaluationSlicesRequest {
    /// Required. The name of the parent ModelEvaluation resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Model evaluation slice resource to be imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_evaluation_slices: std::vec::Vec<crate::model::ModelEvaluationSlice>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl BatchImportModelEvaluationSlicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchImportModelEvaluationSlicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_evaluation_slices][crate::model::BatchImportModelEvaluationSlicesRequest::model_evaluation_slices].
    pub fn set_model_evaluation_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelEvaluationSlice>,
    {
        use std::iter::Iterator;
        self.model_evaluation_slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for BatchImportModelEvaluationSlicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesRequest"
    }
}

/// Response message for
/// [ModelService.BatchImportModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]: crate::client::ModelService::batch_import_model_evaluation_slices
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportModelEvaluationSlicesResponse {
    /// Output only. List of imported
    /// [ModelEvaluationSlice.name][google.cloud.aiplatform.v1.ModelEvaluationSlice.name].
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.name]: crate::model::ModelEvaluationSlice::name
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub imported_model_evaluation_slices: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl BatchImportModelEvaluationSlicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_model_evaluation_slices][crate::model::BatchImportModelEvaluationSlicesResponse::imported_model_evaluation_slices].
    pub fn set_imported_model_evaluation_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.imported_model_evaluation_slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for BatchImportModelEvaluationSlicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesResponse"
    }
}

/// Request message for
/// [ModelService.BatchImportEvaluatedAnnotations][google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]: crate::client::ModelService::batch_import_evaluated_annotations
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportEvaluatedAnnotationsRequest {
    /// Required. The name of the parent ModelEvaluationSlice resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Evaluated annotations resource to be imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub evaluated_annotations: std::vec::Vec<crate::model::EvaluatedAnnotation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl BatchImportEvaluatedAnnotationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchImportEvaluatedAnnotationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [evaluated_annotations][crate::model::BatchImportEvaluatedAnnotationsRequest::evaluated_annotations].
    pub fn set_evaluated_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedAnnotation>,
    {
        use std::iter::Iterator;
        self.evaluated_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for BatchImportEvaluatedAnnotationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsRequest"
    }
}

/// Response message for
/// [ModelService.BatchImportEvaluatedAnnotations][google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]: crate::client::ModelService::batch_import_evaluated_annotations
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportEvaluatedAnnotationsResponse {
    /// Output only. Number of EvaluatedAnnotations imported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub imported_evaluated_annotations_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl BatchImportEvaluatedAnnotationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_evaluated_annotations_count][crate::model::BatchImportEvaluatedAnnotationsResponse::imported_evaluated_annotations_count].
    pub fn set_imported_evaluated_annotations_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.imported_evaluated_annotations_count = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for BatchImportEvaluatedAnnotationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsResponse"
    }
}

/// Request message for
/// [ModelService.GetModelEvaluation][google.cloud.aiplatform.v1.ModelService.GetModelEvaluation].
///
/// [google.cloud.aiplatform.v1.ModelService.GetModelEvaluation]: crate::client::ModelService::get_model_evaluation
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelEvaluationRequest {
    /// Required. The name of the ModelEvaluation resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl GetModelEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelEvaluationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for GetModelEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelEvaluationRequest"
    }
}

/// Request message for
/// [ModelService.ListModelEvaluations][google.cloud.aiplatform.v1.ModelService.ListModelEvaluations].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]: crate::client::ModelService::list_model_evaluations
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationsRequest {
    /// Required. The resource name of the Model to list the ModelEvaluations from.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListModelEvaluationsResponse.next_page_token][google.cloud.aiplatform.v1.ListModelEvaluationsResponse.next_page_token]
    /// of the previous
    /// [ModelService.ListModelEvaluations][google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationsResponse.next_page_token]: crate::model::ListModelEvaluationsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]: crate::client::ModelService::list_model_evaluations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelEvaluationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelEvaluationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelEvaluationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelEvaluationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelEvaluationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelEvaluationsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelEvaluationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationsRequest"
    }
}

/// Response message for
/// [ModelService.ListModelEvaluations][google.cloud.aiplatform.v1.ModelService.ListModelEvaluations].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]: crate::client::ModelService::list_model_evaluations
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationsResponse {
    /// List of ModelEvaluations in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_evaluations: std::vec::Vec<crate::model::ModelEvaluation>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListModelEvaluationsRequest.page_token][google.cloud.aiplatform.v1.ListModelEvaluationsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationsRequest.page_token]: crate::model::ListModelEvaluationsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelEvaluationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelEvaluationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [model_evaluations][crate::model::ListModelEvaluationsResponse::model_evaluations].
    pub fn set_model_evaluations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelEvaluation>,
    {
        use std::iter::Iterator;
        self.model_evaluations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelEvaluationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationsResponse"
    }
}

#[cfg(feature = "model_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelEvaluationsResponse {
    type PageItem = crate::model::ModelEvaluation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.model_evaluations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ModelService.GetModelEvaluationSlice][google.cloud.aiplatform.v1.ModelService.GetModelEvaluationSlice].
///
/// [google.cloud.aiplatform.v1.ModelService.GetModelEvaluationSlice]: crate::client::ModelService::get_model_evaluation_slice
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelEvaluationSliceRequest {
    /// Required. The name of the ModelEvaluationSlice resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl GetModelEvaluationSliceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelEvaluationSliceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for GetModelEvaluationSliceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelEvaluationSliceRequest"
    }
}

/// Request message for
/// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationSlicesRequest {
    /// Required. The resource name of the ModelEvaluation to list the
    /// ModelEvaluationSlices from. Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// * `slice.dimension` - for =.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListModelEvaluationSlicesResponse.next_page_token][google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse.next_page_token]
    /// of the previous
    /// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse.next_page_token]: crate::model::ListModelEvaluationSlicesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelEvaluationSlicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelEvaluationSlicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelEvaluationSlicesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelEvaluationSlicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelEvaluationSlicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelEvaluationSlicesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelEvaluationSlicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest"
    }
}

/// Response message for
/// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
#[cfg(feature = "model_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationSlicesResponse {
    /// List of ModelEvaluations in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_evaluation_slices: std::vec::Vec<crate::model::ModelEvaluationSlice>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListModelEvaluationSlicesRequest.page_token][google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest.page_token]: crate::model::ListModelEvaluationSlicesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_service")]
impl ListModelEvaluationSlicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelEvaluationSlicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [model_evaluation_slices][crate::model::ListModelEvaluationSlicesResponse::model_evaluation_slices].
    pub fn set_model_evaluation_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelEvaluationSlice>,
    {
        use std::iter::Iterator;
        self.model_evaluation_slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_service")]
impl wkt::message::Message for ListModelEvaluationSlicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse"
    }
}

#[cfg(feature = "model_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelEvaluationSlicesResponse {
    type PageItem = crate::model::ModelEvaluationSlice;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.model_evaluation_slices
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents a Neural Architecture Search (NAS) job.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasJob {
    /// Output only. Resource name of the NasJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the NasJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The specification of a NasJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nas_job_spec: std::option::Option<crate::model::NasJobSpec>,

    /// Output only. Output of the NasJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nas_job_output: std::option::Option<crate::model::NasJobOutput>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the NasJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasJob for the first time entered the
    /// `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasJob entered any of the following states:
    /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is JOB_STATE_FAILED or
    /// JOB_STATE_CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize NasJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a NasJob.
    /// If this is set, then all resources created by the NasJob
    /// will be encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. Enable a separation of Custom model training
    /// and restricted image training for tenant project.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub enable_restricted_image_training: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl NasJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NasJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NasJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [nas_job_spec][crate::model::NasJob::nas_job_spec].
    pub fn set_nas_job_spec<
        T: std::convert::Into<std::option::Option<crate::model::NasJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_job_spec = v.into();
        self
    }

    /// Sets the value of [nas_job_output][crate::model::NasJob::nas_job_output].
    pub fn set_nas_job_output<
        T: std::convert::Into<std::option::Option<crate::model::NasJobOutput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_job_output = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NasJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NasJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::NasJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::NasJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NasJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::NasJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NasJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [enable_restricted_image_training][crate::model::NasJob::enable_restricted_image_training].
    #[deprecated]
    pub fn set_enable_restricted_image_training<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_restricted_image_training = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::NasJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::NasJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NasJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for NasJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJob"
    }
}

/// Represents a NasTrial details along with its parameters. If there is a
/// corresponding train NasTrial, the train NasTrial is also returned.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasTrialDetail {
    /// Output only. Resource name of the NasTrialDetail.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The parameters for the NasJob NasTrial.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parameters: std::string::String,

    /// The requested search NasTrial.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_trial: std::option::Option<crate::model::NasTrial>,

    /// The train NasTrial corresponding to
    /// [search_trial][google.cloud.aiplatform.v1.NasTrialDetail.search_trial].
    /// Only populated if
    /// [search_trial][google.cloud.aiplatform.v1.NasTrialDetail.search_trial] is
    /// used for training.
    ///
    /// [google.cloud.aiplatform.v1.NasTrialDetail.search_trial]: crate::model::NasTrialDetail::search_trial
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub train_trial: std::option::Option<crate::model::NasTrial>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl NasTrialDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NasTrialDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::NasTrialDetail::parameters].
    pub fn set_parameters<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [search_trial][crate::model::NasTrialDetail::search_trial].
    pub fn set_search_trial<T: std::convert::Into<std::option::Option<crate::model::NasTrial>>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_trial = v.into();
        self
    }

    /// Sets the value of [train_trial][crate::model::NasTrialDetail::train_trial].
    pub fn set_train_trial<T: std::convert::Into<std::option::Option<crate::model::NasTrial>>>(
        mut self,
        v: T,
    ) -> Self {
        self.train_trial = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for NasTrialDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasTrialDetail"
    }
}

/// Represents the spec of a NasJob.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasJobSpec {
    /// The ID of the existing NasJob in the same Project and Location
    /// which will be used to resume search. search_space_spec and
    /// nas_algorithm_spec are obtained from previous NasJob hence should not
    /// provide them again for this NasJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resume_nas_job_id: std::string::String,

    /// It defines the search space for Neural Architecture Search (NAS).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub search_space_spec: std::string::String,

    /// The Neural Architecture Search (NAS) algorithm specification.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub nas_algorithm_spec: std::option::Option<crate::model::nas_job_spec::NasAlgorithmSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl NasJobSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resume_nas_job_id][crate::model::NasJobSpec::resume_nas_job_id].
    pub fn set_resume_nas_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resume_nas_job_id = v.into();
        self
    }

    /// Sets the value of [search_space_spec][crate::model::NasJobSpec::search_space_spec].
    pub fn set_search_space_spec<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_space_spec = v.into();
        self
    }

    /// Sets the value of [nas_algorithm_spec][crate::model::NasJobSpec::nas_algorithm_spec].
    ///
    /// Note that all the setters affecting `nas_algorithm_spec` are mutually
    /// exclusive.
    pub fn set_nas_algorithm_spec<
        T: std::convert::Into<std::option::Option<crate::model::nas_job_spec::NasAlgorithmSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_algorithm_spec = v.into();
        self
    }

    /// The value of [nas_algorithm_spec][crate::model::NasJobSpec::nas_algorithm_spec]
    /// if it holds a `MultiTrialAlgorithmSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_trial_algorithm_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::nas_job_spec::MultiTrialAlgorithmSpec>>
    {
        #[allow(unreachable_patterns)]
        self.nas_algorithm_spec.as_ref().and_then(|v| match v {
            crate::model::nas_job_spec::NasAlgorithmSpec::MultiTrialAlgorithmSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [nas_algorithm_spec][crate::model::NasJobSpec::nas_algorithm_spec]
    /// to hold a `MultiTrialAlgorithmSpec`.
    ///
    /// Note that all the setters affecting `nas_algorithm_spec` are
    /// mutually exclusive.
    pub fn set_multi_trial_algorithm_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::nas_job_spec::MultiTrialAlgorithmSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_algorithm_spec = std::option::Option::Some(
            crate::model::nas_job_spec::NasAlgorithmSpec::MultiTrialAlgorithmSpec(v.into()),
        );
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for NasJobSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec"
    }
}

/// Defines additional types related to [NasJobSpec].
#[cfg(feature = "job_service")]
pub mod nas_job_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The spec of multi-trial Neural Architecture Search (NAS).
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiTrialAlgorithmSpec {
        /// The multi-trial Neural Architecture Search (NAS) algorithm
        /// type. Defaults to `REINFORCEMENT_LEARNING`.
        pub multi_trial_algorithm:
            crate::model::nas_job_spec::multi_trial_algorithm_spec::MultiTrialAlgorithm,

        /// Metric specs for the NAS job.
        /// Validation for this field is done at `multi_trial_algorithm_spec` field.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub metric:
            std::option::Option<crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec>,

        /// Required. Spec for search trials.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub search_trial_spec: std::option::Option<
            crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec,
        >,

        /// Spec for train trials. Top N [TrainTrialSpec.max_parallel_trial_count]
        /// search trials will be trained for every M
        /// [TrainTrialSpec.frequency] trials searched.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub train_trial_spec: std::option::Option<
            crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl MultiTrialAlgorithmSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [multi_trial_algorithm][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::multi_trial_algorithm].
        pub fn set_multi_trial_algorithm<
            T: std::convert::Into<
                    crate::model::nas_job_spec::multi_trial_algorithm_spec::MultiTrialAlgorithm,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.multi_trial_algorithm = v.into();
            self
        }

        /// Sets the value of [metric][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::metric].
        pub fn set_metric<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metric = v.into();
            self
        }

        /// Sets the value of [search_trial_spec][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::search_trial_spec].
        pub fn set_search_trial_spec<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_trial_spec = v.into();
            self
        }

        /// Sets the value of [train_trial_spec][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::train_trial_spec].
        pub fn set_train_trial_spec<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.train_trial_spec = v.into();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for MultiTrialAlgorithmSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec"
        }
    }

    /// Defines additional types related to [MultiTrialAlgorithmSpec].
    #[cfg(feature = "job_service")]
    pub mod multi_trial_algorithm_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a metric to optimize.
        #[cfg(feature = "job_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MetricSpec {
            /// Required. The ID of the metric. Must not contain whitespaces.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub metric_id: std::string::String,

            /// Required. The optimization goal of the metric.
            pub goal: crate::model::nas_job_spec::multi_trial_algorithm_spec::metric_spec::GoalType,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "job_service")]
        impl MetricSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [metric_id][crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec::metric_id].
            pub fn set_metric_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.metric_id = v.into();
                self
            }

            /// Sets the value of [goal][crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec::goal].
            pub fn set_goal<T: std::convert::Into<crate::model::nas_job_spec::multi_trial_algorithm_spec::metric_spec::GoalType>>(mut self, v: T) -> Self{
                self.goal = v.into();
                self
            }
        }

        #[cfg(feature = "job_service")]
        impl wkt::message::Message for MetricSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec"
            }
        }

        /// Defines additional types related to [MetricSpec].
        #[cfg(feature = "job_service")]
        pub mod metric_spec {
            #[allow(unused_imports)]
            use super::*;

            /// The available types of optimization goals.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(feature = "job_service")]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum GoalType {
                /// Goal Type will default to maximize.
                Unspecified,
                /// Maximize the goal metric.
                Maximize,
                /// Minimize the goal metric.
                Minimize,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [GoalType::value] or
                /// [GoalType::name].
                UnknownValue(goal_type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(feature = "job_service")]
            pub mod goal_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(feature = "job_service")]
            impl GoalType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Maximize => std::option::Option::Some(1),
                        Self::Minimize => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("GOAL_TYPE_UNSPECIFIED"),
                        Self::Maximize => std::option::Option::Some("MAXIMIZE"),
                        Self::Minimize => std::option::Option::Some("MINIMIZE"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl std::default::Default for GoalType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(feature = "job_service")]
            impl std::fmt::Display for GoalType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(feature = "job_service")]
            impl std::convert::From<i32> for GoalType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Maximize,
                        2 => Self::Minimize,
                        _ => Self::UnknownValue(goal_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl std::convert::From<&str> for GoalType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "GOAL_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "MAXIMIZE" => Self::Maximize,
                        "MINIMIZE" => Self::Minimize,
                        _ => Self::UnknownValue(goal_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl serde::ser::Serialize for GoalType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Maximize => serializer.serialize_i32(1),
                        Self::Minimize => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(feature = "job_service")]
            impl<'de> serde::de::Deserialize<'de> for GoalType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<GoalType>::new(
                        ".google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec.GoalType"))
                }
            }
        }

        /// Represent spec for search trials.
        #[cfg(feature = "job_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SearchTrialSpec {
            /// Required. The spec of a search trial job. The same spec applies to
            /// all search trials.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub search_trial_job_spec: std::option::Option<crate::model::CustomJobSpec>,

            /// Required. The maximum number of Neural Architecture Search (NAS) trials
            /// to run.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_trial_count: i32,

            /// Required. The maximum number of trials to run in parallel.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_parallel_trial_count: i32,

            /// The number of failed trials that need to be seen before failing
            /// the NasJob.
            ///
            /// If set to 0, Vertex AI decides how many trials must fail
            /// before the whole job fails.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_failed_trial_count: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "job_service")]
        impl SearchTrialSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [search_trial_job_spec][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::search_trial_job_spec].
            pub fn set_search_trial_job_spec<
                T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.search_trial_job_spec = v.into();
                self
            }

            /// Sets the value of [max_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::max_trial_count].
            pub fn set_max_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_trial_count = v.into();
                self
            }

            /// Sets the value of [max_parallel_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::max_parallel_trial_count].
            pub fn set_max_parallel_trial_count<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.max_parallel_trial_count = v.into();
                self
            }

            /// Sets the value of [max_failed_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::max_failed_trial_count].
            pub fn set_max_failed_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_failed_trial_count = v.into();
                self
            }
        }

        #[cfg(feature = "job_service")]
        impl wkt::message::Message for SearchTrialSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec"
            }
        }

        /// Represent spec for train trials.
        #[cfg(feature = "job_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TrainTrialSpec {
            /// Required. The spec of a train trial job. The same spec applies to
            /// all train trials.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub train_trial_job_spec: std::option::Option<crate::model::CustomJobSpec>,

            /// Required. The maximum number of trials to run in parallel.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_parallel_trial_count: i32,

            /// Required. Frequency of search trials to start train stage. Top N
            /// [TrainTrialSpec.max_parallel_trial_count]
            /// search trials will be trained for every M
            /// [TrainTrialSpec.frequency] trials searched.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub frequency: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "job_service")]
        impl TrainTrialSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [train_trial_job_spec][crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec::train_trial_job_spec].
            pub fn set_train_trial_job_spec<
                T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.train_trial_job_spec = v.into();
                self
            }

            /// Sets the value of [max_parallel_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec::max_parallel_trial_count].
            pub fn set_max_parallel_trial_count<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.max_parallel_trial_count = v.into();
                self
            }

            /// Sets the value of [frequency][crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec::frequency].
            pub fn set_frequency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.frequency = v.into();
                self
            }
        }

        #[cfg(feature = "job_service")]
        impl wkt::message::Message for TrainTrialSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec"
            }
        }

        /// The available types of multi-trial algorithms.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "job_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MultiTrialAlgorithm {
            /// Defaults to `REINFORCEMENT_LEARNING`.
            Unspecified,
            /// The Reinforcement Learning Algorithm for Multi-trial Neural
            /// Architecture Search (NAS).
            ReinforcementLearning,
            /// The Grid Search Algorithm for Multi-trial Neural
            /// Architecture Search (NAS).
            GridSearch,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MultiTrialAlgorithm::value] or
            /// [MultiTrialAlgorithm::name].
            UnknownValue(multi_trial_algorithm::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "job_service")]
        pub mod multi_trial_algorithm {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "job_service")]
        impl MultiTrialAlgorithm {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ReinforcementLearning => std::option::Option::Some(1),
                    Self::GridSearch => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("MULTI_TRIAL_ALGORITHM_UNSPECIFIED")
                    }
                    Self::ReinforcementLearning => {
                        std::option::Option::Some("REINFORCEMENT_LEARNING")
                    }
                    Self::GridSearch => std::option::Option::Some("GRID_SEARCH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "job_service")]
        impl std::default::Default for MultiTrialAlgorithm {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "job_service")]
        impl std::fmt::Display for MultiTrialAlgorithm {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "job_service")]
        impl std::convert::From<i32> for MultiTrialAlgorithm {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ReinforcementLearning,
                    2 => Self::GridSearch,
                    _ => Self::UnknownValue(multi_trial_algorithm::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "job_service")]
        impl std::convert::From<&str> for MultiTrialAlgorithm {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MULTI_TRIAL_ALGORITHM_UNSPECIFIED" => Self::Unspecified,
                    "REINFORCEMENT_LEARNING" => Self::ReinforcementLearning,
                    "GRID_SEARCH" => Self::GridSearch,
                    _ => Self::UnknownValue(multi_trial_algorithm::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "job_service")]
        impl serde::ser::Serialize for MultiTrialAlgorithm {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ReinforcementLearning => serializer.serialize_i32(1),
                    Self::GridSearch => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "job_service")]
        impl<'de> serde::de::Deserialize<'de> for MultiTrialAlgorithm {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MultiTrialAlgorithm>::new(
                    ".google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.MultiTrialAlgorithm"))
            }
        }
    }

    /// The Neural Architecture Search (NAS) algorithm specification.
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum NasAlgorithmSpec {
        /// The spec of multi-trial algorithms.
        MultiTrialAlgorithmSpec(
            std::boxed::Box<crate::model::nas_job_spec::MultiTrialAlgorithmSpec>,
        ),
    }
}

/// Represents a uCAIP NasJob output.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasJobOutput {
    /// The output of this Neural Architecture Search (NAS) job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output: std::option::Option<crate::model::nas_job_output::Output>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl NasJobOutput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::NasJobOutput::output].
    ///
    /// Note that all the setters affecting `output` are mutually
    /// exclusive.
    pub fn set_output<
        T: std::convert::Into<std::option::Option<crate::model::nas_job_output::Output>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = v.into();
        self
    }

    /// The value of [output][crate::model::NasJobOutput::output]
    /// if it holds a `MultiTrialJobOutput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_trial_job_output(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::nas_job_output::MultiTrialJobOutput>>
    {
        #[allow(unreachable_patterns)]
        self.output.as_ref().and_then(|v| match v {
            crate::model::nas_job_output::Output::MultiTrialJobOutput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output][crate::model::NasJobOutput::output]
    /// to hold a `MultiTrialJobOutput`.
    ///
    /// Note that all the setters affecting `output` are
    /// mutually exclusive.
    pub fn set_multi_trial_job_output<
        T: std::convert::Into<std::boxed::Box<crate::model::nas_job_output::MultiTrialJobOutput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = std::option::Option::Some(
            crate::model::nas_job_output::Output::MultiTrialJobOutput(v.into()),
        );
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for NasJobOutput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJobOutput"
    }
}

/// Defines additional types related to [NasJobOutput].
#[cfg(feature = "job_service")]
pub mod nas_job_output {
    #[allow(unused_imports)]
    use super::*;

    /// The output of a multi-trial Neural Architecture Search (NAS) jobs.
    #[cfg(feature = "job_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiTrialJobOutput {
        /// Output only. List of NasTrials that were started as part of search stage.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub search_trials: std::vec::Vec<crate::model::NasTrial>,

        /// Output only. List of NasTrials that were started as part of train stage.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub train_trials: std::vec::Vec<crate::model::NasTrial>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "job_service")]
    impl MultiTrialJobOutput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search_trials][crate::model::nas_job_output::MultiTrialJobOutput::search_trials].
        pub fn set_search_trials<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::NasTrial>,
        {
            use std::iter::Iterator;
            self.search_trials = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [train_trials][crate::model::nas_job_output::MultiTrialJobOutput::train_trials].
        pub fn set_train_trials<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::NasTrial>,
        {
            use std::iter::Iterator;
            self.train_trials = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "job_service")]
    impl wkt::message::Message for MultiTrialJobOutput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NasJobOutput.MultiTrialJobOutput"
        }
    }

    /// The output of this Neural Architecture Search (NAS) job.
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Output {
        /// Output only. The output of this multi-trial Neural Architecture Search
        /// (NAS) job.
        MultiTrialJobOutput(std::boxed::Box<crate::model::nas_job_output::MultiTrialJobOutput>),
    }
}

/// Represents a uCAIP NasJob trial.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasTrial {
    /// Output only. The identifier of the NasTrial assigned by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The detailed state of the NasTrial.
    pub state: crate::model::nas_trial::State,

    /// Output only. The final measurement containing the objective value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_measurement: std::option::Option<crate::model::Measurement>,

    /// Output only. Time when the NasTrial was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasTrial's status changed to `SUCCEEDED` or
    /// `INFEASIBLE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl NasTrial {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::NasTrial::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NasTrial::state].
    pub fn set_state<T: std::convert::Into<crate::model::nas_trial::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [final_measurement][crate::model::NasTrial::final_measurement].
    pub fn set_final_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.final_measurement = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::NasTrial::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::NasTrial::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for NasTrial {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasTrial"
    }
}

/// Defines additional types related to [NasTrial].
#[cfg(feature = "job_service")]
pub mod nas_trial {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a NasTrial state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "job_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The NasTrial state is unspecified.
        Unspecified,
        /// Indicates that a specific NasTrial has been requested, but it has not yet
        /// been suggested by the service.
        Requested,
        /// Indicates that the NasTrial has been suggested.
        Active,
        /// Indicates that the NasTrial should stop according to the service.
        Stopping,
        /// Indicates that the NasTrial is completed successfully.
        Succeeded,
        /// Indicates that the NasTrial should not be attempted again.
        /// The service will set a NasTrial to INFEASIBLE when it's done but missing
        /// the final_measurement.
        Infeasible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "job_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "job_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Requested => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Stopping => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Infeasible => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Requested => std::option::Option::Some("REQUESTED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Infeasible => std::option::Option::Some("INFEASIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "job_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Requested,
                2 => Self::Active,
                3 => Self::Stopping,
                4 => Self::Succeeded,
                5 => Self::Infeasible,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "REQUESTED" => Self::Requested,
                "ACTIVE" => Self::Active,
                "STOPPING" => Self::Stopping,
                "SUCCEEDED" => Self::Succeeded,
                "INFEASIBLE" => Self::Infeasible,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Requested => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Stopping => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Infeasible => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "job_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.NasTrial.State",
            ))
        }
    }
}

/// Network spec.
#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkSpec {
    /// Whether to enable public internet access. Default false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_internet_access: bool,

    /// The full name of the Google Compute Engine
    /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// The name of the subnet that this instance is in.
    /// Format:
    /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl NetworkSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_internet_access][crate::model::NetworkSpec::enable_internet_access].
    pub fn set_enable_internet_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_internet_access = v.into();
        self
    }

    /// Sets the value of [network][crate::model::NetworkSpec::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkSpec::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl wkt::message::Message for NetworkSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NetworkSpec"
    }
}

/// The euc configuration of NotebookRuntimeTemplate.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookEucConfig {
    /// Input only. Whether EUC is disabled in this NotebookRuntimeTemplate.
    /// In proto3, the default value of a boolean is false. In this way, by default
    /// EUC will be enabled for NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub euc_disabled: bool,

    /// Output only. Whether ActAs check is bypassed for service account attached
    /// to the VM. If false, we need ActAs check for the default Compute Engine
    /// Service account. When a Runtime is created, a VM is allocated using Default
    /// Compute Engine Service Account. Any user requesting to use this Runtime
    /// requires Service Account User (ActAs) permission over this SA. If true,
    /// Runtime owner is using EUC and does not require the above permission as VM
    /// no longer use default Compute Engine SA, but a P4SA.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub bypass_actas_check: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl NotebookEucConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [euc_disabled][crate::model::NotebookEucConfig::euc_disabled].
    pub fn set_euc_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.euc_disabled = v.into();
        self
    }

    /// Sets the value of [bypass_actas_check][crate::model::NotebookEucConfig::bypass_actas_check].
    pub fn set_bypass_actas_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.bypass_actas_check = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for NotebookEucConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookEucConfig"
    }
}

/// NotebookExecutionJob represents an instance of a notebook execution.
#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookExecutionJob {
    /// Output only. The resource name of this NotebookExecutionJob. Format:
    /// `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the NotebookExecutionJob. The name can be up to 128
    /// characters long and can consist of any UTF-8 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Max running time of the execution job in seconds (default 86400s / 24 hrs).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_timeout: std::option::Option<wkt::Duration>,

    /// Output only. The Schedule resource name if this job is triggered by one.
    /// Format:
    /// `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schedule_resource_name: std::string::String,

    /// Output only. The state of the NotebookExecutionJob.
    pub job_state: crate::model::JobState,

    /// Output only. Populated when the NotebookExecutionJob is completed. When
    /// there is an error during notebook execution, the error details are
    /// populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Output only. Timestamp when this NotebookExecutionJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this NotebookExecutionJob was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize NotebookExecutionJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the kernel to use during notebook execution. If unset, the
    /// default kernel is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kernel_name: std::string::String,

    /// Customer-managed encryption key spec for the notebook execution job.
    /// This field is auto-populated if the
    /// [NotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookRuntimeTemplate]
    /// has an encryption spec.
    ///
    /// [google.cloud.aiplatform.v1.NotebookRuntimeTemplate]: crate::model::NotebookRuntimeTemplate
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The input notebook.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_source: std::option::Option<crate::model::notebook_execution_job::NotebookSource>,

    /// The compute config to use for an execution job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub environment_spec:
        std::option::Option<crate::model::notebook_execution_job::EnvironmentSpec>,

    /// The location to store the notebook execution result.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub execution_sink: std::option::Option<crate::model::notebook_execution_job::ExecutionSink>,

    /// The identity to run the execution as.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub execution_identity:
        std::option::Option<crate::model::notebook_execution_job::ExecutionIdentity>,

    /// Runtime environment for the notebook execution job. If unspecified, the
    /// default runtime of Colab is used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_environment:
        std::option::Option<crate::model::notebook_execution_job::RuntimeEnvironment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl NotebookExecutionJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotebookExecutionJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotebookExecutionJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::NotebookExecutionJob::execution_timeout].
    pub fn set_execution_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_timeout = v.into();
        self
    }

    /// Sets the value of [schedule_resource_name][crate::model::NotebookExecutionJob::schedule_resource_name].
    pub fn set_schedule_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_resource_name = v.into();
        self
    }

    /// Sets the value of [job_state][crate::model::NotebookExecutionJob::job_state].
    pub fn set_job_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.job_state = v.into();
        self
    }

    /// Sets the value of [status][crate::model::NotebookExecutionJob::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NotebookExecutionJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotebookExecutionJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [kernel_name][crate::model::NotebookExecutionJob::kernel_name].
    pub fn set_kernel_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kernel_name = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NotebookExecutionJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NotebookExecutionJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source].
    ///
    /// Note that all the setters affecting `notebook_source` are mutually
    /// exclusive.
    pub fn set_notebook_source<
        T: std::convert::Into<
                std::option::Option<crate::model::notebook_execution_job::NotebookSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = v.into();
        self
    }

    /// The value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// if it holds a `DataformRepositorySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dataform_repository_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::DataformRepositorySource>,
    > {
        #[allow(unreachable_patterns)]
        self.notebook_source.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::NotebookSource::DataformRepositorySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// if it holds a `GcsNotebookSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_notebook_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::GcsNotebookSource>,
    > {
        #[allow(unreachable_patterns)]
        self.notebook_source.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::NotebookSource::GcsNotebookSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// if it holds a `DirectNotebookSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn direct_notebook_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::DirectNotebookSource>,
    > {
        #[allow(unreachable_patterns)]
        self.notebook_source.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::NotebookSource::DirectNotebookSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// to hold a `DataformRepositorySource`.
    ///
    /// Note that all the setters affecting `notebook_source` are
    /// mutually exclusive.
    pub fn set_dataform_repository_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::notebook_execution_job::DataformRepositorySource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = std::option::Option::Some(
            crate::model::notebook_execution_job::NotebookSource::DataformRepositorySource(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// to hold a `GcsNotebookSource`.
    ///
    /// Note that all the setters affecting `notebook_source` are
    /// mutually exclusive.
    pub fn set_gcs_notebook_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::notebook_execution_job::GcsNotebookSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = std::option::Option::Some(
            crate::model::notebook_execution_job::NotebookSource::GcsNotebookSource(v.into()),
        );
        self
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// to hold a `DirectNotebookSource`.
    ///
    /// Note that all the setters affecting `notebook_source` are
    /// mutually exclusive.
    pub fn set_direct_notebook_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::notebook_execution_job::DirectNotebookSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = std::option::Option::Some(
            crate::model::notebook_execution_job::NotebookSource::DirectNotebookSource(v.into()),
        );
        self
    }

    /// Sets the value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec].
    ///
    /// Note that all the setters affecting `environment_spec` are mutually
    /// exclusive.
    pub fn set_environment_spec<
        T: std::convert::Into<
                std::option::Option<crate::model::notebook_execution_job::EnvironmentSpec>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_spec = v.into();
        self
    }

    /// The value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// if it holds a `NotebookRuntimeTemplateResourceName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook_runtime_template_resource_name(
        &self,
    ) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.environment_spec.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::EnvironmentSpec::NotebookRuntimeTemplateResourceName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// if it holds a `CustomEnvironmentSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_environment_spec(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::CustomEnvironmentSpec>,
    > {
        #[allow(unreachable_patterns)]
        self.environment_spec.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::EnvironmentSpec::CustomEnvironmentSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// to hold a `NotebookRuntimeTemplateResourceName`.
    ///
    /// Note that all the setters affecting `environment_spec` are
    /// mutually exclusive.
    pub fn set_notebook_runtime_template_resource_name<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_spec = std::option::Option::Some(
            crate::model::notebook_execution_job::EnvironmentSpec::NotebookRuntimeTemplateResourceName(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// to hold a `CustomEnvironmentSpec`.
    ///
    /// Note that all the setters affecting `environment_spec` are
    /// mutually exclusive.
    pub fn set_custom_environment_spec<
        T: std::convert::Into<
                std::boxed::Box<crate::model::notebook_execution_job::CustomEnvironmentSpec>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_spec = std::option::Option::Some(
            crate::model::notebook_execution_job::EnvironmentSpec::CustomEnvironmentSpec(v.into()),
        );
        self
    }

    /// Sets the value of [execution_sink][crate::model::NotebookExecutionJob::execution_sink].
    ///
    /// Note that all the setters affecting `execution_sink` are mutually
    /// exclusive.
    pub fn set_execution_sink<
        T: std::convert::Into<
                std::option::Option<crate::model::notebook_execution_job::ExecutionSink>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_sink = v.into();
        self
    }

    /// The value of [execution_sink][crate::model::NotebookExecutionJob::execution_sink]
    /// if it holds a `GcsOutputUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_output_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_sink.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::ExecutionSink::GcsOutputUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_sink][crate::model::NotebookExecutionJob::execution_sink]
    /// to hold a `GcsOutputUri`.
    ///
    /// Note that all the setters affecting `execution_sink` are
    /// mutually exclusive.
    pub fn set_gcs_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_sink = std::option::Option::Some(
            crate::model::notebook_execution_job::ExecutionSink::GcsOutputUri(v.into()),
        );
        self
    }

    /// Sets the value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity].
    ///
    /// Note that all the setters affecting `execution_identity` are mutually
    /// exclusive.
    pub fn set_execution_identity<
        T: std::convert::Into<
                std::option::Option<crate::model::notebook_execution_job::ExecutionIdentity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_identity = v.into();
        self
    }

    /// The value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// if it holds a `ExecutionUser`, `None` if the field is not set or
    /// holds a different branch.
    pub fn execution_user(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_identity.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::ExecutionIdentity::ExecutionUser(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// if it holds a `ServiceAccount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_account(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_identity.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::ExecutionIdentity::ServiceAccount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// to hold a `ExecutionUser`.
    ///
    /// Note that all the setters affecting `execution_identity` are
    /// mutually exclusive.
    pub fn set_execution_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_identity = std::option::Option::Some(
            crate::model::notebook_execution_job::ExecutionIdentity::ExecutionUser(v.into()),
        );
        self
    }

    /// Sets the value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// to hold a `ServiceAccount`.
    ///
    /// Note that all the setters affecting `execution_identity` are
    /// mutually exclusive.
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_identity = std::option::Option::Some(
            crate::model::notebook_execution_job::ExecutionIdentity::ServiceAccount(v.into()),
        );
        self
    }

    /// Sets the value of [runtime_environment][crate::model::NotebookExecutionJob::runtime_environment].
    ///
    /// Note that all the setters affecting `runtime_environment` are mutually
    /// exclusive.
    pub fn set_runtime_environment<
        T: std::convert::Into<
                std::option::Option<crate::model::notebook_execution_job::RuntimeEnvironment>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_environment = v.into();
        self
    }

    /// The value of [runtime_environment][crate::model::NotebookExecutionJob::runtime_environment]
    /// if it holds a `WorkbenchRuntime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn workbench_runtime(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::notebook_execution_job::WorkbenchRuntime>>
    {
        #[allow(unreachable_patterns)]
        self.runtime_environment.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::RuntimeEnvironment::WorkbenchRuntime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_environment][crate::model::NotebookExecutionJob::runtime_environment]
    /// to hold a `WorkbenchRuntime`.
    ///
    /// Note that all the setters affecting `runtime_environment` are
    /// mutually exclusive.
    pub fn set_workbench_runtime<
        T: std::convert::Into<std::boxed::Box<crate::model::notebook_execution_job::WorkbenchRuntime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_environment = std::option::Option::Some(
            crate::model::notebook_execution_job::RuntimeEnvironment::WorkbenchRuntime(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl wkt::message::Message for NotebookExecutionJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob"
    }
}

/// Defines additional types related to [NotebookExecutionJob].
#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
pub mod notebook_execution_job {
    #[allow(unused_imports)]
    use super::*;

    /// The Dataform Repository containing the input notebook.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataformRepositorySource {
        /// The resource name of the Dataform Repository. Format:
        /// `projects/{project_id}/locations/{location}/repositories/{repository_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataform_repository_resource_name: std::string::String,

        /// The commit SHA to read repository with. If unset, the file will be read
        /// at HEAD.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub commit_sha: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl DataformRepositorySource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataform_repository_resource_name][crate::model::notebook_execution_job::DataformRepositorySource::dataform_repository_resource_name].
        pub fn set_dataform_repository_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataform_repository_resource_name = v.into();
            self
        }

        /// Sets the value of [commit_sha][crate::model::notebook_execution_job::DataformRepositorySource::commit_sha].
        pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.commit_sha = v.into();
            self
        }
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl wkt::message::Message for DataformRepositorySource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.DataformRepositorySource"
        }
    }

    /// The Cloud Storage uri for the input notebook.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsNotebookSource {
        /// The Cloud Storage uri pointing to the ipynb file. Format:
        /// `gs://bucket/notebook_file.ipynb`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// The version of the Cloud Storage object to read. If unset, the current
        /// version of the object is read. See
        /// <https://cloud.google.com/storage/docs/metadata#generation-number>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub generation: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl GcsNotebookSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::notebook_execution_job::GcsNotebookSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [generation][crate::model::notebook_execution_job::GcsNotebookSource::generation].
        pub fn set_generation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.generation = v.into();
            self
        }
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl wkt::message::Message for GcsNotebookSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.GcsNotebookSource"
        }
    }

    /// The content of the input notebook in ipynb format.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DirectNotebookSource {
        /// The base64-encoded contents of the input notebook file.
        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub content: ::bytes::Bytes,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl DirectNotebookSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [content][crate::model::notebook_execution_job::DirectNotebookSource::content].
        pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl wkt::message::Message for DirectNotebookSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.DirectNotebookSource"
        }
    }

    /// Compute configuration to use for an execution job.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomEnvironmentSpec {
        /// The specification of a single machine for the execution job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_spec: std::option::Option<crate::model::MachineSpec>,

        /// The specification of a persistent disk to attach for the execution job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub persistent_disk_spec: std::option::Option<crate::model::PersistentDiskSpec>,

        /// The network configuration to use for the execution job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub network_spec: std::option::Option<crate::model::NetworkSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl CustomEnvironmentSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_spec][crate::model::notebook_execution_job::CustomEnvironmentSpec::machine_spec].
        pub fn set_machine_spec<
            T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.machine_spec = v.into();
            self
        }

        /// Sets the value of [persistent_disk_spec][crate::model::notebook_execution_job::CustomEnvironmentSpec::persistent_disk_spec].
        pub fn set_persistent_disk_spec<
            T: std::convert::Into<std::option::Option<crate::model::PersistentDiskSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.persistent_disk_spec = v.into();
            self
        }

        /// Sets the value of [network_spec][crate::model::notebook_execution_job::CustomEnvironmentSpec::network_spec].
        pub fn set_network_spec<
            T: std::convert::Into<std::option::Option<crate::model::NetworkSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network_spec = v.into();
            self
        }
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl wkt::message::Message for CustomEnvironmentSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.CustomEnvironmentSpec"
        }
    }

    /// Configuration for a Workbench Instances-based environment.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WorkbenchRuntime {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl WorkbenchRuntime {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    impl wkt::message::Message for WorkbenchRuntime {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.WorkbenchRuntime"
        }
    }

    /// The input notebook.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum NotebookSource {
        /// The Dataform Repository pointing to a single file notebook repository.
        DataformRepositorySource(
            std::boxed::Box<crate::model::notebook_execution_job::DataformRepositorySource>,
        ),
        /// The Cloud Storage url pointing to the ipynb file. Format:
        /// `gs://bucket/notebook_file.ipynb`
        GcsNotebookSource(std::boxed::Box<crate::model::notebook_execution_job::GcsNotebookSource>),
        /// The contents of an input notebook file.
        DirectNotebookSource(
            std::boxed::Box<crate::model::notebook_execution_job::DirectNotebookSource>,
        ),
    }

    /// The compute config to use for an execution job.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EnvironmentSpec {
        /// The NotebookRuntimeTemplate to source compute configuration from.
        NotebookRuntimeTemplateResourceName(std::string::String),
        /// The custom compute configuration for an execution job.
        CustomEnvironmentSpec(
            std::boxed::Box<crate::model::notebook_execution_job::CustomEnvironmentSpec>,
        ),
    }

    /// The location to store the notebook execution result.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ExecutionSink {
        /// The Cloud Storage location to upload the result to. Format:
        /// `gs://bucket-name`
        GcsOutputUri(std::string::String),
    }

    /// The identity to run the execution as.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ExecutionIdentity {
        /// The user email to run the execution as. Only supported by Colab runtimes.
        ExecutionUser(std::string::String),
        /// The service account to run the execution as.
        ServiceAccount(std::string::String),
    }

    /// Runtime environment for the notebook execution job. If unspecified, the
    /// default runtime of Colab is used.
    #[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RuntimeEnvironment {
        /// The Workbench runtime configuration to use for the notebook execution.
        WorkbenchRuntime(std::boxed::Box<crate::model::notebook_execution_job::WorkbenchRuntime>),
    }
}

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookIdleShutdownConfig {
    /// Required. Duration is accurate to the second. In Notebook, Idle Timeout is
    /// accurate to minute so the range of idle_timeout (second) is: 10 * 60 ~ 1440
    ///
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub idle_shutdown_disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl NotebookIdleShutdownConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_timeout][crate::model::NotebookIdleShutdownConfig::idle_timeout].
    pub fn set_idle_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_timeout = v.into();
        self
    }

    /// Sets the value of [idle_shutdown_disabled][crate::model::NotebookIdleShutdownConfig::idle_shutdown_disabled].
    pub fn set_idle_shutdown_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.idle_shutdown_disabled = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for NotebookIdleShutdownConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookIdleShutdownConfig"
    }
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
/// Multiple runtimes can be created from a runtime template.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookRuntimeTemplate {
    /// The resource name of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the NotebookRuntimeTemplate.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Deprecated: This field has no behavior. Use
    /// notebook_runtime_type = 'ONE_CLICK' instead.
    ///
    /// The default template to use if not specified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub is_default: bool,

    /// Optional. Immutable. The specification of a single machine for the
    /// template.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Optional. The specification of [persistent
    /// disk][<https://cloud.google.com/compute/docs/disks/persistent-disks>]
    /// attached to the runtime as data disk storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_persistent_disk_spec: std::option::Option<crate::model::PersistentDiskSpec>,

    /// Optional. Network spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_spec: std::option::Option<crate::model::NetworkSpec>,

    /// Deprecated: This field is ignored and the "Vertex AI Notebook Service
    /// Account"
    /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
    /// used for the runtime workload identity.
    /// See
    /// <https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account>
    /// for more details.
    /// For NotebookExecutionJob, use NotebookExecutionJob.service_account instead.
    ///
    /// The service account that the runtime workload runs as.
    /// You can use any service account within the same project, but you
    /// must have the service account user permission to use the instance.
    ///
    /// If not specified, the [Compute Engine default service
    /// account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
    /// is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub service_account: std::string::String,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize the
    /// NotebookRuntimeTemplates.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The idle shutdown configuration of NotebookRuntimeTemplate. This config
    /// will only be set when idle shutdown is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_shutdown_config: std::option::Option<crate::model::NotebookIdleShutdownConfig>,

    /// EUC configuration of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub euc_config: std::option::Option<crate::model::NotebookEucConfig>,

    /// Output only. Timestamp when this NotebookRuntimeTemplate was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this NotebookRuntimeTemplate was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Immutable. The type of the notebook runtime template.
    pub notebook_runtime_type: crate::model::NotebookRuntimeType,

    /// Optional. Immutable. Runtime Shielded VM spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_vm_config: std::option::Option<crate::model::ShieldedVmConfig>,

    /// Optional. The Compute Engine tags to add to runtime (see [Tagging
    /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Customer-managed encryption key spec for the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. The notebook software configuration of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub software_config: std::option::Option<crate::model::NotebookSoftwareConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl NotebookRuntimeTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotebookRuntimeTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotebookRuntimeTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotebookRuntimeTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [is_default][crate::model::NotebookRuntimeTemplate::is_default].
    #[deprecated]
    pub fn set_is_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_default = v.into();
        self
    }

    /// Sets the value of [machine_spec][crate::model::NotebookRuntimeTemplate::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [data_persistent_disk_spec][crate::model::NotebookRuntimeTemplate::data_persistent_disk_spec].
    pub fn set_data_persistent_disk_spec<
        T: std::convert::Into<std::option::Option<crate::model::PersistentDiskSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_persistent_disk_spec = v.into();
        self
    }

    /// Sets the value of [network_spec][crate::model::NotebookRuntimeTemplate::network_spec].
    pub fn set_network_spec<
        T: std::convert::Into<std::option::Option<crate::model::NetworkSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::NotebookRuntimeTemplate::service_account].
    #[deprecated]
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::NotebookRuntimeTemplate::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [idle_shutdown_config][crate::model::NotebookRuntimeTemplate::idle_shutdown_config].
    pub fn set_idle_shutdown_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookIdleShutdownConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.idle_shutdown_config = v.into();
        self
    }

    /// Sets the value of [euc_config][crate::model::NotebookRuntimeTemplate::euc_config].
    pub fn set_euc_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookEucConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.euc_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NotebookRuntimeTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotebookRuntimeTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_type][crate::model::NotebookRuntimeTemplate::notebook_runtime_type].
    pub fn set_notebook_runtime_type<T: std::convert::Into<crate::model::NotebookRuntimeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_type = v.into();
        self
    }

    /// Sets the value of [shielded_vm_config][crate::model::NotebookRuntimeTemplate::shielded_vm_config].
    pub fn set_shielded_vm_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedVmConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_vm_config = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NotebookRuntimeTemplate::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::NotebookRuntimeTemplate::software_config].
    pub fn set_software_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookSoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.software_config = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::NotebookRuntimeTemplate::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NotebookRuntimeTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for NotebookRuntimeTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntimeTemplate"
    }
}

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime limited to 24
/// hours.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookRuntime {
    /// Output only. The resource name of the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user email of the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_user: std::string::String,

    /// Output only. The pointer to NotebookRuntimeTemplate this NotebookRuntime is
    /// created from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime_template_ref:
        std::option::Option<crate::model::NotebookRuntimeTemplateRef>,

    /// Output only. The proxy endpoint used to access the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub proxy_uri: std::string::String,

    /// Output only. Timestamp when this NotebookRuntime was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this NotebookRuntime was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The health state of the NotebookRuntime.
    pub health_state: crate::model::notebook_runtime::HealthState,

    /// Required. The display name of the NotebookRuntime.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Deprecated: This field is no longer used and the "Vertex AI
    /// Notebook Service Account"
    /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
    /// used for the runtime workload identity.
    /// See
    /// <https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account>
    /// for more details.
    ///
    /// The service account that the NotebookRuntime workload runs as.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Output only. The runtime (instance) state of the NotebookRuntime.
    pub runtime_state: crate::model::notebook_runtime::RuntimeState,

    /// Output only. Whether NotebookRuntime is upgradable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub is_upgradable: bool,

    /// The labels with user-defined metadata to organize your
    /// NotebookRuntime.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one NotebookRuntime
    /// (System labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for NotebookRuntime:
    ///
    /// * "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output
    ///   only, its value is the Compute Engine instance id.
    /// * "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
    ///   either "bigquery" or "vertex"; if absent, it should be "vertex". This is to
    ///   describe the entry service, either BigQuery or Vertex.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this NotebookRuntime will be expired:
    ///
    /// . System Predefined NotebookRuntime: 24 hours after creation. After
    ///   expiration, system predifined runtime will be deleted.
    /// . User created NotebookRuntime: 6 months after last upgrade. After
    ///   expiration, user created runtime will be stopped and allowed for upgrade.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The VM os image version of NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The type of the notebook runtime.
    pub notebook_runtime_type: crate::model::NotebookRuntimeType,

    /// Output only. The specification of a single machine used by the notebook
    /// runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Output only. The specification of [persistent
    /// disk][<https://cloud.google.com/compute/docs/disks/persistent-disks>]
    /// attached to the notebook runtime as data disk storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_persistent_disk_spec: std::option::Option<crate::model::PersistentDiskSpec>,

    /// Output only. Network spec of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_spec: std::option::Option<crate::model::NetworkSpec>,

    /// Output only. The idle shutdown configuration of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_shutdown_config: std::option::Option<crate::model::NotebookIdleShutdownConfig>,

    /// Output only. EUC configuration of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub euc_config: std::option::Option<crate::model::NotebookEucConfig>,

    /// Output only. Runtime Shielded VM spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_vm_config: std::option::Option<crate::model::ShieldedVmConfig>,

    /// Optional. The Compute Engine tags to add to runtime (see [Tagging
    /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Output only. Software config of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub software_config: std::option::Option<crate::model::NotebookSoftwareConfig>,

    /// Output only. Customer-managed encryption key spec for the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl NotebookRuntime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotebookRuntime::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [runtime_user][crate::model::NotebookRuntime::runtime_user].
    pub fn set_runtime_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_user = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template_ref][crate::model::NotebookRuntime::notebook_runtime_template_ref].
    pub fn set_notebook_runtime_template_ref<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntimeTemplateRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template_ref = v.into();
        self
    }

    /// Sets the value of [proxy_uri][crate::model::NotebookRuntime::proxy_uri].
    pub fn set_proxy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.proxy_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NotebookRuntime::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotebookRuntime::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [health_state][crate::model::NotebookRuntime::health_state].
    pub fn set_health_state<T: std::convert::Into<crate::model::notebook_runtime::HealthState>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotebookRuntime::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotebookRuntime::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::NotebookRuntime::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [runtime_state][crate::model::NotebookRuntime::runtime_state].
    pub fn set_runtime_state<
        T: std::convert::Into<crate::model::notebook_runtime::RuntimeState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_state = v.into();
        self
    }

    /// Sets the value of [is_upgradable][crate::model::NotebookRuntime::is_upgradable].
    pub fn set_is_upgradable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_upgradable = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::NotebookRuntime::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [version][crate::model::NotebookRuntime::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_type][crate::model::NotebookRuntime::notebook_runtime_type].
    pub fn set_notebook_runtime_type<T: std::convert::Into<crate::model::NotebookRuntimeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_type = v.into();
        self
    }

    /// Sets the value of [machine_spec][crate::model::NotebookRuntime::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [data_persistent_disk_spec][crate::model::NotebookRuntime::data_persistent_disk_spec].
    pub fn set_data_persistent_disk_spec<
        T: std::convert::Into<std::option::Option<crate::model::PersistentDiskSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_persistent_disk_spec = v.into();
        self
    }

    /// Sets the value of [network_spec][crate::model::NotebookRuntime::network_spec].
    pub fn set_network_spec<
        T: std::convert::Into<std::option::Option<crate::model::NetworkSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_spec = v.into();
        self
    }

    /// Sets the value of [idle_shutdown_config][crate::model::NotebookRuntime::idle_shutdown_config].
    pub fn set_idle_shutdown_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookIdleShutdownConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.idle_shutdown_config = v.into();
        self
    }

    /// Sets the value of [euc_config][crate::model::NotebookRuntime::euc_config].
    pub fn set_euc_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookEucConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.euc_config = v.into();
        self
    }

    /// Sets the value of [shielded_vm_config][crate::model::NotebookRuntime::shielded_vm_config].
    pub fn set_shielded_vm_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedVmConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_vm_config = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::NotebookRuntime::software_config].
    pub fn set_software_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookSoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.software_config = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NotebookRuntime::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::NotebookRuntime::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::NotebookRuntime::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::NotebookRuntime::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NotebookRuntime::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for NotebookRuntime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntime"
    }
}

/// Defines additional types related to [NotebookRuntime].
#[cfg(feature = "notebook_service")]
pub mod notebook_runtime {
    #[allow(unused_imports)]
    use super::*;

    /// The substate of the NotebookRuntime to display health information.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "notebook_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HealthState {
        /// Unspecified health state.
        Unspecified,
        /// NotebookRuntime is in healthy state. Applies to ACTIVE state.
        Healthy,
        /// NotebookRuntime is in unhealthy state. Applies to ACTIVE state.
        Unhealthy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HealthState::value] or
        /// [HealthState::name].
        UnknownValue(health_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "notebook_service")]
    pub mod health_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "notebook_service")]
    impl HealthState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Healthy => std::option::Option::Some(1),
                Self::Unhealthy => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HEALTH_STATE_UNSPECIFIED"),
                Self::Healthy => std::option::Option::Some("HEALTHY"),
                Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::default::Default for HealthState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::fmt::Display for HealthState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::convert::From<i32> for HealthState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Healthy,
                2 => Self::Unhealthy,
                _ => Self::UnknownValue(health_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::convert::From<&str> for HealthState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HEALTH_STATE_UNSPECIFIED" => Self::Unspecified,
                "HEALTHY" => Self::Healthy,
                "UNHEALTHY" => Self::Unhealthy,
                _ => Self::UnknownValue(health_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl serde::ser::Serialize for HealthState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Healthy => serializer.serialize_i32(1),
                Self::Unhealthy => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl<'de> serde::de::Deserialize<'de> for HealthState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HealthState>::new(
                ".google.cloud.aiplatform.v1.NotebookRuntime.HealthState",
            ))
        }
    }

    /// The substate of the NotebookRuntime to display state of runtime.
    /// The resource of NotebookRuntime is in ACTIVE state for these sub state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "notebook_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuntimeState {
        /// Unspecified runtime state.
        Unspecified,
        /// NotebookRuntime is in running state.
        Running,
        /// NotebookRuntime is in starting state.
        BeingStarted,
        /// NotebookRuntime is in stopping state.
        BeingStopped,
        /// NotebookRuntime is in stopped state.
        Stopped,
        /// NotebookRuntime is in upgrading state. It is in the middle of upgrading
        /// process.
        BeingUpgraded,
        /// NotebookRuntime was unable to start/stop properly.
        Error,
        /// NotebookRuntime is in invalid state. Cannot be recovered.
        Invalid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RuntimeState::value] or
        /// [RuntimeState::name].
        UnknownValue(runtime_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "notebook_service")]
    pub mod runtime_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "notebook_service")]
    impl RuntimeState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::BeingStarted => std::option::Option::Some(2),
                Self::BeingStopped => std::option::Option::Some(3),
                Self::Stopped => std::option::Option::Some(4),
                Self::BeingUpgraded => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(100),
                Self::Invalid => std::option::Option::Some(101),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RUNTIME_STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::BeingStarted => std::option::Option::Some("BEING_STARTED"),
                Self::BeingStopped => std::option::Option::Some("BEING_STOPPED"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::BeingUpgraded => std::option::Option::Some("BEING_UPGRADED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::default::Default for RuntimeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::fmt::Display for RuntimeState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::convert::From<i32> for RuntimeState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::BeingStarted,
                3 => Self::BeingStopped,
                4 => Self::Stopped,
                5 => Self::BeingUpgraded,
                100 => Self::Error,
                101 => Self::Invalid,
                _ => Self::UnknownValue(runtime_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::convert::From<&str> for RuntimeState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RUNTIME_STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "BEING_STARTED" => Self::BeingStarted,
                "BEING_STOPPED" => Self::BeingStopped,
                "STOPPED" => Self::Stopped,
                "BEING_UPGRADED" => Self::BeingUpgraded,
                "ERROR" => Self::Error,
                "INVALID" => Self::Invalid,
                _ => Self::UnknownValue(runtime_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl serde::ser::Serialize for RuntimeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::BeingStarted => serializer.serialize_i32(2),
                Self::BeingStopped => serializer.serialize_i32(3),
                Self::Stopped => serializer.serialize_i32(4),
                Self::BeingUpgraded => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(100),
                Self::Invalid => serializer.serialize_i32(101),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl<'de> serde::de::Deserialize<'de> for RuntimeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RuntimeState>::new(
                ".google.cloud.aiplatform.v1.NotebookRuntime.RuntimeState",
            ))
        }
    }
}

/// Points to a NotebookRuntimeTemplateRef.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookRuntimeTemplateRef {
    /// Immutable. A resource name of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_template: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl NotebookRuntimeTemplateRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notebook_runtime_template][crate::model::NotebookRuntimeTemplateRef::notebook_runtime_template].
    pub fn set_notebook_runtime_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for NotebookRuntimeTemplateRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntimeTemplateRef"
    }
}

/// Request message for
/// [NotebookService.CreateNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate]: crate::client::NotebookService::create_notebook_runtime_template
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookRuntimeTemplateRequest {
    /// Required. The resource name of the Location to create the
    /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NotebookRuntimeTemplate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime_template: std::option::Option<crate::model::NotebookRuntimeTemplate>,

    /// Optional. User specified ID for the notebook runtime template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_template_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl CreateNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNotebookRuntimeTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template][crate::model::CreateNotebookRuntimeTemplateRequest::notebook_runtime_template].
    pub fn set_notebook_runtime_template<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntimeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template_id][crate::model::CreateNotebookRuntimeTemplateRequest::notebook_runtime_template_id].
    pub fn set_notebook_runtime_template_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template_id = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for CreateNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateRequest"
    }
}

/// Metadata information for
/// [NotebookService.CreateNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate]: crate::client::NotebookService::create_notebook_runtime_template
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookRuntimeTemplateOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl CreateNotebookRuntimeTemplateOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateNotebookRuntimeTemplateOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for CreateNotebookRuntimeTemplateOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateOperationMetadata"
    }
}

/// Request message for
/// [NotebookService.GetNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntimeTemplate]
///
/// [google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntimeTemplate]: crate::client::NotebookService::get_notebook_runtime_template
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotebookRuntimeTemplateRequest {
    /// Required. The name of the NotebookRuntimeTemplate resource.
    /// Format:
    /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl GetNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotebookRuntimeTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for GetNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookRuntimeTemplateRequest"
    }
}

/// Request message for
/// [NotebookService.ListNotebookRuntimeTemplates][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]: crate::client::NotebookService::list_notebook_runtime_templates
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimeTemplatesRequest {
    /// Required. The resource name of the Location from which to list the
    /// NotebookRuntimeTemplates.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
    ///   represents the NotebookRuntimeTemplate ID,
    ///   i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
    ///   [google.cloud.aiplatform.v1.NotebookRuntimeTemplate.name].
    /// * `display_name` supports = and !=
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    /// * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
    ///   [USER_DEFINED, ONE_CLICK].
    /// * `machineType` supports = and !=.
    /// * `acceleratorType` supports = and !=.
    ///
    /// Some examples:
    ///
    /// * `notebookRuntimeTemplate=notebookRuntimeTemplate123`
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    /// * `notebookRuntimeType=USER_DEFINED`
    /// * `machineType=e2-standard-4`
    /// * `acceleratorType=NVIDIA_TESLA_T4`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListNotebookRuntimeTemplatesResponse.next_page_token][google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse.next_page_token]
    /// of the previous
    /// [NotebookService.ListNotebookRuntimeTemplates][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse.next_page_token]: crate::model::ListNotebookRuntimeTemplatesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]: crate::client::NotebookService::list_notebook_runtime_templates
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending. Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ListNotebookRuntimeTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotebookRuntimeTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotebookRuntimeTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotebookRuntimeTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotebookRuntimeTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListNotebookRuntimeTemplatesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotebookRuntimeTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ListNotebookRuntimeTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest"
    }
}

/// Response message for
/// [NotebookService.ListNotebookRuntimeTemplates][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]: crate::client::NotebookService::list_notebook_runtime_templates
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimeTemplatesResponse {
    /// List of NotebookRuntimeTemplates in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notebook_runtime_templates: std::vec::Vec<crate::model::NotebookRuntimeTemplate>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListNotebookRuntimeTemplatesRequest.page_token][google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest.page_token]: crate::model::ListNotebookRuntimeTemplatesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ListNotebookRuntimeTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNotebookRuntimeTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_templates][crate::model::ListNotebookRuntimeTemplatesResponse::notebook_runtime_templates].
    pub fn set_notebook_runtime_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotebookRuntimeTemplate>,
    {
        use std::iter::Iterator;
        self.notebook_runtime_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ListNotebookRuntimeTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse"
    }
}

#[cfg(feature = "notebook_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotebookRuntimeTemplatesResponse {
    type PageItem = crate::model::NotebookRuntimeTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notebook_runtime_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [NotebookService.DeleteNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntimeTemplate]: crate::client::NotebookService::delete_notebook_runtime_template
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotebookRuntimeTemplateRequest {
    /// Required. The name of the NotebookRuntimeTemplate resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl DeleteNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotebookRuntimeTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for DeleteNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookRuntimeTemplateRequest"
    }
}

/// Request message for
/// [NotebookService.UpdateNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.UpdateNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpdateNotebookRuntimeTemplate]: crate::client::NotebookService::update_notebook_runtime_template
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNotebookRuntimeTemplateRequest {
    /// Required. The NotebookRuntimeTemplate to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime_template: std::option::Option<crate::model::NotebookRuntimeTemplate>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. Input format:
    /// `{paths: "${updated_filed}"}` Updatable fields:
    ///
    /// * `encryption_spec.kms_key_name`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl UpdateNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notebook_runtime_template][crate::model::UpdateNotebookRuntimeTemplateRequest::notebook_runtime_template].
    pub fn set_notebook_runtime_template<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntimeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNotebookRuntimeTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for UpdateNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateNotebookRuntimeTemplateRequest"
    }
}

/// Request message for
/// [NotebookService.AssignNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime]: crate::client::NotebookService::assign_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignNotebookRuntimeRequest {
    /// Required. The resource name of the Location to get the NotebookRuntime
    /// assignment. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource name of the NotebookRuntimeTemplate based on which a
    /// NotebookRuntime will be assigned (reuse or create a new one).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_template: std::string::String,

    /// Required. Provide runtime specific information (e.g. runtime owner,
    /// notebook id) used for NotebookRuntime assignment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime: std::option::Option<crate::model::NotebookRuntime>,

    /// Optional. User specified ID for the notebook runtime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl AssignNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AssignNotebookRuntimeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template][crate::model::AssignNotebookRuntimeRequest::notebook_runtime_template].
    pub fn set_notebook_runtime_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [notebook_runtime][crate::model::AssignNotebookRuntimeRequest::notebook_runtime].
    pub fn set_notebook_runtime<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_id][crate::model::AssignNotebookRuntimeRequest::notebook_runtime_id].
    pub fn set_notebook_runtime_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_id = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for AssignNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AssignNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.AssignNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime]: crate::client::NotebookService::assign_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl AssignNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::AssignNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::AssignNotebookRuntimeOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for AssignNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AssignNotebookRuntimeOperationMetadata"
    }
}

/// Request message for
/// [NotebookService.GetNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntime]
///
/// [google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntime]: crate::client::NotebookService::get_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl GetNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for GetNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookRuntimeRequest"
    }
}

/// Request message for
/// [NotebookService.ListNotebookRuntimes][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]: crate::client::NotebookService::list_notebook_runtimes
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimesRequest {
    /// Required. The resource name of the Location from which to list the
    /// NotebookRuntimes.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `notebookRuntime` supports = and !=. `notebookRuntime` represents the
    ///   NotebookRuntime ID,
    ///   i.e. the last segment of the NotebookRuntime's [resource name]
    ///   [google.cloud.aiplatform.v1.NotebookRuntime.name].
    /// * `displayName` supports = and != and regex.
    /// * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
    ///   represents the NotebookRuntimeTemplate ID,
    ///   i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
    ///   [google.cloud.aiplatform.v1.NotebookRuntimeTemplate.name].
    /// * `healthState` supports = and !=. healthState enum: [HEALTHY, UNHEALTHY,
    ///   HEALTH_STATE_UNSPECIFIED].
    /// * `runtimeState` supports = and !=. runtimeState enum:
    ///   [RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
    ///   STOPPED, BEING_UPGRADED, ERROR, INVALID].
    /// * `runtimeUser` supports = and !=.
    /// * API version is UI only: `uiState` supports = and !=. uiState enum:
    ///   [UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
    ///   UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
    ///   UI_RESOURCE_STATE_CREATION_FAILED].
    /// * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
    ///   [USER_DEFINED, ONE_CLICK].
    /// * `machineType` supports = and !=.
    /// * `acceleratorType` supports = and !=.
    ///
    /// Some examples:
    ///
    /// * `notebookRuntime="notebookRuntime123"`
    /// * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
    /// * `notebookRuntimeTemplate="notebookRuntimeTemplate321"`
    /// * `healthState=HEALTHY`
    /// * `runtimeState=RUNNING`
    /// * `runtimeUser="test@google.com"`
    /// * `uiState=UI_RESOURCE_STATE_BEING_DELETED`
    /// * `notebookRuntimeType=USER_DEFINED`
    /// * `machineType=e2-standard-4`
    /// * `acceleratorType=NVIDIA_TESLA_T4`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListNotebookRuntimesResponse.next_page_token][google.cloud.aiplatform.v1.ListNotebookRuntimesResponse.next_page_token]
    /// of the previous
    /// [NotebookService.ListNotebookRuntimes][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimesResponse.next_page_token]: crate::model::ListNotebookRuntimesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]: crate::client::NotebookService::list_notebook_runtimes
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending. Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ListNotebookRuntimesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotebookRuntimesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotebookRuntimesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotebookRuntimesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotebookRuntimesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListNotebookRuntimesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotebookRuntimesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ListNotebookRuntimesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimesRequest"
    }
}

/// Response message for
/// [NotebookService.ListNotebookRuntimes][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]: crate::client::NotebookService::list_notebook_runtimes
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimesResponse {
    /// List of NotebookRuntimes in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notebook_runtimes: std::vec::Vec<crate::model::NotebookRuntime>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListNotebookRuntimesRequest.page_token][google.cloud.aiplatform.v1.ListNotebookRuntimesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimesRequest.page_token]: crate::model::ListNotebookRuntimesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ListNotebookRuntimesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNotebookRuntimesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [notebook_runtimes][crate::model::ListNotebookRuntimesResponse::notebook_runtimes].
    pub fn set_notebook_runtimes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotebookRuntime>,
    {
        use std::iter::Iterator;
        self.notebook_runtimes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ListNotebookRuntimesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimesResponse"
    }
}

#[cfg(feature = "notebook_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotebookRuntimesResponse {
    type PageItem = crate::model::NotebookRuntime;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notebook_runtimes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [NotebookService.DeleteNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntime]: crate::client::NotebookService::delete_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be deleted.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl DeleteNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for DeleteNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookRuntimeRequest"
    }
}

/// Request message for
/// [NotebookService.UpgradeNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime]: crate::client::NotebookService::upgrade_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be upgrade.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl UpgradeNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for UpgradeNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.UpgradeNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime]: crate::client::NotebookService::upgrade_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl UpgradeNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpgradeNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::UpgradeNotebookRuntimeOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for UpgradeNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeOperationMetadata"
    }
}

/// Response message for
/// [NotebookService.UpgradeNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime]: crate::client::NotebookService::upgrade_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNotebookRuntimeResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl UpgradeNotebookRuntimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for UpgradeNotebookRuntimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeResponse"
    }
}

/// Request message for
/// [NotebookService.StartNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime]: crate::client::NotebookService::start_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be started.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl StartNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for StartNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.StartNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime]: crate::client::NotebookService::start_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl StartNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::StartNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::StartNotebookRuntimeOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for StartNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeOperationMetadata"
    }
}

/// Response message for
/// [NotebookService.StartNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime]: crate::client::NotebookService::start_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartNotebookRuntimeResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl StartNotebookRuntimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for StartNotebookRuntimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeResponse"
    }
}

/// Request message for
/// [NotebookService.StopNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime]: crate::client::NotebookService::stop_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be stopped.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl StopNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for StopNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.StopNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime]: crate::client::NotebookService::stop_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl StopNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::StopNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for StopNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeOperationMetadata"
    }
}

/// Response message for
/// [NotebookService.StopNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime]: crate::client::NotebookService::stop_notebook_runtime
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopNotebookRuntimeResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl StopNotebookRuntimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for StopNotebookRuntimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeResponse"
    }
}

/// Request message for [NotebookService.CreateNotebookExecutionJob]
#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookExecutionJobRequest {
    /// Required. The resource name of the Location to create the
    /// NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NotebookExecutionJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_execution_job: std::option::Option<crate::model::NotebookExecutionJob>,

    /// Optional. User specified ID for the NotebookExecutionJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_execution_job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl CreateNotebookExecutionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNotebookExecutionJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notebook_execution_job][crate::model::CreateNotebookExecutionJobRequest::notebook_execution_job].
    pub fn set_notebook_execution_job<
        T: std::convert::Into<std::option::Option<crate::model::NotebookExecutionJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_execution_job = v.into();
        self
    }

    /// Sets the value of [notebook_execution_job_id][crate::model::CreateNotebookExecutionJobRequest::notebook_execution_job_id].
    pub fn set_notebook_execution_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_execution_job_id = v.into();
        self
    }
}

#[cfg(any(feature = "notebook_service", feature = "schedule_service",))]
impl wkt::message::Message for CreateNotebookExecutionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookExecutionJobRequest"
    }
}

/// Metadata information for
/// [NotebookService.CreateNotebookExecutionJob][google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob].
///
/// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob]: crate::client::NotebookService::create_notebook_execution_job
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookExecutionJobOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl CreateNotebookExecutionJobOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateNotebookExecutionJobOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::CreateNotebookExecutionJobOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for CreateNotebookExecutionJobOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookExecutionJobOperationMetadata"
    }
}

/// Request message for [NotebookService.GetNotebookExecutionJob]
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotebookExecutionJobRequest {
    /// Required. The name of the NotebookExecutionJob resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
    pub view: crate::model::NotebookExecutionJobView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl GetNotebookExecutionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotebookExecutionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetNotebookExecutionJobRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::NotebookExecutionJobView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for GetNotebookExecutionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookExecutionJobRequest"
    }
}

/// Request message for [NotebookService.ListNotebookExecutionJobs]
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookExecutionJobsRequest {
    /// Required. The resource name of the Location from which to list the
    /// NotebookExecutionJobs.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `notebookExecutionJob` supports = and !=. `notebookExecutionJob`
    ///   represents the NotebookExecutionJob ID.
    /// * `displayName` supports = and != and regex.
    /// * `schedule` supports = and != and regex.
    ///
    /// Some examples:
    ///
    /// * `notebookExecutionJob="123"`
    /// * `notebookExecutionJob="my-execution-job"`
    /// * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListNotebookExecutionJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse.next_page_token]
    /// of the previous
    /// [NotebookService.ListNotebookExecutionJobs][google.cloud.aiplatform.v1.NotebookService.ListNotebookExecutionJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse.next_page_token]: crate::model::ListNotebookExecutionJobsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.NotebookService.ListNotebookExecutionJobs]: crate::client::NotebookService::list_notebook_execution_jobs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending. Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
    pub view: crate::model::NotebookExecutionJobView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ListNotebookExecutionJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotebookExecutionJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotebookExecutionJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotebookExecutionJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotebookExecutionJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotebookExecutionJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListNotebookExecutionJobsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::NotebookExecutionJobView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ListNotebookExecutionJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest"
    }
}

/// Response message for [NotebookService.CreateNotebookExecutionJob]
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookExecutionJobsResponse {
    /// List of NotebookExecutionJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notebook_execution_jobs: std::vec::Vec<crate::model::NotebookExecutionJob>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListNotebookExecutionJobsRequest.page_token][google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest.page_token]: crate::model::ListNotebookExecutionJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl ListNotebookExecutionJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNotebookExecutionJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [notebook_execution_jobs][crate::model::ListNotebookExecutionJobsResponse::notebook_execution_jobs].
    pub fn set_notebook_execution_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotebookExecutionJob>,
    {
        use std::iter::Iterator;
        self.notebook_execution_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for ListNotebookExecutionJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse"
    }
}

#[cfg(feature = "notebook_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotebookExecutionJobsResponse {
    type PageItem = crate::model::NotebookExecutionJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notebook_execution_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for [NotebookService.DeleteNotebookExecutionJob]
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotebookExecutionJobRequest {
    /// Required. The name of the NotebookExecutionJob resource to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl DeleteNotebookExecutionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotebookExecutionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for DeleteNotebookExecutionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookExecutionJobRequest"
    }
}

/// Post startup script config.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostStartupScriptConfig {
    /// Optional. Post startup script to run after runtime is started.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub post_startup_script: std::string::String,

    /// Optional. Post startup script url to download. Example:
    /// https://bucket/script.sh
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub post_startup_script_url: std::string::String,

    /// Optional. Post startup script behavior that defines download and execution
    /// behavior.
    pub post_startup_script_behavior:
        crate::model::post_startup_script_config::PostStartupScriptBehavior,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl PostStartupScriptConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [post_startup_script][crate::model::PostStartupScriptConfig::post_startup_script].
    pub fn set_post_startup_script<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script = v.into();
        self
    }

    /// Sets the value of [post_startup_script_url][crate::model::PostStartupScriptConfig::post_startup_script_url].
    pub fn set_post_startup_script_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script_url = v.into();
        self
    }

    /// Sets the value of [post_startup_script_behavior][crate::model::PostStartupScriptConfig::post_startup_script_behavior].
    pub fn set_post_startup_script_behavior<
        T: std::convert::Into<crate::model::post_startup_script_config::PostStartupScriptBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script_behavior = v.into();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for PostStartupScriptConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PostStartupScriptConfig"
    }
}

/// Defines additional types related to [PostStartupScriptConfig].
#[cfg(feature = "notebook_service")]
pub mod post_startup_script_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a notebook runtime post startup script behavior.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "notebook_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PostStartupScriptBehavior {
        /// Unspecified post startup script behavior.
        Unspecified,
        /// Run post startup script after runtime is started.
        RunOnce,
        /// Run post startup script after runtime is stopped.
        RunEveryStart,
        /// Download and run post startup script every time runtime is started.
        DownloadAndRunEveryStart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PostStartupScriptBehavior::value] or
        /// [PostStartupScriptBehavior::name].
        UnknownValue(post_startup_script_behavior::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "notebook_service")]
    pub mod post_startup_script_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "notebook_service")]
    impl PostStartupScriptBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RunOnce => std::option::Option::Some(1),
                Self::RunEveryStart => std::option::Option::Some(2),
                Self::DownloadAndRunEveryStart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED")
                }
                Self::RunOnce => std::option::Option::Some("RUN_ONCE"),
                Self::RunEveryStart => std::option::Option::Some("RUN_EVERY_START"),
                Self::DownloadAndRunEveryStart => {
                    std::option::Option::Some("DOWNLOAD_AND_RUN_EVERY_START")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::default::Default for PostStartupScriptBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::fmt::Display for PostStartupScriptBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::convert::From<i32> for PostStartupScriptBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RunOnce,
                2 => Self::RunEveryStart,
                3 => Self::DownloadAndRunEveryStart,
                _ => Self::UnknownValue(post_startup_script_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl std::convert::From<&str> for PostStartupScriptBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "RUN_ONCE" => Self::RunOnce,
                "RUN_EVERY_START" => Self::RunEveryStart,
                "DOWNLOAD_AND_RUN_EVERY_START" => Self::DownloadAndRunEveryStart,
                _ => Self::UnknownValue(post_startup_script_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl serde::ser::Serialize for PostStartupScriptBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RunOnce => serializer.serialize_i32(1),
                Self::RunEveryStart => serializer.serialize_i32(2),
                Self::DownloadAndRunEveryStart => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "notebook_service")]
    impl<'de> serde::de::Deserialize<'de> for PostStartupScriptBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PostStartupScriptBehavior>::new(
                    ".google.cloud.aiplatform.v1.PostStartupScriptConfig.PostStartupScriptBehavior",
                ),
            )
        }
    }
}

/// Notebook Software Config.
#[cfg(feature = "notebook_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookSoftwareConfig {
    /// Optional. Environment variables to be passed to the container.
    /// Maximum limit is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    /// Optional. Post startup script config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_startup_script_config: std::option::Option<crate::model::PostStartupScriptConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "notebook_service")]
impl NotebookSoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [post_startup_script_config][crate::model::NotebookSoftwareConfig::post_startup_script_config].
    pub fn set_post_startup_script_config<
        T: std::convert::Into<std::option::Option<crate::model::PostStartupScriptConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script_config = v.into();
        self
    }

    /// Sets the value of [env][crate::model::NotebookSoftwareConfig::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "notebook_service")]
impl wkt::message::Message for NotebookSoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookSoftwareConfig"
    }
}

/// Schema is used to define the format of input/output data. Represents a select
/// subset of an [OpenAPI 3.0 schema
/// object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
/// be added in the future as needed.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schema {
    /// Optional. The type of the data.
    #[serde(rename = "type")]
    pub r#type: crate::model::Type,

    /// Optional. The format of the data.
    /// Supported formats:
    /// for NUMBER type: "float", "double"
    /// for INTEGER type: "int32", "int64"
    /// for STRING type: "email", "byte", etc
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub format: std::string::String,

    /// Optional. The title of the Schema.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Optional. The description of the data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Indicates if the value may be null.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// Optional. Default value of the data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default: std::option::Option<wkt::Value>,

    /// Optional. SCHEMA FIELDS FOR TYPE ARRAY
    /// Schema of the elements of Type.ARRAY.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub items: std::option::Option<std::boxed::Box<crate::model::Schema>>,

    /// Optional. Minimum number of the elements for Type.ARRAY.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_items: i64,

    /// Optional. Maximum number of the elements for Type.ARRAY.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_items: i64,

    /// Optional. Possible values of the element of primitive type with enum
    /// format. Examples:
    ///
    /// . We can define direction as :
    ///   {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
    /// . We can define apartment number as :
    ///   {type:INTEGER, format:enum, enum:["101", "201", "301"]}
    #[serde(rename = "enum")]
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub r#enum: std::vec::Vec<std::string::String>,

    /// Optional. SCHEMA FIELDS FOR TYPE OBJECT
    /// Properties of Type.OBJECT.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, crate::model::Schema>,

    /// Optional. The order of the properties.
    /// Not a standard field in open api spec. Only used to support the order of
    /// the properties.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub property_ordering: std::vec::Vec<std::string::String>,

    /// Optional. Required properties of Type.OBJECT.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub required: std::vec::Vec<std::string::String>,

    /// Optional. Minimum number of the properties for Type.OBJECT.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_properties: i64,

    /// Optional. Maximum number of the properties for Type.OBJECT.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_properties: i64,

    /// Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER
    /// Minimum value of the Type.INTEGER and Type.NUMBER
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub minimum: f64,

    /// Optional. Maximum value of the Type.INTEGER and Type.NUMBER
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub maximum: f64,

    /// Optional. SCHEMA FIELDS FOR TYPE STRING
    /// Minimum length of the Type.STRING
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_length: i64,

    /// Optional. Maximum length of the Type.STRING
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_length: i64,

    /// Optional. Pattern of the Type.STRING to restrict a string to a regular
    /// expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pattern: std::string::String,

    /// Optional. Example of the object. Will only populated when the object is the
    /// root.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub example: std::option::Option<wkt::Value>,

    /// Optional. The value should be validated against any (one or more) of the
    /// subschemas in the list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub any_of: std::vec::Vec<crate::model::Schema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Schema::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Schema::format].
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Schema::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Schema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::Schema::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [default][crate::model::Schema::default].
    pub fn set_default<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.default = v.into();
        self
    }

    /// Sets the value of [items][crate::model::Schema::items].
    pub fn set_items<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Schema>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.items = v.into();
        self
    }

    /// Sets the value of [min_items][crate::model::Schema::min_items].
    pub fn set_min_items<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min_items = v.into();
        self
    }

    /// Sets the value of [max_items][crate::model::Schema::max_items].
    pub fn set_max_items<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_items = v.into();
        self
    }

    /// Sets the value of [min_properties][crate::model::Schema::min_properties].
    pub fn set_min_properties<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min_properties = v.into();
        self
    }

    /// Sets the value of [max_properties][crate::model::Schema::max_properties].
    pub fn set_max_properties<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_properties = v.into();
        self
    }

    /// Sets the value of [minimum][crate::model::Schema::minimum].
    pub fn set_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.minimum = v.into();
        self
    }

    /// Sets the value of [maximum][crate::model::Schema::maximum].
    pub fn set_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.maximum = v.into();
        self
    }

    /// Sets the value of [min_length][crate::model::Schema::min_length].
    pub fn set_min_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min_length = v.into();
        self
    }

    /// Sets the value of [max_length][crate::model::Schema::max_length].
    pub fn set_max_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_length = v.into();
        self
    }

    /// Sets the value of [pattern][crate::model::Schema::pattern].
    pub fn set_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pattern = v.into();
        self
    }

    /// Sets the value of [example][crate::model::Schema::example].
    pub fn set_example<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.example = v.into();
        self
    }

    /// Sets the value of [r#enum][crate::model::Schema::enum].
    pub fn set_enum<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.r#enum = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [property_ordering][crate::model::Schema::property_ordering].
    pub fn set_property_ordering<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.property_ordering = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [required][crate::model::Schema::required].
    pub fn set_required<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.required = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [any_of][crate::model::Schema::any_of].
    pub fn set_any_of<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.any_of = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::Schema::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Schema"
    }
}

/// Generic Metadata shared by all operations.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "migration_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
    feature = "vizier_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenericOperationMetadata {
    /// Output only. Partial failures encountered.
    /// E.g. single files that couldn't be read.
    /// This field should never exceed 20 entries.
    /// Status details field will contain standard Google Cloud error details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_failures: std::vec::Vec<rpc::model::Status>,

    /// Output only. Time when the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the operation was updated for the last time.
    /// If the operation has finished (successfully or not), this is the finish
    /// time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "migration_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
    feature = "vizier_service",
))]
impl GenericOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::GenericOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::GenericOperationMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [partial_failures][crate::model::GenericOperationMetadata::partial_failures].
    pub fn set_partial_failures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_failures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "gen_ai_tuning_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "migration_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
    feature = "vizier_service",
))]
impl wkt::message::Message for GenericOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenericOperationMetadata"
    }
}

/// Details of operations that perform deletes of any entities.
#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
))]
impl DeleteOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeleteOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(any(
    feature = "dataset_service",
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "feature_registry_service",
    feature = "featurestore_service",
    feature = "index_endpoint_service",
    feature = "index_service",
    feature = "job_service",
    feature = "metadata_service",
    feature = "model_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "pipeline_service",
    feature = "reasoning_engine_service",
    feature = "schedule_service",
    feature = "specialist_pool_service",
    feature = "tensorboard_service",
    feature = "vertex_rag_data_service",
))]
impl wkt::message::Message for DeleteOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteOperationMetadata"
    }
}

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
/// A PersistentResource can have multiple node pools and each node
/// pool can have its own machine spec.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersistentResource {
    /// Immutable. Resource name of a PersistentResource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The display name of the PersistentResource.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The spec of the pools of different resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_pools: std::vec::Vec<crate::model::ResourcePool>,

    /// Output only. The detailed state of a Study.
    pub state: crate::model::persistent_resource::State,

    /// Output only. Only populated when persistent resource's state is `STOPPING`
    /// or `ERROR`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Time when the PersistentResource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the PersistentResource for the first time entered
    /// the `RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the PersistentResource was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize
    /// PersistentResource.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The full name of the Compute Engine
    /// [network](/compute/docs/networks-and-firewalls#networks) to peered with
    /// Vertex AI to host the persistent resources.
    /// For example, `projects/12345/global/networks/myVPC`.
    /// [Format](/compute/docs/reference/rest/v1/networks/insert)
    /// is of the form `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in `12345`, and {network} is a
    /// network name.
    ///
    /// To specify this field, you must have already [configured VPC Network
    /// Peering for Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
    ///
    /// If this field is left unspecified, the resources aren't peered with any
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Customer-managed encryption key spec for a PersistentResource.
    /// If set, this PersistentResource and all sub-resources of this
    /// PersistentResource will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. Persistent Resource runtime spec.
    /// For example, used for Ray cluster configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_runtime_spec: std::option::Option<crate::model::ResourceRuntimeSpec>,

    /// Output only. Runtime information of the Persistent Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_runtime: std::option::Option<crate::model::ResourceRuntime>,

    /// Optional. A list of names for the reserved IP ranges under the VPC network
    /// that can be used for this persistent resource.
    ///
    /// If set, we will deploy the persistent resource within the provided IP
    /// ranges. Otherwise, the persistent resource is deployed to any IP
    /// ranges under the provided VPC network.
    ///
    /// Example: ['vertex-ai-ip-range'].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl PersistentResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PersistentResource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PersistentResource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PersistentResource::state].
    pub fn set_state<T: std::convert::Into<crate::model::persistent_resource::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PersistentResource::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PersistentResource::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::PersistentResource::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PersistentResource::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PersistentResource::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::PersistentResource::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [resource_runtime_spec][crate::model::PersistentResource::resource_runtime_spec].
    pub fn set_resource_runtime_spec<
        T: std::convert::Into<std::option::Option<crate::model::ResourceRuntimeSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_runtime_spec = v.into();
        self
    }

    /// Sets the value of [resource_runtime][crate::model::PersistentResource::resource_runtime].
    pub fn set_resource_runtime<
        T: std::convert::Into<std::option::Option<crate::model::ResourceRuntime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_runtime = v.into();
        self
    }

    /// Sets the value of [resource_pools][crate::model::PersistentResource::resource_pools].
    pub fn set_resource_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourcePool>,
    {
        use std::iter::Iterator;
        self.resource_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::PersistentResource::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::PersistentResource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for PersistentResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PersistentResource"
    }
}

/// Defines additional types related to [PersistentResource].
#[cfg(feature = "persistent_resource_service")]
pub mod persistent_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the PersistentResource state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "persistent_resource_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the persistent resources is being
        /// created.
        Provisioning,
        /// The RUNNING state indicates the persistent resource is healthy and fully
        /// usable.
        Running,
        /// The STOPPING state indicates the persistent resource is being deleted.
        Stopping,
        /// The ERROR state indicates the persistent resource may be unusable.
        /// Details can be found in the `error` field.
        Error,
        /// The REBOOTING state indicates the persistent resource is being rebooted
        /// (PR is not available right now but is expected to be ready again later).
        Rebooting,
        /// The UPDATING state indicates the persistent resource is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "persistent_resource_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "persistent_resource_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Rebooting => std::option::Option::Some(6),
                Self::Updating => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Rebooting => std::option::Option::Some("REBOOTING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                3 => Self::Running,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Rebooting,
                7 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "REBOOTING" => Self::Rebooting,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Rebooting => serializer.serialize_i32(6),
                Self::Updating => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.PersistentResource.State",
            ))
        }
    }
}

/// Represents the spec of a group of resources of the same type,
/// for example machine type, disk, and accelerators, in a PersistentResource.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourcePool {
    /// Immutable. The unique ID in a PersistentResource for referring to this
    /// resource pool. User can specify it if necessary. Otherwise, it's generated
    /// automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Required. Immutable. The specification of a single machine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Optional. The total number of machines to use for this resource pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub replica_count: std::option::Option<i64>,

    /// Optional. Disk spec for the machine in this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_spec: std::option::Option<crate::model::DiskSpec>,

    /// Output only. The number of machines currently in use by training jobs for
    /// this resource pool. Will replace idle_replica_count.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub used_replica_count: i64,

    /// Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_spec: std::option::Option<crate::model::resource_pool::AutoscalingSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl ResourcePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ResourcePool::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [machine_spec][crate::model::ResourcePool::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::ResourcePool::replica_count].
    pub fn set_replica_count<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [disk_spec][crate::model::ResourcePool::disk_spec].
    pub fn set_disk_spec<T: std::convert::Into<std::option::Option<crate::model::DiskSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_spec = v.into();
        self
    }

    /// Sets the value of [used_replica_count][crate::model::ResourcePool::used_replica_count].
    pub fn set_used_replica_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.used_replica_count = v.into();
        self
    }

    /// Sets the value of [autoscaling_spec][crate::model::ResourcePool::autoscaling_spec].
    pub fn set_autoscaling_spec<
        T: std::convert::Into<std::option::Option<crate::model::resource_pool::AutoscalingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_spec = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for ResourcePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourcePool"
    }
}

/// Defines additional types related to [ResourcePool].
#[cfg(feature = "persistent_resource_service")]
pub mod resource_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The min/max number of replicas allowed if enabling autoscaling
    #[cfg(feature = "persistent_resource_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutoscalingSpec {
        /// Optional. min replicas in the node pool,
        /// must be  replica_count and < max_replica_count or will throw error.
        /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
        /// resource_pool to be 0 to match the OSS Ray
        /// behavior(<https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters>).
        /// As for Persistent Resource, the min_replica_count must be > 0, we added
        /// a corresponding validation inside
        /// CreatePersistentResourceRequestValidator.java.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub min_replica_count: std::option::Option<i64>,

        /// Optional. max replicas in the node pool,
        /// must be  replica_count and > min_replica_count or will throw error
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub max_replica_count: std::option::Option<i64>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "persistent_resource_service")]
    impl AutoscalingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_replica_count][crate::model::resource_pool::AutoscalingSpec::min_replica_count].
        pub fn set_min_replica_count<T: std::convert::Into<std::option::Option<i64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_replica_count = v.into();
            self
        }

        /// Sets the value of [max_replica_count][crate::model::resource_pool::AutoscalingSpec::max_replica_count].
        pub fn set_max_replica_count<T: std::convert::Into<std::option::Option<i64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_replica_count = v.into();
            self
        }
    }

    #[cfg(feature = "persistent_resource_service")]
    impl wkt::message::Message for AutoscalingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ResourcePool.AutoscalingSpec"
        }
    }
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to:
///
/// * Service accounts used to run the workloads.
/// * Whether to make it a dedicated Ray Cluster.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRuntimeSpec {
    /// Optional. Configure the use of workload identity on the PersistentResource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_account_spec: std::option::Option<crate::model::ServiceAccountSpec>,

    /// Optional. Ray cluster configuration.
    /// Required when creating a dedicated RayCluster on the PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_spec: std::option::Option<crate::model::RaySpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl ResourceRuntimeSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_spec][crate::model::ResourceRuntimeSpec::service_account_spec].
    pub fn set_service_account_spec<
        T: std::convert::Into<std::option::Option<crate::model::ServiceAccountSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_spec = v.into();
        self
    }

    /// Sets the value of [ray_spec][crate::model::ResourceRuntimeSpec::ray_spec].
    pub fn set_ray_spec<T: std::convert::Into<std::option::Option<crate::model::RaySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ray_spec = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for ResourceRuntimeSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourceRuntimeSpec"
    }
}

/// Configuration information for the Ray cluster.
/// For experimental launch, Ray cluster creation and Persistent
/// cluster creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RaySpec {
    /// Optional. Default image for user to choose a preferred ML framework
    /// (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt
    /// images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
    /// Either this or the resource_pool_images is required. Use this field if
    /// you need all the resource pools to have the same Ray image. Otherwise, use
    /// the {@code resource_pool_images} field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Optional. Required if image_uri isn't set. A map of resource_pool_id to
    /// prebuild Ray image if user need to use different images for different
    /// head/worker pools. This map needs to cover all the resource pool ids.
    /// Example:
    /// {
    /// "ray_head_node_pool": "head image"
    /// "ray_worker_node_pool1": "worker image"
    /// "ray_worker_node_pool2": "another worker image"
    /// }
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_pool_images: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This will be used to indicate which resource pool will serve as
    /// the Ray head node(the first node within that pool). Will use the machine
    /// from the first workerpool as the head node by default if this field isn't
    /// set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub head_node_resource_pool_id: std::string::String,

    /// Optional. Ray metrics configurations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_metric_spec: std::option::Option<crate::model::RayMetricSpec>,

    /// Optional. OSS Ray logging configurations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_logs_spec: std::option::Option<crate::model::RayLogsSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl RaySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_uri][crate::model::RaySpec::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [head_node_resource_pool_id][crate::model::RaySpec::head_node_resource_pool_id].
    pub fn set_head_node_resource_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.head_node_resource_pool_id = v.into();
        self
    }

    /// Sets the value of [ray_metric_spec][crate::model::RaySpec::ray_metric_spec].
    pub fn set_ray_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::RayMetricSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_metric_spec = v.into();
        self
    }

    /// Sets the value of [ray_logs_spec][crate::model::RaySpec::ray_logs_spec].
    pub fn set_ray_logs_spec<
        T: std::convert::Into<std::option::Option<crate::model::RayLogsSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_logs_spec = v.into();
        self
    }

    /// Sets the value of [resource_pool_images][crate::model::RaySpec::resource_pool_images].
    pub fn set_resource_pool_images<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_pool_images = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for RaySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RaySpec"
    }
}

/// Persistent Cluster runtime information as output
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRuntime {
    /// Output only. URIs for user to connect to the Cluster.
    /// Example:
    /// {
    /// "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
    /// "RAY_DASHBOARD_URI": "ray-dashboard-address:8888"
    /// }
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub access_uris: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl ResourceRuntime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_uris][crate::model::ResourceRuntime::access_uris].
    pub fn set_access_uris<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.access_uris = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for ResourceRuntime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourceRuntime"
    }
}

/// Configuration for the use of custom service account to run the workloads.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceAccountSpec {
    /// Required. If true, custom user-managed service account is enforced to run
    /// any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses
    /// the [Vertex AI Custom Code Service
    /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_custom_service_account: bool,

    /// Optional. Required when all below conditions are met
    ///
    /// * `enable_custom_service_account` is true;
    /// * any runtime is specified via `ResourceRuntimeSpec` on creation time,
    ///   for example, Ray
    ///
    /// The users must have `iam.serviceAccounts.actAs` permission on this service
    /// account and then the specified runtime containers will run as it.
    ///
    /// Do not set this field if you want to submit jobs using custom service
    /// account to this PersistentResource after creation, but only specify the
    /// `service_account` inside the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl ServiceAccountSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_custom_service_account][crate::model::ServiceAccountSpec::enable_custom_service_account].
    pub fn set_enable_custom_service_account<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_custom_service_account = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::ServiceAccountSpec::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for ServiceAccountSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ServiceAccountSpec"
    }
}

/// Configuration for the Ray metrics.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayMetricSpec {
    /// Optional. Flag to disable the Ray metrics collection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl RayMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::RayMetricSpec::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for RayMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RayMetricSpec"
    }
}

/// Configuration for the Ray OSS Logs.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayLogsSpec {
    /// Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl RayLogsSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::RayLogsSpec::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for RayLogsSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RayLogsSpec"
    }
}

/// Request message for
/// [PersistentResourceService.CreatePersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.CreatePersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.CreatePersistentResource]: crate::client::PersistentResourceService::create_persistent_resource
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePersistentResourceRequest {
    /// Required. The resource name of the Location to create the
    /// PersistentResource in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The PersistentResource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistent_resource: std::option::Option<crate::model::PersistentResource>,

    /// Required. The ID to use for the PersistentResource, which become the final
    /// component of the PersistentResource's resource name.
    ///
    /// The maximum length is 63 characters, and valid characters
    /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub persistent_resource_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl CreatePersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePersistentResourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [persistent_resource][crate::model::CreatePersistentResourceRequest::persistent_resource].
    pub fn set_persistent_resource<
        T: std::convert::Into<std::option::Option<crate::model::PersistentResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource = v.into();
        self
    }

    /// Sets the value of [persistent_resource_id][crate::model::CreatePersistentResourceRequest::persistent_resource_id].
    pub fn set_persistent_resource_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource_id = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for CreatePersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePersistentResourceRequest"
    }
}

/// Details of operations that perform create PersistentResource.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePersistentResourceOperationMetadata {
    /// Operation metadata for PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Progress Message for Create LRO
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl CreatePersistentResourceOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreatePersistentResourceOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::CreatePersistentResourceOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for CreatePersistentResourceOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePersistentResourceOperationMetadata"
    }
}

/// Details of operations that perform update PersistentResource.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePersistentResourceOperationMetadata {
    /// Operation metadata for PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Progress Message for Update LRO
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl UpdatePersistentResourceOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdatePersistentResourceOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::UpdatePersistentResourceOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for UpdatePersistentResourceOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdatePersistentResourceOperationMetadata"
    }
}

/// Details of operations that perform reboot PersistentResource.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebootPersistentResourceOperationMetadata {
    /// Operation metadata for PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Progress Message for Reboot LRO
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl RebootPersistentResourceOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::RebootPersistentResourceOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::RebootPersistentResourceOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for RebootPersistentResourceOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebootPersistentResourceOperationMetadata"
    }
}

/// Request message for
/// [PersistentResourceService.GetPersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.GetPersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.GetPersistentResource]: crate::client::PersistentResourceService::get_persistent_resource
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPersistentResourceRequest {
    /// Required. The name of the PersistentResource resource.
    /// Format:
    /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl GetPersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPersistentResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for GetPersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPersistentResourceRequest"
    }
}

/// Request message for
/// [PersistentResourceService.ListPersistentResources][google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources]: crate::client::PersistentResourceService::list_persistent_resources
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPersistentResourcesRequest {
    /// Required. The resource name of the Location to list the PersistentResources
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListPersistentResourcesResponse.next_page_token][google.cloud.aiplatform.v1.ListPersistentResourcesResponse.next_page_token]
    /// of the previous [PersistentResourceService.ListPersistentResource][] call.
    ///
    /// [google.cloud.aiplatform.v1.ListPersistentResourcesResponse.next_page_token]: crate::model::ListPersistentResourcesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl ListPersistentResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPersistentResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPersistentResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPersistentResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for ListPersistentResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPersistentResourcesRequest"
    }
}

/// Response message for
/// [PersistentResourceService.ListPersistentResources][google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources]
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources]: crate::client::PersistentResourceService::list_persistent_resources
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPersistentResourcesResponse {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub persistent_resources: std::vec::Vec<crate::model::PersistentResource>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListPersistentResourcesRequest.page_token][google.cloud.aiplatform.v1.ListPersistentResourcesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListPersistentResourcesRequest.page_token]: crate::model::ListPersistentResourcesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl ListPersistentResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPersistentResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [persistent_resources][crate::model::ListPersistentResourcesResponse::persistent_resources].
    pub fn set_persistent_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PersistentResource>,
    {
        use std::iter::Iterator;
        self.persistent_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for ListPersistentResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPersistentResourcesResponse"
    }
}

#[cfg(feature = "persistent_resource_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPersistentResourcesResponse {
    type PageItem = crate::model::PersistentResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.persistent_resources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [PersistentResourceService.DeletePersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.DeletePersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.DeletePersistentResource]: crate::client::PersistentResourceService::delete_persistent_resource
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePersistentResourceRequest {
    /// Required. The name of the PersistentResource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl DeletePersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePersistentResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for DeletePersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeletePersistentResourceRequest"
    }
}

/// Request message for UpdatePersistentResource method.
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePersistentResourceRequest {
    /// Required. The PersistentResource to update.
    ///
    /// The PersistentResource's `name` field is used to identify the
    /// PersistentResource to update. Format:
    /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistent_resource: std::option::Option<crate::model::PersistentResource>,

    /// Required. Specify the fields to be overwritten in the PersistentResource by
    /// the update method.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl UpdatePersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [persistent_resource][crate::model::UpdatePersistentResourceRequest::persistent_resource].
    pub fn set_persistent_resource<
        T: std::convert::Into<std::option::Option<crate::model::PersistentResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePersistentResourceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for UpdatePersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdatePersistentResourceRequest"
    }
}

/// Request message for
/// [PersistentResourceService.RebootPersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.RebootPersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.RebootPersistentResource]: crate::client::PersistentResourceService::reboot_persistent_resource
#[cfg(feature = "persistent_resource_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebootPersistentResourceRequest {
    /// Required. The name of the PersistentResource resource.
    /// Format:
    /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "persistent_resource_service")]
impl RebootPersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RebootPersistentResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "persistent_resource_service")]
impl wkt::message::Message for RebootPersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebootPersistentResourceRequest"
    }
}

/// An instance of a machine learning PipelineJob.
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineJob {
    /// Output only. The resource name of the PipelineJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the Pipeline.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Pipeline creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Pipeline start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Pipeline end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this PipelineJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The spec of the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_spec: std::option::Option<wkt::Struct>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::PipelineState,

    /// Output only. The details of pipeline run. Not available in the list view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_detail: std::option::Option<crate::model::PipelineJobDetail>,

    /// Output only. The error that occurred during pipeline execution.
    /// Only populated when the pipeline's state is FAILED or CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize PipelineJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    ///
    /// Note there is some reserved label key for Vertex AI Pipelines.
    ///
    /// - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Runtime config of the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::pipeline_job::RuntimeConfig>,

    /// Customer-managed encryption key spec for a pipelineJob. If set, this
    /// PipelineJob and all of its sub-resources will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The service account that the pipeline workload runs as.
    /// If not specified, the Compute Engine default service account in the project
    /// will be used.
    /// See
    /// <https://cloud.google.com/compute/docs/access/service-accounts#default_service_account>
    ///
    /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The full name of the Compute Engine
    /// [network](/compute/docs/networks-and-firewalls#networks) to which the
    /// Pipeline Job's workload should be peered. For example,
    /// `projects/12345/global/networks/myVPC`.
    /// [Format](/compute/docs/reference/rest/v1/networks/insert)
    /// is of the form `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in `12345`, and {network} is a
    /// network name.
    ///
    /// Private services access must already be configured for the network.
    /// Pipeline job will apply the network configuration to the Google Cloud
    /// resources being launched, if applied, such as Vertex AI
    /// Training or Dataflow job. If left unspecified, the workload is not peered
    /// with any network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// A list of names for the reserved ip ranges under the VPC network
    /// that can be used for this Pipeline Job's workload.
    ///
    /// If set, we will deploy the Pipeline Job's workload within the provided ip
    /// ranges. Otherwise, the job will be deployed to any ip ranges under the
    /// provided VPC network.
    ///
    /// Example: ['vertex-ai-ip-range'].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    /// A template uri from where the
    /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec],
    /// if empty, will be downloaded. Currently, only uri from Vertex Template
    /// Registry & Gallery is supported. Reference to
    /// <https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template>.
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_uri: std::string::String,

    /// Output only. Pipeline template metadata. Will fill up fields if
    /// [PipelineJob.template_uri][google.cloud.aiplatform.v1.PipelineJob.template_uri]
    /// is from supported template registry.
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.template_uri]: crate::model::PipelineJob::template_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template_metadata: std::option::Option<crate::model::PipelineTemplateMetadata>,

    /// Output only. The schedule resource name.
    /// Only returned if the Pipeline is created by Schedule API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schedule_name: std::string::String,

    /// Optional. Whether to do component level validations before job creation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub preflight_validations: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PipelineJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PipelineJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PipelineJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::PipelineJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::PipelineJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PipelineJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [pipeline_spec][crate::model::PipelineJob::pipeline_spec].
    pub fn set_pipeline_spec<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PipelineJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::PipelineState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [job_detail][crate::model::PipelineJob::job_detail].
    pub fn set_job_detail<
        T: std::convert::Into<std::option::Option<crate::model::PipelineJobDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_detail = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PipelineJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [runtime_config][crate::model::PipelineJob::runtime_config].
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::pipeline_job::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::PipelineJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::PipelineJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PipelineJob::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [template_uri][crate::model::PipelineJob::template_uri].
    pub fn set_template_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_uri = v.into();
        self
    }

    /// Sets the value of [template_metadata][crate::model::PipelineJob::template_metadata].
    pub fn set_template_metadata<
        T: std::convert::Into<std::option::Option<crate::model::PipelineTemplateMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template_metadata = v.into();
        self
    }

    /// Sets the value of [schedule_name][crate::model::PipelineJob::schedule_name].
    pub fn set_schedule_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule_name = v.into();
        self
    }

    /// Sets the value of [preflight_validations][crate::model::PipelineJob::preflight_validations].
    pub fn set_preflight_validations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.preflight_validations = v.into();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::PipelineJob::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::PipelineJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for PipelineJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob"
    }
}

/// Defines additional types related to [PipelineJob].
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
pub mod pipeline_job {
    #[allow(unused_imports)]
    use super::*;

    /// The runtime config of a PipelineJob.
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RuntimeConfig {
        /// Deprecated. Use
        /// [RuntimeConfig.parameter_values][google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.parameter_values]
        /// instead. The runtime parameters of the PipelineJob. The parameters will
        /// be passed into
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// to replace the placeholders at runtime. This field is used by pipelines
        /// built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower,
        /// such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
        ///
        /// [google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.parameter_values]: crate::model::pipeline_job::RuntimeConfig::parameter_values
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        #[deprecated]
        pub parameters: std::collections::HashMap<std::string::String, crate::model::Value>,

        /// Required. A path in a Cloud Storage bucket, which will be treated as the
        /// root output directory of the pipeline. It is used by the system to
        /// generate the paths of output artifacts. The artifact paths are generated
        /// with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the
        /// specified output directory. The service account specified in this
        /// pipeline must have the `storage.objects.get` and `storage.objects.create`
        /// permissions for this bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub gcs_output_directory: std::string::String,

        /// The runtime parameters of the PipelineJob. The parameters will be
        /// passed into
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// to replace the placeholders at runtime. This field is used by pipelines
        /// built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as
        /// pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2
        /// DSL.
        ///
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub parameter_values: std::collections::HashMap<std::string::String, wkt::Value>,

        /// Represents the failure policy of a pipeline. Currently, the default of a
        /// pipeline is that the pipeline will continue to run until no more tasks
        /// can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW.
        /// However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it
        /// will stop scheduling any new tasks when a task has failed. Any scheduled
        /// tasks will continue to completion.
        pub failure_policy: crate::model::PipelineFailurePolicy,

        /// The runtime artifacts of the PipelineJob. The key will be the input
        /// artifact name and the value would be one of the InputArtifact.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub input_artifacts: std::collections::HashMap<
            std::string::String,
            crate::model::pipeline_job::runtime_config::InputArtifact,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl RuntimeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [gcs_output_directory][crate::model::pipeline_job::RuntimeConfig::gcs_output_directory].
        pub fn set_gcs_output_directory<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcs_output_directory = v.into();
            self
        }

        /// Sets the value of [failure_policy][crate::model::pipeline_job::RuntimeConfig::failure_policy].
        pub fn set_failure_policy<T: std::convert::Into<crate::model::PipelineFailurePolicy>>(
            mut self,
            v: T,
        ) -> Self {
            self.failure_policy = v.into();
            self
        }

        /// Sets the value of [parameters][crate::model::pipeline_job::RuntimeConfig::parameters].
        #[deprecated]
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [parameter_values][crate::model::pipeline_job::RuntimeConfig::parameter_values].
        pub fn set_parameter_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.parameter_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [input_artifacts][crate::model::pipeline_job::RuntimeConfig::input_artifacts].
        pub fn set_input_artifacts<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::pipeline_job::runtime_config::InputArtifact>,
        {
            use std::iter::Iterator;
            self.input_artifacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl wkt::message::Message for RuntimeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig"
        }
    }

    /// Defines additional types related to [RuntimeConfig].
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    pub mod runtime_config {
        #[allow(unused_imports)]
        use super::*;

        /// The type of an input artifact.
        #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct InputArtifact {
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub kind: std::option::Option<
                crate::model::pipeline_job::runtime_config::input_artifact::Kind,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
        impl InputArtifact {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [kind][crate::model::pipeline_job::runtime_config::InputArtifact::kind].
            ///
            /// Note that all the setters affecting `kind` are mutually
            /// exclusive.
            pub fn set_kind<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::pipeline_job::runtime_config::input_artifact::Kind,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.kind = v.into();
                self
            }

            /// The value of [kind][crate::model::pipeline_job::runtime_config::InputArtifact::kind]
            /// if it holds a `ArtifactId`, `None` if the field is not set or
            /// holds a different branch.
            pub fn artifact_id(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.kind.as_ref().and_then(|v| match v {
                    crate::model::pipeline_job::runtime_config::input_artifact::Kind::ArtifactId(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [kind][crate::model::pipeline_job::runtime_config::InputArtifact::kind]
            /// to hold a `ArtifactId`.
            ///
            /// Note that all the setters affecting `kind` are
            /// mutually exclusive.
            pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kind = std::option::Option::Some(
                    crate::model::pipeline_job::runtime_config::input_artifact::Kind::ArtifactId(
                        v.into(),
                    ),
                );
                self
            }
        }

        #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
        impl wkt::message::Message for InputArtifact {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.InputArtifact"
            }
        }

        /// Defines additional types related to [InputArtifact].
        #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
        pub mod input_artifact {
            #[allow(unused_imports)]
            use super::*;

            #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Kind {
                /// Artifact resource id from MLMD. Which is the last portion of an
                /// artifact resource name:
                /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
                /// The artifact must stay within the same project, location and default
                /// metadatastore as the pipeline.
                ArtifactId(std::string::String),
            }
        }
    }
}

/// Pipeline template metadata if
/// [PipelineJob.template_uri][google.cloud.aiplatform.v1.PipelineJob.template_uri]
/// is from supported template registry. Currently, the only supported registry
/// is Artifact Registry.
///
/// [google.cloud.aiplatform.v1.PipelineJob.template_uri]: crate::model::PipelineJob::template_uri
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineTemplateMetadata {
    /// The version_name in artifact registry.
    ///
    /// Will always be presented in output if the
    /// [PipelineJob.template_uri][google.cloud.aiplatform.v1.PipelineJob.template_uri]
    /// is from supported template registry.
    ///
    /// Format is "sha256:abcdef123456...".
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.template_uri]: crate::model::PipelineJob::template_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineTemplateMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::PipelineTemplateMetadata::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for PipelineTemplateMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTemplateMetadata"
    }
}

/// The runtime detail of PipelineJob.
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineJobDetail {
    /// Output only. The context of the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_context: std::option::Option<crate::model::Context>,

    /// Output only. The context of the current pipeline run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_run_context: std::option::Option<crate::model::Context>,

    /// Output only. The runtime details of the tasks under the pipeline.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub task_details: std::vec::Vec<crate::model::PipelineTaskDetail>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineJobDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_context][crate::model::PipelineJobDetail::pipeline_context].
    pub fn set_pipeline_context<
        T: std::convert::Into<std::option::Option<crate::model::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_context = v.into();
        self
    }

    /// Sets the value of [pipeline_run_context][crate::model::PipelineJobDetail::pipeline_run_context].
    pub fn set_pipeline_run_context<
        T: std::convert::Into<std::option::Option<crate::model::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_run_context = v.into();
        self
    }

    /// Sets the value of [task_details][crate::model::PipelineJobDetail::task_details].
    pub fn set_task_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineTaskDetail>,
    {
        use std::iter::Iterator;
        self.task_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for PipelineJobDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJobDetail"
    }
}

/// The runtime detail of a task execution.
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineTaskDetail {
    /// Output only. The system generated ID of the task.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub task_id: i64,

    /// Output only. The id of the parent task if the task is within a component
    /// scope. Empty if the task is at the root level.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parent_task_id: i64,

    /// Output only. The user specified name of the task that is defined in
    /// [pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec].
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub task_name: std::string::String,

    /// Output only. Task create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Task start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Task end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The detailed execution info.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub executor_detail: std::option::Option<crate::model::PipelineTaskExecutorDetail>,

    /// Output only. State of the task.
    pub state: crate::model::pipeline_task_detail::State,

    /// Output only. The execution metadata of the task.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution: std::option::Option<crate::model::Execution>,

    /// Output only. The error that occurred during task execution.
    /// Only populated when the task's state is FAILED or CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. A list of task status. This field keeps a record of task
    /// status evolving over time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_task_status: std::vec::Vec<crate::model::pipeline_task_detail::PipelineTaskStatus>,

    /// Output only. The runtime input artifacts of the task.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub inputs: std::collections::HashMap<
        std::string::String,
        crate::model::pipeline_task_detail::ArtifactList,
    >,

    /// Output only. The runtime output artifacts of the task.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub outputs: std::collections::HashMap<
        std::string::String,
        crate::model::pipeline_task_detail::ArtifactList,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineTaskDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [task_id][crate::model::PipelineTaskDetail::task_id].
    pub fn set_task_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.task_id = v.into();
        self
    }

    /// Sets the value of [parent_task_id][crate::model::PipelineTaskDetail::parent_task_id].
    pub fn set_parent_task_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parent_task_id = v.into();
        self
    }

    /// Sets the value of [task_name][crate::model::PipelineTaskDetail::task_name].
    pub fn set_task_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.task_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PipelineTaskDetail::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::PipelineTaskDetail::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::PipelineTaskDetail::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [executor_detail][crate::model::PipelineTaskDetail::executor_detail].
    pub fn set_executor_detail<
        T: std::convert::Into<std::option::Option<crate::model::PipelineTaskExecutorDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.executor_detail = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PipelineTaskDetail::state].
    pub fn set_state<T: std::convert::Into<crate::model::pipeline_task_detail::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::PipelineTaskDetail::execution].
    pub fn set_execution<T: std::convert::Into<std::option::Option<crate::model::Execution>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PipelineTaskDetail::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [pipeline_task_status][crate::model::PipelineTaskDetail::pipeline_task_status].
    pub fn set_pipeline_task_status<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pipeline_task_detail::PipelineTaskStatus>,
    {
        use std::iter::Iterator;
        self.pipeline_task_status = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inputs][crate::model::PipelineTaskDetail::inputs].
    pub fn set_inputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::pipeline_task_detail::ArtifactList>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [outputs][crate::model::PipelineTaskDetail::outputs].
    pub fn set_outputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::pipeline_task_detail::ArtifactList>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for PipelineTaskDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail"
    }
}

/// Defines additional types related to [PipelineTaskDetail].
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
pub mod pipeline_task_detail {
    #[allow(unused_imports)]
    use super::*;

    /// A single record of the task status.
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PipelineTaskStatus {
        /// Output only. Update time of this status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The state of the task.
        pub state: crate::model::pipeline_task_detail::State,

        /// Output only. The error that occurred during the state. May be set when
        /// the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or
        /// FAILED state. If the state is FAILED, the error here is final and not
        /// going to be retried. If the state is a non-final state, the error
        /// indicates a system-error being retried.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub error: std::option::Option<rpc::model::Status>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl PipelineTaskStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_time][crate::model::pipeline_task_detail::PipelineTaskStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [state][crate::model::pipeline_task_detail::PipelineTaskStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::pipeline_task_detail::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::pipeline_task_detail::PipelineTaskStatus::error].
        pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.error = v.into();
            self
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl wkt::message::Message for PipelineTaskStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail.PipelineTaskStatus"
        }
    }

    /// A list of artifact metadata.
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArtifactList {
        /// Output only. A list of artifact metadata.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub artifacts: std::vec::Vec<crate::model::Artifact>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl ArtifactList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [artifacts][crate::model::pipeline_task_detail::ArtifactList::artifacts].
        pub fn set_artifacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Artifact>,
        {
            use std::iter::Iterator;
            self.artifacts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl wkt::message::Message for ArtifactList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail.ArtifactList"
        }
    }

    /// Specifies state of TaskExecution
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// Specifies pending state for the task.
        Pending,
        /// Specifies task is being executed.
        Running,
        /// Specifies task completed successfully.
        Succeeded,
        /// Specifies Task cancel is in pending state.
        CancelPending,
        /// Specifies task is being cancelled.
        Cancelling,
        /// Specifies task was cancelled.
        Cancelled,
        /// Specifies task failed.
        Failed,
        /// Specifies task was skipped due to cache hit.
        Skipped,
        /// Specifies that the task was not triggered because the task's trigger
        /// policy is not satisfied. The trigger policy is specified in the
        /// `condition` field of
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec].
        ///
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        NotTriggered,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::CancelPending => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::Skipped => std::option::Option::Some(8),
                Self::NotTriggered => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::CancelPending => std::option::Option::Some("CANCEL_PENDING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::NotTriggered => std::option::Option::Some("NOT_TRIGGERED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::CancelPending,
                5 => Self::Cancelling,
                6 => Self::Cancelled,
                7 => Self::Failed,
                8 => Self::Skipped,
                9 => Self::NotTriggered,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCEL_PENDING" => Self::CancelPending,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "SKIPPED" => Self::Skipped,
                "NOT_TRIGGERED" => Self::NotTriggered,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::CancelPending => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::Skipped => serializer.serialize_i32(8),
                Self::NotTriggered => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.PipelineTaskDetail.State",
            ))
        }
    }
}

/// The runtime detail of a pipeline executor.
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineTaskExecutorDetail {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::pipeline_task_executor_detail::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineTaskExecutorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::PipelineTaskExecutorDetail::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<
                std::option::Option<crate::model::pipeline_task_executor_detail::Details>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// if it holds a `ContainerDetail`, `None` if the field is not set or
    /// holds a different branch.
    pub fn container_detail(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::pipeline_task_executor_detail::ContainerDetail>,
    > {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::pipeline_task_executor_detail::Details::ContainerDetail(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// if it holds a `CustomJobDetail`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_job_detail(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::pipeline_task_executor_detail::CustomJobDetail>,
    > {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::pipeline_task_executor_detail::Details::CustomJobDetail(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// to hold a `ContainerDetail`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_container_detail<
        T: std::convert::Into<
                std::boxed::Box<crate::model::pipeline_task_executor_detail::ContainerDetail>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::pipeline_task_executor_detail::Details::ContainerDetail(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// to hold a `CustomJobDetail`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_custom_job_detail<
        T: std::convert::Into<
                std::boxed::Box<crate::model::pipeline_task_executor_detail::CustomJobDetail>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::pipeline_task_executor_detail::Details::CustomJobDetail(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for PipelineTaskExecutorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail"
    }
}

/// Defines additional types related to [PipelineTaskExecutorDetail].
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
pub mod pipeline_task_executor_detail {
    #[allow(unused_imports)]
    use super::*;

    /// The detail of a container execution. It contains the job names of the
    /// lifecycle of a container execution.
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ContainerDetail {
        /// Output only. The name of the
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the main container
        /// execution.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub main_job: std::string::String,

        /// Output only. The name of the
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the
        /// pre-caching-check container execution. This job will be available if the
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// specifies the `pre_caching_check` hook in the lifecycle events.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pre_caching_check_job: std::string::String,

        /// Output only. The names of the previously failed
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the main container
        /// executions. The list includes the all attempts in chronological order.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failed_main_jobs: std::vec::Vec<std::string::String>,

        /// Output only. The names of the previously failed
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the
        /// pre-caching-check container executions. This job will be available if the
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// specifies the `pre_caching_check` hook in the lifecycle events. The list
        /// includes the all attempts in chronological order.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failed_pre_caching_check_jobs: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl ContainerDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [main_job][crate::model::pipeline_task_executor_detail::ContainerDetail::main_job].
        pub fn set_main_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.main_job = v.into();
            self
        }

        /// Sets the value of [pre_caching_check_job][crate::model::pipeline_task_executor_detail::ContainerDetail::pre_caching_check_job].
        pub fn set_pre_caching_check_job<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pre_caching_check_job = v.into();
            self
        }

        /// Sets the value of [failed_main_jobs][crate::model::pipeline_task_executor_detail::ContainerDetail::failed_main_jobs].
        pub fn set_failed_main_jobs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.failed_main_jobs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [failed_pre_caching_check_jobs][crate::model::pipeline_task_executor_detail::ContainerDetail::failed_pre_caching_check_jobs].
        pub fn set_failed_pre_caching_check_jobs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.failed_pre_caching_check_jobs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl wkt::message::Message for ContainerDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.ContainerDetail"
        }
    }

    /// The detailed info for a custom job executor.
    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomJobDetail {
        /// Output only. The name of the
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob].
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub job: std::string::String,

        /// Output only. The names of the previously failed
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob]. The list includes the
        /// all attempts in chronological order.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failed_jobs: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl CustomJobDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job][crate::model::pipeline_task_executor_detail::CustomJobDetail::job].
        pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.job = v.into();
            self
        }

        /// Sets the value of [failed_jobs][crate::model::pipeline_task_executor_detail::CustomJobDetail::failed_jobs].
        pub fn set_failed_jobs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.failed_jobs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    impl wkt::message::Message for CustomJobDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.CustomJobDetail"
        }
    }

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Output only. The detailed info for a container executor.
        ContainerDetail(
            std::boxed::Box<crate::model::pipeline_task_executor_detail::ContainerDetail>,
        ),
        /// Output only. The detailed info for a custom job executor.
        CustomJobDetail(
            std::boxed::Box<crate::model::pipeline_task_executor_detail::CustomJobDetail>,
        ),
    }
}

/// Runtime operation information for
/// [PipelineService.BatchCancelPipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs]: crate::client::PipelineService::batch_cancel_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCancelPipelineJobsOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl BatchCancelPipelineJobsOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchCancelPipelineJobsOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for BatchCancelPipelineJobsOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsOperationMetadata"
    }
}

/// Request message for
/// [PipelineService.CreateTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.CreateTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.CreateTrainingPipeline]: crate::client::PipelineService::create_training_pipeline
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTrainingPipelineRequest {
    /// Required. The resource name of the Location to create the TrainingPipeline
    /// in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The TrainingPipeline to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_pipeline: std::option::Option<crate::model::TrainingPipeline>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl CreateTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTrainingPipelineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [training_pipeline][crate::model::CreateTrainingPipelineRequest::training_pipeline].
    pub fn set_training_pipeline<
        T: std::convert::Into<std::option::Option<crate::model::TrainingPipeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_pipeline = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for CreateTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.GetTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.GetTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.GetTrainingPipeline]: crate::client::PipelineService::get_training_pipeline
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTrainingPipelineRequest {
    /// Required. The name of the TrainingPipeline resource.
    /// Format:
    /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl GetTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTrainingPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for GetTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.ListTrainingPipelines][google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines].
///
/// [google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]: crate::client::PipelineService::list_training_pipelines
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrainingPipelinesRequest {
    /// Required. The resource name of the Location to list the TrainingPipelines
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `training_task_definition` `=`, `!=` comparisons, and `:` wildcard.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"`
    /// * `state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"`
    /// * `NOT display_name="my_pipeline"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `training_task_definition:"*automl_text_classification*"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListTrainingPipelinesResponse.next_page_token][google.cloud.aiplatform.v1.ListTrainingPipelinesResponse.next_page_token]
    /// of the previous
    /// [PipelineService.ListTrainingPipelines][google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListTrainingPipelinesResponse.next_page_token]: crate::model::ListTrainingPipelinesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]: crate::client::PipelineService::list_training_pipelines
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl ListTrainingPipelinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTrainingPipelinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTrainingPipelinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTrainingPipelinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTrainingPipelinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTrainingPipelinesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for ListTrainingPipelinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrainingPipelinesRequest"
    }
}

/// Response message for
/// [PipelineService.ListTrainingPipelines][google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]
///
/// [google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]: crate::client::PipelineService::list_training_pipelines
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrainingPipelinesResponse {
    /// List of TrainingPipelines in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub training_pipelines: std::vec::Vec<crate::model::TrainingPipeline>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListTrainingPipelinesRequest.page_token][google.cloud.aiplatform.v1.ListTrainingPipelinesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListTrainingPipelinesRequest.page_token]: crate::model::ListTrainingPipelinesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl ListTrainingPipelinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTrainingPipelinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [training_pipelines][crate::model::ListTrainingPipelinesResponse::training_pipelines].
    pub fn set_training_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrainingPipeline>,
    {
        use std::iter::Iterator;
        self.training_pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for ListTrainingPipelinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrainingPipelinesResponse"
    }
}

#[cfg(feature = "pipeline_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTrainingPipelinesResponse {
    type PageItem = crate::model::TrainingPipeline;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.training_pipelines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [PipelineService.DeleteTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.DeleteTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.DeleteTrainingPipeline]: crate::client::PipelineService::delete_training_pipeline
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTrainingPipelineRequest {
    /// Required. The name of the TrainingPipeline resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl DeleteTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTrainingPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for DeleteTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.CancelTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.CancelTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.CancelTrainingPipeline]: crate::client::PipelineService::cancel_training_pipeline
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelTrainingPipelineRequest {
    /// Required. The name of the TrainingPipeline to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl CancelTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelTrainingPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for CancelTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.CreatePipelineJob][google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob]: crate::client::PipelineService::create_pipeline_job
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePipelineJobRequest {
    /// Required. The resource name of the Location to create the PipelineJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The PipelineJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_job: std::option::Option<crate::model::PipelineJob>,

    /// The ID to use for the PipelineJob, which will become the final component of
    /// the PipelineJob name. If not provided, an ID will be automatically
    /// generated.
    ///
    /// This value should be less than 128 characters, and valid characters
    /// are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pipeline_job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl CreatePipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePipelineJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [pipeline_job][crate::model::CreatePipelineJobRequest::pipeline_job].
    pub fn set_pipeline_job<
        T: std::convert::Into<std::option::Option<crate::model::PipelineJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_job = v.into();
        self
    }

    /// Sets the value of [pipeline_job_id][crate::model::CreatePipelineJobRequest::pipeline_job_id].
    pub fn set_pipeline_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_job_id = v.into();
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for CreatePipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.GetPipelineJob][google.cloud.aiplatform.v1.PipelineService.GetPipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.GetPipelineJob]: crate::client::PipelineService::get_pipeline_job
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPipelineJobRequest {
    /// Required. The name of the PipelineJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl GetPipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPipelineJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for GetPipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.ListPipelineJobs][google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]: crate::client::PipelineService::list_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPipelineJobsRequest {
    /// Required. The resource name of the Location to list the PipelineJobs from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the PipelineJobs that match the filter expression. The following
    /// fields are supported:
    ///
    /// * `pipeline_name`: Supports `=` and `!=` comparisons.
    /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and `:` wildcard.
    ///   for example, can check if pipeline's display_name contains *step* by
    ///   doing display_name:\"*step*\"
    /// * `state`: Supports `=` and `!=` comparisons.
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `labels`: Supports key-value equality and key presence.
    /// * `template_uri`: Supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `template_metadata.version`: Supports `=`, `!=` comparisons, and `:`
    ///   wildcard.
    ///
    /// Filter expressions can be combined together using logical operators
    /// (`AND` & `OR`).
    /// For example: `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`.
    ///
    /// The syntax to define filter expression is based on
    /// <https://google.aip.dev/160>.
    ///
    /// Examples:
    ///
    /// * `create_time>"2021-05-18T00:00:00Z" OR
    ///   update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated
    ///   after 2020-05-18 00:00:00 UTC.
    /// * `labels.env = "prod"`
    ///   PipelineJobs with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListPipelineJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListPipelineJobsResponse.next_page_token]
    /// of the previous
    /// [PipelineService.ListPipelineJobs][google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListPipelineJobsResponse.next_page_token]: crate::model::ListPipelineJobsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]: crate::client::PipelineService::list_pipeline_jobs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by. The default sort order is in
    /// ascending order. Use "desc" after a field name for descending. You can have
    /// multiple order_by fields provided e.g. "create_time desc, end_time",
    /// "end_time, start_time, update_time" For example, using "create_time desc,
    /// end_time" will order results by create time in descending order, and if
    /// there are multiple jobs having the same create time, order them by the end
    /// time in ascending order. if order_by is not specified, it will order by
    /// default order is create time in descending order. Supported fields:
    ///
    /// * `create_time`
    /// * `update_time`
    /// * `end_time`
    /// * `start_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl ListPipelineJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPipelineJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPipelineJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPipelineJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPipelineJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPipelineJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListPipelineJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for ListPipelineJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPipelineJobsRequest"
    }
}

/// Response message for
/// [PipelineService.ListPipelineJobs][google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]
///
/// [google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]: crate::client::PipelineService::list_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPipelineJobsResponse {
    /// List of PipelineJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_jobs: std::vec::Vec<crate::model::PipelineJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListPipelineJobsRequest.page_token][google.cloud.aiplatform.v1.ListPipelineJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListPipelineJobsRequest.page_token]: crate::model::ListPipelineJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl ListPipelineJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPipelineJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [pipeline_jobs][crate::model::ListPipelineJobsResponse::pipeline_jobs].
    pub fn set_pipeline_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineJob>,
    {
        use std::iter::Iterator;
        self.pipeline_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for ListPipelineJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPipelineJobsResponse"
    }
}

#[cfg(feature = "pipeline_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPipelineJobsResponse {
    type PageItem = crate::model::PipelineJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.pipeline_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [PipelineService.DeletePipelineJob][google.cloud.aiplatform.v1.PipelineService.DeletePipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.DeletePipelineJob]: crate::client::PipelineService::delete_pipeline_job
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePipelineJobRequest {
    /// Required. The name of the PipelineJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl DeletePipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePipelineJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for DeletePipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeletePipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.BatchDeletePipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs]: crate::client::PipelineService::batch_delete_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeletePipelineJobsRequest {
    /// Required. The name of the PipelineJobs' parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The names of the PipelineJobs to delete.
    /// A maximum of 32 PipelineJobs can be deleted in a batch.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl BatchDeletePipelineJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeletePipelineJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeletePipelineJobsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for BatchDeletePipelineJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDeletePipelineJobsRequest"
    }
}

/// Response message for
/// [PipelineService.BatchDeletePipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs]: crate::client::PipelineService::batch_delete_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeletePipelineJobsResponse {
    /// PipelineJobs deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_jobs: std::vec::Vec<crate::model::PipelineJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl BatchDeletePipelineJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_jobs][crate::model::BatchDeletePipelineJobsResponse::pipeline_jobs].
    pub fn set_pipeline_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineJob>,
    {
        use std::iter::Iterator;
        self.pipeline_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for BatchDeletePipelineJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDeletePipelineJobsResponse"
    }
}

/// Request message for
/// [PipelineService.CancelPipelineJob][google.cloud.aiplatform.v1.PipelineService.CancelPipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.CancelPipelineJob]: crate::client::PipelineService::cancel_pipeline_job
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelPipelineJobRequest {
    /// Required. The name of the PipelineJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl CancelPipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelPipelineJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for CancelPipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelPipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.BatchCancelPipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs]: crate::client::PipelineService::batch_cancel_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCancelPipelineJobsRequest {
    /// Required. The name of the PipelineJobs' parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The names of the PipelineJobs to cancel.
    /// A maximum of 32 PipelineJobs can be cancelled in a batch.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl BatchCancelPipelineJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCancelPipelineJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchCancelPipelineJobsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for BatchCancelPipelineJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsRequest"
    }
}

/// Response message for
/// [PipelineService.BatchCancelPipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs]: crate::client::PipelineService::batch_cancel_pipeline_jobs
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCancelPipelineJobsResponse {
    /// PipelineJobs cancelled.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_jobs: std::vec::Vec<crate::model::PipelineJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl BatchCancelPipelineJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_jobs][crate::model::BatchCancelPipelineJobsResponse::pipeline_jobs].
    pub fn set_pipeline_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineJob>,
    {
        use std::iter::Iterator;
        self.pipeline_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for BatchCancelPipelineJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsResponse"
    }
}

/// Request message for
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict].
///
/// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The instances that are the input to the prediction call.
    /// A DeployedModel may have an upper limit on the number of instances it
    /// supports per request, and when it is exceeded the prediction call errors
    /// in case of AutoML Models, or, in case of customer created Models, the
    /// behaviour is as documented by that Model.
    /// The schema of any single instance may be specified via Endpoint's
    /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// The parameters that govern the prediction. The schema of the parameters may
    /// be specified via Endpoint's DeployedModels' [Model's
    /// ][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [parameters_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<wkt::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl PredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::PredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::PredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::PredictRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for PredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictRequest"
    }
}

/// Response message for
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict].
///
/// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictResponse {
    /// The predictions that are the output of the predictions call.
    /// The schema of any single prediction may be specified via Endpoint's
    /// DeployedModels' [Model's ][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]: crate::model::PredictSchemata::prediction_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predictions: std::vec::Vec<wkt::Value>,

    /// ID of the Endpoint's DeployedModel that served this prediction.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// Output only. The resource name of the Model which is deployed as the
    /// DeployedModel that this prediction hits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the Model which is deployed as the
    /// DeployedModel that this prediction hits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    /// Output only. The [display
    /// name][google.cloud.aiplatform.v1.Model.display_name] of the Model which is
    /// deployed as the DeployedModel that this prediction hits.
    ///
    /// [google.cloud.aiplatform.v1.Model.display_name]: crate::model::Model::display_name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_display_name: std::string::String,

    /// Output only. Request-level metadata returned by the model. The metadata
    /// type will be dependent upon the model implementation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl PredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model_id][crate::model::PredictResponse::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::PredictResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::PredictResponse::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }

    /// Sets the value of [model_display_name][crate::model::PredictResponse::model_display_name].
    pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_display_name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::PredictResponse::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [predictions][crate::model::PredictResponse::predictions].
    pub fn set_predictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.predictions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for PredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictResponse"
    }
}

/// Request message for
/// [PredictionService.RawPredict][google.cloud.aiplatform.v1.PredictionService.RawPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.RawPredict]: crate::client::PredictionService::raw_predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input. Supports HTTP headers and arbitrary data payload.
    ///
    /// A [DeployedModel][google.cloud.aiplatform.v1.DeployedModel] may have an
    /// upper limit on the number of instances it supports per request. When this
    /// limit it is exceeded for an AutoML model, the
    /// [RawPredict][google.cloud.aiplatform.v1.PredictionService.RawPredict]
    /// method returns an error. When this limit is exceeded for a custom-trained
    /// model, the behavior varies depending on the model.
    ///
    /// You can specify the schema for each instance in the
    /// [predict_schemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// field when you create a [Model][google.cloud.aiplatform.v1.Model]. This
    /// schema applies when you deploy the `Model` as a `DeployedModel` to an
    /// [Endpoint][google.cloud.aiplatform.v1.Endpoint] and use the `RawPredict`
    /// method.
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
    /// [google.cloud.aiplatform.v1.Endpoint]: crate::model::Endpoint
    /// [google.cloud.aiplatform.v1.Model]: crate::model::Model
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictionService.RawPredict]: crate::client::PredictionService::raw_predict
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_body: std::option::Option<api::model::HttpBody>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl RawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::RawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [http_body][crate::model::RawPredictRequest::http_body].
    pub fn set_http_body<T: std::convert::Into<std::option::Option<api::model::HttpBody>>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_body = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for RawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RawPredictRequest"
    }
}

/// Request message for
/// [PredictionService.StreamRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamRawPredict].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input. Supports HTTP headers and arbitrary data payload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_body: std::option::Option<api::model::HttpBody>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [http_body][crate::model::StreamRawPredictRequest::http_body].
    pub fn set_http_body<T: std::convert::Into<std::option::Option<api::model::HttpBody>>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_body = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamRawPredictRequest"
    }
}

/// Request message for
/// [PredictionService.DirectPredict][google.cloud.aiplatform.v1.PredictionService.DirectPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectPredict]: crate::client::PredictionService::direct_predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl DirectPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DirectPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::DirectPredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::DirectPredictRequest::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for DirectPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectPredictRequest"
    }
}

/// Response message for
/// [PredictionService.DirectPredict][google.cloud.aiplatform.v1.PredictionService.DirectPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectPredict]: crate::client::PredictionService::direct_predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl DirectPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::DirectPredictResponse::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::DirectPredictResponse::outputs].
    pub fn set_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for DirectPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectPredictResponse"
    }
}

/// Request message for
/// [PredictionService.DirectRawPredict][google.cloud.aiplatform.v1.PredictionService.DirectRawPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectRawPredict]: crate::client::PredictionService::direct_raw_predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Fully qualified name of the API method being invoked to perform
    /// predictions.
    ///
    /// Format:
    /// `/namespace.Service/Method/`
    /// Example:
    /// `/tensorflow.serving.PredictionService/Predict`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub input: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl DirectRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DirectRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::DirectRawPredictRequest::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::DirectRawPredictRequest::input].
    pub fn set_input<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for DirectRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectRawPredictRequest"
    }
}

/// Response message for
/// [PredictionService.DirectRawPredict][google.cloud.aiplatform.v1.PredictionService.DirectRawPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectRawPredict]: crate::client::PredictionService::direct_raw_predict
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectRawPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub output: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl DirectRawPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::DirectRawPredictResponse::output].
    pub fn set_output<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for DirectRawPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectRawPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamDirectPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamDirectPredictRequest.endpoint]
/// field and optionally [input][]. The subsequent messages must contain
/// [input][].
///
/// [google.cloud.aiplatform.v1.StreamDirectPredictRequest.endpoint]: crate::model::StreamDirectPredictRequest::endpoint
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. The prediction input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inputs: std::vec::Vec<crate::model::Tensor>,

    /// Optional. The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamDirectPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamDirectPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::StreamDirectPredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::StreamDirectPredictRequest::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamDirectPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamDirectPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectPredict].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamDirectPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::StreamDirectPredictResponse::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::StreamDirectPredictResponse::outputs].
    pub fn set_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamDirectPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamDirectRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectRawPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.endpoint]
/// and
/// [method_name][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.method_name]
/// fields and optionally
/// [input][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.input]. The
/// subsequent messages must contain
/// [input][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.input].
/// [method_name][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.method_name]
/// in the subsequent messages have no effect.
///
/// [google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.endpoint]: crate::model::StreamDirectRawPredictRequest::endpoint
/// [google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.input]: crate::model::StreamDirectRawPredictRequest::input
/// [google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.method_name]: crate::model::StreamDirectRawPredictRequest::method_name
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. Fully qualified name of the API method being invoked to perform
    /// predictions.
    ///
    /// Format:
    /// `/namespace.Service/Method/`
    /// Example:
    /// `/tensorflow.serving.PredictionService/Predict`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// Optional. The prediction input.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub input: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamDirectRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamDirectRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::StreamDirectRawPredictRequest::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::StreamDirectRawPredictRequest::input].
    pub fn set_input<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamDirectRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectRawPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamDirectRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectRawPredict].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectRawPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub output: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamDirectRawPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::StreamDirectRawPredictResponse::output].
    pub fn set_output<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamDirectRawPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectRawPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamingPredict][google.cloud.aiplatform.v1.PredictionService.StreamingPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamingPredictRequest.endpoint] field
/// and optionally [input][]. The subsequent messages must contain [input][].
///
/// [google.cloud.aiplatform.v1.StreamingPredictRequest.endpoint]: crate::model::StreamingPredictRequest::endpoint
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamingPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamingPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::StreamingPredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::StreamingPredictRequest::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamingPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamingPredict][google.cloud.aiplatform.v1.PredictionService.StreamingPredict].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamingPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::StreamingPredictResponse::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::StreamingPredictResponse::outputs].
    pub fn set_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamingPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamingRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamingRawPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamingRawPredictRequest.endpoint]
/// and
/// [method_name][google.cloud.aiplatform.v1.StreamingRawPredictRequest.method_name]
/// fields and optionally
/// [input][google.cloud.aiplatform.v1.StreamingRawPredictRequest.input]. The
/// subsequent messages must contain
/// [input][google.cloud.aiplatform.v1.StreamingRawPredictRequest.input].
/// [method_name][google.cloud.aiplatform.v1.StreamingRawPredictRequest.method_name]
/// in the subsequent messages have no effect.
///
/// [google.cloud.aiplatform.v1.StreamingRawPredictRequest.endpoint]: crate::model::StreamingRawPredictRequest::endpoint
/// [google.cloud.aiplatform.v1.StreamingRawPredictRequest.input]: crate::model::StreamingRawPredictRequest::input
/// [google.cloud.aiplatform.v1.StreamingRawPredictRequest.method_name]: crate::model::StreamingRawPredictRequest::method_name
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Fully qualified name of the API method being invoked to perform
    /// predictions.
    ///
    /// Format:
    /// `/namespace.Service/Method/`
    /// Example:
    /// `/tensorflow.serving.PredictionService/Predict`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub input: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamingRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamingRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::StreamingRawPredictRequest::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::StreamingRawPredictRequest::input].
    pub fn set_input<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamingRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingRawPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamingRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamingRawPredict].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRawPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub output: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl StreamingRawPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::StreamingRawPredictResponse::output].
    pub fn set_output<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for StreamingRawPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingRawPredictResponse"
    }
}

/// Request message for
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
///
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainRequest {
    /// Required. The name of the Endpoint requested to serve the explanation.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The instances that are the input to the explanation call.
    /// A DeployedModel may have an upper limit on the number of instances it
    /// supports per request, and when it is exceeded the explanation call errors
    /// in case of AutoML Models, or, in case of customer created Models, the
    /// behaviour is as documented by that Model.
    /// The schema of any single instance may be specified via Endpoint's
    /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// The parameters that govern the prediction. The schema of the parameters may
    /// be specified via Endpoint's DeployedModels' [Model's
    /// ][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [parameters_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<wkt::Value>,

    /// If specified, overrides the
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// of the DeployedModel. Can be used for explaining prediction results with
    /// different configurations, such as:
    ///
    /// - Explaining top-5 predictions results as opposed to top-1;
    /// - Increasing path count or step count of the attribution methods to reduce
    ///   approximate errors;
    /// - Using different baselines for explaining the prediction results.
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec_override: std::option::Option<crate::model::ExplanationSpecOverride>,

    /// If specified, this ExplainRequest will be served by the chosen
    /// DeployedModel, overriding
    /// [Endpoint.traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split].
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl ExplainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::ExplainRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::ExplainRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [explanation_spec_override][crate::model::ExplainRequest::explanation_spec_override].
    pub fn set_explanation_spec_override<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpecOverride>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec_override = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::ExplainRequest::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ExplainRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for ExplainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplainRequest"
    }
}

/// Response message for
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
///
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainResponse {
    /// The explanations of the Model's
    /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions].
    ///
    /// It has the same number of elements as
    /// [instances][google.cloud.aiplatform.v1.ExplainRequest.instances] to be
    /// explained.
    ///
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explanations: std::vec::Vec<crate::model::Explanation>,

    /// ID of the Endpoint's DeployedModel that served this explanation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// The predictions that are the output of the predictions call.
    /// Same as
    /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions].
    ///
    /// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predictions: std::vec::Vec<wkt::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl ExplainResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model_id][crate::model::ExplainResponse::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [explanations][crate::model::ExplainResponse::explanations].
    pub fn set_explanations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Explanation>,
    {
        use std::iter::Iterator;
        self.explanations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predictions][crate::model::ExplainResponse::predictions].
    pub fn set_predictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.predictions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for ExplainResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplainResponse"
    }
}

/// Request message for [PredictionService.CountTokens][].
#[cfg(feature = "llm_utility_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CountTokensRequest {
    /// Required. The name of the Endpoint requested to perform token counting.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. The name of the publisher model requested to serve the
    /// prediction. Format:
    /// `projects/{project}/locations/{location}/publishers/*/models/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. The instances that are the input to token counting call.
    /// Schema is identical to the prediction schema of the underlying model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// Optional. Input content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. The user provided system instructions for the model.
    /// Note: only text should be used in parts and content in each part will be in
    /// a separate paragraph.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::Content>,

    /// Optional. A list of `Tools` the model may use to generate the next
    /// response.
    ///
    /// A `Tool` is a piece of code that enables the system to interact with
    /// external systems to perform an action, or set of actions, outside of
    /// knowledge and scope of the model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tools: std::vec::Vec<crate::model::Tool>,

    /// Optional. Generation config that the model will use to generate the
    /// response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generation_config: std::option::Option<crate::model::GenerationConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "llm_utility_service")]
impl CountTokensRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::CountTokensRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CountTokensRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::CountTokensRequest::system_instruction].
    pub fn set_system_instruction<
        T: std::convert::Into<std::option::Option<crate::model::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_instruction = v.into();
        self
    }

    /// Sets the value of [generation_config][crate::model::CountTokensRequest::generation_config].
    pub fn set_generation_config<
        T: std::convert::Into<std::option::Option<crate::model::GenerationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generation_config = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::CountTokensRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [contents][crate::model::CountTokensRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tools][crate::model::CountTokensRequest::tools].
    pub fn set_tools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tool>,
    {
        use std::iter::Iterator;
        self.tools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "llm_utility_service")]
impl wkt::message::Message for CountTokensRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CountTokensRequest"
    }
}

/// Response message for [PredictionService.CountTokens][].
#[cfg(feature = "llm_utility_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CountTokensResponse {
    /// The total number of tokens counted across all instances from the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_tokens: i32,

    /// The total number of billable characters counted across all instances from
    /// the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_billable_characters: i32,

    /// Output only. List of modalities that were processed in the request input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub prompt_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "llm_utility_service")]
impl CountTokensResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_tokens][crate::model::CountTokensResponse::total_tokens].
    pub fn set_total_tokens<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_tokens = v.into();
        self
    }

    /// Sets the value of [total_billable_characters][crate::model::CountTokensResponse::total_billable_characters].
    pub fn set_total_billable_characters<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_billable_characters = v.into();
        self
    }

    /// Sets the value of [prompt_tokens_details][crate::model::CountTokensResponse::prompt_tokens_details].
    pub fn set_prompt_tokens_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModalityTokenCount>,
    {
        use std::iter::Iterator;
        self.prompt_tokens_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "llm_utility_service")]
impl wkt::message::Message for CountTokensResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CountTokensResponse"
    }
}

/// Request message for [PredictionService.GenerateContent].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateContentRequest {
    /// Required. The fully qualified name of the publisher model or tuned model
    /// endpoint to use.
    ///
    /// Publisher model format:
    /// `projects/{project}/locations/{location}/publishers/*/models/*`
    ///
    /// Tuned model endpoint format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Required. The content of the current conversation with the model.
    ///
    /// For single-turn queries, this is a single instance. For multi-turn queries,
    /// this is a repeated field that contains conversation history + latest
    /// request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. The user provided system instructions for the model.
    /// Note: only text should be used in parts and content in each part will be in
    /// a separate paragraph.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::Content>,

    /// Optional. The name of the cached content used as context to serve the
    /// prediction. Note: only used in explicit caching, where users can have
    /// control over caching (e.g. what content to cache) and enjoy guaranteed cost
    /// savings. Format:
    /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cached_content: std::string::String,

    /// Optional. A list of `Tools` the model may use to generate the next
    /// response.
    ///
    /// A `Tool` is a piece of code that enables the system to interact with
    /// external systems to perform an action, or set of actions, outside of
    /// knowledge and scope of the model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tools: std::vec::Vec<crate::model::Tool>,

    /// Optional. Tool config. This config is shared for all tools provided in the
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tool_config: std::option::Option<crate::model::ToolConfig>,

    /// Optional. The labels with user-defined metadata for the request. It is used
    /// for billing and reporting only.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints) and can only contain lowercase letters, numeric
    /// characters, underscores, and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Per request settings for blocking unsafe content.
    /// Enforced on GenerateContentResponse.candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub safety_settings: std::vec::Vec<crate::model::SafetySetting>,

    /// Optional. Generation config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generation_config: std::option::Option<crate::model::GenerationConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl GenerateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::GenerateContentRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::GenerateContentRequest::system_instruction].
    pub fn set_system_instruction<
        T: std::convert::Into<std::option::Option<crate::model::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_instruction = v.into();
        self
    }

    /// Sets the value of [cached_content][crate::model::GenerateContentRequest::cached_content].
    pub fn set_cached_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cached_content = v.into();
        self
    }

    /// Sets the value of [tool_config][crate::model::GenerateContentRequest::tool_config].
    pub fn set_tool_config<T: std::convert::Into<std::option::Option<crate::model::ToolConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tool_config = v.into();
        self
    }

    /// Sets the value of [generation_config][crate::model::GenerateContentRequest::generation_config].
    pub fn set_generation_config<
        T: std::convert::Into<std::option::Option<crate::model::GenerationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generation_config = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::GenerateContentRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tools][crate::model::GenerateContentRequest::tools].
    pub fn set_tools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tool>,
    {
        use std::iter::Iterator;
        self.tools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [safety_settings][crate::model::GenerateContentRequest::safety_settings].
    pub fn set_safety_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SafetySetting>,
    {
        use std::iter::Iterator;
        self.safety_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::GenerateContentRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for GenerateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentRequest"
    }
}

/// Response message for [PredictionService.GenerateContent].
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateContentResponse {
    /// Output only. Generated candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub candidates: std::vec::Vec<crate::model::Candidate>,

    /// Output only. The model version used to generate the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version: std::string::String,

    /// Output only. Timestamp when the request is made to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. response_id is used to identify each response. It is the
    /// encoding of the event_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub response_id: std::string::String,

    /// Output only. Content filter results for a prompt sent in the request.
    /// Note: Sent only in the first stream chunk.
    /// Only happens when no candidates were generated due to content violations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prompt_feedback:
        std::option::Option<crate::model::generate_content_response::PromptFeedback>,

    /// Usage metadata about the response(s).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub usage_metadata: std::option::Option<crate::model::generate_content_response::UsageMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl GenerateContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_version][crate::model::GenerateContentResponse::model_version].
    pub fn set_model_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GenerateContentResponse::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [response_id][crate::model::GenerateContentResponse::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [prompt_feedback][crate::model::GenerateContentResponse::prompt_feedback].
    pub fn set_prompt_feedback<
        T: std::convert::Into<
                std::option::Option<crate::model::generate_content_response::PromptFeedback>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prompt_feedback = v.into();
        self
    }

    /// Sets the value of [usage_metadata][crate::model::GenerateContentResponse::usage_metadata].
    pub fn set_usage_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::generate_content_response::UsageMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.usage_metadata = v.into();
        self
    }

    /// Sets the value of [candidates][crate::model::GenerateContentResponse::candidates].
    pub fn set_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Candidate>,
    {
        use std::iter::Iterator;
        self.candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for GenerateContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse"
    }
}

/// Defines additional types related to [GenerateContentResponse].
#[cfg(feature = "prediction_service")]
pub mod generate_content_response {
    #[allow(unused_imports)]
    use super::*;

    /// Content filter results for a prompt sent in the request.
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PromptFeedback {
        /// Output only. Blocked reason.
        pub block_reason: crate::model::generate_content_response::prompt_feedback::BlockedReason,

        /// Output only. Safety ratings.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub safety_ratings: std::vec::Vec<crate::model::SafetyRating>,

        /// Output only. A readable block reason message.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub block_reason_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl PromptFeedback {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [block_reason][crate::model::generate_content_response::PromptFeedback::block_reason].
        pub fn set_block_reason<
            T: std::convert::Into<
                    crate::model::generate_content_response::prompt_feedback::BlockedReason,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.block_reason = v.into();
            self
        }

        /// Sets the value of [block_reason_message][crate::model::generate_content_response::PromptFeedback::block_reason_message].
        pub fn set_block_reason_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.block_reason_message = v.into();
            self
        }

        /// Sets the value of [safety_ratings][crate::model::generate_content_response::PromptFeedback::safety_ratings].
        pub fn set_safety_ratings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::SafetyRating>,
        {
            use std::iter::Iterator;
            self.safety_ratings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for PromptFeedback {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse.PromptFeedback"
        }
    }

    /// Defines additional types related to [PromptFeedback].
    #[cfg(feature = "prediction_service")]
    pub mod prompt_feedback {
        #[allow(unused_imports)]
        use super::*;

        /// Blocked reason enumeration.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "prediction_service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BlockedReason {
            /// Unspecified blocked reason.
            Unspecified,
            /// Candidates blocked due to safety.
            Safety,
            /// Candidates blocked due to other reason.
            Other,
            /// Candidates blocked due to the terms which are included from the
            /// terminology blocklist.
            Blocklist,
            /// Candidates blocked due to prohibited content.
            ProhibitedContent,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BlockedReason::value] or
            /// [BlockedReason::name].
            UnknownValue(blocked_reason::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "prediction_service")]
        pub mod blocked_reason {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "prediction_service")]
        impl BlockedReason {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Safety => std::option::Option::Some(1),
                    Self::Other => std::option::Option::Some(2),
                    Self::Blocklist => std::option::Option::Some(3),
                    Self::ProhibitedContent => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("BLOCKED_REASON_UNSPECIFIED"),
                    Self::Safety => std::option::Option::Some("SAFETY"),
                    Self::Other => std::option::Option::Some("OTHER"),
                    Self::Blocklist => std::option::Option::Some("BLOCKLIST"),
                    Self::ProhibitedContent => std::option::Option::Some("PROHIBITED_CONTENT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "prediction_service")]
        impl std::default::Default for BlockedReason {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "prediction_service")]
        impl std::fmt::Display for BlockedReason {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "prediction_service")]
        impl std::convert::From<i32> for BlockedReason {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Safety,
                    2 => Self::Other,
                    3 => Self::Blocklist,
                    4 => Self::ProhibitedContent,
                    _ => Self::UnknownValue(blocked_reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "prediction_service")]
        impl std::convert::From<&str> for BlockedReason {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "BLOCKED_REASON_UNSPECIFIED" => Self::Unspecified,
                    "SAFETY" => Self::Safety,
                    "OTHER" => Self::Other,
                    "BLOCKLIST" => Self::Blocklist,
                    "PROHIBITED_CONTENT" => Self::ProhibitedContent,
                    _ => Self::UnknownValue(blocked_reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "prediction_service")]
        impl serde::ser::Serialize for BlockedReason {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Safety => serializer.serialize_i32(1),
                    Self::Other => serializer.serialize_i32(2),
                    Self::Blocklist => serializer.serialize_i32(3),
                    Self::ProhibitedContent => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "prediction_service")]
        impl<'de> serde::de::Deserialize<'de> for BlockedReason {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BlockedReason>::new(
                    ".google.cloud.aiplatform.v1.GenerateContentResponse.PromptFeedback.BlockedReason"))
            }
        }
    }

    /// Usage metadata about response(s).
    #[cfg(feature = "prediction_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UsageMetadata {
        /// Number of tokens in the request. When `cached_content` is set, this is
        /// still the total effective prompt size meaning this includes the number of
        /// tokens in the cached content.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub prompt_token_count: i32,

        /// Number of tokens in the response(s).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub candidates_token_count: i32,

        /// Total token count for prompt and response candidates.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub total_token_count: i32,

        /// Output only. Number of tokens in the cached part in the input (the cached
        /// content).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub cached_content_token_count: i32,

        /// Output only. List of modalities that were processed in the request input.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub prompt_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,

        /// Output only. List of modalities of the cached content in the request
        /// input.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub cache_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,

        /// Output only. List of modalities that were returned in the response.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub candidates_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "prediction_service")]
    impl UsageMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [prompt_token_count][crate::model::generate_content_response::UsageMetadata::prompt_token_count].
        pub fn set_prompt_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.prompt_token_count = v.into();
            self
        }

        /// Sets the value of [candidates_token_count][crate::model::generate_content_response::UsageMetadata::candidates_token_count].
        pub fn set_candidates_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.candidates_token_count = v.into();
            self
        }

        /// Sets the value of [total_token_count][crate::model::generate_content_response::UsageMetadata::total_token_count].
        pub fn set_total_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_token_count = v.into();
            self
        }

        /// Sets the value of [cached_content_token_count][crate::model::generate_content_response::UsageMetadata::cached_content_token_count].
        pub fn set_cached_content_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.cached_content_token_count = v.into();
            self
        }

        /// Sets the value of [prompt_tokens_details][crate::model::generate_content_response::UsageMetadata::prompt_tokens_details].
        pub fn set_prompt_tokens_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ModalityTokenCount>,
        {
            use std::iter::Iterator;
            self.prompt_tokens_details = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [cache_tokens_details][crate::model::generate_content_response::UsageMetadata::cache_tokens_details].
        pub fn set_cache_tokens_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ModalityTokenCount>,
        {
            use std::iter::Iterator;
            self.cache_tokens_details = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [candidates_tokens_details][crate::model::generate_content_response::UsageMetadata::candidates_tokens_details].
        pub fn set_candidates_tokens_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ModalityTokenCount>,
        {
            use std::iter::Iterator;
            self.candidates_tokens_details = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "prediction_service")]
    impl wkt::message::Message for UsageMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse.UsageMetadata"
        }
    }
}

/// A Model Garden Publisher Model.
#[cfg(feature = "model_garden_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PublisherModel {
    /// Output only. The resource name of the PublisherModel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The version ID of the PublisherModel.
    /// A new version is committed when a new model version is uploaded under an
    /// existing model id. It is an auto-incrementing decimal number in string
    /// representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_id: std::string::String,

    /// Required. Indicates the open source category of the publisher model.
    pub open_source_category: crate::model::publisher_model::OpenSourceCategory,

    /// Optional. Supported call-to-action options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub supported_actions: std::option::Option<crate::model::publisher_model::CallToAction>,

    /// Optional. Additional information about the model's Frameworks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub frameworks: std::vec::Vec<std::string::String>,

    /// Optional. Indicates the launch stage of the model.
    pub launch_stage: crate::model::publisher_model::LaunchStage,

    /// Optional. Indicates the state of the model version.
    pub version_state: crate::model::publisher_model::VersionState,

    /// Optional. Output only. Immutable. Used to indicate this model has a
    /// publisher model and provide the template of the publisher model resource
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub publisher_model_template: std::string::String,

    /// Optional. The schemata that describes formats of the PublisherModel's
    /// predictions and explanations as given and returned via
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict].
    ///
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_schemata: std::option::Option<crate::model::PredictSchemata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "model_garden_service")]
impl PublisherModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PublisherModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::PublisherModel::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [open_source_category][crate::model::PublisherModel::open_source_category].
    pub fn set_open_source_category<
        T: std::convert::Into<crate::model::publisher_model::OpenSourceCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_source_category = v.into();
        self
    }

    /// Sets the value of [supported_actions][crate::model::PublisherModel::supported_actions].
    pub fn set_supported_actions<
        T: std::convert::Into<std::option::Option<crate::model::publisher_model::CallToAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.supported_actions = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::PublisherModel::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::publisher_model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [version_state][crate::model::PublisherModel::version_state].
    pub fn set_version_state<T: std::convert::Into<crate::model::publisher_model::VersionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_state = v.into();
        self
    }

    /// Sets the value of [publisher_model_template][crate::model::PublisherModel::publisher_model_template].
    pub fn set_publisher_model_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.publisher_model_template = v.into();
        self
    }

    /// Sets the value of [predict_schemata][crate::model::PublisherModel::predict_schemata].
    pub fn set_predict_schemata<
        T: std::convert::Into<std::option::Option<crate::model::PredictSchemata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_schemata = v.into();
        self
    }

    /// Sets the value of [frameworks][crate::model::PublisherModel::frameworks].
    pub fn set_frameworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.frameworks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "model_garden_service")]
impl wkt::message::Message for PublisherModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel"
    }
}

/// Defines additional types related to [PublisherModel].
#[cfg(feature = "model_garden_service")]
pub mod publisher_model {
    #[allow(unused_imports)]
    use super::*;

    /// Reference to a resource.
    #[cfg(feature = "model_garden_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceReference {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub reference:
            std::option::Option<crate::model::publisher_model::resource_reference::Reference>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_garden_service")]
    impl ResourceReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference].
        ///
        /// Note that all the setters affecting `reference` are mutually
        /// exclusive.
        pub fn set_reference<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::resource_reference::Reference,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.reference = v.into();
            self
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `Uri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::Uri(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `ResourceName`, `None` if the field is not set or
        /// holds a different branch.
        pub fn resource_name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::ResourceName(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `UseCase`, `None` if the field is not set or
        /// holds a different branch.
        #[deprecated]
        pub fn use_case(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::UseCase(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `Description`, `None` if the field is not set or
        /// holds a different branch.
        #[deprecated]
        pub fn description(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::Description(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `Uri`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::Uri(v.into()),
            );
            self
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `ResourceName`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        pub fn set_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::ResourceName(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `UseCase`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        #[deprecated]
        pub fn set_use_case<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::UseCase(v.into()),
            );
            self
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `Description`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        #[deprecated]
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::Description(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl wkt::message::Message for ResourceReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.ResourceReference"
        }
    }

    /// Defines additional types related to [ResourceReference].
    #[cfg(feature = "model_garden_service")]
    pub mod resource_reference {
        #[allow(unused_imports)]
        use super::*;

        #[cfg(feature = "model_garden_service")]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Reference {
            /// The URI of the resource.
            Uri(std::string::String),
            /// The resource name of the Google Cloud resource.
            ResourceName(std::string::String),
            /// Use case (CUJ) of the resource.
            #[deprecated]
            UseCase(std::string::String),
            /// Description of the resource.
            #[deprecated]
            Description(std::string::String),
        }
    }

    /// A named piece of documentation.
    #[cfg(feature = "model_garden_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Documentation {
        /// Required. E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA,
        /// NODE.JS, etc..
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub title: std::string::String,

        /// Required. Content of this piece of document (in Markdown format).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub content: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_garden_service")]
    impl Documentation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [title][crate::model::publisher_model::Documentation::title].
        pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [content][crate::model::publisher_model::Documentation::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl wkt::message::Message for Documentation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.Documentation"
        }
    }

    /// Actions could take on this Publisher Model.
    #[cfg(feature = "model_garden_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CallToAction {
        /// Optional. To view Rest API docs.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub view_rest_api:
            std::option::Option<crate::model::publisher_model::call_to_action::ViewRestApi>,

        /// Optional. Open notebook of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_notebook: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open notebooks of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_notebooks:
            std::option::Option<crate::model::publisher_model::call_to_action::OpenNotebooks>,

        /// Optional. Create application using the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub create_application: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open fine-tuning pipeline of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_fine_tuning_pipeline: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open fine-tuning pipelines of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_fine_tuning_pipelines: std::option::Option<
            crate::model::publisher_model::call_to_action::OpenFineTuningPipelines,
        >,

        /// Optional. Open prompt-tuning pipeline of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_prompt_tuning_pipeline: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open Genie / Playground.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_genie: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Deploy the PublisherModel to Vertex Endpoint.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub deploy: std::option::Option<crate::model::publisher_model::call_to_action::Deploy>,

        /// Optional. Deploy PublisherModel to Google Kubernetes Engine.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub deploy_gke:
            std::option::Option<crate::model::publisher_model::call_to_action::DeployGke>,

        /// Optional. Open in Generation AI Studio.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_generation_ai_studio: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Request for access.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub request_access: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open evaluation pipeline of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_evaluation_pipeline: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "model_garden_service")]
    impl CallToAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [view_rest_api][crate::model::publisher_model::CallToAction::view_rest_api].
        pub fn set_view_rest_api<
            T: std::convert::Into<
                    std::option::Option<crate::model::publisher_model::call_to_action::ViewRestApi>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.view_rest_api = v.into();
            self
        }

        /// Sets the value of [open_notebook][crate::model::publisher_model::CallToAction::open_notebook].
        pub fn set_open_notebook<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_notebook = v.into();
            self
        }

        /// Sets the value of [open_notebooks][crate::model::publisher_model::CallToAction::open_notebooks].
        pub fn set_open_notebooks<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::OpenNotebooks,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_notebooks = v.into();
            self
        }

        /// Sets the value of [create_application][crate::model::publisher_model::CallToAction::create_application].
        pub fn set_create_application<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.create_application = v.into();
            self
        }

        /// Sets the value of [open_fine_tuning_pipeline][crate::model::publisher_model::CallToAction::open_fine_tuning_pipeline].
        pub fn set_open_fine_tuning_pipeline<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_fine_tuning_pipeline = v.into();
            self
        }

        /// Sets the value of [open_fine_tuning_pipelines][crate::model::publisher_model::CallToAction::open_fine_tuning_pipelines].
        pub fn set_open_fine_tuning_pipelines<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::OpenFineTuningPipelines,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_fine_tuning_pipelines = v.into();
            self
        }

        /// Sets the value of [open_prompt_tuning_pipeline][crate::model::publisher_model::CallToAction::open_prompt_tuning_pipeline].
        pub fn set_open_prompt_tuning_pipeline<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_prompt_tuning_pipeline = v.into();
            self
        }

        /// Sets the value of [open_genie][crate::model::publisher_model::CallToAction::open_genie].
        pub fn set_open_genie<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_genie = v.into();
            self
        }

        /// Sets the value of [deploy][crate::model::publisher_model::CallToAction::deploy].
        pub fn set_deploy<
            T: std::convert::Into<
                    std::option::Option<crate::model::publisher_model::call_to_action::Deploy>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.deploy = v.into();
            self
        }

        /// Sets the value of [deploy_gke][crate::model::publisher_model::CallToAction::deploy_gke].
        pub fn set_deploy_gke<
            T: std::convert::Into<
                    std::option::Option<crate::model::publisher_model::call_to_action::DeployGke>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.deploy_gke = v.into();
            self
        }

        /// Sets the value of [open_generation_ai_studio][crate::model::publisher_model::CallToAction::open_generation_ai_studio].
        pub fn set_open_generation_ai_studio<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_generation_ai_studio = v.into();
            self
        }

        /// Sets the value of [request_access][crate::model::publisher_model::CallToAction::request_access].
        pub fn set_request_access<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request_access = v.into();
            self
        }

        /// Sets the value of [open_evaluation_pipeline][crate::model::publisher_model::CallToAction::open_evaluation_pipeline].
        pub fn set_open_evaluation_pipeline<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_evaluation_pipeline = v.into();
            self
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl wkt::message::Message for CallToAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction"
        }
    }

    /// Defines additional types related to [CallToAction].
    #[cfg(feature = "model_garden_service")]
    pub mod call_to_action {
        #[allow(unused_imports)]
        use super::*;

        /// The regional resource name or the URI. Key is region, e.g.,
        /// us-central1, europe-west2, global, etc..
        #[cfg(feature = "model_garden_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RegionalResourceReferences {
            /// Required.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub references: std::collections::HashMap<
                std::string::String,
                crate::model::publisher_model::ResourceReference,
            >,

            /// Required.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// Optional. Title of the resource.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub resource_title: std::option::Option<std::string::String>,

            /// Optional. Use case (CUJ) of the resource.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub resource_use_case: std::option::Option<std::string::String>,

            /// Optional. Description of the resource.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub resource_description: std::option::Option<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_garden_service")]
        impl RegionalResourceReferences {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::publisher_model::call_to_action::RegionalResourceReferences::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [resource_title][crate::model::publisher_model::call_to_action::RegionalResourceReferences::resource_title].
            pub fn set_resource_title<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.resource_title = v.into();
                self
            }

            /// Sets the value of [resource_use_case][crate::model::publisher_model::call_to_action::RegionalResourceReferences::resource_use_case].
            pub fn set_resource_use_case<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.resource_use_case = v.into();
                self
            }

            /// Sets the value of [resource_description][crate::model::publisher_model::call_to_action::RegionalResourceReferences::resource_description].
            pub fn set_resource_description<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.resource_description = v.into();
                self
            }

            /// Sets the value of [references][crate::model::publisher_model::call_to_action::RegionalResourceReferences::references].
            pub fn set_references<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<crate::model::publisher_model::ResourceReference>,
            {
                use std::iter::Iterator;
                self.references = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        #[cfg(feature = "model_garden_service")]
        impl wkt::message::Message for RegionalResourceReferences {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.RegionalResourceReferences"
            }
        }

        /// Rest API docs.
        #[cfg(feature = "model_garden_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ViewRestApi {
            /// Required.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub documentations: std::vec::Vec<crate::model::publisher_model::Documentation>,

            /// Required. The title of the view rest API.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_garden_service")]
        impl ViewRestApi {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::publisher_model::call_to_action::ViewRestApi::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [documentations][crate::model::publisher_model::call_to_action::ViewRestApi::documentations].
            pub fn set_documentations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::publisher_model::Documentation>,
            {
                use std::iter::Iterator;
                self.documentations = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "model_garden_service")]
        impl wkt::message::Message for ViewRestApi {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.ViewRestApi"
            }
        }

        /// Open notebooks.
        #[cfg(feature = "model_garden_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OpenNotebooks {
            /// Required. Regional resource references to notebooks.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub notebooks: std::vec::Vec<
                crate::model::publisher_model::call_to_action::RegionalResourceReferences,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_garden_service")]
        impl OpenNotebooks {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [notebooks][crate::model::publisher_model::call_to_action::OpenNotebooks::notebooks].
            pub fn set_notebooks<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
            {
                use std::iter::Iterator;
                self.notebooks = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "model_garden_service")]
        impl wkt::message::Message for OpenNotebooks {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenNotebooks"
            }
        }

        /// Open fine tuning pipelines.
        #[cfg(feature = "model_garden_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OpenFineTuningPipelines {
            /// Required. Regional resource references to fine tuning pipelines.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub fine_tuning_pipelines: std::vec::Vec<
                crate::model::publisher_model::call_to_action::RegionalResourceReferences,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_garden_service")]
        impl OpenFineTuningPipelines {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [fine_tuning_pipelines][crate::model::publisher_model::call_to_action::OpenFineTuningPipelines::fine_tuning_pipelines].
            pub fn set_fine_tuning_pipelines<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                    >,
            {
                use std::iter::Iterator;
                self.fine_tuning_pipelines = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "model_garden_service")]
        impl wkt::message::Message for OpenFineTuningPipelines {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenFineTuningPipelines"
            }
        }

        /// Model metadata that is needed for UploadModel or
        /// DeployModel/CreateEndpoint requests.
        #[cfg(feature = "model_garden_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Deploy {
            /// Optional. Default model display name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub model_display_name: std::string::String,

            /// Optional. Large model reference. When this is set, model_artifact_spec
            /// is not needed.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub large_model_reference: std::option::Option<crate::model::LargeModelReference>,

            /// Optional. The specification of the container that is to be used when
            /// deploying this Model in Vertex AI. Not present for Large Models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub container_spec: std::option::Option<crate::model::ModelContainerSpec>,

            /// Optional. The path to the directory containing the Model artifact and
            /// any of its supporting files.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub artifact_uri: std::string::String,

            /// Optional. The name of the deploy task (e.g., "text to image
            /// generation").
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub deploy_task_name: std::option::Option<std::string::String>,

            /// Optional. Metadata information about this deployment config.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub deploy_metadata: std::option::Option<
                crate::model::publisher_model::call_to_action::deploy::DeployMetadata,
            >,

            /// Required. The title of the regional resource reference.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// Optional. The signed URI for ephemeral Cloud Storage access to model
            /// artifact.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub public_artifact_uri: std::string::String,

            /// The prediction (for example, the machine) resources that the
            /// DeployedModel uses.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub prediction_resources: std::option::Option<
                crate::model::publisher_model::call_to_action::deploy::PredictionResources,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_garden_service")]
        impl Deploy {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_display_name][crate::model::publisher_model::call_to_action::Deploy::model_display_name].
            pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.model_display_name = v.into();
                self
            }

            /// Sets the value of [large_model_reference][crate::model::publisher_model::call_to_action::Deploy::large_model_reference].
            pub fn set_large_model_reference<
                T: std::convert::Into<std::option::Option<crate::model::LargeModelReference>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.large_model_reference = v.into();
                self
            }

            /// Sets the value of [container_spec][crate::model::publisher_model::call_to_action::Deploy::container_spec].
            pub fn set_container_spec<
                T: std::convert::Into<std::option::Option<crate::model::ModelContainerSpec>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.container_spec = v.into();
                self
            }

            /// Sets the value of [artifact_uri][crate::model::publisher_model::call_to_action::Deploy::artifact_uri].
            pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.artifact_uri = v.into();
                self
            }

            /// Sets the value of [deploy_task_name][crate::model::publisher_model::call_to_action::Deploy::deploy_task_name].
            pub fn set_deploy_task_name<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.deploy_task_name = v.into();
                self
            }

            /// Sets the value of [deploy_metadata][crate::model::publisher_model::call_to_action::Deploy::deploy_metadata].
            pub fn set_deploy_metadata<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::publisher_model::call_to_action::deploy::DeployMetadata,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.deploy_metadata = v.into();
                self
            }

            /// Sets the value of [title][crate::model::publisher_model::call_to_action::Deploy::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [public_artifact_uri][crate::model::publisher_model::call_to_action::Deploy::public_artifact_uri].
            pub fn set_public_artifact_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.public_artifact_uri = v.into();
                self
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources].
            ///
            /// Note that all the setters affecting `prediction_resources` are mutually
            /// exclusive.
            pub fn set_prediction_resources<T: std::convert::Into<std::option::Option<crate::model::publisher_model::call_to_action::deploy::PredictionResources>>>(mut self, v: T) -> Self
            {
                self.prediction_resources = v.into();
                self
            }

            /// The value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// if it holds a `DedicatedResources`, `None` if the field is not set or
            /// holds a different branch.
            pub fn dedicated_resources(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::DedicatedResources>>
            {
                #[allow(unreachable_patterns)]
                self.prediction_resources.as_ref().and_then(|v| match v {
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::DedicatedResources(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// if it holds a `AutomaticResources`, `None` if the field is not set or
            /// holds a different branch.
            pub fn automatic_resources(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticResources>>
            {
                #[allow(unreachable_patterns)]
                self.prediction_resources.as_ref().and_then(|v| match v {
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::AutomaticResources(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// if it holds a `SharedResources`, `None` if the field is not set or
            /// holds a different branch.
            pub fn shared_resources(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.prediction_resources.as_ref().and_then(|v| match v {
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::SharedResources(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// to hold a `DedicatedResources`.
            ///
            /// Note that all the setters affecting `prediction_resources` are
            /// mutually exclusive.
            pub fn set_dedicated_resources<
                T: std::convert::Into<std::boxed::Box<crate::model::DedicatedResources>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = std::option::Option::Some(
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::DedicatedResources(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// to hold a `AutomaticResources`.
            ///
            /// Note that all the setters affecting `prediction_resources` are
            /// mutually exclusive.
            pub fn set_automatic_resources<
                T: std::convert::Into<std::boxed::Box<crate::model::AutomaticResources>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = std::option::Option::Some(
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::AutomaticResources(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// to hold a `SharedResources`.
            ///
            /// Note that all the setters affecting `prediction_resources` are
            /// mutually exclusive.
            pub fn set_shared_resources<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = std::option::Option::Some(
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::SharedResources(
                        v.into()
                    )
                );
                self
            }
        }

        #[cfg(feature = "model_garden_service")]
        impl wkt::message::Message for Deploy {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy"
            }
        }

        /// Defines additional types related to [Deploy].
        #[cfg(feature = "model_garden_service")]
        pub mod deploy {
            #[allow(unused_imports)]
            use super::*;

            /// Metadata information about the deployment for managing deployment
            /// config.
            #[cfg(feature = "model_garden_service")]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DeployMetadata {
                /// Optional. Labels for the deployment. For managing deployment config
                /// like verifying, source of deployment config, etc.
                #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
                pub labels: std::collections::HashMap<std::string::String, std::string::String>,

                /// Optional. Sample request for deployed endpoint.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub sample_request: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "model_garden_service")]
            impl DeployMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [sample_request][crate::model::publisher_model::call_to_action::deploy::DeployMetadata::sample_request].
                pub fn set_sample_request<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.sample_request = v.into();
                    self
                }

                /// Sets the value of [labels][crate::model::publisher_model::call_to_action::deploy::DeployMetadata::labels].
                pub fn set_labels<T, K, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = (K, V)>,
                    K: std::convert::Into<std::string::String>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                    self
                }
            }

            #[cfg(feature = "model_garden_service")]
            impl wkt::message::Message for DeployMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy.DeployMetadata"
                }
            }

            /// The prediction (for example, the machine) resources that the
            /// DeployedModel uses.
            #[cfg(feature = "model_garden_service")]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum PredictionResources {
                /// A description of resources that are dedicated to the DeployedModel,
                /// and that need a higher degree of manual configuration.
                DedicatedResources(std::boxed::Box<crate::model::DedicatedResources>),
                /// A description of resources that to large degree are decided by Vertex
                /// AI, and require only a modest additional configuration.
                AutomaticResources(std::boxed::Box<crate::model::AutomaticResources>),
                /// The resource name of the shared DeploymentResourcePool to deploy on.
                /// Format:
                /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
                SharedResources(std::string::String),
            }
        }

        /// Configurations for PublisherModel GKE deployment
        #[cfg(feature = "model_garden_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DeployGke {
            /// Optional. GKE deployment configuration in yaml format.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub gke_yaml_configs: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "model_garden_service")]
        impl DeployGke {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gke_yaml_configs][crate::model::publisher_model::call_to_action::DeployGke::gke_yaml_configs].
            pub fn set_gke_yaml_configs<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.gke_yaml_configs = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "model_garden_service")]
        impl wkt::message::Message for DeployGke {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.DeployGke"
            }
        }
    }

    /// An enum representing the open source category of a PublisherModel.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "model_garden_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OpenSourceCategory {
        /// The open source category is unspecified, which should not be used.
        Unspecified,
        /// Used to indicate the PublisherModel is not open sourced.
        Proprietary,
        /// Used to indicate the PublisherModel is a Google-owned open source model
        /// w/ Google checkpoint.
        GoogleOwnedOssWithGoogleCheckpoint,
        /// Used to indicate the PublisherModel is a 3p-owned open source model w/
        /// Google checkpoint.
        ThirdPartyOwnedOssWithGoogleCheckpoint,
        /// Used to indicate the PublisherModel is a Google-owned pure open source
        /// model.
        GoogleOwnedOss,
        /// Used to indicate the PublisherModel is a 3p-owned pure open source model.
        ThirdPartyOwnedOss,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OpenSourceCategory::value] or
        /// [OpenSourceCategory::name].
        UnknownValue(open_source_category::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "model_garden_service")]
    pub mod open_source_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "model_garden_service")]
    impl OpenSourceCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Proprietary => std::option::Option::Some(1),
                Self::GoogleOwnedOssWithGoogleCheckpoint => std::option::Option::Some(2),
                Self::ThirdPartyOwnedOssWithGoogleCheckpoint => std::option::Option::Some(3),
                Self::GoogleOwnedOss => std::option::Option::Some(4),
                Self::ThirdPartyOwnedOss => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPEN_SOURCE_CATEGORY_UNSPECIFIED"),
                Self::Proprietary => std::option::Option::Some("PROPRIETARY"),
                Self::GoogleOwnedOssWithGoogleCheckpoint => {
                    std::option::Option::Some("GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT")
                }
                Self::ThirdPartyOwnedOssWithGoogleCheckpoint => {
                    std::option::Option::Some("THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT")
                }
                Self::GoogleOwnedOss => std::option::Option::Some("GOOGLE_OWNED_OSS"),
                Self::ThirdPartyOwnedOss => std::option::Option::Some("THIRD_PARTY_OWNED_OSS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::default::Default for OpenSourceCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::fmt::Display for OpenSourceCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::convert::From<i32> for OpenSourceCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Proprietary,
                2 => Self::GoogleOwnedOssWithGoogleCheckpoint,
                3 => Self::ThirdPartyOwnedOssWithGoogleCheckpoint,
                4 => Self::GoogleOwnedOss,
                5 => Self::ThirdPartyOwnedOss,
                _ => Self::UnknownValue(open_source_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::convert::From<&str> for OpenSourceCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPEN_SOURCE_CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "PROPRIETARY" => Self::Proprietary,
                "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" => {
                    Self::GoogleOwnedOssWithGoogleCheckpoint
                }
                "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" => {
                    Self::ThirdPartyOwnedOssWithGoogleCheckpoint
                }
                "GOOGLE_OWNED_OSS" => Self::GoogleOwnedOss,
                "THIRD_PARTY_OWNED_OSS" => Self::ThirdPartyOwnedOss,
                _ => Self::UnknownValue(open_source_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl serde::ser::Serialize for OpenSourceCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Proprietary => serializer.serialize_i32(1),
                Self::GoogleOwnedOssWithGoogleCheckpoint => serializer.serialize_i32(2),
                Self::ThirdPartyOwnedOssWithGoogleCheckpoint => serializer.serialize_i32(3),
                Self::GoogleOwnedOss => serializer.serialize_i32(4),
                Self::ThirdPartyOwnedOss => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl<'de> serde::de::Deserialize<'de> for OpenSourceCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OpenSourceCategory>::new(
                ".google.cloud.aiplatform.v1.PublisherModel.OpenSourceCategory",
            ))
        }
    }

    /// An enum representing the launch stage of a PublisherModel.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "model_garden_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LaunchStage {
        /// The model launch stage is unspecified.
        Unspecified,
        /// Used to indicate the PublisherModel is at Experimental launch stage,
        /// available to a small set of customers.
        Experimental,
        /// Used to indicate the PublisherModel is at Private Preview launch stage,
        /// only available to a small set of customers, although a larger set of
        /// customers than an Experimental launch. Previews are the first launch
        /// stage used to get feedback from customers.
        PrivatePreview,
        /// Used to indicate the PublisherModel is at Public Preview launch stage,
        /// available to all customers, although not supported for production
        /// workloads.
        PublicPreview,
        /// Used to indicate the PublisherModel is at GA launch stage, available to
        /// all customers and ready for production workload.
        Ga,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LaunchStage::value] or
        /// [LaunchStage::name].
        UnknownValue(launch_stage::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "model_garden_service")]
    pub mod launch_stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "model_garden_service")]
    impl LaunchStage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Experimental => std::option::Option::Some(1),
                Self::PrivatePreview => std::option::Option::Some(2),
                Self::PublicPreview => std::option::Option::Some(3),
                Self::Ga => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LAUNCH_STAGE_UNSPECIFIED"),
                Self::Experimental => std::option::Option::Some("EXPERIMENTAL"),
                Self::PrivatePreview => std::option::Option::Some("PRIVATE_PREVIEW"),
                Self::PublicPreview => std::option::Option::Some("PUBLIC_PREVIEW"),
                Self::Ga => std::option::Option::Some("GA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::default::Default for LaunchStage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::fmt::Display for LaunchStage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::convert::From<i32> for LaunchStage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Experimental,
                2 => Self::PrivatePreview,
                3 => Self::PublicPreview,
                4 => Self::Ga,
                _ => Self::UnknownValue(launch_stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::convert::From<&str> for LaunchStage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LAUNCH_STAGE_UNSPECIFIED" => Self::Unspecified,
                "EXPERIMENTAL" => Self::Experimental,
                "PRIVATE_PREVIEW" => Self::PrivatePreview,
                "PUBLIC_PREVIEW" => Self::PublicPreview,
                "GA" => Self::Ga,
                _ => Self::UnknownValue(launch_stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl serde::ser::Serialize for LaunchStage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Experimental => serializer.serialize_i32(1),
                Self::PrivatePreview => serializer.serialize_i32(2),
                Self::PublicPreview => serializer.serialize_i32(3),
                Self::Ga => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl<'de> serde::de::Deserialize<'de> for LaunchStage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LaunchStage>::new(
                ".google.cloud.aiplatform.v1.PublisherModel.LaunchStage",
            ))
        }
    }

    /// An enum representing the state of the PublicModelVersion.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "model_garden_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionState {
        /// The version state is unspecified.
        Unspecified,
        /// Used to indicate the version is stable.
        Stable,
        /// Used to indicate the version is unstable.
        Unstable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionState::value] or
        /// [VersionState::name].
        UnknownValue(version_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "model_garden_service")]
    pub mod version_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "model_garden_service")]
    impl VersionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Stable => std::option::Option::Some(1),
                Self::Unstable => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_STATE_UNSPECIFIED"),
                Self::Stable => std::option::Option::Some("VERSION_STATE_STABLE"),
                Self::Unstable => std::option::Option::Some("VERSION_STATE_UNSTABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::default::Default for VersionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::fmt::Display for VersionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::convert::From<i32> for VersionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Stable,
                2 => Self::Unstable,
                _ => Self::UnknownValue(version_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl std::convert::From<&str> for VersionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_STATE_UNSPECIFIED" => Self::Unspecified,
                "VERSION_STATE_STABLE" => Self::Stable,
                "VERSION_STATE_UNSTABLE" => Self::Unstable,
                _ => Self::UnknownValue(version_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl serde::ser::Serialize for VersionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Stable => serializer.serialize_i32(1),
                Self::Unstable => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "model_garden_service")]
    impl<'de> serde::de::Deserialize<'de> for VersionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionState>::new(
                ".google.cloud.aiplatform.v1.PublisherModel.VersionState",
            ))
        }
    }
}

/// ReasoningEngine configurations
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReasoningEngineSpec {
    /// Optional. User provided package spec of the ReasoningEngine.
    /// Ignored when users directly specify a deployment image through
    /// `deployment_spec.first_party_image_override`, but keeping the
    /// field_behavior to avoid introducing breaking changes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub package_spec: std::option::Option<crate::model::reasoning_engine_spec::PackageSpec>,

    /// Optional. The specification of a Reasoning Engine deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_spec: std::option::Option<crate::model::reasoning_engine_spec::DeploymentSpec>,

    /// Optional. Declarations for object class methods in OpenAPI specification
    /// format.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub class_methods: std::vec::Vec<wkt::Struct>,

    /// Optional. The OSS agent framework used to develop the agent.
    /// Currently supported values: "langchain", "langgraph", "ag2", "custom".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub agent_framework: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl ReasoningEngineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_spec][crate::model::ReasoningEngineSpec::package_spec].
    pub fn set_package_spec<
        T: std::convert::Into<std::option::Option<crate::model::reasoning_engine_spec::PackageSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.package_spec = v.into();
        self
    }

    /// Sets the value of [deployment_spec][crate::model::ReasoningEngineSpec::deployment_spec].
    pub fn set_deployment_spec<
        T: std::convert::Into<
                std::option::Option<crate::model::reasoning_engine_spec::DeploymentSpec>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_spec = v.into();
        self
    }

    /// Sets the value of [agent_framework][crate::model::ReasoningEngineSpec::agent_framework].
    pub fn set_agent_framework<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_framework = v.into();
        self
    }

    /// Sets the value of [class_methods][crate::model::ReasoningEngineSpec::class_methods].
    pub fn set_class_methods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Struct>,
    {
        use std::iter::Iterator;
        self.class_methods = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for ReasoningEngineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec"
    }
}

/// Defines additional types related to [ReasoningEngineSpec].
#[cfg(feature = "reasoning_engine_service")]
pub mod reasoning_engine_spec {
    #[allow(unused_imports)]
    use super::*;

    /// User provided package spec like pickled object and package requirements.
    #[cfg(feature = "reasoning_engine_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PackageSpec {
        /// Optional. The Cloud Storage URI of the pickled python object.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pickle_object_gcs_uri: std::string::String,

        /// Optional. The Cloud Storage URI of the dependency files in tar.gz format.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dependency_files_gcs_uri: std::string::String,

        /// Optional. The Cloud Storage URI of the `requirements.txt` file
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub requirements_gcs_uri: std::string::String,

        /// Optional. The Python version. Currently support 3.8, 3.9, 3.10, 3.11.
        /// If not specified, default value is 3.10.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub python_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "reasoning_engine_service")]
    impl PackageSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pickle_object_gcs_uri][crate::model::reasoning_engine_spec::PackageSpec::pickle_object_gcs_uri].
        pub fn set_pickle_object_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pickle_object_gcs_uri = v.into();
            self
        }

        /// Sets the value of [dependency_files_gcs_uri][crate::model::reasoning_engine_spec::PackageSpec::dependency_files_gcs_uri].
        pub fn set_dependency_files_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dependency_files_gcs_uri = v.into();
            self
        }

        /// Sets the value of [requirements_gcs_uri][crate::model::reasoning_engine_spec::PackageSpec::requirements_gcs_uri].
        pub fn set_requirements_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.requirements_gcs_uri = v.into();
            self
        }

        /// Sets the value of [python_version][crate::model::reasoning_engine_spec::PackageSpec::python_version].
        pub fn set_python_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.python_version = v.into();
            self
        }
    }

    #[cfg(feature = "reasoning_engine_service")]
    impl wkt::message::Message for PackageSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec.PackageSpec"
        }
    }

    /// The specification of a Reasoning Engine deployment.
    #[cfg(feature = "reasoning_engine_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DeploymentSpec {
        /// Optional. Environment variables to be set with the Reasoning Engine
        /// deployment. The environment variables can be updated through the
        /// UpdateReasoningEngine API.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub env: std::vec::Vec<crate::model::EnvVar>,

        /// Optional. Environment variables where the value is a secret in Cloud
        /// Secret Manager.
        /// To use this feature, add 'Secret Manager Secret Accessor' role
        /// (roles/secretmanager.secretAccessor) to AI Platform Reasoning Engine
        /// Service Agent.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub secret_env: std::vec::Vec<crate::model::SecretEnvVar>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "reasoning_engine_service")]
    impl DeploymentSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [env][crate::model::reasoning_engine_spec::DeploymentSpec::env].
        pub fn set_env<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::EnvVar>,
        {
            use std::iter::Iterator;
            self.env = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [secret_env][crate::model::reasoning_engine_spec::DeploymentSpec::secret_env].
        pub fn set_secret_env<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::SecretEnvVar>,
        {
            use std::iter::Iterator;
            self.secret_env = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "reasoning_engine_service")]
    impl wkt::message::Message for DeploymentSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec.DeploymentSpec"
        }
    }
}

/// ReasoningEngine provides a customizable runtime for models to determine
/// which actions to take and in which order.
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReasoningEngine {
    /// Identifier. The resource name of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The description of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Configurations of the ReasoningEngine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::ReasoningEngineSpec>,

    /// Output only. Timestamp when this ReasoningEngine was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this ReasoningEngine was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl ReasoningEngine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReasoningEngine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ReasoningEngine::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ReasoningEngine::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::ReasoningEngine::spec].
    pub fn set_spec<
        T: std::convert::Into<std::option::Option<crate::model::ReasoningEngineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ReasoningEngine::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ReasoningEngine::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ReasoningEngine::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for ReasoningEngine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngine"
    }
}

/// Request message for [ReasoningEngineExecutionService.Query][].
#[cfg(feature = "reasoning_engine_execution_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource to use.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Input content provided by users in JSON object format. Examples
    /// include text query, function calling parameters, media bytes, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input: std::option::Option<wkt::Struct>,

    /// Optional. Class method to be used for the query.
    /// It is optional and defaults to "query" if unspecified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub class_method: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_execution_service")]
impl QueryReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::QueryReasoningEngineRequest::input].
    pub fn set_input<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// Sets the value of [class_method][crate::model::QueryReasoningEngineRequest::class_method].
    pub fn set_class_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.class_method = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_execution_service")]
impl wkt::message::Message for QueryReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryReasoningEngineRequest"
    }
}

/// Response message for [ReasoningEngineExecutionService.Query][]
#[cfg(feature = "reasoning_engine_execution_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryReasoningEngineResponse {
    /// Response provided by users in JSON object format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output: std::option::Option<wkt::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_execution_service")]
impl QueryReasoningEngineResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::QueryReasoningEngineResponse::output].
    pub fn set_output<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_execution_service")]
impl wkt::message::Message for QueryReasoningEngineResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryReasoningEngineResponse"
    }
}

/// Request message for [ReasoningEngineExecutionService.StreamQuery][].
#[cfg(feature = "reasoning_engine_execution_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamQueryReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource to use.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Input content provided by users in JSON object format. Examples
    /// include text query, function calling parameters, media bytes, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input: std::option::Option<wkt::Struct>,

    /// Optional. Class method to be used for the stream query.
    /// It is optional and defaults to "stream_query" if unspecified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub class_method: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_execution_service")]
impl StreamQueryReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamQueryReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::StreamQueryReasoningEngineRequest::input].
    pub fn set_input<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// Sets the value of [class_method][crate::model::StreamQueryReasoningEngineRequest::class_method].
    pub fn set_class_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.class_method = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_execution_service")]
impl wkt::message::Message for StreamQueryReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamQueryReasoningEngineRequest"
    }
}

/// Request message for
/// [ReasoningEngineService.CreateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine]: crate::client::ReasoningEngineService::create_reasoning_engine
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReasoningEngineRequest {
    /// Required. The resource name of the Location to create the ReasoningEngine
    /// in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ReasoningEngine to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reasoning_engine: std::option::Option<crate::model::ReasoningEngine>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl CreateReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReasoningEngineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reasoning_engine][crate::model::CreateReasoningEngineRequest::reasoning_engine].
    pub fn set_reasoning_engine<
        T: std::convert::Into<std::option::Option<crate::model::ReasoningEngine>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reasoning_engine = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for CreateReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateReasoningEngineRequest"
    }
}

/// Details of
/// [ReasoningEngineService.CreateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine]
/// operation.
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine]: crate::client::ReasoningEngineService::create_reasoning_engine
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReasoningEngineOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl CreateReasoningEngineOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateReasoningEngineOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for CreateReasoningEngineOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateReasoningEngineOperationMetadata"
    }
}

/// Request message for
/// [ReasoningEngineService.GetReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.GetReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.GetReasoningEngine]: crate::client::ReasoningEngineService::get_reasoning_engine
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl GetReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for GetReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetReasoningEngineRequest"
    }
}

/// Request message for
/// [ReasoningEngineService.UpdateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine]: crate::client::ReasoningEngineService::update_reasoning_engine
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateReasoningEngineRequest {
    /// Required. The ReasoningEngine which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reasoning_engine: std::option::Option<crate::model::ReasoningEngine>,

    /// Optional. Mask specifying which fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl UpdateReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reasoning_engine][crate::model::UpdateReasoningEngineRequest::reasoning_engine].
    pub fn set_reasoning_engine<
        T: std::convert::Into<std::option::Option<crate::model::ReasoningEngine>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reasoning_engine = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateReasoningEngineRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for UpdateReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateReasoningEngineRequest"
    }
}

/// Details of
/// [ReasoningEngineService.UpdateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine]
/// operation.
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine]: crate::client::ReasoningEngineService::update_reasoning_engine
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateReasoningEngineOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl UpdateReasoningEngineOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateReasoningEngineOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for UpdateReasoningEngineOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateReasoningEngineOperationMetadata"
    }
}

/// Request message for
/// [ReasoningEngineService.ListReasoningEngines][google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines]: crate::client::ReasoningEngineService::list_reasoning_engines
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReasoningEnginesRequest {
    /// Required. The resource name of the Location to list the ReasoningEngines
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list filter.
    /// More detail in [AIP-160](https://google.aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl ListReasoningEnginesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReasoningEnginesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReasoningEnginesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReasoningEnginesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReasoningEnginesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for ListReasoningEnginesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListReasoningEnginesRequest"
    }
}

/// Response message for
/// [ReasoningEngineService.ListReasoningEngines][google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines]
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines]: crate::client::ReasoningEngineService::list_reasoning_engines
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReasoningEnginesResponse {
    /// List of ReasoningEngines in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reasoning_engines: std::vec::Vec<crate::model::ReasoningEngine>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListReasoningEnginesRequest.page_token][google.cloud.aiplatform.v1.ListReasoningEnginesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListReasoningEnginesRequest.page_token]: crate::model::ListReasoningEnginesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl ListReasoningEnginesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListReasoningEnginesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [reasoning_engines][crate::model::ListReasoningEnginesResponse::reasoning_engines].
    pub fn set_reasoning_engines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReasoningEngine>,
    {
        use std::iter::Iterator;
        self.reasoning_engines = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for ListReasoningEnginesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListReasoningEnginesResponse"
    }
}

#[cfg(feature = "reasoning_engine_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReasoningEnginesResponse {
    type PageItem = crate::model::ReasoningEngine;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reasoning_engines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ReasoningEngineService.DeleteReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.DeleteReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.DeleteReasoningEngine]: crate::client::ReasoningEngineService::delete_reasoning_engine
#[cfg(feature = "reasoning_engine_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, child resources of this reasoning engine will
    /// also be deleted. Otherwise, the request will fail with FAILED_PRECONDITION
    /// error when the reasoning engine has undeleted child resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "reasoning_engine_service")]
impl DeleteReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteReasoningEngineRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "reasoning_engine_service")]
impl wkt::message::Message for DeleteReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteReasoningEngineRequest"
    }
}

/// A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a
/// DeployedModel) to draw its Compute Engine resources from a Shared
/// Reservation, or exclusively from on-demand capacity.
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Required. Specifies the reservation affinity type.
    pub reservation_affinity_type: crate::model::reservation_affinity::Type,

    /// Optional. Corresponds to the label key of a reservation resource. To target
    /// a SPECIFIC_RESERVATION by name, use
    /// `compute.googleapis.com/reservation-name` as the key and specify the name
    /// of your reservation as its value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Optional. Corresponds to the label values of a reservation resource. This
    /// must be the full resource name of the reservation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reservation_affinity_type][crate::model::ReservationAffinity::reservation_affinity_type].
    pub fn set_reservation_affinity_type<
        T: std::convert::Into<crate::model::reservation_affinity::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reservation_affinity_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReservationAffinity"
    }
}

/// Defines additional types related to [ReservationAffinity].
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Identifies a type of reservation affinity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified,
        /// Do not consume from any reserved capacity, only use on-demand.
        NoReservation,
        /// Consume any reservation available, falling back to on-demand.
        AnyReservation,
        /// Consume from a specific reservation. When chosen, the reservation
        /// must be identified via the `key` and `values` fields.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "deployment_resource_pool_service",
        feature = "endpoint_service",
        feature = "index_endpoint_service",
        feature = "job_service",
        feature = "model_garden_service",
        feature = "notebook_service",
        feature = "persistent_resource_service",
        feature = "schedule_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.aiplatform.v1.ReservationAffinity.Type",
            ))
        }
    }
}

/// A SavedQuery is a view of the dataset. It references a subset of annotations
/// by problem type and filters.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SavedQuery {
    /// Output only. Resource name of the SavedQuery.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the SavedQuery.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Some additional information about the SavedQuery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this SavedQuery was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when SavedQuery was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Filters on the Annotations in the dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_filter: std::string::String,

    /// Required. Problem type of the SavedQuery.
    /// Allowed values:
    ///
    /// * IMAGE_CLASSIFICATION_SINGLE_LABEL
    /// * IMAGE_CLASSIFICATION_MULTI_LABEL
    /// * IMAGE_BOUNDING_POLY
    /// * IMAGE_BOUNDING_BOX
    /// * TEXT_CLASSIFICATION_SINGLE_LABEL
    /// * TEXT_CLASSIFICATION_MULTI_LABEL
    /// * TEXT_EXTRACTION
    /// * TEXT_SENTIMENT
    /// * VIDEO_CLASSIFICATION
    /// * VIDEO_OBJECT_TRACKING
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub problem_type: std::string::String,

    /// Output only. Number of AnnotationSpecs in the context of the SavedQuery.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub annotation_spec_count: i32,

    /// Used to perform a consistent read-modify-write update. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. If the Annotations belonging to the SavedQuery can be used for
    /// AutoML training.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub support_automl_training: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl SavedQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SavedQuery::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SavedQuery::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SavedQuery::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SavedQuery::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SavedQuery::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [annotation_filter][crate::model::SavedQuery::annotation_filter].
    pub fn set_annotation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_filter = v.into();
        self
    }

    /// Sets the value of [problem_type][crate::model::SavedQuery::problem_type].
    pub fn set_problem_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.problem_type = v.into();
        self
    }

    /// Sets the value of [annotation_spec_count][crate::model::SavedQuery::annotation_spec_count].
    pub fn set_annotation_spec_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.annotation_spec_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::SavedQuery::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [support_automl_training][crate::model::SavedQuery::support_automl_training].
    pub fn set_support_automl_training<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.support_automl_training = v.into();
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for SavedQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SavedQuery"
    }
}

/// An instance of a Schedule periodically schedules runs to make API calls based
/// on user specified time specification and API request type.
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schedule {
    /// Immutable. The resource name of the Schedule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of the Schedule.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Timestamp after which the first run can be scheduled.
    /// Default to Schedule create time if not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Timestamp after which no new runs can be scheduled.
    /// If specified, The schedule will be completed when either
    /// end_time is reached or when scheduled_run_count >= max_run_count.
    /// If not specified, new runs will keep getting scheduled until this Schedule
    /// is paused or deleted. Already scheduled runs will be allowed to complete.
    /// Unset if not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Maximum run count of the schedule.
    /// If specified, The schedule will be completed when either
    /// started_run_count >= max_run_count or when end_time is reached.
    /// If not specified, new runs will keep getting scheduled until this Schedule
    /// is paused or deleted. Already scheduled runs will be allowed to complete.
    /// Unset if not specified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_run_count: i64,

    /// Output only. The number of runs started by this schedule.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub started_run_count: i64,

    /// Output only. The state of this Schedule.
    pub state: crate::model::schedule::State,

    /// Output only. Timestamp when this Schedule was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule should schedule the next run.
    /// Having a next_run_time in the past means the runs are being started
    /// behind schedule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule was last paused.
    /// Unset if never paused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_pause_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule was last resumed.
    /// Unset if never resumed from pause.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_resume_time: std::option::Option<wkt::Timestamp>,

    /// Required. Maximum number of runs that can be started concurrently for this
    /// Schedule. This is the limit for starting the scheduled requests and not the
    /// execution of the operations/jobs created by the requests (if applicable).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_concurrent_run_count: i64,

    /// Optional. Whether new scheduled runs can be queued when max_concurrent_runs
    /// limit is reached. If set to true, new runs will be queued instead of
    /// skipped. Default to false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_queueing: bool,

    /// Output only. Whether to backfill missed runs when the schedule is resumed
    /// from PAUSED state. If set to true, all missed runs will be scheduled. New
    /// runs will be scheduled after the backfill is complete. Default to false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub catch_up: bool,

    /// Output only. Response of the last scheduled run.
    /// This is the response for starting the scheduled requests and not the
    /// execution of the operations/jobs created by the requests (if applicable).
    /// Unset if no run has been scheduled yet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_scheduled_run_response: std::option::Option<crate::model::schedule::RunResponse>,

    /// Required.
    /// The time specification to launch scheduled runs.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub time_specification: std::option::Option<crate::model::schedule::TimeSpecification>,

    /// Required.
    /// The API request template to launch the scheduled runs.
    /// User-specified ID is not supported in the request template.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::schedule::Request>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Schedule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Schedule::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Schedule::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Schedule::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [max_run_count][crate::model::Schedule::max_run_count].
    pub fn set_max_run_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_run_count = v.into();
        self
    }

    /// Sets the value of [started_run_count][crate::model::Schedule::started_run_count].
    pub fn set_started_run_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.started_run_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Schedule::state].
    pub fn set_state<T: std::convert::Into<crate::model::schedule::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Schedule::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Schedule::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [next_run_time][crate::model::Schedule::next_run_time].
    pub fn set_next_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_run_time = v.into();
        self
    }

    /// Sets the value of [last_pause_time][crate::model::Schedule::last_pause_time].
    pub fn set_last_pause_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_pause_time = v.into();
        self
    }

    /// Sets the value of [last_resume_time][crate::model::Schedule::last_resume_time].
    pub fn set_last_resume_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_resume_time = v.into();
        self
    }

    /// Sets the value of [max_concurrent_run_count][crate::model::Schedule::max_concurrent_run_count].
    pub fn set_max_concurrent_run_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_concurrent_run_count = v.into();
        self
    }

    /// Sets the value of [allow_queueing][crate::model::Schedule::allow_queueing].
    pub fn set_allow_queueing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_queueing = v.into();
        self
    }

    /// Sets the value of [catch_up][crate::model::Schedule::catch_up].
    pub fn set_catch_up<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.catch_up = v.into();
        self
    }

    /// Sets the value of [last_scheduled_run_response][crate::model::Schedule::last_scheduled_run_response].
    pub fn set_last_scheduled_run_response<
        T: std::convert::Into<std::option::Option<crate::model::schedule::RunResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_scheduled_run_response = v.into();
        self
    }

    /// Sets the value of [time_specification][crate::model::Schedule::time_specification].
    ///
    /// Note that all the setters affecting `time_specification` are mutually
    /// exclusive.
    pub fn set_time_specification<
        T: std::convert::Into<std::option::Option<crate::model::schedule::TimeSpecification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_specification = v.into();
        self
    }

    /// The value of [time_specification][crate::model::Schedule::time_specification]
    /// if it holds a `Cron`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cron(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.time_specification.as_ref().and_then(|v| match v {
            crate::model::schedule::TimeSpecification::Cron(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time_specification][crate::model::Schedule::time_specification]
    /// to hold a `Cron`.
    ///
    /// Note that all the setters affecting `time_specification` are
    /// mutually exclusive.
    pub fn set_cron<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_specification =
            std::option::Option::Some(crate::model::schedule::TimeSpecification::Cron(v.into()));
        self
    }

    /// Sets the value of [request][crate::model::Schedule::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::schedule::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::Schedule::request]
    /// if it holds a `CreatePipelineJobRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_pipeline_job_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreatePipelineJobRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::schedule::Request::CreatePipelineJobRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::Schedule::request]
    /// if it holds a `CreateNotebookExecutionJobRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_notebook_execution_job_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateNotebookExecutionJobRequest>>
    {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::schedule::Request::CreateNotebookExecutionJobRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::Schedule::request]
    /// to hold a `CreatePipelineJobRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_pipeline_job_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreatePipelineJobRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::schedule::Request::CreatePipelineJobRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::Schedule::request]
    /// to hold a `CreateNotebookExecutionJobRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_notebook_execution_job_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateNotebookExecutionJobRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::schedule::Request::CreateNotebookExecutionJobRequest(v.into()),
        );
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Schedule"
    }
}

/// Defines additional types related to [Schedule].
#[cfg(feature = "schedule_service")]
pub mod schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Status of a scheduled run.
    #[cfg(feature = "schedule_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RunResponse {
        /// The scheduled run time based on the user-specified schedule.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub scheduled_run_time: std::option::Option<wkt::Timestamp>,

        /// The response of the scheduled run.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub run_response: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "schedule_service")]
    impl RunResponse {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scheduled_run_time][crate::model::schedule::RunResponse::scheduled_run_time].
        pub fn set_scheduled_run_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scheduled_run_time = v.into();
            self
        }

        /// Sets the value of [run_response][crate::model::schedule::RunResponse::run_response].
        pub fn set_run_response<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.run_response = v.into();
            self
        }
    }

    #[cfg(feature = "schedule_service")]
    impl wkt::message::Message for RunResponse {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Schedule.RunResponse"
        }
    }

    /// Possible state of the schedule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "schedule_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// The Schedule is active. Runs are being scheduled on the user-specified
        /// timespec.
        Active,
        /// The schedule is paused. No new runs will be created until the schedule
        /// is resumed. Already started runs will be allowed to complete.
        Paused,
        /// The Schedule is completed. No new runs will be scheduled. Already started
        /// runs will be allowed to complete. Schedules in completed state cannot be
        /// paused or resumed.
        Completed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "schedule_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "schedule_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Completed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "schedule_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "schedule_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "schedule_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Paused,
                3 => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "schedule_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PAUSED" => Self::Paused,
                "COMPLETED" => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "schedule_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Completed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "schedule_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.Schedule.State",
            ))
        }
    }

    /// Required.
    /// The time specification to launch scheduled runs.
    #[cfg(feature = "schedule_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TimeSpecification {
        /// Cron schedule (<https://en.wikipedia.org/wiki/Cron>) to launch scheduled
        /// runs. To explicitly set a timezone to the cron tab, apply a prefix in the
        /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
        /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
        /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
        /// "TZ=America/New_York 1 * * * *".
        Cron(std::string::String),
    }

    /// Required.
    /// The API request template to launch the scheduled runs.
    /// User-specified ID is not supported in the request template.
    #[cfg(feature = "schedule_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// Request for
        /// [PipelineService.CreatePipelineJob][google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob].
        /// CreatePipelineJobRequest.parent field is required (format:
        /// projects/{project}/locations/{location}).
        ///
        /// [google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob]: crate::client::PipelineService::create_pipeline_job
        CreatePipelineJobRequest(std::boxed::Box<crate::model::CreatePipelineJobRequest>),
        /// Request for
        /// [NotebookService.CreateNotebookExecutionJob][google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob].
        ///
        /// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob]: crate::client::NotebookService::create_notebook_execution_job
        CreateNotebookExecutionJobRequest(
            std::boxed::Box<crate::model::CreateNotebookExecutionJobRequest>,
        ),
    }
}

/// Request message for
/// [ScheduleService.CreateSchedule][google.cloud.aiplatform.v1.ScheduleService.CreateSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.CreateSchedule]: crate::client::ScheduleService::create_schedule
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateScheduleRequest {
    /// Required. The resource name of the Location to create the Schedule in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Schedule to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::Schedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl CreateScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateScheduleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::CreateScheduleRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<std::option::Option<crate::model::Schedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for CreateScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.GetSchedule][google.cloud.aiplatform.v1.ScheduleService.GetSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.GetSchedule]: crate::client::ScheduleService::get_schedule
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetScheduleRequest {
    /// Required. The name of the Schedule resource.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl GetScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for GetScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.ListSchedules][google.cloud.aiplatform.v1.ScheduleService.ListSchedules].
///
/// [google.cloud.aiplatform.v1.ScheduleService.ListSchedules]: crate::client::ScheduleService::list_schedules
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSchedulesRequest {
    /// Required. The resource name of the Location to list the Schedules from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the Schedules that match the filter expression. The following
    /// fields are supported:
    ///
    /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state`: Supports `=` and `!=` comparisons.
    /// * `request`: Supports existence of the <request_type> check.
    ///   (e.g. `create_pipeline_job_request:*` --> Schedule has
    ///   create_pipeline_job_request).
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, `>=` comparisons and `:*`
    ///   existence check. Values must be in RFC 3339 format.
    /// * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
    ///   comparisons. Values must be in RFC 3339 format.
    ///
    /// Filter expressions can be combined together using logical operators
    /// (`NOT`, `AND` & `OR`).
    /// The syntax to define filter expression is based on
    /// <https://google.aip.dev/160>.
    ///
    /// Examples:
    ///
    /// * `state="ACTIVE" AND display_name:"my_schedule_*"`
    /// * `NOT display_name="my_schedule"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `end_time>"2021-05-18T00:00:00Z" OR NOT end_time:*`
    /// * `create_pipeline_job_request:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    /// Default to 100 if not specified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListSchedulesResponse.next_page_token][google.cloud.aiplatform.v1.ListSchedulesResponse.next_page_token]
    /// of the previous
    /// [ScheduleService.ListSchedules][google.cloud.aiplatform.v1.ScheduleService.ListSchedules]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListSchedulesResponse.next_page_token]: crate::model::ListSchedulesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ScheduleService.ListSchedules]: crate::client::ScheduleService::list_schedules
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by. The default sort order is in
    /// ascending order. Use "desc" after a field name for descending. You can have
    /// multiple order_by fields provided.
    ///
    /// For example, using "create_time desc, end_time" will order results by
    /// create time in descending order, and if there are multiple schedules having
    /// the same create time, order them by the end time in ascending order.
    ///
    /// If order_by is not specified, it will order by default with create_time in
    /// descending order.
    ///
    /// Supported fields:
    ///
    /// * `create_time`
    /// * `start_time`
    /// * `end_time`
    /// * `next_run_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl ListSchedulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchedulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSchedulesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchedulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchedulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSchedulesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for ListSchedulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSchedulesRequest"
    }
}

/// Response message for
/// [ScheduleService.ListSchedules][google.cloud.aiplatform.v1.ScheduleService.ListSchedules]
///
/// [google.cloud.aiplatform.v1.ScheduleService.ListSchedules]: crate::client::ScheduleService::list_schedules
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSchedulesResponse {
    /// List of Schedules in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schedules: std::vec::Vec<crate::model::Schedule>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListSchedulesRequest.page_token][google.cloud.aiplatform.v1.ListSchedulesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListSchedulesRequest.page_token]: crate::model::ListSchedulesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl ListSchedulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSchedulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [schedules][crate::model::ListSchedulesResponse::schedules].
    pub fn set_schedules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schedule>,
    {
        use std::iter::Iterator;
        self.schedules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for ListSchedulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSchedulesResponse"
    }
}

#[cfg(feature = "schedule_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSchedulesResponse {
    type PageItem = crate::model::Schedule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schedules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ScheduleService.DeleteSchedule][google.cloud.aiplatform.v1.ScheduleService.DeleteSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.DeleteSchedule]: crate::client::ScheduleService::delete_schedule
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteScheduleRequest {
    /// Required. The name of the Schedule resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl DeleteScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for DeleteScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.PauseSchedule][google.cloud.aiplatform.v1.ScheduleService.PauseSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.PauseSchedule]: crate::client::ScheduleService::pause_schedule
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseScheduleRequest {
    /// Required. The name of the Schedule resource to be paused.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl PauseScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for PauseScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PauseScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.ResumeSchedule][google.cloud.aiplatform.v1.ScheduleService.ResumeSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.ResumeSchedule]: crate::client::ScheduleService::resume_schedule
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeScheduleRequest {
    /// Required. The name of the Schedule resource to be resumed.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Whether to backfill missed runs when the schedule is resumed from
    /// PAUSED state. If set to true, all missed runs will be scheduled. New runs
    /// will be scheduled after the backfill is complete. This will also update
    /// [Schedule.catch_up][google.cloud.aiplatform.v1.Schedule.catch_up] field.
    /// Default to false.
    ///
    /// [google.cloud.aiplatform.v1.Schedule.catch_up]: crate::model::Schedule::catch_up
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub catch_up: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl ResumeScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [catch_up][crate::model::ResumeScheduleRequest::catch_up].
    pub fn set_catch_up<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.catch_up = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for ResumeScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResumeScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.UpdateSchedule][google.cloud.aiplatform.v1.ScheduleService.UpdateSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.UpdateSchedule]: crate::client::ScheduleService::update_schedule
#[cfg(feature = "schedule_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateScheduleRequest {
    /// Required. The Schedule which replaces the resource on the server.
    /// The following restrictions will be applied:
    ///
    /// * The scheduled request type cannot be changed.
    /// * The non-empty fields cannot be unset.
    /// * The output_only fields will be ignored if specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::Schedule>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "schedule_service")]
impl UpdateScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule][crate::model::UpdateScheduleRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<std::option::Option<crate::model::Schedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateScheduleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "schedule_service")]
impl wkt::message::Message for UpdateScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateScheduleRequest"
    }
}

/// PSC config that is used to automatically create forwarding rule via
/// ServiceConnectionMap.
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PSCAutomationConfig {
    /// Required. Project id used to create forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The full name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
    /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
    /// `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in '12345', and {network} is
    /// network name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl PSCAutomationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PSCAutomationConfig::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PSCAutomationConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for PSCAutomationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PSCAutomationConfig"
    }
}

/// Represents configuration for private service connect.
#[cfg(any(
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "index_endpoint_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateServiceConnectConfig {
    /// Required. If true, expose the IndexEndpoint via private service connect.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_private_service_connect: bool,

    /// A list of Projects from which the forwarding rule will target the service
    /// attachment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub project_allowlist: std::vec::Vec<std::string::String>,

    /// Output only. The name of the generated service attachment resource.
    /// This is only populated if the endpoint is deployed with
    /// PrivateServiceConnect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "index_endpoint_service",
))]
impl PrivateServiceConnectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_service_connect][crate::model::PrivateServiceConnectConfig::enable_private_service_connect].
    pub fn set_enable_private_service_connect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_service_connect = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PrivateServiceConnectConfig::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [project_allowlist][crate::model::PrivateServiceConnectConfig::project_allowlist].
    pub fn set_project_allowlist<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.project_allowlist = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "endpoint_service",
    feature = "feature_online_store_admin_service",
    feature = "index_endpoint_service",
))]
impl wkt::message::Message for PrivateServiceConnectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PrivateServiceConnectConfig"
    }
}

/// PscAutomatedEndpoints defines the output of the forwarding rule
/// automatically created by each PscAutomationConfig.
#[cfg(feature = "index_endpoint_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscAutomatedEndpoints {
    /// Corresponding project_id in pscAutomationConfigs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Corresponding network in pscAutomationConfigs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Ip Address created by the automated forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub match_address: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "index_endpoint_service")]
impl PscAutomatedEndpoints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PscAutomatedEndpoints::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscAutomatedEndpoints::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [match_address][crate::model::PscAutomatedEndpoints::match_address].
    pub fn set_match_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.match_address = v.into();
        self
    }
}

#[cfg(feature = "index_endpoint_service")]
impl wkt::message::Message for PscAutomatedEndpoints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PscAutomatedEndpoints"
    }
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs. It includes a group of specialist managers and workers.
/// Managers are responsible for managing the workers in this pool as well as
/// customers' data labeling jobs associated with this pool. Customers create
/// specialist pool as well as start data labeling jobs on Cloud, managers and
/// workers handle the jobs using CrowdCompute console.
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpecialistPool {
    /// Required. The resource name of the SpecialistPool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the SpecialistPool.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    /// This field should be unique on project-level.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The number of managers in this SpecialistPool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub specialist_managers_count: i32,

    /// The email addresses of the managers in the SpecialistPool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_manager_emails: std::vec::Vec<std::string::String>,

    /// Output only. The resource name of the pending data labeling jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pending_data_labeling_jobs: std::vec::Vec<std::string::String>,

    /// The email addresses of workers in the SpecialistPool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_worker_emails: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl SpecialistPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SpecialistPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SpecialistPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [specialist_managers_count][crate::model::SpecialistPool::specialist_managers_count].
    pub fn set_specialist_managers_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.specialist_managers_count = v.into();
        self
    }

    /// Sets the value of [specialist_manager_emails][crate::model::SpecialistPool::specialist_manager_emails].
    pub fn set_specialist_manager_emails<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specialist_manager_emails = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pending_data_labeling_jobs][crate::model::SpecialistPool::pending_data_labeling_jobs].
    pub fn set_pending_data_labeling_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pending_data_labeling_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [specialist_worker_emails][crate::model::SpecialistPool::specialist_worker_emails].
    pub fn set_specialist_worker_emails<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specialist_worker_emails = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for SpecialistPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SpecialistPool"
    }
}

/// Request message for
/// [SpecialistPoolService.CreateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool]: crate::client::SpecialistPoolService::create_specialist_pool
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSpecialistPoolRequest {
    /// Required. The parent Project name for the new SpecialistPool.
    /// The form is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The SpecialistPool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub specialist_pool: std::option::Option<crate::model::SpecialistPool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl CreateSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSpecialistPoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [specialist_pool][crate::model::CreateSpecialistPoolRequest::specialist_pool].
    pub fn set_specialist_pool<
        T: std::convert::Into<std::option::Option<crate::model::SpecialistPool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.specialist_pool = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for CreateSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateSpecialistPoolRequest"
    }
}

/// Runtime operation information for
/// [SpecialistPoolService.CreateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool]: crate::client::SpecialistPoolService::create_specialist_pool
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSpecialistPoolOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl CreateSpecialistPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateSpecialistPoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for CreateSpecialistPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateSpecialistPoolOperationMetadata"
    }
}

/// Request message for
/// [SpecialistPoolService.GetSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.GetSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.GetSpecialistPool]: crate::client::SpecialistPoolService::get_specialist_pool
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSpecialistPoolRequest {
    /// Required. The name of the SpecialistPool resource.
    /// The form is
    /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl GetSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSpecialistPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for GetSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetSpecialistPoolRequest"
    }
}

/// Request message for
/// [SpecialistPoolService.ListSpecialistPools][google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]: crate::client::SpecialistPoolService::list_specialist_pools
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSpecialistPoolsRequest {
    /// Required. The name of the SpecialistPool's parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained by
    /// [ListSpecialistPoolsResponse.next_page_token][google.cloud.aiplatform.v1.ListSpecialistPoolsResponse.next_page_token]
    /// of the previous
    /// [SpecialistPoolService.ListSpecialistPools][google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]
    /// call. Return first page if empty.
    ///
    /// [google.cloud.aiplatform.v1.ListSpecialistPoolsResponse.next_page_token]: crate::model::ListSpecialistPoolsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]: crate::client::SpecialistPoolService::list_specialist_pools
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read. FieldMask represents a set of
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl ListSpecialistPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSpecialistPoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSpecialistPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSpecialistPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListSpecialistPoolsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for ListSpecialistPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSpecialistPoolsRequest"
    }
}

/// Response message for
/// [SpecialistPoolService.ListSpecialistPools][google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]: crate::client::SpecialistPoolService::list_specialist_pools
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSpecialistPoolsResponse {
    /// A list of SpecialistPools that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_pools: std::vec::Vec<crate::model::SpecialistPool>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl ListSpecialistPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSpecialistPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [specialist_pools][crate::model::ListSpecialistPoolsResponse::specialist_pools].
    pub fn set_specialist_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpecialistPool>,
    {
        use std::iter::Iterator;
        self.specialist_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for ListSpecialistPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSpecialistPoolsResponse"
    }
}

#[cfg(feature = "specialist_pool_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSpecialistPoolsResponse {
    type PageItem = crate::model::SpecialistPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.specialist_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [SpecialistPoolService.DeleteSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.DeleteSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.DeleteSpecialistPool]: crate::client::SpecialistPoolService::delete_specialist_pool
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSpecialistPoolRequest {
    /// Required. The resource name of the SpecialistPool to delete. Format:
    /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any specialist managers in this SpecialistPool will also be
    /// deleted. (Otherwise, the request will only work if the SpecialistPool has
    /// no specialist managers.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl DeleteSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSpecialistPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteSpecialistPoolRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for DeleteSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteSpecialistPoolRequest"
    }
}

/// Request message for
/// [SpecialistPoolService.UpdateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool]: crate::client::SpecialistPoolService::update_specialist_pool
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSpecialistPoolRequest {
    /// Required. The SpecialistPool which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub specialist_pool: std::option::Option<crate::model::SpecialistPool>,

    /// Required. The update mask applies to the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl UpdateSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [specialist_pool][crate::model::UpdateSpecialistPoolRequest::specialist_pool].
    pub fn set_specialist_pool<
        T: std::convert::Into<std::option::Option<crate::model::SpecialistPool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.specialist_pool = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSpecialistPoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for UpdateSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateSpecialistPoolRequest"
    }
}

/// Runtime operation metadata for
/// [SpecialistPoolService.UpdateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool]: crate::client::SpecialistPoolService::update_specialist_pool
#[cfg(feature = "specialist_pool_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSpecialistPoolOperationMetadata {
    /// Output only. The name of the SpecialistPool to which the specialists are
    /// being added. Format:
    /// `projects/{project_id}/locations/{location_id}/specialistPools/{specialist_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub specialist_pool: std::string::String,

    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "specialist_pool_service")]
impl UpdateSpecialistPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [specialist_pool][crate::model::UpdateSpecialistPoolOperationMetadata::specialist_pool].
    pub fn set_specialist_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.specialist_pool = v.into();
        self
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateSpecialistPoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "specialist_pool_service")]
impl wkt::message::Message for UpdateSpecialistPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateSpecialistPoolOperationMetadata"
    }
}

/// A message representing a Study.
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Study {
    /// Output only. The name of a study. The study's globally unique identifier.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Describes the Study, default value is empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Configuration of the Study.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study_spec: std::option::Option<crate::model::StudySpec>,

    /// Output only. The detailed state of a Study.
    pub state: crate::model::study::State,

    /// Output only. Time at which the study was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A human readable reason why the Study is inactive.
    /// This should be empty if a study is ACTIVE or COMPLETED.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inactive_reason: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl Study {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Study::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Study::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [study_spec][crate::model::Study::study_spec].
    pub fn set_study_spec<T: std::convert::Into<std::option::Option<crate::model::StudySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.study_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Study::state].
    pub fn set_state<T: std::convert::Into<crate::model::study::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Study::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [inactive_reason][crate::model::Study::inactive_reason].
    pub fn set_inactive_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.inactive_reason = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for Study {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Study"
    }
}

/// Defines additional types related to [Study].
#[cfg(feature = "vizier_service")]
pub mod study {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the Study state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "vizier_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The study state is unspecified.
        Unspecified,
        /// The study is active.
        Active,
        /// The study is stopped due to an internal error.
        Inactive,
        /// The study is done when the service exhausts the parameter search space
        /// or max_trial_count is reached.
        Completed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "vizier_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "vizier_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::Completed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "vizier_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "vizier_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "vizier_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Inactive,
                3 => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "vizier_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                "COMPLETED" => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "vizier_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::Completed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "vizier_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.Study.State",
            ))
        }
    }
}

/// A message representing a Trial. A Trial contains a unique set of Parameters
/// that has been or will be evaluated, along with the objective metrics got by
/// running the Trial.
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trial {
    /// Output only. Resource name of the Trial assigned by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The identifier of the Trial assigned by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The detailed state of the Trial.
    pub state: crate::model::trial::State,

    /// Output only. The parameters of the Trial.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::trial::Parameter>,

    /// Output only. The final measurement containing the objective value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_measurement: std::option::Option<crate::model::Measurement>,

    /// Output only. A list of measurements that are strictly lexicographically
    /// ordered by their induced tuples (steps, elapsed_duration).
    /// These are used for early stopping computations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub measurements: std::vec::Vec<crate::model::Measurement>,

    /// Output only. Time when the Trial was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the Trial's status changed to `SUCCEEDED` or
    /// `INFEASIBLE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The identifier of the client that originally requested this
    /// Trial. Each client is identified by a unique client_id. When a client asks
    /// for a suggestion, Vertex AI Vizier will assign it a Trial. The client
    /// should evaluate the Trial, complete it, and report back to Vertex AI
    /// Vizier. If suggestion is asked again by same client_id before the Trial is
    /// completed, the same Trial will be returned. Multiple clients with
    /// different client_ids can ask for suggestions simultaneously, each of them
    /// will get their own Trial.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,

    /// Output only. A human readable string describing why the Trial is
    /// infeasible. This is set only if Trial state is `INFEASIBLE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub infeasible_reason: std::string::String,

    /// Output only. The CustomJob name linked to the Trial.
    /// It's set for a HyperparameterTuningJob's Trial.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub custom_job: std::string::String,

    /// Output only. URIs for accessing [interactive
    /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
    /// (one URI for each training node). Only available if this trial is part of
    /// a
    /// [HyperparameterTuningJob][google.cloud.aiplatform.v1.HyperparameterTuningJob]
    /// and the job's
    /// [trial_job_spec.enable_web_access][google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]
    /// field is `true`.
    ///
    /// The keys are names of each node used for the trial; for example,
    /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
    /// the second worker pool, and `workerpool1-1` for the second node in the
    /// second worker pool.
    ///
    /// The values are the URIs for each node's interactive shell.
    ///
    /// [google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]: crate::model::CustomJobSpec::enable_web_access
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob]: crate::model::HyperparameterTuningJob
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub web_access_uris: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl Trial {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Trial::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Trial::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Trial::state].
    pub fn set_state<T: std::convert::Into<crate::model::trial::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [final_measurement][crate::model::Trial::final_measurement].
    pub fn set_final_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.final_measurement = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Trial::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Trial::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::Trial::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [infeasible_reason][crate::model::Trial::infeasible_reason].
    pub fn set_infeasible_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.infeasible_reason = v.into();
        self
    }

    /// Sets the value of [custom_job][crate::model::Trial::custom_job].
    pub fn set_custom_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_job = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::Trial::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::trial::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [measurements][crate::model::Trial::measurements].
    pub fn set_measurements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Measurement>,
    {
        use std::iter::Iterator;
        self.measurements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [web_access_uris][crate::model::Trial::web_access_uris].
    pub fn set_web_access_uris<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.web_access_uris = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl wkt::message::Message for Trial {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Trial"
    }
}

/// Defines additional types related to [Trial].
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
pub mod trial {
    #[allow(unused_imports)]
    use super::*;

    /// A message representing a parameter to be tuned.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Parameter {
        /// Output only. The ID of the parameter. The parameter should be defined in
        /// [StudySpec's
        /// Parameters][google.cloud.aiplatform.v1.StudySpec.parameters].
        ///
        /// [google.cloud.aiplatform.v1.StudySpec.parameters]: crate::model::StudySpec::parameters
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub parameter_id: std::string::String,

        /// Output only. The value of the parameter.
        /// `number_value` will be set if a parameter defined in StudySpec is
        /// in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
        /// `string_value` will be set if a parameter defined in StudySpec is
        /// in type 'CATEGORICAL'.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<wkt::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl Parameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter_id][crate::model::trial::Parameter::parameter_id].
        pub fn set_parameter_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_id = v.into();
            self
        }

        /// Sets the value of [value][crate::model::trial::Parameter::value].
        pub fn set_value<T: std::convert::Into<std::option::Option<wkt::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for Parameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Trial.Parameter"
        }
    }

    /// Describes a Trial state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Trial state is unspecified.
        Unspecified,
        /// Indicates that a specific Trial has been requested, but it has not yet
        /// been suggested by the service.
        Requested,
        /// Indicates that the Trial has been suggested.
        Active,
        /// Indicates that the Trial should stop according to the service.
        Stopping,
        /// Indicates that the Trial is completed successfully.
        Succeeded,
        /// Indicates that the Trial should not be attempted again.
        /// The service will set a Trial to INFEASIBLE when it's done but missing
        /// the final_measurement.
        Infeasible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Requested => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Stopping => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Infeasible => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Requested => std::option::Option::Some("REQUESTED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Infeasible => std::option::Option::Some("INFEASIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Requested,
                2 => Self::Active,
                3 => Self::Stopping,
                4 => Self::Succeeded,
                5 => Self::Infeasible,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "REQUESTED" => Self::Requested,
                "ACTIVE" => Self::Active,
                "STOPPING" => Self::Stopping,
                "SUCCEEDED" => Self::Succeeded,
                "INFEASIBLE" => Self::Infeasible,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Requested => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Stopping => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Infeasible => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.Trial.State",
            ))
        }
    }
}

#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrialContext {
    /// A human-readable field which can store a description of this context.
    /// This will become part of the resulting Trial's description field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// If/when a Trial is generated or selected from this Context,
    /// its Parameters will match any parameters specified here.
    /// (I.e. if this context specifies parameter name:'a' int_value:3,
    /// then a resulting Trial will have int_value:3 for its parameter named
    /// 'a'.) Note that we first attempt to match existing REQUESTED Trials with
    /// contexts, and if there are no matches, we generate suggestions in the
    /// subspace defined by the parameters specified here.
    /// NOTE: a Context without any Parameters matches the entire feasible search
    /// space.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::trial::Parameter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl TrialContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::TrialContext::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::TrialContext::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::trial::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for TrialContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrialContext"
    }
}

/// Time-based Constraint for Study
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StudyTimeConstraint {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub constraint: std::option::Option<crate::model::study_time_constraint::Constraint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl StudyTimeConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraint][crate::model::StudyTimeConstraint::constraint].
    ///
    /// Note that all the setters affecting `constraint` are mutually
    /// exclusive.
    pub fn set_constraint<
        T: std::convert::Into<std::option::Option<crate::model::study_time_constraint::Constraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = v.into();
        self
    }

    /// The value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// if it holds a `MaxDuration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_duration(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::study_time_constraint::Constraint::MaxDuration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// if it holds a `EndTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn end_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::study_time_constraint::Constraint::EndTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// to hold a `MaxDuration`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_max_duration<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = std::option::Option::Some(
            crate::model::study_time_constraint::Constraint::MaxDuration(v.into()),
        );
        self
    }

    /// Sets the value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// to hold a `EndTime`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_end_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = std::option::Option::Some(
            crate::model::study_time_constraint::Constraint::EndTime(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl wkt::message::Message for StudyTimeConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StudyTimeConstraint"
    }
}

/// Defines additional types related to [StudyTimeConstraint].
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
pub mod study_time_constraint {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Constraint {
        /// Counts the wallclock time passed since the creation of this Study.
        MaxDuration(std::boxed::Box<wkt::Duration>),
        /// Compares the wallclock time to this time. Must use UTC timezone.
        EndTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// Represents specification of a Study.
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StudySpec {
    /// Required. Metric specs for the Study.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::study_spec::MetricSpec>,

    /// Required. The set of parameters to tune.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::study_spec::ParameterSpec>,

    /// The search algorithm specified for the Study.
    pub algorithm: crate::model::study_spec::Algorithm,

    /// The observation noise level of the study.
    /// Currently only supported by the Vertex AI Vizier service. Not supported by
    /// HyperparameterTuningJob or TrainingPipeline.
    pub observation_noise: crate::model::study_spec::ObservationNoise,

    /// Describe which measurement selection type will be used
    pub measurement_selection_type: crate::model::study_spec::MeasurementSelectionType,

    /// Conditions for automated stopping of a Study. Enable automated stopping by
    /// configuring at least one condition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study_stopping_config: std::option::Option<crate::model::study_spec::StudyStoppingConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub automated_stopping_spec:
        std::option::Option<crate::model::study_spec::AutomatedStoppingSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl StudySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [algorithm][crate::model::StudySpec::algorithm].
    pub fn set_algorithm<T: std::convert::Into<crate::model::study_spec::Algorithm>>(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [observation_noise][crate::model::StudySpec::observation_noise].
    pub fn set_observation_noise<
        T: std::convert::Into<crate::model::study_spec::ObservationNoise>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.observation_noise = v.into();
        self
    }

    /// Sets the value of [measurement_selection_type][crate::model::StudySpec::measurement_selection_type].
    pub fn set_measurement_selection_type<
        T: std::convert::Into<crate::model::study_spec::MeasurementSelectionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.measurement_selection_type = v.into();
        self
    }

    /// Sets the value of [study_stopping_config][crate::model::StudySpec::study_stopping_config].
    pub fn set_study_stopping_config<
        T: std::convert::Into<std::option::Option<crate::model::study_spec::StudyStoppingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.study_stopping_config = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::StudySpec::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::study_spec::MetricSpec>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parameters][crate::model::StudySpec::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::study_spec::ParameterSpec>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec].
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are mutually
    /// exclusive.
    pub fn set_automated_stopping_spec<
        T: std::convert::Into<std::option::Option<crate::model::study_spec::AutomatedStoppingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = v.into();
        self
    }

    /// The value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// if it holds a `DecayCurveStoppingSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn decay_curve_stopping_spec(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::study_spec::DecayCurveAutomatedStoppingSpec>,
    > {
        #[allow(unreachable_patterns)]
        self.automated_stopping_spec.as_ref().and_then(|v| match v {
            crate::model::study_spec::AutomatedStoppingSpec::DecayCurveStoppingSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// if it holds a `MedianAutomatedStoppingSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn median_automated_stopping_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::MedianAutomatedStoppingSpec>>
    {
        #[allow(unreachable_patterns)]
        self.automated_stopping_spec.as_ref().and_then(|v| match v {
            crate::model::study_spec::AutomatedStoppingSpec::MedianAutomatedStoppingSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// if it holds a `ConvexAutomatedStoppingSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn convex_automated_stopping_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::ConvexAutomatedStoppingSpec>>
    {
        #[allow(unreachable_patterns)]
        self.automated_stopping_spec.as_ref().and_then(|v| match v {
            crate::model::study_spec::AutomatedStoppingSpec::ConvexAutomatedStoppingSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// to hold a `DecayCurveStoppingSpec`.
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are
    /// mutually exclusive.
    pub fn set_decay_curve_stopping_spec<
        T: std::convert::Into<
                std::boxed::Box<crate::model::study_spec::DecayCurveAutomatedStoppingSpec>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = std::option::Option::Some(
            crate::model::study_spec::AutomatedStoppingSpec::DecayCurveStoppingSpec(v.into()),
        );
        self
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// to hold a `MedianAutomatedStoppingSpec`.
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are
    /// mutually exclusive.
    pub fn set_median_automated_stopping_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::study_spec::MedianAutomatedStoppingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = std::option::Option::Some(
            crate::model::study_spec::AutomatedStoppingSpec::MedianAutomatedStoppingSpec(v.into()),
        );
        self
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// to hold a `ConvexAutomatedStoppingSpec`.
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are
    /// mutually exclusive.
    pub fn set_convex_automated_stopping_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::study_spec::ConvexAutomatedStoppingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = std::option::Option::Some(
            crate::model::study_spec::AutomatedStoppingSpec::ConvexAutomatedStoppingSpec(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl wkt::message::Message for StudySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec"
    }
}

/// Defines additional types related to [StudySpec].
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
pub mod study_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a metric to optimize.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetricSpec {
        /// Required. The ID of the metric. Must not contain whitespaces and must be
        /// unique amongst all MetricSpecs.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metric_id: std::string::String,

        /// Required. The optimization goal of the metric.
        pub goal: crate::model::study_spec::metric_spec::GoalType,

        /// Used for safe search. In the case, the metric will be a safety
        /// metric. You must provide a separate metric for objective metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub safety_config:
            std::option::Option<crate::model::study_spec::metric_spec::SafetyMetricConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl MetricSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metric_id][crate::model::study_spec::MetricSpec::metric_id].
        pub fn set_metric_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.metric_id = v.into();
            self
        }

        /// Sets the value of [goal][crate::model::study_spec::MetricSpec::goal].
        pub fn set_goal<T: std::convert::Into<crate::model::study_spec::metric_spec::GoalType>>(
            mut self,
            v: T,
        ) -> Self {
            self.goal = v.into();
            self
        }

        /// Sets the value of [safety_config][crate::model::study_spec::MetricSpec::safety_config].
        pub fn set_safety_config<
            T: std::convert::Into<
                    std::option::Option<crate::model::study_spec::metric_spec::SafetyMetricConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.safety_config = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for MetricSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MetricSpec"
        }
    }

    /// Defines additional types related to [MetricSpec].
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    pub mod metric_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Used in safe optimization to specify threshold levels and risk tolerance.
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SafetyMetricConfig {
            /// Safety threshold (boundary value between safe and unsafe). NOTE that if
            /// you leave SafetyMetricConfig unset, a default value of 0 will be used.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub safety_threshold: f64,

            /// Desired minimum fraction of safe trials (over total number of trials)
            /// that should be targeted by the algorithm at any time during the
            /// study (best effort). This should be between 0.0 and 1.0 and a value of
            /// 0.0 means that there is no minimum and an algorithm proceeds without
            /// targeting any specific fraction. A value of 1.0 means that the
            /// algorithm attempts to only Suggest safe Trials.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub desired_min_safe_trials_fraction: std::option::Option<f64>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl SafetyMetricConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [safety_threshold][crate::model::study_spec::metric_spec::SafetyMetricConfig::safety_threshold].
            pub fn set_safety_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.safety_threshold = v.into();
                self
            }

            /// Sets the value of [desired_min_safe_trials_fraction][crate::model::study_spec::metric_spec::SafetyMetricConfig::desired_min_safe_trials_fraction].
            pub fn set_desired_min_safe_trials_fraction<
                T: std::convert::Into<std::option::Option<f64>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.desired_min_safe_trials_fraction = v.into();
                self
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl wkt::message::Message for SafetyMetricConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MetricSpec.SafetyMetricConfig"
            }
        }

        /// The available types of optimization goals.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum GoalType {
            /// Goal Type will default to maximize.
            Unspecified,
            /// Maximize the goal metric.
            Maximize,
            /// Minimize the goal metric.
            Minimize,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [GoalType::value] or
            /// [GoalType::name].
            UnknownValue(goal_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        pub mod goal_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl GoalType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Maximize => std::option::Option::Some(1),
                    Self::Minimize => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("GOAL_TYPE_UNSPECIFIED"),
                    Self::Maximize => std::option::Option::Some("MAXIMIZE"),
                    Self::Minimize => std::option::Option::Some("MINIMIZE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::default::Default for GoalType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::fmt::Display for GoalType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::convert::From<i32> for GoalType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Maximize,
                    2 => Self::Minimize,
                    _ => Self::UnknownValue(goal_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::convert::From<&str> for GoalType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "GOAL_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "MAXIMIZE" => Self::Maximize,
                    "MINIMIZE" => Self::Minimize,
                    _ => Self::UnknownValue(goal_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl serde::ser::Serialize for GoalType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Maximize => serializer.serialize_i32(1),
                    Self::Minimize => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl<'de> serde::de::Deserialize<'de> for GoalType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<GoalType>::new(
                    ".google.cloud.aiplatform.v1.StudySpec.MetricSpec.GoalType",
                ))
            }
        }
    }

    /// Represents a single parameter to optimize.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ParameterSpec {
        /// Required. The ID of the parameter. Must not contain whitespaces and must
        /// be unique amongst all ParameterSpecs.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub parameter_id: std::string::String,

        /// How the parameter should be scaled.
        /// Leave unset for `CATEGORICAL` parameters.
        pub scale_type: crate::model::study_spec::parameter_spec::ScaleType,

        /// A conditional parameter node is active if the parameter's value matches
        /// the conditional node's parent_value_condition.
        ///
        /// If two items in conditional_parameter_specs have the same name, they
        /// must have disjoint parent_value_condition.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub conditional_parameter_specs:
            std::vec::Vec<crate::model::study_spec::parameter_spec::ConditionalParameterSpec>,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub parameter_value_spec:
            std::option::Option<crate::model::study_spec::parameter_spec::ParameterValueSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl ParameterSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter_id][crate::model::study_spec::ParameterSpec::parameter_id].
        pub fn set_parameter_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_id = v.into();
            self
        }

        /// Sets the value of [scale_type][crate::model::study_spec::ParameterSpec::scale_type].
        pub fn set_scale_type<
            T: std::convert::Into<crate::model::study_spec::parameter_spec::ScaleType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scale_type = v.into();
            self
        }

        /// Sets the value of [conditional_parameter_specs][crate::model::study_spec::ParameterSpec::conditional_parameter_specs].
        pub fn set_conditional_parameter_specs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::study_spec::parameter_spec::ConditionalParameterSpec,
                >,
        {
            use std::iter::Iterator;
            self.conditional_parameter_specs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec].
        ///
        /// Note that all the setters affecting `parameter_value_spec` are mutually
        /// exclusive.
        pub fn set_parameter_value_spec<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::study_spec::parameter_spec::ParameterValueSpec,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = v.into();
            self
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `DoubleValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn double_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::DoubleValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DoubleValueSpec(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `IntegerValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn integer_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::IntegerValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::IntegerValueSpec(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `CategoricalValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn categorical_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::CategoricalValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::CategoricalValueSpec(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `DiscreteValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn discrete_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::DiscreteValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DiscreteValueSpec(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `DoubleValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_double_value_spec<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::study_spec::parameter_spec::DoubleValueSpec>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DoubleValueSpec(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `IntegerValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_integer_value_spec<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::study_spec::parameter_spec::IntegerValueSpec>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::IntegerValueSpec(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `CategoricalValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_categorical_value_spec<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::study_spec::parameter_spec::CategoricalValueSpec>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::CategoricalValueSpec(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `DiscreteValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_discrete_value_spec<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::study_spec::parameter_spec::DiscreteValueSpec>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DiscreteValueSpec(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for ParameterSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec"
        }
    }

    /// Defines additional types related to [ParameterSpec].
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    pub mod parameter_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Value specification for a parameter in `DOUBLE` type.
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DoubleValueSpec {
            /// Required. Inclusive minimum value of the parameter.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub min_value: f64,

            /// Required. Inclusive maximum value of the parameter.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_value: f64,

            /// A default value for a `DOUBLE` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<f64>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl DoubleValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_value][crate::model::study_spec::parameter_spec::DoubleValueSpec::min_value].
            pub fn set_min_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::study_spec::parameter_spec::DoubleValueSpec::max_value].
            pub fn set_max_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::DoubleValueSpec::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<f64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl wkt::message::Message for DoubleValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DoubleValueSpec"
            }
        }

        /// Value specification for a parameter in `INTEGER` type.
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IntegerValueSpec {
            /// Required. Inclusive minimum value of the parameter.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub min_value: i64,

            /// Required. Inclusive maximum value of the parameter.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_value: i64,

            /// A default value for an `INTEGER` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub default_value: std::option::Option<i64>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl IntegerValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_value][crate::model::study_spec::parameter_spec::IntegerValueSpec::min_value].
            pub fn set_min_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::study_spec::parameter_spec::IntegerValueSpec::max_value].
            pub fn set_max_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::IntegerValueSpec::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<i64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl wkt::message::Message for IntegerValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.IntegerValueSpec"
            }
        }

        /// Value specification for a parameter in `CATEGORICAL` type.
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CategoricalValueSpec {
            /// Required. The list of possible categories.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub values: std::vec::Vec<std::string::String>,

            /// A default value for a `CATEGORICAL` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl CategoricalValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::CategoricalValueSpec::default_value].
            pub fn set_default_value<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }

            /// Sets the value of [values][crate::model::study_spec::parameter_spec::CategoricalValueSpec::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl wkt::message::Message for CategoricalValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.CategoricalValueSpec"
            }
        }

        /// Value specification for a parameter in `DISCRETE` type.
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DiscreteValueSpec {
            /// Required. A list of possible values.
            /// The list should be in increasing order and at least 1e-10 apart.
            /// For instance, this parameter might have possible settings of 1.5, 2.5,
            /// and 4.0. This list should not contain more than 1,000 values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub values: std::vec::Vec<f64>,

            /// A default value for a `DISCRETE` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.  It automatically rounds to the
            /// nearest feasible discrete point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<f64>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl DiscreteValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::DiscreteValueSpec::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<f64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }

            /// Sets the value of [values][crate::model::study_spec::parameter_spec::DiscreteValueSpec::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<f64>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl wkt::message::Message for DiscreteValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DiscreteValueSpec"
            }
        }

        /// Represents a parameter spec with condition from its parent parameter.
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ConditionalParameterSpec {

            /// Required. The spec for a conditional parameter.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub parameter_spec: std::option::Option<std::boxed::Box<crate::model::study_spec::ParameterSpec>>,

            /// A set of parameter values from the parent ParameterSpec's feasible
            /// space.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub parent_value_condition: std::option::Option<crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl ConditionalParameterSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [parameter_spec][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parameter_spec].
            pub fn set_parameter_spec<
                T: std::convert::Into<
                        std::option::Option<
                            std::boxed::Box<crate::model::study_spec::ParameterSpec>,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.parameter_spec = v.into();
                self
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition].
            ///
            /// Note that all the setters affecting `parent_value_condition` are mutually
            /// exclusive.
            pub fn set_parent_value_condition<T: std::convert::Into<std::option::Option<crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition>>>(mut self, v: T) -> Self
            {
                self.parent_value_condition = v.into();
                self
            }

            /// The value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// if it holds a `ParentDiscreteValues`, `None` if the field is not set or
            /// holds a different branch.
            pub fn parent_discrete_values(&self) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition>>{
                #[allow(unreachable_patterns)]
                self.parent_value_condition.as_ref().and_then(|v| match v {
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentDiscreteValues(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// if it holds a `ParentIntValues`, `None` if the field is not set or
            /// holds a different branch.
            pub fn parent_int_values(&self) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition>>{
                #[allow(unreachable_patterns)]
                self.parent_value_condition.as_ref().and_then(|v| match v {
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentIntValues(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// if it holds a `ParentCategoricalValues`, `None` if the field is not set or
            /// holds a different branch.
            pub fn parent_categorical_values(&self) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition>>{
                #[allow(unreachable_patterns)]
                self.parent_value_condition.as_ref().and_then(|v| match v {
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentCategoricalValues(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// to hold a `ParentDiscreteValues`.
            ///
            /// Note that all the setters affecting `parent_value_condition` are
            /// mutually exclusive.
            pub fn set_parent_discrete_values<T: std::convert::Into<std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition>>>(mut self, v: T) -> Self{
                self.parent_value_condition = std::option::Option::Some(
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentDiscreteValues(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// to hold a `ParentIntValues`.
            ///
            /// Note that all the setters affecting `parent_value_condition` are
            /// mutually exclusive.
            pub fn set_parent_int_values<T: std::convert::Into<std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition>>>(mut self, v: T) -> Self{
                self.parent_value_condition = std::option::Option::Some(
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentIntValues(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// to hold a `ParentCategoricalValues`.
            ///
            /// Note that all the setters affecting `parent_value_condition` are
            /// mutually exclusive.
            pub fn set_parent_categorical_values<T: std::convert::Into<std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition>>>(mut self, v: T) -> Self{
                self.parent_value_condition = std::option::Option::Some(
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentCategoricalValues(
                        v.into()
                    )
                );
                self
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl wkt::message::Message for ConditionalParameterSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec"
            }
        }

        /// Defines additional types related to [ConditionalParameterSpec].
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        pub mod conditional_parameter_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Represents the spec to match discrete values from parent parameter.
            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DiscreteValueCondition {
                /// Required. Matches values of the parent parameter of 'DISCRETE' type.
                /// All values must exist in `discrete_value_spec` of parent parameter.
                ///
                /// The Epsilon of the value matching is 1e-10.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub values: std::vec::Vec<f64>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            impl DiscreteValueCondition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [values][crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition::values].
                pub fn set_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<f64>,
                {
                    use std::iter::Iterator;
                    self.values = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            impl wkt::message::Message for DiscreteValueCondition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition"
                }
            }

            /// Represents the spec to match integer values from parent parameter.
            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct IntValueCondition {
                /// Required. Matches values of the parent parameter of 'INTEGER' type.
                /// All values must lie in `integer_value_spec` of parent parameter.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
                pub values: std::vec::Vec<i64>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            impl IntValueCondition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [values][crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition::values].
                pub fn set_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<i64>,
                {
                    use std::iter::Iterator;
                    self.values = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            impl wkt::message::Message for IntValueCondition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition"
                }
            }

            /// Represents the spec to match categorical values from parent parameter.
            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct CategoricalValueCondition {
                /// Required. Matches values of the parent parameter of 'CATEGORICAL'
                /// type. All values must exist in `categorical_value_spec` of parent
                /// parameter.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub values: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            impl CategoricalValueCondition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [values][crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition::values].
                pub fn set_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.values = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            impl wkt::message::Message for CategoricalValueCondition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition"
                }
            }

            /// A set of parameter values from the parent ParameterSpec's feasible
            /// space.
            #[cfg(any(feature = "job_service", feature = "vizier_service",))]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum ParentValueCondition {
                /// The spec for matching values from a parent parameter of
                /// `DISCRETE` type.
                ParentDiscreteValues(std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition>),
                /// The spec for matching values from a parent parameter of `INTEGER`
                /// type.
                ParentIntValues(std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition>),
                /// The spec for matching values from a parent parameter of
                /// `CATEGORICAL` type.
                ParentCategoricalValues(std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition>),
            }
        }

        /// The type of scaling that should be applied to this parameter.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ScaleType {
            /// By default, no scaling is applied.
            Unspecified,
            /// Scales the feasible space to (0, 1) linearly.
            UnitLinearScale,
            /// Scales the feasible space logarithmically to (0, 1). The entire
            /// feasible space must be strictly positive.
            UnitLogScale,
            /// Scales the feasible space "reverse" logarithmically to (0, 1). The
            /// result is that values close to the top of the feasible space are spread
            /// out more than points near the bottom. The entire feasible space must be
            /// strictly positive.
            UnitReverseLogScale,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ScaleType::value] or
            /// [ScaleType::name].
            UnknownValue(scale_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        pub mod scale_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl ScaleType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::UnitLinearScale => std::option::Option::Some(1),
                    Self::UnitLogScale => std::option::Option::Some(2),
                    Self::UnitReverseLogScale => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCALE_TYPE_UNSPECIFIED"),
                    Self::UnitLinearScale => std::option::Option::Some("UNIT_LINEAR_SCALE"),
                    Self::UnitLogScale => std::option::Option::Some("UNIT_LOG_SCALE"),
                    Self::UnitReverseLogScale => {
                        std::option::Option::Some("UNIT_REVERSE_LOG_SCALE")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::default::Default for ScaleType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::fmt::Display for ScaleType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::convert::From<i32> for ScaleType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::UnitLinearScale,
                    2 => Self::UnitLogScale,
                    3 => Self::UnitReverseLogScale,
                    _ => Self::UnknownValue(scale_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl std::convert::From<&str> for ScaleType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCALE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "UNIT_LINEAR_SCALE" => Self::UnitLinearScale,
                    "UNIT_LOG_SCALE" => Self::UnitLogScale,
                    "UNIT_REVERSE_LOG_SCALE" => Self::UnitReverseLogScale,
                    _ => Self::UnknownValue(scale_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl serde::ser::Serialize for ScaleType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::UnitLinearScale => serializer.serialize_i32(1),
                    Self::UnitLogScale => serializer.serialize_i32(2),
                    Self::UnitReverseLogScale => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        impl<'de> serde::de::Deserialize<'de> for ScaleType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScaleType>::new(
                    ".google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ScaleType",
                ))
            }
        }

        #[cfg(any(feature = "job_service", feature = "vizier_service",))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ParameterValueSpec {
            /// The value spec for a 'DOUBLE' parameter.
            DoubleValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::DoubleValueSpec>,
            ),
            /// The value spec for an 'INTEGER' parameter.
            IntegerValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::IntegerValueSpec>,
            ),
            /// The value spec for a 'CATEGORICAL' parameter.
            CategoricalValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::CategoricalValueSpec>,
            ),
            /// The value spec for a 'DISCRETE' parameter.
            DiscreteValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::DiscreteValueSpec>,
            ),
        }
    }

    /// The decay curve automated stopping rule builds a Gaussian Process
    /// Regressor to predict the final objective value of a Trial based on the
    /// already completed Trials and the intermediate measurements of the current
    /// Trial. Early stopping is requested for the current Trial if there is very
    /// low probability to exceed the optimal value found so far.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DecayCurveAutomatedStoppingSpec {
        /// True if
        /// [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration]
        /// is used as the x-axis of each Trials Decay Curve. Otherwise,
        /// [Measurement.step_count][google.cloud.aiplatform.v1.Measurement.step_count]
        /// will be used as the x-axis.
        ///
        /// [google.cloud.aiplatform.v1.Measurement.elapsed_duration]: crate::model::Measurement::elapsed_duration
        /// [google.cloud.aiplatform.v1.Measurement.step_count]: crate::model::Measurement::step_count
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub use_elapsed_duration: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl DecayCurveAutomatedStoppingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [use_elapsed_duration][crate::model::study_spec::DecayCurveAutomatedStoppingSpec::use_elapsed_duration].
        pub fn set_use_elapsed_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_elapsed_duration = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for DecayCurveAutomatedStoppingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.DecayCurveAutomatedStoppingSpec"
        }
    }

    /// The median automated stopping rule stops a pending Trial if the Trial's
    /// best objective_value is strictly below the median 'performance' of all
    /// completed Trials reported up to the Trial's last measurement.
    /// Currently, 'performance' refers to the running average of the objective
    /// values reported by the Trial in each measurement.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MedianAutomatedStoppingSpec {
        /// True if median automated stopping rule applies on
        /// [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration].
        /// It means that elapsed_duration field of latest measurement of current
        /// Trial is used to compute median objective value for each completed
        /// Trials.
        ///
        /// [google.cloud.aiplatform.v1.Measurement.elapsed_duration]: crate::model::Measurement::elapsed_duration
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub use_elapsed_duration: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl MedianAutomatedStoppingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [use_elapsed_duration][crate::model::study_spec::MedianAutomatedStoppingSpec::use_elapsed_duration].
        pub fn set_use_elapsed_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_elapsed_duration = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for MedianAutomatedStoppingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MedianAutomatedStoppingSpec"
        }
    }

    /// Configuration for ConvexAutomatedStoppingSpec.
    /// When there are enough completed trials (configured by
    /// min_measurement_count), for pending trials with enough measurements and
    /// steps, the policy first computes an overestimate of the objective value at
    /// max_num_steps according to the slope of the incomplete objective value
    /// curve. No prediction can be made if the curve is completely flat. If the
    /// overestimation is worse than the best objective value of the completed
    /// trials, this pending trial will be early-stopped, but a last measurement
    /// will be added to the pending trial with max_num_steps and predicted
    /// objective value from the autoregression model.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConvexAutomatedStoppingSpec {
        /// Steps used in predicting the final objective for early stopped trials. In
        /// general, it's set to be the same as the defined steps in training /
        /// tuning. If not defined, it will learn it from the completed trials. When
        /// use_steps is false, this field is set to the maximum elapsed seconds.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_step_count: i64,

        /// Minimum number of steps for a trial to complete. Trials which do not have
        /// a measurement with step_count > min_step_count won't be considered for
        /// early stopping. It's ok to set it to 0, and a trial can be early stopped
        /// at any stage. By default, min_step_count is set to be one-tenth of the
        /// max_step_count.
        /// When use_elapsed_duration is true, this field is set to the minimum
        /// elapsed seconds.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub min_step_count: i64,

        /// The minimal number of measurements in a Trial.  Early-stopping checks
        /// will not trigger if less than min_measurement_count+1 completed trials or
        /// pending trials with less than min_measurement_count measurements. If not
        /// defined, the default value is 5.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub min_measurement_count: i64,

        /// The hyper-parameter name used in the tuning job that stands for learning
        /// rate. Leave it blank if learning rate is not in a parameter in tuning.
        /// The learning_rate is used to estimate the objective value of the ongoing
        /// trial.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub learning_rate_parameter_name: std::string::String,

        /// This bool determines whether or not the rule is applied based on
        /// elapsed_secs or steps. If use_elapsed_duration==false, the early stopping
        /// decision is made according to the predicted objective values according to
        /// the target steps. If use_elapsed_duration==true, elapsed_secs is used
        /// instead of steps. Also, in this case, the parameters max_num_steps and
        /// min_num_steps are overloaded to contain max_elapsed_seconds and
        /// min_elapsed_seconds.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub use_elapsed_duration: bool,

        /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
        /// to be early stopped using a newly trained auto-regressive model. When
        /// this flag is set to True, all stopped trials from the beginning are
        /// potentially updated in terms of their `final_measurement`. Also, note
        /// that the training logic of autoregressive models is different in this
        /// case. Enabling this option has shown better results and this may be the
        /// default option in the future.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_all_stopped_trials: std::option::Option<bool>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl ConvexAutomatedStoppingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_step_count][crate::model::study_spec::ConvexAutomatedStoppingSpec::max_step_count].
        pub fn set_max_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_step_count = v.into();
            self
        }

        /// Sets the value of [min_step_count][crate::model::study_spec::ConvexAutomatedStoppingSpec::min_step_count].
        pub fn set_min_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.min_step_count = v.into();
            self
        }

        /// Sets the value of [min_measurement_count][crate::model::study_spec::ConvexAutomatedStoppingSpec::min_measurement_count].
        pub fn set_min_measurement_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.min_measurement_count = v.into();
            self
        }

        /// Sets the value of [learning_rate_parameter_name][crate::model::study_spec::ConvexAutomatedStoppingSpec::learning_rate_parameter_name].
        pub fn set_learning_rate_parameter_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.learning_rate_parameter_name = v.into();
            self
        }

        /// Sets the value of [use_elapsed_duration][crate::model::study_spec::ConvexAutomatedStoppingSpec::use_elapsed_duration].
        pub fn set_use_elapsed_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_elapsed_duration = v.into();
            self
        }

        /// Sets the value of [update_all_stopped_trials][crate::model::study_spec::ConvexAutomatedStoppingSpec::update_all_stopped_trials].
        pub fn set_update_all_stopped_trials<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_all_stopped_trials = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for ConvexAutomatedStoppingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ConvexAutomatedStoppingSpec"
        }
    }

    /// The configuration (stopping conditions) for automated stopping of a Study.
    /// Conditions include trial budgets, time budgets, and convergence detection.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StudyStoppingConfig {
        /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
        /// STOPPING state.
        ///
        /// The bottom line is: set to true if you want to interrupt on-going
        /// evaluations of Trials as soon as the study stopping condition is met.
        /// (Please see Study.State documentation for the source of truth).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub should_stop_asap: std::option::Option<wkt::BoolValue>,

        /// Each "stopping rule" in this proto specifies an "if" condition. Before
        /// Vizier would generate a new suggestion, it first checks each specified
        /// stopping rule, from top to bottom in this list.
        /// Note that the first few rules (e.g. minimum_runtime_constraint,
        /// min_num_trials) will prevent other stopping rules from being evaluated
        /// until they are met. For example, setting `min_num_trials=5` and
        /// `always_stop_after= 1 hour` means that the Study will ONLY stop after it
        /// has 5 COMPLETED trials, even if more than an hour has passed since its
        /// creation. It follows the first applicable rule (whose "if" condition is
        /// satisfied) to make a stopping decision. If none of the specified rules
        /// are applicable, then Vizier decides that the study should not stop.
        /// If Vizier decides that the study should stop, the study enters
        /// STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
        /// IMPORTANT: The automatic study state transition happens precisely as
        /// described above; that is, deleting trials or updating StudyConfig NEVER
        /// automatically moves the study state back to ACTIVE. If you want to
        /// _resume_ a Study that was stopped, 1) change the stopping conditions if
        /// necessary, 2) activate the study, and then 3) ask for suggestions.
        /// If the specified time or duration has not passed, do not stop the
        /// study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub minimum_runtime_constraint: std::option::Option<crate::model::StudyTimeConstraint>,

        /// If the specified time or duration has passed, stop the study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub maximum_runtime_constraint: std::option::Option<crate::model::StudyTimeConstraint>,

        /// If there are fewer than this many COMPLETED trials, do not stop the
        /// study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_num_trials: std::option::Option<wkt::Int32Value>,

        /// If there are more than this many trials, stop the study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_num_trials: std::option::Option<wkt::Int32Value>,

        /// If the objective value has not improved for this many consecutive
        /// trials, stop the study.
        ///
        /// WARNING: Effective only for single-objective studies.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_num_trials_no_progress: std::option::Option<wkt::Int32Value>,

        /// If the objective value has not improved for this much time, stop the
        /// study.
        ///
        /// WARNING: Effective only for single-objective studies.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_duration_no_progress: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl StudyStoppingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [should_stop_asap][crate::model::study_spec::StudyStoppingConfig::should_stop_asap].
        pub fn set_should_stop_asap<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.should_stop_asap = v.into();
            self
        }

        /// Sets the value of [minimum_runtime_constraint][crate::model::study_spec::StudyStoppingConfig::minimum_runtime_constraint].
        pub fn set_minimum_runtime_constraint<
            T: std::convert::Into<std::option::Option<crate::model::StudyTimeConstraint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.minimum_runtime_constraint = v.into();
            self
        }

        /// Sets the value of [maximum_runtime_constraint][crate::model::study_spec::StudyStoppingConfig::maximum_runtime_constraint].
        pub fn set_maximum_runtime_constraint<
            T: std::convert::Into<std::option::Option<crate::model::StudyTimeConstraint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.maximum_runtime_constraint = v.into();
            self
        }

        /// Sets the value of [min_num_trials][crate::model::study_spec::StudyStoppingConfig::min_num_trials].
        pub fn set_min_num_trials<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_num_trials = v.into();
            self
        }

        /// Sets the value of [max_num_trials][crate::model::study_spec::StudyStoppingConfig::max_num_trials].
        pub fn set_max_num_trials<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_num_trials = v.into();
            self
        }

        /// Sets the value of [max_num_trials_no_progress][crate::model::study_spec::StudyStoppingConfig::max_num_trials_no_progress].
        pub fn set_max_num_trials_no_progress<
            T: std::convert::Into<std::option::Option<wkt::Int32Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_num_trials_no_progress = v.into();
            self
        }

        /// Sets the value of [max_duration_no_progress][crate::model::study_spec::StudyStoppingConfig::max_duration_no_progress].
        pub fn set_max_duration_no_progress<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_duration_no_progress = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for StudyStoppingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.StudyStoppingConfig"
        }
    }

    /// The available search algorithms for the Study.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Algorithm {
        /// The default algorithm used by Vertex AI for [hyperparameter
        /// tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
        /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
        Unspecified,
        /// Simple grid search within the feasible space. To use grid search,
        /// all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
        GridSearch,
        /// Simple random search within the feasible space.
        RandomSearch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Algorithm::value] or
        /// [Algorithm::name].
        UnknownValue(algorithm::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    pub mod algorithm {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl Algorithm {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GridSearch => std::option::Option::Some(2),
                Self::RandomSearch => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ALGORITHM_UNSPECIFIED"),
                Self::GridSearch => std::option::Option::Some("GRID_SEARCH"),
                Self::RandomSearch => std::option::Option::Some("RANDOM_SEARCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::default::Default for Algorithm {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::fmt::Display for Algorithm {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<i32> for Algorithm {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::GridSearch,
                3 => Self::RandomSearch,
                _ => Self::UnknownValue(algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<&str> for Algorithm {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALGORITHM_UNSPECIFIED" => Self::Unspecified,
                "GRID_SEARCH" => Self::GridSearch,
                "RANDOM_SEARCH" => Self::RandomSearch,
                _ => Self::UnknownValue(algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl serde::ser::Serialize for Algorithm {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GridSearch => serializer.serialize_i32(2),
                Self::RandomSearch => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl<'de> serde::de::Deserialize<'de> for Algorithm {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Algorithm>::new(
                ".google.cloud.aiplatform.v1.StudySpec.Algorithm",
            ))
        }
    }

    /// Describes the noise level of the repeated observations.
    ///
    /// "Noisy" means that the repeated observations with the same Trial parameters
    /// may lead to different metric evaluations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ObservationNoise {
        /// The default noise level chosen by Vertex AI.
        Unspecified,
        /// Vertex AI assumes that the objective function is (nearly)
        /// perfectly reproducible, and will never repeat the same Trial
        /// parameters.
        Low,
        /// Vertex AI will estimate the amount of noise in metric
        /// evaluations, it may repeat the same Trial parameters more than once.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ObservationNoise::value] or
        /// [ObservationNoise::name].
        UnknownValue(observation_noise::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    pub mod observation_noise {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl ObservationNoise {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OBSERVATION_NOISE_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::default::Default for ObservationNoise {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::fmt::Display for ObservationNoise {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<i32> for ObservationNoise {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(observation_noise::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<&str> for ObservationNoise {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OBSERVATION_NOISE_UNSPECIFIED" => Self::Unspecified,
                "LOW" => Self::Low,
                "HIGH" => Self::High,
                _ => Self::UnknownValue(observation_noise::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl serde::ser::Serialize for ObservationNoise {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl<'de> serde::de::Deserialize<'de> for ObservationNoise {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ObservationNoise>::new(
                ".google.cloud.aiplatform.v1.StudySpec.ObservationNoise",
            ))
        }
    }

    /// This indicates which measurement to use if/when the service automatically
    /// selects the final measurement from previously reported intermediate
    /// measurements. Choose this based on two considerations:
    /// A) Do you expect your measurements to monotonically improve?
    /// If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
    /// situation where your system can "over-train" and you expect the
    /// performance to get better for a while but then start declining,
    /// choose BEST_MEASUREMENT.
    /// B) Are your measurements significantly noisy and/or irreproducible?
    /// If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
    /// may be better to choose LAST_MEASUREMENT.
    /// If both or neither of (A) and (B) apply, it doesn't matter which
    /// selection type is chosen.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MeasurementSelectionType {
        /// Will be treated as LAST_MEASUREMENT.
        Unspecified,
        /// Use the last measurement reported.
        LastMeasurement,
        /// Use the best measurement reported.
        BestMeasurement,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MeasurementSelectionType::value] or
        /// [MeasurementSelectionType::name].
        UnknownValue(measurement_selection_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    pub mod measurement_selection_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl MeasurementSelectionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LastMeasurement => std::option::Option::Some(1),
                Self::BestMeasurement => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("MEASUREMENT_SELECTION_TYPE_UNSPECIFIED")
                }
                Self::LastMeasurement => std::option::Option::Some("LAST_MEASUREMENT"),
                Self::BestMeasurement => std::option::Option::Some("BEST_MEASUREMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::default::Default for MeasurementSelectionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::fmt::Display for MeasurementSelectionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<i32> for MeasurementSelectionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LastMeasurement,
                2 => Self::BestMeasurement,
                _ => Self::UnknownValue(measurement_selection_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl std::convert::From<&str> for MeasurementSelectionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LAST_MEASUREMENT" => Self::LastMeasurement,
                "BEST_MEASUREMENT" => Self::BestMeasurement,
                _ => Self::UnknownValue(measurement_selection_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl serde::ser::Serialize for MeasurementSelectionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LastMeasurement => serializer.serialize_i32(1),
                Self::BestMeasurement => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl<'de> serde::de::Deserialize<'de> for MeasurementSelectionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<MeasurementSelectionType>::new(
                    ".google.cloud.aiplatform.v1.StudySpec.MeasurementSelectionType",
                ),
            )
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AutomatedStoppingSpec {
        /// The automated early stopping spec using decay curve rule.
        DecayCurveStoppingSpec(
            std::boxed::Box<crate::model::study_spec::DecayCurveAutomatedStoppingSpec>,
        ),
        /// The automated early stopping spec using median rule.
        MedianAutomatedStoppingSpec(
            std::boxed::Box<crate::model::study_spec::MedianAutomatedStoppingSpec>,
        ),
        /// The automated early stopping spec using convex stopping rule.
        ConvexAutomatedStoppingSpec(
            std::boxed::Box<crate::model::study_spec::ConvexAutomatedStoppingSpec>,
        ),
    }
}

/// A message representing a Measurement of a Trial. A Measurement contains
/// the Metrics got by executing a Trial using suggested hyperparameter
/// values.
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Measurement {
    /// Output only. Time that the Trial has been running at the point of this
    /// Measurement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub elapsed_duration: std::option::Option<wkt::Duration>,

    /// Output only. The number of steps the machine learning model has been
    /// trained for. Must be non-negative.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub step_count: i64,

    /// Output only. A list of metrics got by evaluating the objective functions
    /// using suggested Parameter values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::measurement::Metric>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl Measurement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [elapsed_duration][crate::model::Measurement::elapsed_duration].
    pub fn set_elapsed_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.elapsed_duration = v.into();
        self
    }

    /// Sets the value of [step_count][crate::model::Measurement::step_count].
    pub fn set_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.step_count = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::Measurement::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::measurement::Metric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "job_service", feature = "vizier_service",))]
impl wkt::message::Message for Measurement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Measurement"
    }
}

/// Defines additional types related to [Measurement].
#[cfg(any(feature = "job_service", feature = "vizier_service",))]
pub mod measurement {
    #[allow(unused_imports)]
    use super::*;

    /// A message representing a metric in the measurement.
    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metric {
        /// Output only. The ID of the Metric. The Metric should be defined in
        /// [StudySpec's Metrics][google.cloud.aiplatform.v1.StudySpec.metrics].
        ///
        /// [google.cloud.aiplatform.v1.StudySpec.metrics]: crate::model::StudySpec::metrics
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metric_id: std::string::String,

        /// Output only. The value for this metric.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub value: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl Metric {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metric_id][crate::model::measurement::Metric::metric_id].
        pub fn set_metric_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.metric_id = v.into();
            self
        }

        /// Sets the value of [value][crate::model::measurement::Metric::value].
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    #[cfg(any(feature = "job_service", feature = "vizier_service",))]
    impl wkt::message::Message for Metric {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Measurement.Metric"
        }
    }
}

/// Tensorboard is a physical database that stores users' training metrics.
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tensorboard {
    /// Output only. Name of the Tensorboard.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of this Tensorboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this Tensorboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Customer-managed encryption key spec for a Tensorboard. If set, this
    /// Tensorboard and all sub-resources of this Tensorboard will be secured by
    /// this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Consumer project Cloud Storage path prefix used to store blob
    /// data, which can either be a bucket or directory. Does not end with a '/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub blob_storage_path_prefix: std::string::String,

    /// Output only. The number of Runs stored in this Tensorboard.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_count: i32,

    /// Output only. Timestamp when this Tensorboard was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Tensorboard was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize your Tensorboards.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Tensorboard
    /// (System labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Used to indicate if the TensorBoard instance is the default one.
    /// Each project & region can have at most one default TensorBoard instance.
    /// Creation of a default TensorBoard instance and updating an existing
    /// TensorBoard instance to be default will mark all other TensorBoard
    /// instances (if any) as non default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub is_default: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl Tensorboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tensorboard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Tensorboard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Tensorboard::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Tensorboard::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [blob_storage_path_prefix][crate::model::Tensorboard::blob_storage_path_prefix].
    pub fn set_blob_storage_path_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.blob_storage_path_prefix = v.into();
        self
    }

    /// Sets the value of [run_count][crate::model::Tensorboard::run_count].
    pub fn set_run_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.run_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Tensorboard::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Tensorboard::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Tensorboard::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [is_default][crate::model::Tensorboard::is_default].
    pub fn set_is_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_default = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Tensorboard::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Tensorboard::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Tensorboard::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for Tensorboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tensorboard"
    }
}

/// All the data stored in a TensorboardTimeSeries.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesData {
    /// Required. The ID of the TensorboardTimeSeries, which will become the final
    /// component of the TensorboardTimeSeries' resource name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series_id: std::string::String,

    /// Required. Immutable. The value type of this time series. All the values in
    /// this time series data must match this value type.
    pub value_type: crate::model::tensorboard_time_series::ValueType,

    /// Required. Data points in this time series.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::TimeSeriesDataPoint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TimeSeriesData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series_id][crate::model::TimeSeriesData::tensorboard_time_series_id].
    pub fn set_tensorboard_time_series_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series_id = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TimeSeriesData::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::tensorboard_time_series::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [values][crate::model::TimeSeriesData::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesDataPoint>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TimeSeriesData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimeSeriesData"
    }
}

/// A TensorboardTimeSeries data point.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesDataPoint {
    /// Wall clock timestamp when this data point is generated by the end user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wall_time: std::option::Option<wkt::Timestamp>,

    /// Step index of this data point within the run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub step: i64,

    /// Value of this time series data point.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::time_series_data_point::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TimeSeriesDataPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [wall_time][crate::model::TimeSeriesDataPoint::wall_time].
    pub fn set_wall_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.wall_time = v.into();
        self
    }

    /// Sets the value of [step][crate::model::TimeSeriesDataPoint::step].
    pub fn set_step<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::time_series_data_point::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::TimeSeriesDataPoint::value]
    /// if it holds a `Scalar`, `None` if the field is not set or
    /// holds a different branch.
    pub fn scalar(&self) -> std::option::Option<&std::boxed::Box<crate::model::Scalar>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::time_series_data_point::Value::Scalar(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TimeSeriesDataPoint::value]
    /// if it holds a `Tensor`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tensor(&self) -> std::option::Option<&std::boxed::Box<crate::model::TensorboardTensor>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::time_series_data_point::Value::Tensor(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TimeSeriesDataPoint::value]
    /// if it holds a `Blobs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blobs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TensorboardBlobSequence>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::time_series_data_point::Value::Blobs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value]
    /// to hold a `Scalar`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_scalar<T: std::convert::Into<std::boxed::Box<crate::model::Scalar>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::time_series_data_point::Value::Scalar(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value]
    /// to hold a `Tensor`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_tensor<T: std::convert::Into<std::boxed::Box<crate::model::TensorboardTensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::time_series_data_point::Value::Tensor(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value]
    /// to hold a `Blobs`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_blobs<
        T: std::convert::Into<std::boxed::Box<crate::model::TensorboardBlobSequence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::time_series_data_point::Value::Blobs(v.into()));
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TimeSeriesDataPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimeSeriesDataPoint"
    }
}

/// Defines additional types related to [TimeSeriesDataPoint].
#[cfg(feature = "tensorboard_service")]
pub mod time_series_data_point {
    #[allow(unused_imports)]
    use super::*;

    /// Value of this time series data point.
    #[cfg(feature = "tensorboard_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A scalar value.
        Scalar(std::boxed::Box<crate::model::Scalar>),
        /// A tensor value.
        Tensor(std::boxed::Box<crate::model::TensorboardTensor>),
        /// A blob sequence value.
        Blobs(std::boxed::Box<crate::model::TensorboardBlobSequence>),
    }
}

/// One point viewable on a scalar metric plot.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scalar {
    /// Value of the point at this step / timestamp.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub value: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl Scalar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::Scalar::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for Scalar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Scalar"
    }
}

/// One point viewable on a tensor metric plot.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardTensor {
    /// Required. Serialized form of
    /// <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto>
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub value: ::bytes::Bytes,

    /// Optional. Version number of TensorProto used to serialize
    /// [value][google.cloud.aiplatform.v1.TensorboardTensor.value].
    ///
    /// [google.cloud.aiplatform.v1.TensorboardTensor.value]: crate::model::TensorboardTensor::value
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version_number: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TensorboardTensor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TensorboardTensor::value].
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [version_number][crate::model::TensorboardTensor::version_number].
    pub fn set_version_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version_number = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TensorboardTensor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTensor"
    }
}

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardBlobSequence {
    /// List of blobs contained within the sequence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::TensorboardBlob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TensorboardBlobSequence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::TensorboardBlobSequence::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardBlob>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TensorboardBlobSequence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardBlobSequence"
    }
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardBlob {
    /// Output only. A URI safe key uniquely identifying a blob. Can be used to
    /// locate the blob stored in the Cloud Storage bucket of the consumer project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Optional. The bytes of the blob is not present unless it's returned by the
    /// ReadTensorboardBlobData endpoint.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TensorboardBlob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TensorboardBlob::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [data][crate::model::TensorboardBlob::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TensorboardBlob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardBlob"
    }
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically the
/// results of a training job run, in a Tensorboard.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardExperiment {
    /// Output only. Name of the TensorboardExperiment.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided name of this TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this TensorboardExperiment was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this TensorboardExperiment was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize your
    /// TensorboardExperiment.
    ///
    /// Label keys and values cannot be longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Dataset (System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with `aiplatform.googleapis.com/`
    /// and are immutable. The following system labels exist for each Dataset:
    ///
    /// * `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
    ///   value is the
    ///   [metadata_schema's][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]
    ///   title.
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. Source of the TensorboardExperiment. Example: a custom training
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TensorboardExperiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TensorboardExperiment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TensorboardExperiment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TensorboardExperiment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TensorboardExperiment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TensorboardExperiment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TensorboardExperiment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [source][crate::model::TensorboardExperiment::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TensorboardExperiment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TensorboardExperiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardExperiment"
    }
}

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardRun {
    /// Output only. Name of the TensorboardRun.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of this TensorboardRun.
    /// This value must be unique among all TensorboardRuns
    /// belonging to the same parent TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this TensorboardRun.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this TensorboardRun was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this TensorboardRun was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize your TensorboardRuns.
    ///
    /// This field will be used to filter and visualize Runs in the Tensorboard UI.
    /// For example, a Vertex AI training job can set a label
    /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
    /// within that job. An end user can set a label experiment_id=xxxxx for all
    /// the runs produced in a Jupyter notebook. These runs can be grouped by a
    /// label value and visualized together in the Tensorboard UI.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one TensorboardRun
    /// (System labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TensorboardRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TensorboardRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TensorboardRun::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TensorboardRun::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TensorboardRun::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TensorboardRun::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TensorboardRun::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TensorboardRun::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TensorboardRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardRun"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboard][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboard]: crate::client::TensorboardService::create_tensorboard
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardRequest {
    /// Required. The resource name of the Location to create the Tensorboard in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Tensorboard to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard: std::option::Option<crate::model::Tensorboard>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl CreateTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard][crate::model::CreateTensorboardRequest::tensorboard].
    pub fn set_tensorboard<
        T: std::convert::Into<std::option::Option<crate::model::Tensorboard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for CreateTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboard][google.cloud.aiplatform.v1.TensorboardService.GetTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboard]: crate::client::TensorboardService::get_tensorboard
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardRequest {
    /// Required. The name of the Tensorboard resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl GetTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for GetTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]: crate::client::TensorboardService::list_tensorboards
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardsRequest {
    /// Required. The resource name of the Location to list Tensorboards.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the Tensorboards that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of Tensorboards to return. The service may return
    /// fewer than this value. If unspecified, at most 100 Tensorboards are
    /// returned. The maximum value is 100; values above 100 are coerced to
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]: crate::client::TensorboardService::list_tensorboards
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardsRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]: crate::client::TensorboardService::list_tensorboards
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardsResponse {
    /// The Tensorboards mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboards: std::vec::Vec<crate::model::Tensorboard>,

    /// A token, which can be sent as
    /// [ListTensorboardsRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardsRequest.page_token]: crate::model::ListTensorboardsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboards][crate::model::ListTensorboardsResponse::tensorboards].
    pub fn set_tensorboards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensorboard>,
    {
        use std::iter::Iterator;
        self.tensorboards = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardsResponse"
    }
}

#[cfg(feature = "tensorboard_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTensorboardsResponse {
    type PageItem = crate::model::Tensorboard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboards
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboard][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboard]: crate::client::TensorboardService::update_tensorboard
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Tensorboard resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The Tensorboard's `name` field is used to identify the
    /// Tensorboard to be updated. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard: std::option::Option<crate::model::Tensorboard>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl UpdateTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard][crate::model::UpdateTensorboardRequest::tensorboard].
    pub fn set_tensorboard<
        T: std::convert::Into<std::option::Option<crate::model::Tensorboard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for UpdateTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboard][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboard]: crate::client::TensorboardService::delete_tensorboard
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardRequest {
    /// Required. The name of the Tensorboard to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl DeleteTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for DeleteTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardUsage][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage]: crate::client::TensorboardService::read_tensorboard_usage
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardUsageRequest {
    /// Required. The name of the Tensorboard resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardUsageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard][crate::model::ReadTensorboardUsageRequest::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardUsageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardUsage][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage]: crate::client::TensorboardService::read_tensorboard_usage
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardUsageResponse {
    /// Maps year-month (YYYYMM) string to per month usage data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub monthly_usage_data: std::collections::HashMap<
        std::string::String,
        crate::model::read_tensorboard_usage_response::PerMonthUsageData,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardUsageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monthly_usage_data][crate::model::ReadTensorboardUsageResponse::monthly_usage_data].
    pub fn set_monthly_usage_data<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::read_tensorboard_usage_response::PerMonthUsageData>,
    {
        use std::iter::Iterator;
        self.monthly_usage_data = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardUsageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse"
    }
}

/// Defines additional types related to [ReadTensorboardUsageResponse].
#[cfg(feature = "tensorboard_service")]
pub mod read_tensorboard_usage_response {
    #[allow(unused_imports)]
    use super::*;

    /// Per user usage data.
    #[cfg(feature = "tensorboard_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerUserUsageData {
        /// User's username
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub username: std::string::String,

        /// Number of times the user has read data within the Tensorboard.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub view_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "tensorboard_service")]
    impl PerUserUsageData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::read_tensorboard_usage_response::PerUserUsageData::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [view_count][crate::model::read_tensorboard_usage_response::PerUserUsageData::view_count].
        pub fn set_view_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.view_count = v.into();
            self
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl wkt::message::Message for PerUserUsageData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerUserUsageData"
        }
    }

    /// Per month usage data
    #[cfg(feature = "tensorboard_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerMonthUsageData {
        /// Usage data for each user in the given month.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub user_usage_data:
            std::vec::Vec<crate::model::read_tensorboard_usage_response::PerUserUsageData>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "tensorboard_service")]
    impl PerMonthUsageData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user_usage_data][crate::model::read_tensorboard_usage_response::PerMonthUsageData::user_usage_data].
        pub fn set_user_usage_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::read_tensorboard_usage_response::PerUserUsageData>,
        {
            use std::iter::Iterator;
            self.user_usage_data = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl wkt::message::Message for PerMonthUsageData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerMonthUsageData"
        }
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardSize][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize]: crate::client::TensorboardService::read_tensorboard_size
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardSizeRequest {
    /// Required. The name of the Tensorboard resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard][crate::model::ReadTensorboardSizeRequest::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardSizeRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardSize][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize]: crate::client::TensorboardService::read_tensorboard_size
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardSizeResponse {
    /// Payload storage size for the TensorBoard
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub storage_size_byte: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardSizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_size_byte][crate::model::ReadTensorboardSizeResponse::storage_size_byte].
    pub fn set_storage_size_byte<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.storage_size_byte = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardSizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardSizeResponse"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardExperiment]: crate::client::TensorboardService::create_tensorboard_experiment
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardExperimentRequest {
    /// Required. The resource name of the Tensorboard to create the
    /// TensorboardExperiment in. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The TensorboardExperiment to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_experiment: std::option::Option<crate::model::TensorboardExperiment>,

    /// Required. The ID to use for the Tensorboard experiment, which becomes the
    /// final component of the Tensorboard experiment's resource name.
    ///
    /// This value should be 1-128 characters, and valid characters
    /// are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_experiment_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl CreateTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardExperimentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiment][crate::model::CreateTensorboardExperimentRequest::tensorboard_experiment].
    pub fn set_tensorboard_experiment<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardExperiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiment_id][crate::model::CreateTensorboardExperimentRequest::tensorboard_experiment_id].
    pub fn set_tensorboard_experiment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment_id = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for CreateTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.GetTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboardExperiment]: crate::client::TensorboardService::get_tensorboard_experiment
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardExperimentRequest {
    /// Required. The name of the TensorboardExperiment resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl GetTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for GetTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]: crate::client::TensorboardService::list_tensorboard_experiments
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardExperimentsRequest {
    /// Required. The resource name of the Tensorboard to list
    /// TensorboardExperiments. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the TensorboardExperiments that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of TensorboardExperiments to return. The service may
    /// return fewer than this value. If unspecified, at most 50
    /// TensorboardExperiments are returned. The maximum value is 1000; values
    /// above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]: crate::client::TensorboardService::list_tensorboard_experiments
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardExperimentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardExperimentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardExperimentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardExperimentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardExperimentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardExperimentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardExperimentsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardExperimentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]: crate::client::TensorboardService::list_tensorboard_experiments
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardExperimentsResponse {
    /// The TensorboardExperiments mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_experiments: std::vec::Vec<crate::model::TensorboardExperiment>,

    /// A token, which can be sent as
    /// [ListTensorboardExperimentsRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest.page_token]: crate::model::ListTensorboardExperimentsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardExperimentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardExperimentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiments][crate::model::ListTensorboardExperimentsResponse::tensorboard_experiments].
    pub fn set_tensorboard_experiments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardExperiment>,
    {
        use std::iter::Iterator;
        self.tensorboard_experiments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardExperimentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardExperimentsResponse"
    }
}

#[cfg(feature = "tensorboard_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTensorboardExperimentsResponse {
    type PageItem = crate::model::TensorboardExperiment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboard_experiments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardExperiment]: crate::client::TensorboardService::update_tensorboard_experiment
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardExperimentRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// TensorboardExperiment resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The TensorboardExperiment's `name` field is used to identify the
    /// TensorboardExperiment to be updated. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_experiment: std::option::Option<crate::model::TensorboardExperiment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl UpdateTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardExperimentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiment][crate::model::UpdateTensorboardExperimentRequest::tensorboard_experiment].
    pub fn set_tensorboard_experiment<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardExperiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for UpdateTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardExperiment]: crate::client::TensorboardService::delete_tensorboard_experiment
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardExperimentRequest {
    /// Required. The name of the TensorboardExperiment to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl DeleteTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for DeleteTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.BatchCreateTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns]: crate::client::TensorboardService::batch_create_tensorboard_runs
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardRunsRequest {
    /// Required. The resource name of the TensorboardExperiment to create the
    /// TensorboardRuns in. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    /// The parent field in the CreateTensorboardRunRequest messages must match
    /// this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the TensorboardRuns to create.
    /// A maximum of 1000 TensorboardRuns can be created in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateTensorboardRunRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl BatchCreateTensorboardRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateTensorboardRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateTensorboardRunsRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateTensorboardRunRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for BatchCreateTensorboardRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardRunsRequest"
    }
}

/// Response message for
/// [TensorboardService.BatchCreateTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns]: crate::client::TensorboardService::batch_create_tensorboard_runs
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardRunsResponse {
    /// The created TensorboardRuns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_runs: std::vec::Vec<crate::model::TensorboardRun>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl BatchCreateTensorboardRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_runs][crate::model::BatchCreateTensorboardRunsResponse::tensorboard_runs].
    pub fn set_tensorboard_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardRun>,
    {
        use std::iter::Iterator;
        self.tensorboard_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for BatchCreateTensorboardRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardRunsResponse"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardRun]: crate::client::TensorboardService::create_tensorboard_run
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardRunRequest {
    /// Required. The resource name of the TensorboardExperiment to create the
    /// TensorboardRun in. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The TensorboardRun to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_run: std::option::Option<crate::model::TensorboardRun>,

    /// Required. The ID to use for the Tensorboard run, which becomes the final
    /// component of the Tensorboard run's resource name.
    ///
    /// This value should be 1-128 characters, and valid characters
    /// are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_run_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl CreateTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardRunRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard_run][crate::model::CreateTensorboardRunRequest::tensorboard_run].
    pub fn set_tensorboard_run<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_run = v.into();
        self
    }

    /// Sets the value of [tensorboard_run_id][crate::model::CreateTensorboardRunRequest::tensorboard_run_id].
    pub fn set_tensorboard_run_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_run_id = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for CreateTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.GetTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboardRun]: crate::client::TensorboardService::get_tensorboard_run
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardRunRequest {
    /// Required. The name of the TensorboardRun resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl GetTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for GetTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardBlobData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardBlobData].
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardBlobDataRequest {
    /// Required. The resource name of the TensorboardTimeSeries to list Blobs.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_series: std::string::String,

    /// IDs of the blobs to read.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blob_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardBlobDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series][crate::model::ReadTensorboardBlobDataRequest::time_series].
    pub fn set_time_series<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_series = v.into();
        self
    }

    /// Sets the value of [blob_ids][crate::model::ReadTensorboardBlobDataRequest::blob_ids].
    pub fn set_blob_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.blob_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardBlobDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardBlobDataRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardBlobData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardBlobData].
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardBlobDataResponse {
    /// Blob messages containing blob bytes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blobs: std::vec::Vec<crate::model::TensorboardBlob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardBlobDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blobs][crate::model::ReadTensorboardBlobDataResponse::blobs].
    pub fn set_blobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardBlob>,
    {
        use std::iter::Iterator;
        self.blobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardBlobDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardBlobDataResponse"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]: crate::client::TensorboardService::list_tensorboard_runs
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardRunsRequest {
    /// Required. The resource name of the TensorboardExperiment to list
    /// TensorboardRuns. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the TensorboardRuns that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of TensorboardRuns to return. The service may return
    /// fewer than this value. If unspecified, at most 50 TensorboardRuns are
    /// returned. The maximum value is 1000; values above 1000 are coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]: crate::client::TensorboardService::list_tensorboard_runs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardRunsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardRunsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardRunsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardRunsRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]: crate::client::TensorboardService::list_tensorboard_runs
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardRunsResponse {
    /// The TensorboardRuns mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_runs: std::vec::Vec<crate::model::TensorboardRun>,

    /// A token, which can be sent as
    /// [ListTensorboardRunsRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardRunsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardRunsRequest.page_token]: crate::model::ListTensorboardRunsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboard_runs][crate::model::ListTensorboardRunsResponse::tensorboard_runs].
    pub fn set_tensorboard_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardRun>,
    {
        use std::iter::Iterator;
        self.tensorboard_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardRunsResponse"
    }
}

#[cfg(feature = "tensorboard_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTensorboardRunsResponse {
    type PageItem = crate::model::TensorboardRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboard_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardRun]: crate::client::TensorboardService::update_tensorboard_run
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardRunRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// TensorboardRun resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The TensorboardRun's `name` field is used to identify the
    /// TensorboardRun to be updated. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_run: std::option::Option<crate::model::TensorboardRun>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl UpdateTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardRunRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard_run][crate::model::UpdateTensorboardRunRequest::tensorboard_run].
    pub fn set_tensorboard_run<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_run = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for UpdateTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardRun]: crate::client::TensorboardService::delete_tensorboard_run
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardRunRequest {
    /// Required. The name of the TensorboardRun to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl DeleteTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for DeleteTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries]: crate::client::TensorboardService::batch_create_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardTimeSeriesRequest {
    /// Required. The resource name of the TensorboardExperiment to create the
    /// TensorboardTimeSeries in.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    /// The TensorboardRuns referenced by the parent fields in the
    /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
    /// TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the TensorboardTimeSeries to
    /// create. A maximum of 1000 TensorboardTimeSeries can be created in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateTensorboardTimeSeriesRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl BatchCreateTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateTensorboardTimeSeriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateTensorboardTimeSeriesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateTensorboardTimeSeriesRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for BatchCreateTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesRequest"
    }
}

/// Response message for
/// [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries]: crate::client::TensorboardService::batch_create_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardTimeSeriesResponse {
    /// The created TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_time_series: std::vec::Vec<crate::model::TensorboardTimeSeries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl BatchCreateTensorboardTimeSeriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series][crate::model::BatchCreateTensorboardTimeSeriesResponse::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardTimeSeries>,
    {
        use std::iter::Iterator;
        self.tensorboard_time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for BatchCreateTensorboardTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesResponse"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardTimeSeries]: crate::client::TensorboardService::create_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardTimeSeriesRequest {
    /// Required. The resource name of the TensorboardRun to create the
    /// TensorboardTimeSeries in.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The user specified unique ID to use for the
    /// TensorboardTimeSeries, which becomes the final component of the
    /// TensorboardTimeSeries's resource name. This value should match
    /// "[a-z0-9][a-z0-9-]{0, 127}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series_id: std::string::String,

    /// Required. The TensorboardTimeSeries to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_time_series: std::option::Option<crate::model::TensorboardTimeSeries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl CreateTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardTimeSeriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series_id][crate::model::CreateTensorboardTimeSeriesRequest::tensorboard_time_series_id].
    pub fn set_tensorboard_time_series_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series_id = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series][crate::model::CreateTensorboardTimeSeriesRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardTimeSeries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for CreateTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.GetTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboardTimeSeries]: crate::client::TensorboardService::get_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardTimeSeriesRequest {
    /// Required. The name of the TensorboardTimeSeries resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl GetTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for GetTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]: crate::client::TensorboardService::list_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardTimeSeriesRequest {
    /// Required. The resource name of the TensorboardRun to list
    /// TensorboardTimeSeries. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the TensorboardTimeSeries that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of TensorboardTimeSeries to return. The service may
    /// return fewer than this value. If unspecified, at most 50
    /// TensorboardTimeSeries are returned. The maximum value is 1000; values
    /// above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]: crate::client::TensorboardService::list_tensorboard_time_series
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardTimeSeriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardTimeSeriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardTimeSeriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardTimeSeriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardTimeSeriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardTimeSeriesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]: crate::client::TensorboardService::list_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardTimeSeriesResponse {
    /// The TensorboardTimeSeries mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_time_series: std::vec::Vec<crate::model::TensorboardTimeSeries>,

    /// A token, which can be sent as
    /// [ListTensorboardTimeSeriesRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest.page_token]: crate::model::ListTensorboardTimeSeriesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ListTensorboardTimeSeriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardTimeSeriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series][crate::model::ListTensorboardTimeSeriesResponse::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardTimeSeries>,
    {
        use std::iter::Iterator;
        self.tensorboard_time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ListTensorboardTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardTimeSeriesResponse"
    }
}

#[cfg(feature = "tensorboard_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTensorboardTimeSeriesResponse {
    type PageItem = crate::model::TensorboardTimeSeries;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboard_time_series
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardTimeSeries]: crate::client::TensorboardService::update_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardTimeSeriesRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// TensorboardTimeSeries resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The TensorboardTimeSeries' `name` field is used to identify the
    /// TensorboardTimeSeries to be updated.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_time_series: std::option::Option<crate::model::TensorboardTimeSeries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl UpdateTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardTimeSeriesRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series][crate::model::UpdateTensorboardTimeSeriesRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardTimeSeries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for UpdateTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardTimeSeries]: crate::client::TensorboardService::delete_tensorboard_time_series
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardTimeSeriesRequest {
    /// Required. The name of the TensorboardTimeSeries to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl DeleteTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for DeleteTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.BatchReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData]: crate::client::TensorboardService::batch_read_tensorboard_time_series_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadTensorboardTimeSeriesDataRequest {
    /// Required. The resource name of the Tensorboard containing
    /// TensorboardTimeSeries to read data from. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`.
    /// The TensorboardTimeSeries referenced by
    /// [time_series][google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest.time_series]
    /// must be sub resources of this Tensorboard.
    ///
    /// [google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest.time_series]: crate::model::BatchReadTensorboardTimeSeriesDataRequest::time_series
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,

    /// Required. The resource names of the TensorboardTimeSeries to read data
    /// from. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl BatchReadTensorboardTimeSeriesDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard][crate::model::BatchReadTensorboardTimeSeriesDataRequest::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }

    /// Sets the value of [time_series][crate::model::BatchReadTensorboardTimeSeriesDataRequest::time_series].
    pub fn set_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for BatchReadTensorboardTimeSeriesDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest"
    }
}

/// Response message for
/// [TensorboardService.BatchReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData]: crate::client::TensorboardService::batch_read_tensorboard_time_series_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadTensorboardTimeSeriesDataResponse {
    /// The returned time series data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data: std::vec::Vec<crate::model::TimeSeriesData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl BatchReadTensorboardTimeSeriesDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_data][crate::model::BatchReadTensorboardTimeSeriesDataResponse::time_series_data].
    pub fn set_time_series_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesData>,
    {
        use std::iter::Iterator;
        self.time_series_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for BatchReadTensorboardTimeSeriesDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataResponse"
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData]: crate::client::TensorboardService::read_tensorboard_time_series_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardTimeSeriesDataRequest {
    /// Required. The resource name of the TensorboardTimeSeries to read data from.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series: std::string::String,

    /// The maximum number of TensorboardTimeSeries' data to return.
    ///
    /// This value should be a positive integer.
    /// This value can be set to -1 to return all data.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_data_points: i32,

    /// Reads the TensorboardTimeSeries' data that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardTimeSeriesDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series][crate::model::ReadTensorboardTimeSeriesDataRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }

    /// Sets the value of [max_data_points][crate::model::ReadTensorboardTimeSeriesDataRequest::max_data_points].
    pub fn set_max_data_points<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_data_points = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ReadTensorboardTimeSeriesDataRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardTimeSeriesDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData]: crate::client::TensorboardService::read_tensorboard_time_series_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardTimeSeriesDataResponse {
    /// The returned time series data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_series_data: std::option::Option<crate::model::TimeSeriesData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ReadTensorboardTimeSeriesDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_data][crate::model::ReadTensorboardTimeSeriesDataResponse::time_series_data].
    pub fn set_time_series_data<
        T: std::convert::Into<std::option::Option<crate::model::TimeSeriesData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_series_data = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ReadTensorboardTimeSeriesDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataResponse"
    }
}

/// Request message for
/// [TensorboardService.WriteTensorboardExperimentData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData]: crate::client::TensorboardService::write_tensorboard_experiment_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardExperimentDataRequest {
    /// Required. The resource name of the TensorboardExperiment to write data to.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_experiment: std::string::String,

    /// Required. Requests containing per-run TensorboardTimeSeries data to write.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub write_run_data_requests: std::vec::Vec<crate::model::WriteTensorboardRunDataRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl WriteTensorboardExperimentDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_experiment][crate::model::WriteTensorboardExperimentDataRequest::tensorboard_experiment].
    pub fn set_tensorboard_experiment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment = v.into();
        self
    }

    /// Sets the value of [write_run_data_requests][crate::model::WriteTensorboardExperimentDataRequest::write_run_data_requests].
    pub fn set_write_run_data_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WriteTensorboardRunDataRequest>,
    {
        use std::iter::Iterator;
        self.write_run_data_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for WriteTensorboardExperimentDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardExperimentDataRequest"
    }
}

/// Response message for
/// [TensorboardService.WriteTensorboardExperimentData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData]: crate::client::TensorboardService::write_tensorboard_experiment_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardExperimentDataResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl WriteTensorboardExperimentDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for WriteTensorboardExperimentDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardExperimentDataResponse"
    }
}

/// Request message for
/// [TensorboardService.WriteTensorboardRunData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData]: crate::client::TensorboardService::write_tensorboard_run_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardRunDataRequest {
    /// Required. The resource name of the TensorboardRun to write data to.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_run: std::string::String,

    /// Required. The TensorboardTimeSeries data to write.
    /// Values with in a time series are indexed by their step value.
    /// Repeated writes to the same step will overwrite the existing value for that
    /// step.
    /// The upper limit of data points per write request is 5000.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data: std::vec::Vec<crate::model::TimeSeriesData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl WriteTensorboardRunDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_run][crate::model::WriteTensorboardRunDataRequest::tensorboard_run].
    pub fn set_tensorboard_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard_run = v.into();
        self
    }

    /// Sets the value of [time_series_data][crate::model::WriteTensorboardRunDataRequest::time_series_data].
    pub fn set_time_series_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesData>,
    {
        use std::iter::Iterator;
        self.time_series_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for WriteTensorboardRunDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardRunDataRequest"
    }
}

/// Response message for
/// [TensorboardService.WriteTensorboardRunData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData]: crate::client::TensorboardService::write_tensorboard_run_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardRunDataResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl WriteTensorboardRunDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for WriteTensorboardRunDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardRunDataResponse"
    }
}

/// Request message for
/// [TensorboardService.ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]: crate::client::TensorboardService::export_tensorboard_time_series_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportTensorboardTimeSeriesDataRequest {
    /// Required. The resource name of the TensorboardTimeSeries to export data
    /// from. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series: std::string::String,

    /// Exports the TensorboardTimeSeries' data that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of data points to return per page.
    /// The default page_size is 1000. Values must be between 1 and 10000.
    /// Values above 10000 are coerced to 10000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]: crate::client::TensorboardService::export_tensorboard_time_series_data
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the TensorboardTimeSeries' data.
    /// By default, TensorboardTimeSeries' data is returned in a pseudo random
    /// order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ExportTensorboardTimeSeriesDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series][crate::model::ExportTensorboardTimeSeriesDataRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ExportTensorboardTimeSeriesDataRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ExportTensorboardTimeSeriesDataRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ExportTensorboardTimeSeriesDataRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ExportTensorboardTimeSeriesDataRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ExportTensorboardTimeSeriesDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest"
    }
}

/// Response message for
/// [TensorboardService.ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]: crate::client::TensorboardService::export_tensorboard_time_series_data
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportTensorboardTimeSeriesDataResponse {
    /// The returned time series data points.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data_points: std::vec::Vec<crate::model::TimeSeriesDataPoint>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest.page_token]: crate::model::ExportTensorboardTimeSeriesDataRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl ExportTensorboardTimeSeriesDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ExportTensorboardTimeSeriesDataResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [time_series_data_points][crate::model::ExportTensorboardTimeSeriesDataResponse::time_series_data_points].
    pub fn set_time_series_data_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesDataPoint>,
    {
        use std::iter::Iterator;
        self.time_series_data_points = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for ExportTensorboardTimeSeriesDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataResponse"
    }
}

#[cfg(feature = "tensorboard_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ExportTensorboardTimeSeriesDataResponse {
    type PageItem = crate::model::TimeSeriesDataPoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.time_series_data_points
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Details of operations that perform create Tensorboard.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardOperationMetadata {
    /// Operation metadata for Tensorboard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl CreateTensorboardOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateTensorboardOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for CreateTensorboardOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardOperationMetadata"
    }
}

/// Details of operations that perform update Tensorboard.
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardOperationMetadata {
    /// Operation metadata for Tensorboard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl UpdateTensorboardOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateTensorboardOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for UpdateTensorboardOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardOperationMetadata"
    }
}

/// TensorboardTimeSeries maps to times series produced in training runs
#[cfg(feature = "tensorboard_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardTimeSeries {
    /// Output only. Name of the TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of this TensorboardTimeSeries.
    /// This value should be unique among all TensorboardTimeSeries resources
    /// belonging to the same TensorboardRun resource (parent resource).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Immutable. Type of TensorboardTimeSeries value.
    pub value_type: crate::model::tensorboard_time_series::ValueType,

    /// Output only. Timestamp when this TensorboardTimeSeries was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this TensorboardTimeSeries was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. Name of the plugin this time series pertain to. Such as Scalar,
    /// Tensor, Blob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub plugin_name: std::string::String,

    /// Data of the current plugin, with the size limited to 65KB.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plugin_data: ::bytes::Bytes,

    /// Output only. Scalar, Tensor, or Blob metadata for this
    /// TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::tensorboard_time_series::Metadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "tensorboard_service")]
impl TensorboardTimeSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TensorboardTimeSeries::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TensorboardTimeSeries::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TensorboardTimeSeries::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TensorboardTimeSeries::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::tensorboard_time_series::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TensorboardTimeSeries::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TensorboardTimeSeries::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TensorboardTimeSeries::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [plugin_name][crate::model::TensorboardTimeSeries::plugin_name].
    pub fn set_plugin_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.plugin_name = v.into();
        self
    }

    /// Sets the value of [plugin_data][crate::model::TensorboardTimeSeries::plugin_data].
    pub fn set_plugin_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.plugin_data = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::TensorboardTimeSeries::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::tensorboard_time_series::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }
}

#[cfg(feature = "tensorboard_service")]
impl wkt::message::Message for TensorboardTimeSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTimeSeries"
    }
}

/// Defines additional types related to [TensorboardTimeSeries].
#[cfg(feature = "tensorboard_service")]
pub mod tensorboard_time_series {
    #[allow(unused_imports)]
    use super::*;

    /// Describes metadata for a TensorboardTimeSeries.
    #[cfg(feature = "tensorboard_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metadata {
        /// Output only. Max step index of all data points within a
        /// TensorboardTimeSeries.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_step: i64,

        /// Output only. Max wall clock timestamp of all data points within a
        /// TensorboardTimeSeries.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_wall_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The largest blob sequence length (number of blobs) of all
        /// data points in this time series, if its ValueType is BLOB_SEQUENCE.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_blob_sequence_length: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "tensorboard_service")]
    impl Metadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_step][crate::model::tensorboard_time_series::Metadata::max_step].
        pub fn set_max_step<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_step = v.into();
            self
        }

        /// Sets the value of [max_wall_time][crate::model::tensorboard_time_series::Metadata::max_wall_time].
        pub fn set_max_wall_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_wall_time = v.into();
            self
        }

        /// Sets the value of [max_blob_sequence_length][crate::model::tensorboard_time_series::Metadata::max_blob_sequence_length].
        pub fn set_max_blob_sequence_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_blob_sequence_length = v.into();
            self
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl wkt::message::Message for Metadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTimeSeries.Metadata"
        }
    }

    /// An enum representing the value type of a TensorboardTimeSeries.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "tensorboard_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// The value type is unspecified.
        Unspecified,
        /// Used for TensorboardTimeSeries that is a list of scalars.
        /// E.g. accuracy of a model over epochs/time.
        Scalar,
        /// Used for TensorboardTimeSeries that is a list of tensors.
        /// E.g. histograms of weights of layer in a model over epoch/time.
        Tensor,
        /// Used for TensorboardTimeSeries that is a list of blob sequences.
        /// E.g. set of sample images with labels over epochs/time.
        BlobSequence,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "tensorboard_service")]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "tensorboard_service")]
    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scalar => std::option::Option::Some(1),
                Self::Tensor => std::option::Option::Some(2),
                Self::BlobSequence => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::Scalar => std::option::Option::Some("SCALAR"),
                Self::Tensor => std::option::Option::Some("TENSOR"),
                Self::BlobSequence => std::option::Option::Some("BLOB_SEQUENCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scalar,
                2 => Self::Tensor,
                3 => Self::BlobSequence,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCALAR" => Self::Scalar,
                "TENSOR" => Self::Tensor,
                "BLOB_SEQUENCE" => Self::BlobSequence,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scalar => serializer.serialize_i32(1),
                Self::Tensor => serializer.serialize_i32(2),
                Self::BlobSequence => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "tensorboard_service")]
    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.aiplatform.v1.TensorboardTimeSeries.ValueType",
            ))
        }
    }
}

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model. A Tool object should contain exactly
/// one type of Tool (e.g FunctionDeclaration, Retrieval or
/// GoogleSearchRetrieval).
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tool {
    /// Optional. Function tool type.
    /// One or more function declarations to be passed to the model along with the
    /// current user query. Model may decide to call a subset of these functions
    /// by populating [FunctionCall][google.cloud.aiplatform.v1.Part.function_call]
    /// in the response. User should provide a
    /// [FunctionResponse][google.cloud.aiplatform.v1.Part.function_response] for
    /// each function call in the next turn. Based on the function responses, Model
    /// will generate the final response back to the user. Maximum 128 function
    /// declarations can be provided.
    ///
    /// [google.cloud.aiplatform.v1.Part.function_call]: crate::model::Part::data
    /// [google.cloud.aiplatform.v1.Part.function_response]: crate::model::Part::data
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub function_declarations: std::vec::Vec<crate::model::FunctionDeclaration>,

    /// Optional. Retrieval tool type.
    /// System will always execute the provided retrieval tool(s) to get external
    /// knowledge to answer the prompt. Retrieval results are presented to the
    /// model for generation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retrieval: std::option::Option<crate::model::Retrieval>,

    /// Optional. GoogleSearch tool type.
    /// Tool to support Google Search in Model. Powered by Google.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_search: std::option::Option<crate::model::tool::GoogleSearch>,

    /// Optional. GoogleSearchRetrieval tool type.
    /// Specialized retrieval tool that is powered by Google search.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_search_retrieval: std::option::Option<crate::model::GoogleSearchRetrieval>,

    /// Optional. Tool to support searching public web data, powered by Vertex AI
    /// Search and Sec4 compliance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enterprise_web_search: std::option::Option<crate::model::EnterpriseWebSearch>,

    /// Optional. CodeExecution tool type.
    /// Enables the model to execute code as part of generation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub code_execution: std::option::Option<crate::model::tool::CodeExecution>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl Tool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retrieval][crate::model::Tool::retrieval].
    pub fn set_retrieval<T: std::convert::Into<std::option::Option<crate::model::Retrieval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retrieval = v.into();
        self
    }

    /// Sets the value of [google_search][crate::model::Tool::google_search].
    pub fn set_google_search<
        T: std::convert::Into<std::option::Option<crate::model::tool::GoogleSearch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_search = v.into();
        self
    }

    /// Sets the value of [google_search_retrieval][crate::model::Tool::google_search_retrieval].
    pub fn set_google_search_retrieval<
        T: std::convert::Into<std::option::Option<crate::model::GoogleSearchRetrieval>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_search_retrieval = v.into();
        self
    }

    /// Sets the value of [enterprise_web_search][crate::model::Tool::enterprise_web_search].
    pub fn set_enterprise_web_search<
        T: std::convert::Into<std::option::Option<crate::model::EnterpriseWebSearch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_web_search = v.into();
        self
    }

    /// Sets the value of [code_execution][crate::model::Tool::code_execution].
    pub fn set_code_execution<
        T: std::convert::Into<std::option::Option<crate::model::tool::CodeExecution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.code_execution = v.into();
        self
    }

    /// Sets the value of [function_declarations][crate::model::Tool::function_declarations].
    pub fn set_function_declarations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FunctionDeclaration>,
    {
        use std::iter::Iterator;
        self.function_declarations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for Tool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tool"
    }
}

/// Defines additional types related to [Tool].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
pub mod tool {
    #[allow(unused_imports)]
    use super::*;

    /// GoogleSearch tool type.
    /// Tool to support Google Search in Model. Powered by Google.
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GoogleSearch {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl GoogleSearch {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl wkt::message::Message for GoogleSearch {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Tool.GoogleSearch"
        }
    }

    /// Tool that executes code generated by the model, and automatically returns
    /// the result to the model.
    ///
    /// See also [ExecutableCode]and [CodeExecutionResult] which are input and
    /// output to this tool.
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CodeExecution {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl CodeExecution {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl wkt::message::Message for CodeExecution {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Tool.CodeExecution"
        }
    }
}

/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
/// in this declaration are the function name, description, parameters and
/// response type. This FunctionDeclaration is a representation of a block of
/// code that can be used as a `Tool` by the model and executed by the client.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionDeclaration {
    /// Required. The name of the function to call.
    /// Must start with a letter or an underscore.
    /// Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a
    /// maximum length of 64.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description and purpose of the function.
    /// Model uses it to decide how and whether to call the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Describes the parameters to this function in JSON Schema Object
    /// format. Reflects the Open API 3.03 Parameter Object. string Key: the name
    /// of the parameter. Parameter names are case sensitive. Schema Value: the
    /// Schema defining the type used for the parameter. For function with no
    /// parameters, this can be left unset. Parameter names must start with a
    /// letter or an underscore and must only contain chars a-z, A-Z, 0-9, or
    /// underscores with a maximum length of 64. Example with 1 required and 1
    /// optional parameter: type: OBJECT properties:
    /// param1:
    /// type: STRING
    /// param2:
    /// type: INTEGER
    /// required:
    ///
    /// - param1
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Schema>,

    /// Optional. Describes the output from this function in JSON Schema format.
    /// Reflects the Open API 3.03 Response Object. The Schema defines the type
    /// used for the response value of the function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::Schema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl FunctionDeclaration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FunctionDeclaration::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FunctionDeclaration::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::FunctionDeclaration::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [response][crate::model::FunctionDeclaration::response].
    pub fn set_response<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for FunctionDeclaration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionDeclaration"
    }
}

/// A predicted [FunctionCall] returned from the model that contains a string
/// representing the [FunctionDeclaration.name] and a structured JSON object
/// containing the parameters and their values.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionCall {
    /// Required. The name of the function to call.
    /// Matches [FunctionDeclaration.name].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Required. The function parameters and values in JSON object
    /// format. See [FunctionDeclaration.parameters] for parameter details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub args: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl FunctionCall {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FunctionCall::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [args][crate::model::FunctionCall::args].
    pub fn set_args<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.args = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for FunctionCall {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionCall"
    }
}

/// The result output from a [FunctionCall] that contains a string representing
/// the [FunctionDeclaration.name] and a structured JSON object containing any
/// output from the function is used as context to the model. This should contain
/// the result of a [FunctionCall] made based on model prediction.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionResponse {
    /// Required. The name of the function to call.
    /// Matches [FunctionDeclaration.name] and [FunctionCall.name].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The function response in JSON object format.
    /// Use "output" key to specify function output and "error" key to specify
    /// error details (if any). If "output" and "error" keys are not specified,
    /// then whole "response" is treated as function output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl FunctionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FunctionResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [response][crate::model::FunctionResponse::response].
    pub fn set_response<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for FunctionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionResponse"
    }
}

/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Generated when using the [FunctionDeclaration] tool and
/// [FunctionCallingConfig] mode is set to [Mode.CODE].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutableCode {
    /// Required. Programming language of the `code`.
    pub language: crate::model::executable_code::Language,

    /// Required. The code to be executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl ExecutableCode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language][crate::model::ExecutableCode::language].
    pub fn set_language<T: std::convert::Into<crate::model::executable_code::Language>>(
        mut self,
        v: T,
    ) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [code][crate::model::ExecutableCode::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for ExecutableCode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExecutableCode"
    }
}

/// Defines additional types related to [ExecutableCode].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
pub mod executable_code {
    #[allow(unused_imports)]
    use super::*;

    /// Supported programming languages for the generated code.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Language {
        /// Unspecified language. This value should not be used.
        Unspecified,
        /// Python >= 3.10, with numpy and simpy available.
        Python,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Language::value] or
        /// [Language::name].
        UnknownValue(language::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    pub mod language {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl Language {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Python => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LANGUAGE_UNSPECIFIED"),
                Self::Python => std::option::Option::Some("PYTHON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::default::Default for Language {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::fmt::Display for Language {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::convert::From<i32> for Language {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Python,
                _ => Self::UnknownValue(language::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::convert::From<&str> for Language {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LANGUAGE_UNSPECIFIED" => Self::Unspecified,
                "PYTHON" => Self::Python,
                _ => Self::UnknownValue(language::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl serde::ser::Serialize for Language {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Python => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Language {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Language>::new(
                ".google.cloud.aiplatform.v1.ExecutableCode.Language",
            ))
        }
    }
}

/// Result of executing the [ExecutableCode].
///
/// Always follows a `part` containing the [ExecutableCode].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CodeExecutionResult {
    /// Required. Outcome of the code execution.
    pub outcome: crate::model::code_execution_result::Outcome,

    /// Optional. Contains stdout when code execution is successful, stderr or
    /// other description otherwise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl CodeExecutionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [outcome][crate::model::CodeExecutionResult::outcome].
    pub fn set_outcome<T: std::convert::Into<crate::model::code_execution_result::Outcome>>(
        mut self,
        v: T,
    ) -> Self {
        self.outcome = v.into();
        self
    }

    /// Sets the value of [output][crate::model::CodeExecutionResult::output].
    pub fn set_output<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for CodeExecutionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CodeExecutionResult"
    }
}

/// Defines additional types related to [CodeExecutionResult].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "gen_ai_tuning_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
pub mod code_execution_result {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of possible outcomes of the code execution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Outcome {
        /// Unspecified status. This value should not be used.
        Unspecified,
        /// Code execution completed successfully.
        Ok,
        /// Code execution finished but with a failure. `stderr` should contain the
        /// reason.
        Failed,
        /// Code execution ran for too long, and was cancelled. There may or may not
        /// be a partial output present.
        DeadlineExceeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Outcome::value] or
        /// [Outcome::name].
        UnknownValue(outcome::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    pub mod outcome {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl Outcome {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OUTCOME_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OUTCOME_OK"),
                Self::Failed => std::option::Option::Some("OUTCOME_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("OUTCOME_DEADLINE_EXCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::default::Default for Outcome {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::fmt::Display for Outcome {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::convert::From<i32> for Outcome {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::Failed,
                3 => Self::DeadlineExceeded,
                _ => Self::UnknownValue(outcome::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl std::convert::From<&str> for Outcome {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OUTCOME_UNSPECIFIED" => Self::Unspecified,
                "OUTCOME_OK" => Self::Ok,
                "OUTCOME_FAILED" => Self::Failed,
                "OUTCOME_DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                _ => Self::UnknownValue(outcome::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl serde::ser::Serialize for Outcome {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "gen_ai_tuning_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Outcome {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Outcome>::new(
                ".google.cloud.aiplatform.v1.CodeExecutionResult.Outcome",
            ))
        }
    }
}

/// Defines a retrieval tool that model can call to access external knowledge.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Retrieval {
    /// Optional. Deprecated. This option is no longer supported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub disable_attribution: bool,

    /// The source of the retrieval.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::retrieval::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl Retrieval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_attribution][crate::model::Retrieval::disable_attribution].
    #[deprecated]
    pub fn set_disable_attribution<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_attribution = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Retrieval::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::retrieval::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Retrieval::source]
    /// if it holds a `VertexAiSearch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_ai_search(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexAISearch>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::retrieval::Source::VertexAiSearch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Retrieval::source]
    /// if it holds a `VertexRagStore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_rag_store(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexRagStore>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::retrieval::Source::VertexRagStore(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Retrieval::source]
    /// to hold a `VertexAiSearch`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_vertex_ai_search<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexAISearch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::retrieval::Source::VertexAiSearch(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Retrieval::source]
    /// to hold a `VertexRagStore`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_store<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexRagStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::retrieval::Source::VertexRagStore(v.into()));
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for Retrieval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Retrieval"
    }
}

/// Defines additional types related to [Retrieval].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
pub mod retrieval {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the retrieval.
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Set to use data source powered by Vertex AI Search.
        VertexAiSearch(std::boxed::Box<crate::model::VertexAISearch>),
        /// Set to use data source powered by Vertex RAG store.
        /// User data is uploaded via the VertexRagDataService.
        VertexRagStore(std::boxed::Box<crate::model::VertexRagStore>),
    }
}

/// Retrieve from Vertex RAG Store for grounding.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexRagStore {
    /// Optional. The representation of the rag source. It can be used to specify
    /// corpus only or ragfiles. Currently only support one corpus or multiple
    /// files from one corpus. In the future we may open up multiple corpora
    /// support.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rag_resources: std::vec::Vec<crate::model::vertex_rag_store::RagResource>,

    /// Optional. Number of top k results to return from the selected corpora.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub similarity_top_k: std::option::Option<i32>,

    /// Optional. Only return results with vector distance smaller than the
    /// threshold.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub vector_distance_threshold: std::option::Option<f64>,

    /// Optional. The retrieval config for the Rag query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_retrieval_config: std::option::Option<crate::model::RagRetrievalConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl VertexRagStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [similarity_top_k][crate::model::VertexRagStore::similarity_top_k].
    #[deprecated]
    pub fn set_similarity_top_k<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.similarity_top_k = v.into();
        self
    }

    /// Sets the value of [vector_distance_threshold][crate::model::VertexRagStore::vector_distance_threshold].
    #[deprecated]
    pub fn set_vector_distance_threshold<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vector_distance_threshold = v.into();
        self
    }

    /// Sets the value of [rag_retrieval_config][crate::model::VertexRagStore::rag_retrieval_config].
    pub fn set_rag_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::RagRetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_retrieval_config = v.into();
        self
    }

    /// Sets the value of [rag_resources][crate::model::VertexRagStore::rag_resources].
    pub fn set_rag_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vertex_rag_store::RagResource>,
    {
        use std::iter::Iterator;
        self.rag_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for VertexRagStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexRagStore"
    }
}

/// Defines additional types related to [VertexRagStore].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
pub mod vertex_rag_store {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of the Rag resource.
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RagResource {
        /// Optional. RagCorpora resource name.
        /// Format:
        /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub rag_corpus: std::string::String,

        /// Optional. rag_file_id. The files should be in the same rag_corpus set in
        /// rag_corpus field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rag_file_ids: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl RagResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rag_corpus][crate::model::vertex_rag_store::RagResource::rag_corpus].
        pub fn set_rag_corpus<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.rag_corpus = v.into();
            self
        }

        /// Sets the value of [rag_file_ids][crate::model::vertex_rag_store::RagResource::rag_file_ids].
        pub fn set_rag_file_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.rag_file_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl wkt::message::Message for RagResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.VertexRagStore.RagResource"
        }
    }
}

/// Retrieve from Vertex AI Search datastore or engine for grounding.
/// datastore and engine are mutually exclusive.
/// See <https://cloud.google.com/products/agent-builder>
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexAISearch {
    /// Optional. Fully-qualified Vertex AI Search data store resource ID.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datastore: std::string::String,

    /// Optional. Fully-qualified Vertex AI Search engine resource ID.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl VertexAISearch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datastore][crate::model::VertexAISearch::datastore].
    pub fn set_datastore<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datastore = v.into();
        self
    }

    /// Sets the value of [engine][crate::model::VertexAISearch::engine].
    pub fn set_engine<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for VertexAISearch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexAISearch"
    }
}

/// Tool to retrieve public web data for grounding, powered by Google.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleSearchRetrieval {
    /// Specifies the dynamic retrieval configuration for the given source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dynamic_retrieval_config: std::option::Option<crate::model::DynamicRetrievalConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl GoogleSearchRetrieval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dynamic_retrieval_config][crate::model::GoogleSearchRetrieval::dynamic_retrieval_config].
    pub fn set_dynamic_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::DynamicRetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dynamic_retrieval_config = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for GoogleSearchRetrieval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleSearchRetrieval"
    }
}

/// Tool to search public web data, powered by Vertex AI Search and Sec4
/// compliance.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnterpriseWebSearch {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl EnterpriseWebSearch {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for EnterpriseWebSearch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EnterpriseWebSearch"
    }
}

/// Describes the options to customize dynamic retrieval.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DynamicRetrievalConfig {
    /// The mode of the predictor to be used in dynamic retrieval.
    pub mode: crate::model::dynamic_retrieval_config::Mode,

    /// Optional. The threshold to be used in dynamic retrieval.
    /// If not set, a system default value is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dynamic_threshold: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl DynamicRetrievalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::DynamicRetrievalConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::dynamic_retrieval_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [dynamic_threshold][crate::model::DynamicRetrievalConfig::dynamic_threshold].
    pub fn set_dynamic_threshold<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dynamic_threshold = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl wkt::message::Message for DynamicRetrievalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DynamicRetrievalConfig"
    }
}

/// Defines additional types related to [DynamicRetrievalConfig].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
pub mod dynamic_retrieval_config {
    #[allow(unused_imports)]
    use super::*;

    /// The mode of the predictor to be used in dynamic retrieval.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Always trigger retrieval.
        Unspecified,
        /// Run retrieval only when system decides it is necessary.
        Dynamic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dynamic => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Dynamic => std::option::Option::Some("MODE_DYNAMIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dynamic,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "MODE_DYNAMIC" => Self::Dynamic,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dynamic => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.aiplatform.v1.DynamicRetrievalConfig.Mode",
            ))
        }
    }
}

/// Tool config. This config is shared for all tools provided in the request.
#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolConfig {
    /// Optional. Function calling config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub function_calling_config: std::option::Option<crate::model::FunctionCallingConfig>,

    /// Optional. Retrieval config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retrieval_config: std::option::Option<crate::model::RetrievalConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
impl ToolConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function_calling_config][crate::model::ToolConfig::function_calling_config].
    pub fn set_function_calling_config<
        T: std::convert::Into<std::option::Option<crate::model::FunctionCallingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.function_calling_config = v.into();
        self
    }

    /// Sets the value of [retrieval_config][crate::model::ToolConfig::retrieval_config].
    pub fn set_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::RetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retrieval_config = v.into();
        self
    }
}

#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
impl wkt::message::Message for ToolConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolConfig"
    }
}

/// Function calling config.
#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionCallingConfig {
    /// Optional. Function calling mode.
    pub mode: crate::model::function_calling_config::Mode,

    /// Optional. Function names to call. Only set when the Mode is ANY. Function
    /// names should match [FunctionDeclaration.name]. With mode set to ANY, model
    /// will predict a function call from the set of function names provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_function_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
impl FunctionCallingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::FunctionCallingConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::function_calling_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [allowed_function_names][crate::model::FunctionCallingConfig::allowed_function_names].
    pub fn set_allowed_function_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_function_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
impl wkt::message::Message for FunctionCallingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionCallingConfig"
    }
}

/// Defines additional types related to [FunctionCallingConfig].
#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
pub mod function_calling_config {
    #[allow(unused_imports)]
    use super::*;

    /// Function calling mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Unspecified function calling mode. This value should not be used.
        Unspecified,
        /// Default model behavior, model decides to predict either function calls
        /// or natural language response.
        Auto,
        /// Model is constrained to always predicting function calls only.
        /// If "allowed_function_names" are set, the predicted function calls will be
        /// limited to any one of "allowed_function_names", else the predicted
        /// function calls will be any one of the provided "function_declarations".
        Any,
        /// Model will not predict any function calls. Model behavior is same as when
        /// not passing any function declarations.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Auto => std::option::Option::Some(1),
                Self::Any => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Auto => std::option::Option::Some("AUTO"),
                Self::Any => std::option::Option::Some("ANY"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Auto,
                2 => Self::Any,
                3 => Self::None,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTO" => Self::Auto,
                "ANY" => Self::Any,
                "NONE" => Self::None,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Auto => serializer.serialize_i32(1),
                Self::Any => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.aiplatform.v1.FunctionCallingConfig.Mode",
            ))
        }
    }
}

/// Retrieval config.
#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrievalConfig {
    /// The location of the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lat_lng: std::option::Option<gtype::model::LatLng>,

    /// The language code of the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub language_code: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
impl RetrievalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lat_lng][crate::model::RetrievalConfig::lat_lng].
    pub fn set_lat_lng<T: std::convert::Into<std::option::Option<gtype::model::LatLng>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lat_lng = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::RetrievalConfig::language_code].
    pub fn set_language_code<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(any(feature = "gen_ai_cache_service", feature = "prediction_service",))]
impl wkt::message::Message for RetrievalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrievalConfig"
    }
}

/// Specifies the context retrieval config.
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagRetrievalConfig {
    /// Optional. The number of contexts to retrieve.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub top_k: i32,

    /// Optional. Config for filters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::rag_retrieval_config::Filter>,

    /// Optional. Config for ranking and reranking.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ranking: std::option::Option<crate::model::rag_retrieval_config::Ranking>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl RagRetrievalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top_k][crate::model::RagRetrievalConfig::top_k].
    pub fn set_top_k<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top_k = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::RagRetrievalConfig::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::rag_retrieval_config::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [ranking][crate::model::RagRetrievalConfig::ranking].
    pub fn set_ranking<
        T: std::convert::Into<std::option::Option<crate::model::rag_retrieval_config::Ranking>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking = v.into();
        self
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
impl wkt::message::Message for RagRetrievalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig"
    }
}

/// Defines additional types related to [RagRetrievalConfig].
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
    feature = "vertex_rag_service",
))]
pub mod rag_retrieval_config {
    #[allow(unused_imports)]
    use super::*;

    /// Config for filters.
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Filter {
        /// Optional. String for metadata filtering.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metadata_filter: std::string::String,

        /// Filter contexts retrieved from the vector DB based on either vector
        /// distance or vector similarity.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub vector_db_threshold:
            std::option::Option<crate::model::rag_retrieval_config::filter::VectorDbThreshold>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl Filter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metadata_filter][crate::model::rag_retrieval_config::Filter::metadata_filter].
        pub fn set_metadata_filter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.metadata_filter = v.into();
            self
        }

        /// Sets the value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold].
        ///
        /// Note that all the setters affecting `vector_db_threshold` are mutually
        /// exclusive.
        pub fn set_vector_db_threshold<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::rag_retrieval_config::filter::VectorDbThreshold,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vector_db_threshold = v.into();
            self
        }

        /// The value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// if it holds a `VectorDistanceThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn vector_distance_threshold(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.vector_db_threshold.as_ref().and_then(|v| match v {
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorDistanceThreshold(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// if it holds a `VectorSimilarityThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn vector_similarity_threshold(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.vector_db_threshold.as_ref().and_then(|v| match v {
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorSimilarityThreshold(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// to hold a `VectorDistanceThreshold`.
        ///
        /// Note that all the setters affecting `vector_db_threshold` are
        /// mutually exclusive.
        pub fn set_vector_distance_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.vector_db_threshold = std::option::Option::Some(
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorDistanceThreshold(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// to hold a `VectorSimilarityThreshold`.
        ///
        /// Note that all the setters affecting `vector_db_threshold` are
        /// mutually exclusive.
        pub fn set_vector_similarity_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.vector_db_threshold = std::option::Option::Some(
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorSimilarityThreshold(
                    v.into()
                )
            );
            self
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl wkt::message::Message for Filter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Filter"
        }
    }

    /// Defines additional types related to [Filter].
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    pub mod filter {
        #[allow(unused_imports)]
        use super::*;

        /// Filter contexts retrieved from the vector DB based on either vector
        /// distance or vector similarity.
        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum VectorDbThreshold {
            /// Optional. Only returns contexts with vector distance smaller than the
            /// threshold.
            VectorDistanceThreshold(f64),
            /// Optional. Only returns contexts with vector similarity larger than the
            /// threshold.
            VectorSimilarityThreshold(f64),
        }
    }

    /// Config for ranking and reranking.
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Ranking {
        /// Config options for ranking. Currently only Rank Service is supported.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub ranking_config:
            std::option::Option<crate::model::rag_retrieval_config::ranking::RankingConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl Ranking {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ranking_config][crate::model::rag_retrieval_config::Ranking::ranking_config].
        ///
        /// Note that all the setters affecting `ranking_config` are mutually
        /// exclusive.
        pub fn set_ranking_config<
            T: std::convert::Into<
                    std::option::Option<crate::model::rag_retrieval_config::ranking::RankingConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking_config = v.into();
            self
        }

        /// The value of [ranking_config][crate::model::rag_retrieval_config::Ranking::ranking_config]
        /// if it holds a `RankService`, `None` if the field is not set or
        /// holds a different branch.
        pub fn rank_service(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::rag_retrieval_config::ranking::RankService>,
        > {
            #[allow(unreachable_patterns)]
            self.ranking_config.as_ref().and_then(|v| match v {
                crate::model::rag_retrieval_config::ranking::RankingConfig::RankService(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [ranking_config][crate::model::rag_retrieval_config::Ranking::ranking_config]
        /// if it holds a `LlmRanker`, `None` if the field is not set or
        /// holds a different branch.
        pub fn llm_ranker(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::rag_retrieval_config::ranking::LlmRanker>,
        > {
            #[allow(unreachable_patterns)]
            self.ranking_config.as_ref().and_then(|v| match v {
                crate::model::rag_retrieval_config::ranking::RankingConfig::LlmRanker(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [ranking_config][crate::model::rag_retrieval_config::Ranking::ranking_config]
        /// to hold a `RankService`.
        ///
        /// Note that all the setters affecting `ranking_config` are
        /// mutually exclusive.
        pub fn set_rank_service<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::rag_retrieval_config::ranking::RankService>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking_config = std::option::Option::Some(
                crate::model::rag_retrieval_config::ranking::RankingConfig::RankService(v.into()),
            );
            self
        }

        /// Sets the value of [ranking_config][crate::model::rag_retrieval_config::Ranking::ranking_config]
        /// to hold a `LlmRanker`.
        ///
        /// Note that all the setters affecting `ranking_config` are
        /// mutually exclusive.
        pub fn set_llm_ranker<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::rag_retrieval_config::ranking::LlmRanker>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking_config = std::option::Option::Some(
                crate::model::rag_retrieval_config::ranking::RankingConfig::LlmRanker(v.into()),
            );
            self
        }
    }

    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    impl wkt::message::Message for Ranking {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking"
        }
    }

    /// Defines additional types related to [Ranking].
    #[cfg(any(
        feature = "gen_ai_cache_service",
        feature = "llm_utility_service",
        feature = "prediction_service",
        feature = "vertex_rag_service",
    ))]
    pub mod ranking {
        #[allow(unused_imports)]
        use super::*;

        /// Config for Rank Service.
        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RankService {
            /// Optional. The model name of the rank service.
            /// Format: `semantic-ranker-512@latest`
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_name: std::option::Option<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        impl RankService {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_name][crate::model::rag_retrieval_config::ranking::RankService::model_name].
            pub fn set_model_name<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.model_name = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        impl wkt::message::Message for RankService {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking.RankService"
            }
        }

        /// Config for LlmRanker.
        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LlmRanker {
            /// Optional. The model name used for ranking.
            /// Format: `gemini-1.5-pro`
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_name: std::option::Option<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        impl LlmRanker {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_name][crate::model::rag_retrieval_config::ranking::LlmRanker::model_name].
            pub fn set_model_name<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.model_name = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        impl wkt::message::Message for LlmRanker {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking.LlmRanker"
            }
        }

        /// Config options for ranking. Currently only Rank Service is supported.
        #[cfg(any(
            feature = "gen_ai_cache_service",
            feature = "llm_utility_service",
            feature = "prediction_service",
            feature = "vertex_rag_service",
        ))]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum RankingConfig {
            /// Optional. Config for Rank Service.
            RankService(std::boxed::Box<crate::model::rag_retrieval_config::ranking::RankService>),
            /// Optional. Config for LlmRanker.
            LlmRanker(std::boxed::Box<crate::model::rag_retrieval_config::ranking::LlmRanker>),
        }
    }
}

/// The TrainingPipeline orchestrates tasks associated with training a Model. It
/// always executes the training task, and optionally may also
/// export data from Vertex AI's Dataset which becomes the training input,
/// [upload][google.cloud.aiplatform.v1.ModelService.UploadModel] the Model to
/// Vertex AI, and evaluate the Model.
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainingPipeline {
    /// Output only. Resource name of the TrainingPipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of this TrainingPipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Specifies Vertex AI owned input data that may be used for training the
    /// Model. The TrainingPipeline's
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]
    /// should make clear whether this config is used and if there are any special
    /// requirements on how it should be filled. If nothing about this config is
    /// mentioned in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition],
    /// then it should be assumed that the TrainingPipeline does not depend on this
    /// configuration.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,

    /// Required. A Google Cloud Storage path to the YAML file that defines the
    /// training task which is responsible for producing the model artifact, and
    /// may also include additional auxiliary work. The definition files that can
    /// be used here are found in
    /// gs://google-cloud-aiplatform/schema/trainingjob/definition/.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_task_definition: std::string::String,

    /// Required. The training task's parameter(s), as specified in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]'s
    /// `inputs`.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_task_inputs: std::option::Option<wkt::Value>,

    /// Output only. The metadata information as specified in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]'s
    /// `metadata`. This metadata is an auxiliary runtime and final information
    /// about the training task. While the pipeline is running this information is
    /// populated only at a best effort basis. Only present if the
    /// pipeline's
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]
    /// contains `metadata` object.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_task_metadata: std::option::Option<wkt::Value>,

    /// Describes the Model that may be uploaded (via
    /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel])
    /// by this TrainingPipeline. The TrainingPipeline's
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]
    /// should make clear whether this Model description should be populated, and
    /// if there are any special requirements regarding how it should be filled. If
    /// nothing is mentioned in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition],
    /// then it should be assumed that this field should not be filled and the
    /// training task either uploads the Model without a need of this information,
    /// or that training task does not support uploading a Model as part of the
    /// pipeline. When the Pipeline's state becomes `PIPELINE_STATE_SUCCEEDED` and
    /// the trained Model had been uploaded into Vertex AI, then the
    /// model_to_upload's resource [name][google.cloud.aiplatform.v1.Model.name] is
    /// populated. The Model is always uploaded into the Project and Location in
    /// which this pipeline is.
    ///
    /// [google.cloud.aiplatform.v1.Model.name]: crate::model::Model::name
    /// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_to_upload: std::option::Option<crate::model::Model>,

    /// Optional. The ID to use for the uploaded Model, which will become the final
    /// component of the model resource name.
    ///
    /// This value may be up to 63 characters, and valid characters are
    /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Optional. When specify this field, the `model_to_upload` will not be
    /// uploaded as a new model, instead, it will become a new version of this
    /// `parent_model`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_model: std::string::String,

    /// Output only. The detailed state of the pipeline.
    pub state: crate::model::PipelineState,

    /// Output only. Only populated when the pipeline's state is
    /// `PIPELINE_STATE_FAILED` or `PIPELINE_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Time when the TrainingPipeline was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TrainingPipeline for the first time entered the
    /// `PIPELINE_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TrainingPipeline entered any of the following
    /// states: `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
    /// `PIPELINE_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TrainingPipeline was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize TrainingPipelines.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key spec for a TrainingPipeline. If set, this
    /// TrainingPipeline will be secured by this key.
    ///
    /// Note: Model trained by this TrainingPipeline is also secured by this key if
    /// [model_to_upload][google.cloud.aiplatform.v1.TrainingPipeline.encryption_spec]
    /// is not set separately.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.encryption_spec]: crate::model::TrainingPipeline::encryption_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl TrainingPipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TrainingPipeline::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TrainingPipeline::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [input_data_config][crate::model::TrainingPipeline::input_data_config].
    pub fn set_input_data_config<
        T: std::convert::Into<std::option::Option<crate::model::InputDataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_data_config = v.into();
        self
    }

    /// Sets the value of [training_task_definition][crate::model::TrainingPipeline::training_task_definition].
    pub fn set_training_task_definition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_task_definition = v.into();
        self
    }

    /// Sets the value of [training_task_inputs][crate::model::TrainingPipeline::training_task_inputs].
    pub fn set_training_task_inputs<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_task_inputs = v.into();
        self
    }

    /// Sets the value of [training_task_metadata][crate::model::TrainingPipeline::training_task_metadata].
    pub fn set_training_task_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_task_metadata = v.into();
        self
    }

    /// Sets the value of [model_to_upload][crate::model::TrainingPipeline::model_to_upload].
    pub fn set_model_to_upload<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_to_upload = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::TrainingPipeline::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [parent_model][crate::model::TrainingPipeline::parent_model].
    pub fn set_parent_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TrainingPipeline::state].
    pub fn set_state<T: std::convert::Into<crate::model::PipelineState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::TrainingPipeline::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TrainingPipeline::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TrainingPipeline::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TrainingPipeline::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TrainingPipeline::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::TrainingPipeline::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TrainingPipeline::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for TrainingPipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrainingPipeline"
    }
}

/// Specifies Vertex AI owned input data to be used for training, and
/// possibly evaluating, the Model.
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InputDataConfig {
    /// Required. The ID of the Dataset in the same Project and Location which data
    /// will be used to train the Model. The Dataset must use schema compatible
    /// with Model being trained, and what is compatible should be described in the
    /// used TrainingPipeline's [training_task_definition]
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition].
    /// For tabular Datasets, all their data is exported to training, to pick
    /// and choose from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Applicable only to Datasets that have DataItems and Annotations.
    ///
    /// A filter on Annotations of the Dataset. Only Annotations that both
    /// match this filter and belong to DataItems not ignored by the split method
    /// are used in respectively training, validation or test role, depending on
    /// the role of the DataItem they are on (for the auto-assigned that role is
    /// decided by Vertex AI). A filter with same syntax as the one used in
    /// [ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations]
    /// may be used, but note here it filters across all Annotations of the
    /// Dataset, and not just within a single DataItem.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotations_filter: std::string::String,

    /// Applicable only to custom training with Datasets that have DataItems and
    /// Annotations.
    ///
    /// Cloud Storage URI that points to a YAML file describing the annotation
    /// schema. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// The schema files that can be used here are found in
    /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
    /// chosen schema must be consistent with
    /// [metadata][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri] of the
    /// Dataset specified by
    /// [dataset_id][google.cloud.aiplatform.v1.InputDataConfig.dataset_id].
    ///
    /// Only Annotations that both match this schema and belong to DataItems not
    /// ignored by the split method are used in respectively training, validation
    /// or test role, depending on the role of the DataItem they are on.
    ///
    /// When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri]: crate::model::InputDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotations_filter]: crate::model::InputDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.InputDataConfig.dataset_id]: crate::model::InputDataConfig::dataset_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_schema_uri: std::string::String,

    /// Only applicable to Datasets that have SavedQueries.
    ///
    /// The ID of a SavedQuery (annotation set) under the Dataset specified by
    /// [dataset_id][google.cloud.aiplatform.v1.InputDataConfig.dataset_id] used
    /// for filtering Annotations for training.
    ///
    /// Only Annotations that are associated with this SavedQuery are used in
    /// respectively training. When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [saved_query_id][google.cloud.aiplatform.v1.InputDataConfig.saved_query_id]
    /// and
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter].
    ///
    /// Only one of
    /// [saved_query_id][google.cloud.aiplatform.v1.InputDataConfig.saved_query_id]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri]
    /// should be specified as both of them represent the same thing: problem type.
    ///
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri]: crate::model::InputDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotations_filter]: crate::model::InputDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.InputDataConfig.dataset_id]: crate::model::InputDataConfig::dataset_id
    /// [google.cloud.aiplatform.v1.InputDataConfig.saved_query_id]: crate::model::InputDataConfig::saved_query_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub saved_query_id: std::string::String,

    /// Whether to persist the ML use assignment to data item system labels.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub persist_ml_use_assignment: bool,

    /// The instructions how the input data should be split between the
    /// training, validation and test sets.
    /// If no split type is provided, the
    /// [fraction_split][google.cloud.aiplatform.v1.InputDataConfig.fraction_split]
    /// is used by default.
    ///
    /// [google.cloud.aiplatform.v1.InputDataConfig.fraction_split]: crate::model::InputDataConfig::split
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::input_data_config::Split>,

    /// Only applicable to Custom and Hyperparameter Tuning TrainingPipelines.
    ///
    /// The destination of the training data to be written to.
    ///
    /// Supported destination file formats:
    ///
    /// * For non-tabular data: "jsonl".
    /// * For tabular data: "csv" and "bigquery".
    ///
    /// The following Vertex AI environment variables are passed to containers
    /// or python modules of the training task when this field is set:
    ///
    /// * AIP_DATA_FORMAT : Exported data format.
    /// * AIP_TRAINING_DATA_URI : Sharded exported training data uris.
    /// * AIP_VALIDATION_DATA_URI : Sharded exported validation data uris.
    /// * AIP_TEST_DATA_URI : Sharded exported test data uris.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::input_data_config::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl InputDataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::InputDataConfig::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [annotations_filter][crate::model::InputDataConfig::annotations_filter].
    pub fn set_annotations_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotations_filter = v.into();
        self
    }

    /// Sets the value of [annotation_schema_uri][crate::model::InputDataConfig::annotation_schema_uri].
    pub fn set_annotation_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_schema_uri = v.into();
        self
    }

    /// Sets the value of [saved_query_id][crate::model::InputDataConfig::saved_query_id].
    pub fn set_saved_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query_id = v.into();
        self
    }

    /// Sets the value of [persist_ml_use_assignment][crate::model::InputDataConfig::persist_ml_use_assignment].
    pub fn set_persist_ml_use_assignment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.persist_ml_use_assignment = v.into();
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split].
    ///
    /// Note that all the setters affecting `split` are mutually
    /// exclusive.
    pub fn set_split<
        T: std::convert::Into<std::option::Option<crate::model::input_data_config::Split>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = v.into();
        self
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `FractionSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fraction_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FractionSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::FractionSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `FilterSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filter_split(&self) -> std::option::Option<&std::boxed::Box<crate::model::FilterSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::FilterSplit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `PredefinedSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn predefined_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PredefinedSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::PredefinedSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `TimestampSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timestamp_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimestampSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::TimestampSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `StratifiedSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stratified_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StratifiedSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::StratifiedSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `FractionSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_fraction_split<
        T: std::convert::Into<std::boxed::Box<crate::model::FractionSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::FractionSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `FilterSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_filter_split<T: std::convert::Into<std::boxed::Box<crate::model::FilterSplit>>>(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::FilterSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `PredefinedSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_predefined_split<
        T: std::convert::Into<std::boxed::Box<crate::model::PredefinedSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::PredefinedSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `TimestampSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_timestamp_split<
        T: std::convert::Into<std::boxed::Box<crate::model::TimestampSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::TimestampSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `StratifiedSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_stratified_split<
        T: std::convert::Into<std::boxed::Box<crate::model::StratifiedSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::StratifiedSplit(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::InputDataConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::input_data_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::InputDataConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination][crate::model::InputDataConfig::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Destination::BigqueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::InputDataConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::input_data_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::InputDataConfig::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::input_data_config::Destination::BigqueryDestination(v.into()),
        );
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for InputDataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.InputDataConfig"
    }
}

/// Defines additional types related to [InputDataConfig].
#[cfg(feature = "pipeline_service")]
pub mod input_data_config {
    #[allow(unused_imports)]
    use super::*;

    /// The instructions how the input data should be split between the
    /// training, validation and test sets.
    /// If no split type is provided, the
    /// [fraction_split][google.cloud.aiplatform.v1.InputDataConfig.fraction_split]
    /// is used by default.
    ///
    /// [google.cloud.aiplatform.v1.InputDataConfig.fraction_split]: crate::model::InputDataConfig::split
    #[cfg(feature = "pipeline_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Split {
        /// Split based on fractions defining the size of each set.
        FractionSplit(std::boxed::Box<crate::model::FractionSplit>),
        /// Split based on the provided filters for each set.
        FilterSplit(std::boxed::Box<crate::model::FilterSplit>),
        /// Supported only for tabular Datasets.
        ///
        /// Split based on a predefined key.
        PredefinedSplit(std::boxed::Box<crate::model::PredefinedSplit>),
        /// Supported only for tabular Datasets.
        ///
        /// Split based on the timestamp of the input data pieces.
        TimestampSplit(std::boxed::Box<crate::model::TimestampSplit>),
        /// Supported only for tabular Datasets.
        ///
        /// Split based on the distribution of the specified column.
        StratifiedSplit(std::boxed::Box<crate::model::StratifiedSplit>),
    }

    /// Only applicable to Custom and Hyperparameter Tuning TrainingPipelines.
    ///
    /// The destination of the training data to be written to.
    ///
    /// Supported destination file formats:
    ///
    /// * For non-tabular data: "jsonl".
    /// * For tabular data: "csv" and "bigquery".
    ///
    /// The following Vertex AI environment variables are passed to containers
    /// or python modules of the training task when this field is set:
    ///
    /// * AIP_DATA_FORMAT : Exported data format.
    /// * AIP_TRAINING_DATA_URI : Sharded exported training data uris.
    /// * AIP_VALIDATION_DATA_URI : Sharded exported validation data uris.
    /// * AIP_TEST_DATA_URI : Sharded exported test data uris.
    #[cfg(feature = "pipeline_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// The Cloud Storage location where the training data is to be
        /// written to. In the given directory a new directory is created with
        /// name:
        /// `dataset-<dataset-id>-<annotation-type>-<timestamp-of-training-call>`
        /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
        /// All training input data is written into that directory.
        ///
        /// The Vertex AI environment variables representing Cloud Storage
        /// data URIs are represented in the Cloud Storage wildcard
        /// format to support sharded data. e.g.: "gs://.../training-*.jsonl"
        ///
        /// * AIP_DATA_FORMAT = "jsonl" for non-tabular data, "csv" for tabular data
        ///
        /// * AIP_TRAINING_DATA_URI =
        ///   "gcs_destination/dataset-\<dataset-id\>-\<annotation-type\>-\<time\>/training-*.${AIP_DATA_FORMAT}"
        ///
        /// * AIP_VALIDATION_DATA_URI =
        ///   "gcs_destination/dataset-\<dataset-id\>-\<annotation-type\>-\<time\>/validation-*.${AIP_DATA_FORMAT}"
        ///
        /// * AIP_TEST_DATA_URI =
        ///   "gcs_destination/dataset-\<dataset-id\>-\<annotation-type\>-\<time\>/test-*.${AIP_DATA_FORMAT}"
        ///
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
        /// Only applicable to custom training with tabular Dataset with BigQuery
        /// source.
        ///
        /// The BigQuery project location where the training data is to be written
        /// to. In the given project a new dataset is created with name
        /// `dataset_<dataset-id>_<annotation-type>_<timestamp-of-training-call>`
        /// where timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training
        /// input data is written into that dataset. In the dataset three
        /// tables are created, `training`, `validation` and `test`.
        ///
        /// * AIP_DATA_FORMAT = "bigquery".
        ///
        /// * AIP_TRAINING_DATA_URI  =
        ///   "bigquery_destination.dataset_\<dataset-id\>_<annotation-type>_\<time\>.training"
        ///
        /// * AIP_VALIDATION_DATA_URI =
        ///   "bigquery_destination.dataset_\<dataset-id\>_<annotation-type>_\<time\>.validation"
        ///
        /// * AIP_TEST_DATA_URI =
        ///   "bigquery_destination.dataset_\<dataset-id\>_<annotation-type>_\<time\>.test"
        ///
        BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
    }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FractionSplit {
    /// The fraction of the input data that is to be used to train the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub test_fraction: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl FractionSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::FractionSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::FractionSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::FractionSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for FractionSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FractionSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored. Currently only
/// supported for Datasets containing DataItems.
/// If any of the filters in this message are to match nothing, then they can be
/// set as '-' (the minus sign).
///
/// Supported only for unstructured Datasets.
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterSplit {
    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to train the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to validate the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub validation_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to test the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub test_filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl FilterSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_filter][crate::model::FilterSplit::training_filter].
    pub fn set_training_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.training_filter = v.into();
        self
    }

    /// Sets the value of [validation_filter][crate::model::FilterSplit::validation_filter].
    pub fn set_validation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_filter = v.into();
        self
    }

    /// Sets the value of [test_filter][crate::model::FilterSplit::test_filter].
    pub fn set_test_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_filter = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for FilterSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FilterSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on the
/// value of a provided key.
///
/// Supported only for tabular Datasets.
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredefinedSplit {
    /// Required. The key is a name of one of the Dataset's data columns.
    /// The value of the key (either the label's value or value in the column)
    /// must be one of {`training`, `validation`, `test`}, and it defines to which
    /// set the given piece of data is assigned. If for a piece of data the key
    /// is not present or has an invalid value, that piece is ignored by the
    /// pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl PredefinedSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::PredefinedSplit::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for PredefinedSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredefinedSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps. The youngest data pieces are assigned to training set,
/// next to validation set, and the oldest to the test set.
///
/// Supported only for tabular Datasets.
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimestampSplit {
    /// The fraction of the input data that is to be used to train the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub test_fraction: f64,

    /// Required. The key is a name of one of the Dataset's data columns.
    /// The values of the key (the values in the column) must be in RFC 3339
    /// `date-time` format, where `time-offset` = `"Z"`
    /// (e.g. 1985-04-12T23:20:50.52Z). If for a piece of data the key is not
    /// present or has an invalid value, that piece is ignored by the pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl TimestampSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::TimestampSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::TimestampSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::TimestampSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }

    /// Sets the value of [key][crate::model::TimestampSplit::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for TimestampSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimestampSplit"
    }
}

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split. The fraction values determine
/// the relative sizes of the splits.
///
/// For example, if the specified column has three values, with 50% of the rows
/// having value "A", 25% value "B", and 25% value "C", and the split fractions
/// are specified as 80/10/10, then the training set will constitute 80% of the
/// training data, with about 50% of the training set rows having the value "A"
/// for the specified column, about 25% having the value "B", and about 25%
/// having the value "C".
///
/// Only the top 500 occurring values are used; any values not in the top
/// 500 values are randomly assigned to a split. If less than three rows contain
/// a specific value, those rows are randomly assigned.
///
/// Supported only for tabular Datasets.
#[cfg(feature = "pipeline_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StratifiedSplit {
    /// The fraction of the input data that is to be used to train the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub test_fraction: f64,

    /// Required. The key is a name of one of the Dataset's data columns.
    /// The key provided must be for a categorical column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pipeline_service")]
impl StratifiedSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::StratifiedSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::StratifiedSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::StratifiedSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }

    /// Sets the value of [key][crate::model::StratifiedSplit::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

#[cfg(feature = "pipeline_service")]
impl wkt::message::Message for StratifiedSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StratifiedSplit"
    }
}

/// Represents a TuningJob that runs with Google owned models.
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuningJob {
    /// Output only. Identifier. Resource name of a TuningJob. Format:
    /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The display name of the
    /// [TunedModel][google.cloud.aiplatform.v1.Model]. The name can be up to 128
    /// characters long and can consist of any UTF-8 characters.
    ///
    /// [google.cloud.aiplatform.v1.Model]: crate::model::Model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tuned_model_display_name: std::string::String,

    /// Optional. The description of the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] was created.
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] for the first time
    /// entered the `JOB_STATE_RUNNING` state.
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TuningJob entered any of the following
    /// [JobStates][google.cloud.aiplatform.v1.JobState]: `JOB_STATE_SUCCEEDED`,
    /// `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`, `JOB_STATE_EXPIRED`.
    ///
    /// [google.cloud.aiplatform.v1.JobState]: crate::model::JobState
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] was most recently
    /// updated.
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Optional. The labels with user-defined metadata to organize
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] and generated resources
    /// such as [Model][google.cloud.aiplatform.v1.Model] and
    /// [Endpoint][google.cloud.aiplatform.v1.Endpoint].
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint]: crate::model::Endpoint
    /// [google.cloud.aiplatform.v1.Model]: crate::model::Model
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The Experiment associated with this
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub experiment: std::string::String,

    /// Output only. The tuned model resources assiociated with this
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuned_model: std::option::Option<crate::model::TunedModel>,

    /// Output only. The tuning data statistics associated with this
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_data_stats: std::option::Option<crate::model::TuningDataStats>,

    /// Customer-managed encryption key options for a TuningJob. If this is set,
    /// then all resources created by the TuningJob will be encrypted with the
    /// provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The service account that the tuningJob workload runs as.
    /// If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the
    /// project will be used. See
    /// <https://cloud.google.com/iam/docs/service-agents#vertex-ai-secure-fine-tuning-service-agent>
    ///
    /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_model: std::option::Option<crate::model::tuning_job::SourceModel>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_spec: std::option::Option<crate::model::tuning_job::TuningSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl TuningJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TuningJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tuned_model_display_name][crate::model::TuningJob::tuned_model_display_name].
    pub fn set_tuned_model_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model_display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TuningJob::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TuningJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TuningJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TuningJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TuningJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TuningJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::TuningJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [experiment][crate::model::TuningJob::experiment].
    pub fn set_experiment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment = v.into();
        self
    }

    /// Sets the value of [tuned_model][crate::model::TuningJob::tuned_model].
    pub fn set_tuned_model<T: std::convert::Into<std::option::Option<crate::model::TunedModel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model = v.into();
        self
    }

    /// Sets the value of [tuning_data_stats][crate::model::TuningJob::tuning_data_stats].
    pub fn set_tuning_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::TuningDataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_data_stats = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::TuningJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::TuningJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TuningJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source_model][crate::model::TuningJob::source_model].
    ///
    /// Note that all the setters affecting `source_model` are mutually
    /// exclusive.
    pub fn set_source_model<
        T: std::convert::Into<std::option::Option<crate::model::tuning_job::SourceModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_model = v.into();
        self
    }

    /// The value of [source_model][crate::model::TuningJob::source_model]
    /// if it holds a `BaseModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn base_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source_model.as_ref().and_then(|v| match v {
            crate::model::tuning_job::SourceModel::BaseModel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_model][crate::model::TuningJob::source_model]
    /// to hold a `BaseModel`.
    ///
    /// Note that all the setters affecting `source_model` are
    /// mutually exclusive.
    pub fn set_base_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_model =
            std::option::Option::Some(crate::model::tuning_job::SourceModel::BaseModel(v.into()));
        self
    }

    /// Sets the value of [tuning_spec][crate::model::TuningJob::tuning_spec].
    ///
    /// Note that all the setters affecting `tuning_spec` are mutually
    /// exclusive.
    pub fn set_tuning_spec<
        T: std::convert::Into<std::option::Option<crate::model::tuning_job::TuningSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_spec = v.into();
        self
    }

    /// The value of [tuning_spec][crate::model::TuningJob::tuning_spec]
    /// if it holds a `SupervisedTuningSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn supervised_tuning_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SupervisedTuningSpec>> {
        #[allow(unreachable_patterns)]
        self.tuning_spec.as_ref().and_then(|v| match v {
            crate::model::tuning_job::TuningSpec::SupervisedTuningSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tuning_spec][crate::model::TuningJob::tuning_spec]
    /// to hold a `SupervisedTuningSpec`.
    ///
    /// Note that all the setters affecting `tuning_spec` are
    /// mutually exclusive.
    pub fn set_supervised_tuning_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::SupervisedTuningSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_spec = std::option::Option::Some(
            crate::model::tuning_job::TuningSpec::SupervisedTuningSpec(v.into()),
        );
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for TuningJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TuningJob"
    }
}

/// Defines additional types related to [TuningJob].
#[cfg(feature = "gen_ai_tuning_service")]
pub mod tuning_job {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "gen_ai_tuning_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceModel {
        /// The base model that is being tuned, e.g., "gemini-1.0-pro-002".
        BaseModel(std::string::String),
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TuningSpec {
        /// Tuning Spec for Supervised Fine Tuning.
        SupervisedTuningSpec(std::boxed::Box<crate::model::SupervisedTuningSpec>),
    }
}

/// The Model Registry Model and Online Prediction Endpoint assiociated with
/// this [TuningJob][google.cloud.aiplatform.v1.TuningJob].
///
/// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TunedModel {
    /// Output only. The resource name of the TunedModel. Format:
    /// `projects/{project}/locations/{location}/models/{model}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. A resource name of an Endpoint. Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl TunedModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::TunedModel::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::TunedModel::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for TunedModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModel"
    }
}

/// Dataset distribution for Supervised Tuning.
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedTuningDatasetDistribution {
    /// Output only. Sum of a given population of values.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sum: i64,

    /// Output only. Sum of a given population of values that are billable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub billable_sum: i64,

    /// Output only. The minimum of the population values.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min: f64,

    /// Output only. The maximum of the population values.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max: f64,

    /// Output only. The arithmetic mean of the values in the population.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub mean: f64,

    /// Output only. The median of the values in the population.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub median: f64,

    /// Output only. The 5th percentile of the values in the population.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub p5: f64,

    /// Output only. The 95th percentile of the values in the population.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub p95: f64,

    /// Output only. Defines the histogram bucket.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub buckets: std::vec::Vec<crate::model::supervised_tuning_dataset_distribution::DatasetBucket>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl SupervisedTuningDatasetDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sum][crate::model::SupervisedTuningDatasetDistribution::sum].
    pub fn set_sum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sum = v.into();
        self
    }

    /// Sets the value of [billable_sum][crate::model::SupervisedTuningDatasetDistribution::billable_sum].
    pub fn set_billable_sum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.billable_sum = v.into();
        self
    }

    /// Sets the value of [min][crate::model::SupervisedTuningDatasetDistribution::min].
    pub fn set_min<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::SupervisedTuningDatasetDistribution::max].
    pub fn set_max<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }

    /// Sets the value of [mean][crate::model::SupervisedTuningDatasetDistribution::mean].
    pub fn set_mean<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.mean = v.into();
        self
    }

    /// Sets the value of [median][crate::model::SupervisedTuningDatasetDistribution::median].
    pub fn set_median<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.median = v.into();
        self
    }

    /// Sets the value of [p5][crate::model::SupervisedTuningDatasetDistribution::p5].
    pub fn set_p5<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.p5 = v.into();
        self
    }

    /// Sets the value of [p95][crate::model::SupervisedTuningDatasetDistribution::p95].
    pub fn set_p95<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.p95 = v.into();
        self
    }

    /// Sets the value of [buckets][crate::model::SupervisedTuningDatasetDistribution::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::supervised_tuning_dataset_distribution::DatasetBucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for SupervisedTuningDatasetDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution"
    }
}

/// Defines additional types related to [SupervisedTuningDatasetDistribution].
#[cfg(feature = "gen_ai_tuning_service")]
pub mod supervised_tuning_dataset_distribution {
    #[allow(unused_imports)]
    use super::*;

    /// Dataset bucket used to create a histogram for the distribution given a
    /// population of values.
    #[cfg(feature = "gen_ai_tuning_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DatasetBucket {
        /// Output only. Number of values in the bucket.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub count: f64,

        /// Output only. Left bound of the bucket.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub left: f64,

        /// Output only. Right bound of the bucket.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub right: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl DatasetBucket {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::supervised_tuning_dataset_distribution::DatasetBucket::count].
        pub fn set_count<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [left][crate::model::supervised_tuning_dataset_distribution::DatasetBucket::left].
        pub fn set_left<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.left = v.into();
            self
        }

        /// Sets the value of [right][crate::model::supervised_tuning_dataset_distribution::DatasetBucket::right].
        pub fn set_right<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.right = v.into();
            self
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl wkt::message::Message for DatasetBucket {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution.DatasetBucket"
        }
    }
}

/// Tuning data statistics for Supervised Tuning.
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedTuningDataStats {
    /// Output only. Number of examples in the tuning dataset.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub tuning_dataset_example_count: i64,

    /// Output only. Number of tuning characters in the tuning dataset.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_tuning_character_count: i64,

    /// Output only. Number of billable characters in the tuning dataset.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    #[deprecated]
    pub total_billable_character_count: i64,

    /// Output only. Number of billable tokens in the tuning dataset.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_token_count: i64,

    /// Output only. Number of tuning steps for this Tuning Job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub tuning_step_count: i64,

    /// Output only. Dataset distributions for the user input tokens.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_input_token_distribution:
        std::option::Option<crate::model::SupervisedTuningDatasetDistribution>,

    /// Output only. Dataset distributions for the user output tokens.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_output_token_distribution:
        std::option::Option<crate::model::SupervisedTuningDatasetDistribution>,

    /// Output only. Dataset distributions for the messages per example.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_message_per_example_distribution:
        std::option::Option<crate::model::SupervisedTuningDatasetDistribution>,

    /// Output only. Sample user messages in the training dataset uri.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_dataset_examples: std::vec::Vec<crate::model::Content>,

    /// The number of examples in the dataset that have been truncated by any
    /// amount.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_truncated_example_count: i64,

    /// A partial sample of the indices (starting from 1) of the truncated
    /// examples.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub truncated_example_indices: std::vec::Vec<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl SupervisedTuningDataStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tuning_dataset_example_count][crate::model::SupervisedTuningDataStats::tuning_dataset_example_count].
    pub fn set_tuning_dataset_example_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.tuning_dataset_example_count = v.into();
        self
    }

    /// Sets the value of [total_tuning_character_count][crate::model::SupervisedTuningDataStats::total_tuning_character_count].
    pub fn set_total_tuning_character_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_tuning_character_count = v.into();
        self
    }

    /// Sets the value of [total_billable_character_count][crate::model::SupervisedTuningDataStats::total_billable_character_count].
    #[deprecated]
    pub fn set_total_billable_character_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_character_count = v.into();
        self
    }

    /// Sets the value of [total_billable_token_count][crate::model::SupervisedTuningDataStats::total_billable_token_count].
    pub fn set_total_billable_token_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_token_count = v.into();
        self
    }

    /// Sets the value of [tuning_step_count][crate::model::SupervisedTuningDataStats::tuning_step_count].
    pub fn set_tuning_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.tuning_step_count = v.into();
        self
    }

    /// Sets the value of [user_input_token_distribution][crate::model::SupervisedTuningDataStats::user_input_token_distribution].
    pub fn set_user_input_token_distribution<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedTuningDatasetDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_input_token_distribution = v.into();
        self
    }

    /// Sets the value of [user_output_token_distribution][crate::model::SupervisedTuningDataStats::user_output_token_distribution].
    pub fn set_user_output_token_distribution<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedTuningDatasetDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_output_token_distribution = v.into();
        self
    }

    /// Sets the value of [user_message_per_example_distribution][crate::model::SupervisedTuningDataStats::user_message_per_example_distribution].
    pub fn set_user_message_per_example_distribution<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedTuningDatasetDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_message_per_example_distribution = v.into();
        self
    }

    /// Sets the value of [total_truncated_example_count][crate::model::SupervisedTuningDataStats::total_truncated_example_count].
    pub fn set_total_truncated_example_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_truncated_example_count = v.into();
        self
    }

    /// Sets the value of [user_dataset_examples][crate::model::SupervisedTuningDataStats::user_dataset_examples].
    pub fn set_user_dataset_examples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.user_dataset_examples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [truncated_example_indices][crate::model::SupervisedTuningDataStats::truncated_example_indices].
    pub fn set_truncated_example_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.truncated_example_indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for SupervisedTuningDataStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDataStats"
    }
}

/// The tuning data statistic values for
/// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
///
/// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuningDataStats {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_data_stats: std::option::Option<crate::model::tuning_data_stats::TuningDataStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl TuningDataStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tuning_data_stats][crate::model::TuningDataStats::tuning_data_stats].
    ///
    /// Note that all the setters affecting `tuning_data_stats` are mutually
    /// exclusive.
    pub fn set_tuning_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::tuning_data_stats::TuningDataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_data_stats = v.into();
        self
    }

    /// The value of [tuning_data_stats][crate::model::TuningDataStats::tuning_data_stats]
    /// if it holds a `SupervisedTuningDataStats`, `None` if the field is not set or
    /// holds a different branch.
    pub fn supervised_tuning_data_stats(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SupervisedTuningDataStats>> {
        #[allow(unreachable_patterns)]
        self.tuning_data_stats.as_ref().and_then(|v| match v {
            crate::model::tuning_data_stats::TuningDataStats::SupervisedTuningDataStats(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tuning_data_stats][crate::model::TuningDataStats::tuning_data_stats]
    /// to hold a `SupervisedTuningDataStats`.
    ///
    /// Note that all the setters affecting `tuning_data_stats` are
    /// mutually exclusive.
    pub fn set_supervised_tuning_data_stats<
        T: std::convert::Into<std::boxed::Box<crate::model::SupervisedTuningDataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_data_stats = std::option::Option::Some(
            crate::model::tuning_data_stats::TuningDataStats::SupervisedTuningDataStats(v.into()),
        );
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for TuningDataStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TuningDataStats"
    }
}

/// Defines additional types related to [TuningDataStats].
#[cfg(feature = "gen_ai_tuning_service")]
pub mod tuning_data_stats {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "gen_ai_tuning_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TuningDataStats {
        /// The SFT Tuning data stats.
        SupervisedTuningDataStats(std::boxed::Box<crate::model::SupervisedTuningDataStats>),
    }
}

/// Hyperparameters for SFT.
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedHyperParameters {
    /// Optional. Number of complete passes the model makes over the entire
    /// training dataset during training.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub epoch_count: i64,

    /// Optional. Multiplier for adjusting the default learning rate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub learning_rate_multiplier: f64,

    /// Optional. Adapter size for tuning.
    pub adapter_size: crate::model::supervised_hyper_parameters::AdapterSize,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl SupervisedHyperParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [epoch_count][crate::model::SupervisedHyperParameters::epoch_count].
    pub fn set_epoch_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.epoch_count = v.into();
        self
    }

    /// Sets the value of [learning_rate_multiplier][crate::model::SupervisedHyperParameters::learning_rate_multiplier].
    pub fn set_learning_rate_multiplier<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.learning_rate_multiplier = v.into();
        self
    }

    /// Sets the value of [adapter_size][crate::model::SupervisedHyperParameters::adapter_size].
    pub fn set_adapter_size<
        T: std::convert::Into<crate::model::supervised_hyper_parameters::AdapterSize>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.adapter_size = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for SupervisedHyperParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedHyperParameters"
    }
}

/// Defines additional types related to [SupervisedHyperParameters].
#[cfg(feature = "gen_ai_tuning_service")]
pub mod supervised_hyper_parameters {
    #[allow(unused_imports)]
    use super::*;

    /// Supported adapter sizes for tuning.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "gen_ai_tuning_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AdapterSize {
        /// Adapter size is unspecified.
        Unspecified,
        /// Adapter size 1.
        One,
        /// Adapter size 4.
        Four,
        /// Adapter size 8.
        Eight,
        /// Adapter size 16.
        Sixteen,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AdapterSize::value] or
        /// [AdapterSize::name].
        UnknownValue(adapter_size::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "gen_ai_tuning_service")]
    pub mod adapter_size {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl AdapterSize {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::One => std::option::Option::Some(1),
                Self::Four => std::option::Option::Some(2),
                Self::Eight => std::option::Option::Some(3),
                Self::Sixteen => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ADAPTER_SIZE_UNSPECIFIED"),
                Self::One => std::option::Option::Some("ADAPTER_SIZE_ONE"),
                Self::Four => std::option::Option::Some("ADAPTER_SIZE_FOUR"),
                Self::Eight => std::option::Option::Some("ADAPTER_SIZE_EIGHT"),
                Self::Sixteen => std::option::Option::Some("ADAPTER_SIZE_SIXTEEN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl std::default::Default for AdapterSize {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl std::fmt::Display for AdapterSize {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl std::convert::From<i32> for AdapterSize {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::One,
                2 => Self::Four,
                3 => Self::Eight,
                4 => Self::Sixteen,
                _ => Self::UnknownValue(adapter_size::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl std::convert::From<&str> for AdapterSize {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ADAPTER_SIZE_UNSPECIFIED" => Self::Unspecified,
                "ADAPTER_SIZE_ONE" => Self::One,
                "ADAPTER_SIZE_FOUR" => Self::Four,
                "ADAPTER_SIZE_EIGHT" => Self::Eight,
                "ADAPTER_SIZE_SIXTEEN" => Self::Sixteen,
                _ => Self::UnknownValue(adapter_size::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl serde::ser::Serialize for AdapterSize {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::One => serializer.serialize_i32(1),
                Self::Four => serializer.serialize_i32(2),
                Self::Eight => serializer.serialize_i32(3),
                Self::Sixteen => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "gen_ai_tuning_service")]
    impl<'de> serde::de::Deserialize<'de> for AdapterSize {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AdapterSize>::new(
                ".google.cloud.aiplatform.v1.SupervisedHyperParameters.AdapterSize",
            ))
        }
    }
}

/// Tuning Spec for Supervised Tuning for first party models.
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedTuningSpec {
    /// Required. Cloud Storage path to file containing training dataset for
    /// tuning. The dataset must be formatted as a JSONL file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_dataset_uri: std::string::String,

    /// Optional. Cloud Storage path to file containing validation dataset for
    /// tuning. The dataset must be formatted as a JSONL file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub validation_dataset_uri: std::string::String,

    /// Optional. Hyperparameters for SFT.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hyper_parameters: std::option::Option<crate::model::SupervisedHyperParameters>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl SupervisedTuningSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_dataset_uri][crate::model::SupervisedTuningSpec::training_dataset_uri].
    pub fn set_training_dataset_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_dataset_uri = v.into();
        self
    }

    /// Sets the value of [validation_dataset_uri][crate::model::SupervisedTuningSpec::validation_dataset_uri].
    pub fn set_validation_dataset_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_dataset_uri = v.into();
        self
    }

    /// Sets the value of [hyper_parameters][crate::model::SupervisedTuningSpec::hyper_parameters].
    pub fn set_hyper_parameters<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedHyperParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyper_parameters = v.into();
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for SupervisedTuningSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningSpec"
    }
}

/// TunedModel Reference for legacy model migration.
#[cfg(feature = "gen_ai_tuning_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TunedModelRef {
    /// The Tuned Model Reference for the model.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tuned_model_ref: std::option::Option<crate::model::tuned_model_ref::TunedModelRef>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "gen_ai_tuning_service")]
impl TunedModelRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref].
    ///
    /// Note that all the setters affecting `tuned_model_ref` are mutually
    /// exclusive.
    pub fn set_tuned_model_ref<
        T: std::convert::Into<std::option::Option<crate::model::tuned_model_ref::TunedModelRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model_ref = v.into();
        self
    }

    /// The value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// if it holds a `TunedModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tuned_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tuned_model_ref.as_ref().and_then(|v| match v {
            crate::model::tuned_model_ref::TunedModelRef::TunedModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// if it holds a `TuningJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tuning_job(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tuned_model_ref.as_ref().and_then(|v| match v {
            crate::model::tuned_model_ref::TunedModelRef::TuningJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// if it holds a `PipelineJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pipeline_job(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tuned_model_ref.as_ref().and_then(|v| match v {
            crate::model::tuned_model_ref::TunedModelRef::PipelineJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// to hold a `TunedModel`.
    ///
    /// Note that all the setters affecting `tuned_model_ref` are
    /// mutually exclusive.
    pub fn set_tuned_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tuned_model_ref = std::option::Option::Some(
            crate::model::tuned_model_ref::TunedModelRef::TunedModel(v.into()),
        );
        self
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// to hold a `TuningJob`.
    ///
    /// Note that all the setters affecting `tuned_model_ref` are
    /// mutually exclusive.
    pub fn set_tuning_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tuned_model_ref = std::option::Option::Some(
            crate::model::tuned_model_ref::TunedModelRef::TuningJob(v.into()),
        );
        self
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// to hold a `PipelineJob`.
    ///
    /// Note that all the setters affecting `tuned_model_ref` are
    /// mutually exclusive.
    pub fn set_pipeline_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tuned_model_ref = std::option::Option::Some(
            crate::model::tuned_model_ref::TunedModelRef::PipelineJob(v.into()),
        );
        self
    }
}

#[cfg(feature = "gen_ai_tuning_service")]
impl wkt::message::Message for TunedModelRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModelRef"
    }
}

/// Defines additional types related to [TunedModelRef].
#[cfg(feature = "gen_ai_tuning_service")]
pub mod tuned_model_ref {
    #[allow(unused_imports)]
    use super::*;

    /// The Tuned Model Reference for the model.
    #[cfg(feature = "gen_ai_tuning_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TunedModelRef {
        /// Support migration from model registry.
        TunedModel(std::string::String),
        /// Support migration from tuning job list page, from gemini-1.0-pro-002
        /// to 1.5 and above.
        TuningJob(std::string::String),
        /// Support migration from tuning job list page, from bison model to gemini
        /// model.
        PipelineJob(std::string::String),
    }
}

/// A list of boolean values.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BoolArray {
    /// A list of bool values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl BoolArray {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::BoolArray::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for BoolArray {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BoolArray"
    }
}

/// A list of double values.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DoubleArray {
    /// A list of double values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl DoubleArray {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::DoubleArray::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for DoubleArray {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DoubleArray"
    }
}

/// A list of int64 values.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Int64Array {
    /// A list of int64 values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub values: std::vec::Vec<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl Int64Array {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::Int64Array::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for Int64Array {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Int64Array"
    }
}

/// A list of string values.
#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StringArray {
    /// A list of string values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl StringArray {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::StringArray::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "feature_online_store_service",
    feature = "featurestore_online_serving_service",
))]
impl wkt::message::Message for StringArray {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StringArray"
    }
}

/// A tensor value type.
#[cfg(feature = "prediction_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tensor {
    /// The data type of tensor.
    pub dtype: crate::model::tensor::DataType,

    /// Shape of the tensor.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub shape: std::vec::Vec<i64>,

    /// Type specific representations that make it easy to create tensor protos in
    /// all languages.  Only the representation corresponding to "dtype" can
    /// be set.  The values hold the flattened representation of the tensor in
    /// row major order.
    ///
    /// [BOOL][google.cloud.aiplatform.v1.Tensor.DataType.BOOL]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.BOOL]: crate::model::tensor::DataType::Bool
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bool_val: std::vec::Vec<bool>,

    /// [STRING][google.cloud.aiplatform.v1.Tensor.DataType.STRING]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.STRING]: crate::model::tensor::DataType::String
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub string_val: std::vec::Vec<std::string::String>,

    /// [STRING][google.cloud.aiplatform.v1.Tensor.DataType.STRING]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.STRING]: crate::model::tensor::DataType::String
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub bytes_val: std::vec::Vec<::bytes::Bytes>,

    /// [FLOAT][google.cloud.aiplatform.v1.Tensor.DataType.FLOAT]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.FLOAT]: crate::model::tensor::DataType::Float
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub float_val: std::vec::Vec<f32>,

    /// [DOUBLE][google.cloud.aiplatform.v1.Tensor.DataType.DOUBLE]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.DOUBLE]: crate::model::tensor::DataType::Double
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub double_val: std::vec::Vec<f64>,

    /// [INT_8][google.cloud.aiplatform.v1.Tensor.DataType.INT8]
    /// [INT_16][google.cloud.aiplatform.v1.Tensor.DataType.INT16]
    /// [INT_32][google.cloud.aiplatform.v1.Tensor.DataType.INT32]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT16]: crate::model::tensor::DataType::Int16
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT32]: crate::model::tensor::DataType::Int32
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT8]: crate::model::tensor::DataType::Int8
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub int_val: std::vec::Vec<i32>,

    /// [INT64][google.cloud.aiplatform.v1.Tensor.DataType.INT64]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT64]: crate::model::tensor::DataType::Int64
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub int64_val: std::vec::Vec<i64>,

    /// [UINT8][google.cloud.aiplatform.v1.Tensor.DataType.UINT8]
    /// [UINT16][google.cloud.aiplatform.v1.Tensor.DataType.UINT16]
    /// [UINT32][google.cloud.aiplatform.v1.Tensor.DataType.UINT32]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT16]: crate::model::tensor::DataType::Uint16
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT32]: crate::model::tensor::DataType::Uint32
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT8]: crate::model::tensor::DataType::Uint8
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uint_val: std::vec::Vec<u32>,

    /// [UINT64][google.cloud.aiplatform.v1.Tensor.DataType.UINT64]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT64]: crate::model::tensor::DataType::Uint64
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub uint64_val: std::vec::Vec<u64>,

    /// A list of tensor values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub list_val: std::vec::Vec<crate::model::Tensor>,

    /// A map of string to tensor.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub struct_val: std::collections::HashMap<std::string::String, crate::model::Tensor>,

    /// Serialized raw tensor content.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub tensor_val: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "prediction_service")]
impl Tensor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dtype][crate::model::Tensor::dtype].
    pub fn set_dtype<T: std::convert::Into<crate::model::tensor::DataType>>(
        mut self,
        v: T,
    ) -> Self {
        self.dtype = v.into();
        self
    }

    /// Sets the value of [tensor_val][crate::model::Tensor::tensor_val].
    pub fn set_tensor_val<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.tensor_val = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::Tensor::shape].
    pub fn set_shape<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.shape = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bool_val][crate::model::Tensor::bool_val].
    pub fn set_bool_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.bool_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [string_val][crate::model::Tensor::string_val].
    pub fn set_string_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.string_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bytes_val][crate::model::Tensor::bytes_val].
    pub fn set_bytes_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.bytes_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [float_val][crate::model::Tensor::float_val].
    pub fn set_float_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.float_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [double_val][crate::model::Tensor::double_val].
    pub fn set_double_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.double_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [int_val][crate::model::Tensor::int_val].
    pub fn set_int_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.int_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [int64_val][crate::model::Tensor::int64_val].
    pub fn set_int64_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.int64_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uint_val][crate::model::Tensor::uint_val].
    pub fn set_uint_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.uint_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uint64_val][crate::model::Tensor::uint64_val].
    pub fn set_uint64_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.uint64_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [list_val][crate::model::Tensor::list_val].
    pub fn set_list_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.list_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [struct_val][crate::model::Tensor::struct_val].
    pub fn set_struct_val<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.struct_val = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "prediction_service")]
impl wkt::message::Message for Tensor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tensor"
    }
}

/// Defines additional types related to [Tensor].
#[cfg(feature = "prediction_service")]
pub mod tensor {
    #[allow(unused_imports)]
    use super::*;

    /// Data type of the tensor.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "prediction_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataType {
        /// Not a legal value for DataType. Used to indicate a DataType field has not
        /// been set.
        Unspecified,
        /// Data types that all computation devices are expected to be
        /// capable to support.
        Bool,
        String,
        Float,
        Double,
        Int8,
        Int16,
        Int32,
        Int64,
        Uint8,
        Uint16,
        Uint32,
        Uint64,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataType::value] or
        /// [DataType::name].
        UnknownValue(data_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "prediction_service")]
    pub mod data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "prediction_service")]
    impl DataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bool => std::option::Option::Some(1),
                Self::String => std::option::Option::Some(2),
                Self::Float => std::option::Option::Some(3),
                Self::Double => std::option::Option::Some(4),
                Self::Int8 => std::option::Option::Some(5),
                Self::Int16 => std::option::Option::Some(6),
                Self::Int32 => std::option::Option::Some(7),
                Self::Int64 => std::option::Option::Some(8),
                Self::Uint8 => std::option::Option::Some(9),
                Self::Uint16 => std::option::Option::Some(10),
                Self::Uint32 => std::option::Option::Some(11),
                Self::Uint64 => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_TYPE_UNSPECIFIED"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Float => std::option::Option::Some("FLOAT"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::Int8 => std::option::Option::Some("INT8"),
                Self::Int16 => std::option::Option::Some("INT16"),
                Self::Int32 => std::option::Option::Some("INT32"),
                Self::Int64 => std::option::Option::Some("INT64"),
                Self::Uint8 => std::option::Option::Some("UINT8"),
                Self::Uint16 => std::option::Option::Some("UINT16"),
                Self::Uint32 => std::option::Option::Some("UINT32"),
                Self::Uint64 => std::option::Option::Some("UINT64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::default::Default for DataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::fmt::Display for DataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<i32> for DataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bool,
                2 => Self::String,
                3 => Self::Float,
                4 => Self::Double,
                5 => Self::Int8,
                6 => Self::Int16,
                7 => Self::Int32,
                8 => Self::Int64,
                9 => Self::Uint8,
                10 => Self::Uint16,
                11 => Self::Uint32,
                12 => Self::Uint64,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl std::convert::From<&str> for DataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BOOL" => Self::Bool,
                "STRING" => Self::String,
                "FLOAT" => Self::Float,
                "DOUBLE" => Self::Double,
                "INT8" => Self::Int8,
                "INT16" => Self::Int16,
                "INT32" => Self::Int32,
                "INT64" => Self::Int64,
                "UINT8" => Self::Uint8,
                "UINT16" => Self::Uint16,
                "UINT32" => Self::Uint32,
                "UINT64" => Self::Uint64,
                _ => Self::UnknownValue(data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl serde::ser::Serialize for DataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bool => serializer.serialize_i32(1),
                Self::String => serializer.serialize_i32(2),
                Self::Float => serializer.serialize_i32(3),
                Self::Double => serializer.serialize_i32(4),
                Self::Int8 => serializer.serialize_i32(5),
                Self::Int16 => serializer.serialize_i32(6),
                Self::Int32 => serializer.serialize_i32(7),
                Self::Int64 => serializer.serialize_i32(8),
                Self::Uint8 => serializer.serialize_i32(9),
                Self::Uint16 => serializer.serialize_i32(10),
                Self::Uint32 => serializer.serialize_i32(11),
                Self::Uint64 => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "prediction_service")]
    impl<'de> serde::de::Deserialize<'de> for DataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataType>::new(
                ".google.cloud.aiplatform.v1.Tensor.DataType",
            ))
        }
    }
}

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
#[cfg(feature = "job_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnmanagedContainerModel {
    /// The path to the directory containing the Model artifact and any of its
    /// supporting files.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_uri: std::string::String,

    /// Contains the schemata used in Model's predictions and explanations
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_schemata: std::option::Option<crate::model::PredictSchemata>,

    /// Input only. The specification of the container that is to be used when
    /// deploying this Model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_spec: std::option::Option<crate::model::ModelContainerSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "job_service")]
impl UnmanagedContainerModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_uri][crate::model::UnmanagedContainerModel::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [predict_schemata][crate::model::UnmanagedContainerModel::predict_schemata].
    pub fn set_predict_schemata<
        T: std::convert::Into<std::option::Option<crate::model::PredictSchemata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_schemata = v.into();
        self
    }

    /// Sets the value of [container_spec][crate::model::UnmanagedContainerModel::container_spec].
    pub fn set_container_spec<
        T: std::convert::Into<std::option::Option<crate::model::ModelContainerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container_spec = v.into();
        self
    }
}

#[cfg(feature = "job_service")]
impl wkt::message::Message for UnmanagedContainerModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UnmanagedContainerModel"
    }
}

/// References an API call. It contains more information about long running
/// operation and Jobs that are triggered by the API call.
#[cfg(feature = "dataset_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserActionReference {
    /// The method name of the API RPC call. For example,
    /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<crate::model::user_action_reference::Reference>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "dataset_service")]
impl UserActionReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::UserActionReference::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::UserActionReference::reference].
    ///
    /// Note that all the setters affecting `reference` are mutually
    /// exclusive.
    pub fn set_reference<
        T: std::convert::Into<std::option::Option<crate::model::user_action_reference::Reference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// The value of [reference][crate::model::UserActionReference::reference]
    /// if it holds a `Operation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn operation(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.reference.as_ref().and_then(|v| match v {
            crate::model::user_action_reference::Reference::Operation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [reference][crate::model::UserActionReference::reference]
    /// if it holds a `DataLabelingJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_labeling_job(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.reference.as_ref().and_then(|v| match v {
            crate::model::user_action_reference::Reference::DataLabelingJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [reference][crate::model::UserActionReference::reference]
    /// to hold a `Operation`.
    ///
    /// Note that all the setters affecting `reference` are
    /// mutually exclusive.
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference = std::option::Option::Some(
            crate::model::user_action_reference::Reference::Operation(v.into()),
        );
        self
    }

    /// Sets the value of [reference][crate::model::UserActionReference::reference]
    /// to hold a `DataLabelingJob`.
    ///
    /// Note that all the setters affecting `reference` are
    /// mutually exclusive.
    pub fn set_data_labeling_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = std::option::Option::Some(
            crate::model::user_action_reference::Reference::DataLabelingJob(v.into()),
        );
        self
    }
}

#[cfg(feature = "dataset_service")]
impl wkt::message::Message for UserActionReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UserActionReference"
    }
}

/// Defines additional types related to [UserActionReference].
#[cfg(feature = "dataset_service")]
pub mod user_action_reference {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(feature = "dataset_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Reference {
        /// For API calls that return a long running operation.
        /// Resource name of the long running operation.
        /// Format:
        /// `projects/{project}/locations/{location}/operations/{operation}`
        Operation(std::string::String),
        /// For API calls that start a LabelingJob.
        /// Resource name of the LabelingJob.
        /// Format:
        /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
        DataLabelingJob(std::string::String),
    }
}

/// Value is the value of the field.
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Value {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::value::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl Value {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::Value::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::value::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::Value::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::value::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::Value::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::Value::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::Value::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = std::option::Option::Some(crate::model::value::Value::IntValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::Value::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = std::option::Option::Some(crate::model::value::Value::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::Value::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = std::option::Option::Some(crate::model::value::Value::StringValue(v.into()));
        self
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl wkt::message::Message for Value {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Value"
    }
}

/// Defines additional types related to [Value].
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
pub mod value {
    #[allow(unused_imports)]
    use super::*;

    #[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// An integer value.
        IntValue(i64),
        /// A double value.
        DoubleValue(f64),
        /// A string value.
        StringValue(std::string::String),
    }
}

/// Config for the embedding model to use for RAG.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagEmbeddingModelConfig {
    /// The model config to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub model_config: std::option::Option<crate::model::rag_embedding_model_config::ModelConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagEmbeddingModelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_config][crate::model::RagEmbeddingModelConfig::model_config].
    ///
    /// Note that all the setters affecting `model_config` are mutually
    /// exclusive.
    pub fn set_model_config<
        T: std::convert::Into<
                std::option::Option<crate::model::rag_embedding_model_config::ModelConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_config = v.into();
        self
    }

    /// The value of [model_config][crate::model::RagEmbeddingModelConfig::model_config]
    /// if it holds a `VertexPredictionEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_prediction_endpoint(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::rag_embedding_model_config::VertexPredictionEndpoint>,
    > {
        #[allow(unreachable_patterns)]
        self.model_config.as_ref().and_then(|v| match v {
            crate::model::rag_embedding_model_config::ModelConfig::VertexPredictionEndpoint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [model_config][crate::model::RagEmbeddingModelConfig::model_config]
    /// to hold a `VertexPredictionEndpoint`.
    ///
    /// Note that all the setters affecting `model_config` are
    /// mutually exclusive.
    pub fn set_vertex_prediction_endpoint<
        T: std::convert::Into<
                std::boxed::Box<crate::model::rag_embedding_model_config::VertexPredictionEndpoint>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_config = std::option::Option::Some(
            crate::model::rag_embedding_model_config::ModelConfig::VertexPredictionEndpoint(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagEmbeddingModelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagEmbeddingModelConfig"
    }
}

/// Defines additional types related to [RagEmbeddingModelConfig].
#[cfg(feature = "vertex_rag_data_service")]
pub mod rag_embedding_model_config {
    #[allow(unused_imports)]
    use super::*;

    /// Config representing a model hosted on Vertex Prediction Endpoint.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexPredictionEndpoint {
        /// Required. The endpoint resource name.
        /// Format:
        /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
        /// or
        /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Output only. The resource name of the model that is deployed on the
        /// endpoint. Present only when the endpoint is not a publisher model.
        /// Pattern:
        /// `projects/{project}/locations/{location}/models/{model}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// Output only. Version ID of the model that is deployed on the endpoint.
        /// Present only when the endpoint is not a publisher model.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_version_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl VertexPredictionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::rag_embedding_model_config::VertexPredictionEndpoint::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [model][crate::model::rag_embedding_model_config::VertexPredictionEndpoint::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_version_id][crate::model::rag_embedding_model_config::VertexPredictionEndpoint::model_version_id].
        pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_version_id = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for VertexPredictionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagEmbeddingModelConfig.VertexPredictionEndpoint"
        }
    }

    /// The model config to use.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ModelConfig {
        /// The Vertex AI Prediction Endpoint that either refers to a publisher model
        /// or an endpoint that is hosting a 1P fine-tuned text embedding model.
        /// Endpoints hosting non-1P fine-tuned text embedding models are
        /// currently not supported.
        /// This is used for dense vector search.
        VertexPredictionEndpoint(
            std::boxed::Box<crate::model::rag_embedding_model_config::VertexPredictionEndpoint>,
        ),
    }
}

/// Config for the Vector DB to use for RAG.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagVectorDbConfig {
    /// Authentication config for the chosen Vector DB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub api_auth: std::option::Option<crate::model::ApiAuth>,

    /// Optional. Immutable. The embedding model config of the Vector DB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_embedding_model_config: std::option::Option<crate::model::RagEmbeddingModelConfig>,

    /// The config for the Vector DB.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vector_db: std::option::Option<crate::model::rag_vector_db_config::VectorDb>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagVectorDbConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_auth][crate::model::RagVectorDbConfig::api_auth].
    pub fn set_api_auth<T: std::convert::Into<std::option::Option<crate::model::ApiAuth>>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_auth = v.into();
        self
    }

    /// Sets the value of [rag_embedding_model_config][crate::model::RagVectorDbConfig::rag_embedding_model_config].
    pub fn set_rag_embedding_model_config<
        T: std::convert::Into<std::option::Option<crate::model::RagEmbeddingModelConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_embedding_model_config = v.into();
        self
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db].
    ///
    /// Note that all the setters affecting `vector_db` are mutually
    /// exclusive.
    pub fn set_vector_db<
        T: std::convert::Into<std::option::Option<crate::model::rag_vector_db_config::VectorDb>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = v.into();
        self
    }

    /// The value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// if it holds a `RagManagedDb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rag_managed_db(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_vector_db_config::RagManagedDb>>
    {
        #[allow(unreachable_patterns)]
        self.vector_db.as_ref().and_then(|v| match v {
            crate::model::rag_vector_db_config::VectorDb::RagManagedDb(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// if it holds a `Pinecone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pinecone(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_vector_db_config::Pinecone>> {
        #[allow(unreachable_patterns)]
        self.vector_db.as_ref().and_then(|v| match v {
            crate::model::rag_vector_db_config::VectorDb::Pinecone(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// if it holds a `VertexVectorSearch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_vector_search(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_vector_db_config::VertexVectorSearch>>
    {
        #[allow(unreachable_patterns)]
        self.vector_db.as_ref().and_then(|v| match v {
            crate::model::rag_vector_db_config::VectorDb::VertexVectorSearch(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// to hold a `RagManagedDb`.
    ///
    /// Note that all the setters affecting `vector_db` are
    /// mutually exclusive.
    pub fn set_rag_managed_db<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_vector_db_config::RagManagedDb>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = std::option::Option::Some(
            crate::model::rag_vector_db_config::VectorDb::RagManagedDb(v.into()),
        );
        self
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// to hold a `Pinecone`.
    ///
    /// Note that all the setters affecting `vector_db` are
    /// mutually exclusive.
    pub fn set_pinecone<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_vector_db_config::Pinecone>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = std::option::Option::Some(
            crate::model::rag_vector_db_config::VectorDb::Pinecone(v.into()),
        );
        self
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// to hold a `VertexVectorSearch`.
    ///
    /// Note that all the setters affecting `vector_db` are
    /// mutually exclusive.
    pub fn set_vertex_vector_search<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_vector_db_config::VertexVectorSearch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = std::option::Option::Some(
            crate::model::rag_vector_db_config::VectorDb::VertexVectorSearch(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagVectorDbConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig"
    }
}

/// Defines additional types related to [RagVectorDbConfig].
#[cfg(feature = "vertex_rag_data_service")]
pub mod rag_vector_db_config {
    #[allow(unused_imports)]
    use super::*;

    /// The config for the default RAG-managed Vector DB.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RagManagedDb {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl RagManagedDb {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for RagManagedDb {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb"
        }
    }

    /// The config for the Pinecone.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Pinecone {
        /// Pinecone index name.
        /// This value cannot be changed after it's set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub index_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl Pinecone {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index_name][crate::model::rag_vector_db_config::Pinecone::index_name].
        pub fn set_index_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.index_name = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for Pinecone {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.Pinecone"
        }
    }

    /// The config for the Vertex Vector Search.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexVectorSearch {
        /// The resource name of the Index Endpoint.
        /// Format:
        /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub index_endpoint: std::string::String,

        /// The resource name of the Index.
        /// Format:
        /// `projects/{project}/locations/{location}/indexes/{index}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub index: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl VertexVectorSearch {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index_endpoint][crate::model::rag_vector_db_config::VertexVectorSearch::index_endpoint].
        pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.index_endpoint = v.into();
            self
        }

        /// Sets the value of [index][crate::model::rag_vector_db_config::VertexVectorSearch::index].
        pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.index = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for VertexVectorSearch {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.VertexVectorSearch"
        }
    }

    /// The config for the Vector DB.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VectorDb {
        /// The config for the RAG-managed Vector DB.
        RagManagedDb(std::boxed::Box<crate::model::rag_vector_db_config::RagManagedDb>),
        /// The config for the Pinecone.
        Pinecone(std::boxed::Box<crate::model::rag_vector_db_config::Pinecone>),
        /// The config for the Vertex Vector Search.
        VertexVectorSearch(std::boxed::Box<crate::model::rag_vector_db_config::VertexVectorSearch>),
    }
}

/// RagFile status.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStatus {
    /// Output only. RagFile state.
    pub state: crate::model::file_status::State,

    /// Output only. Only when the `state` field is ERROR.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_status: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl FileStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::FileStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::file_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_status][crate::model::FileStatus::error_status].
    pub fn set_error_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_status = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for FileStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FileStatus"
    }
}

/// Defines additional types related to [FileStatus].
#[cfg(feature = "vertex_rag_data_service")]
pub mod file_status {
    #[allow(unused_imports)]
    use super::*;

    /// RagFile state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// RagFile state is unspecified.
        Unspecified,
        /// RagFile resource has been created and indexed successfully.
        Active,
        /// RagFile resource is in a problematic state.
        /// See `error_message` field for details.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "vertex_rag_data_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Error => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Error => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.FileStatus.State",
            ))
        }
    }
}

/// Config for the Vertex AI Search.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexAiSearchConfig {
    /// Vertex AI Search Serving Config resource full name. For example,
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
    /// or
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/servingConfigs/{serving_config}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serving_config: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl VertexAiSearchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::VertexAiSearchConfig::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for VertexAiSearchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexAiSearchConfig"
    }
}

/// RagCorpus status.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CorpusStatus {
    /// Output only. RagCorpus life state.
    pub state: crate::model::corpus_status::State,

    /// Output only. Only when the `state` field is ERROR.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_status: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl CorpusStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CorpusStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::corpus_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_status][crate::model::CorpusStatus::error_status].
    pub fn set_error_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_status = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for CorpusStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorpusStatus"
    }
}

/// Defines additional types related to [CorpusStatus].
#[cfg(feature = "vertex_rag_data_service")]
pub mod corpus_status {
    #[allow(unused_imports)]
    use super::*;

    /// RagCorpus life state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// This state is not supposed to happen.
        Unknown,
        /// RagCorpus resource entry is initialized, but hasn't done validation.
        Initialized,
        /// RagCorpus is provisioned successfully and is ready to serve.
        Active,
        /// RagCorpus is in a problematic situation.
        /// See `error_message` field for details.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "vertex_rag_data_service")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Initialized => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Initialized => std::option::Option::Some("INITIALIZED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Initialized,
                2 => Self::Active,
                3 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "INITIALIZED" => Self::Initialized,
                "ACTIVE" => Self::Active,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Initialized => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.aiplatform.v1.CorpusStatus.State",
            ))
        }
    }
}

/// A RagCorpus is a RagFile container and a project can have multiple
/// RagCorpora.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagCorpus {
    /// Output only. The resource name of the RagCorpus.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the RagCorpus.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The description of the RagCorpus.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this RagCorpus was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this RagCorpus was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. RagCorpus state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub corpus_status: std::option::Option<crate::model::CorpusStatus>,

    /// The backend config of the RagCorpus.
    /// It can be data store and/or retrieval engine.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub backend_config: std::option::Option<crate::model::rag_corpus::BackendConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagCorpus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RagCorpus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RagCorpus::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::RagCorpus::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RagCorpus::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::RagCorpus::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [corpus_status][crate::model::RagCorpus::corpus_status].
    pub fn set_corpus_status<
        T: std::convert::Into<std::option::Option<crate::model::CorpusStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.corpus_status = v.into();
        self
    }

    /// Sets the value of [backend_config][crate::model::RagCorpus::backend_config].
    ///
    /// Note that all the setters affecting `backend_config` are mutually
    /// exclusive.
    pub fn set_backend_config<
        T: std::convert::Into<std::option::Option<crate::model::rag_corpus::BackendConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_config = v.into();
        self
    }

    /// The value of [backend_config][crate::model::RagCorpus::backend_config]
    /// if it holds a `VectorDbConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vector_db_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RagVectorDbConfig>> {
        #[allow(unreachable_patterns)]
        self.backend_config.as_ref().and_then(|v| match v {
            crate::model::rag_corpus::BackendConfig::VectorDbConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [backend_config][crate::model::RagCorpus::backend_config]
    /// if it holds a `VertexAiSearchConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_ai_search_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexAiSearchConfig>> {
        #[allow(unreachable_patterns)]
        self.backend_config.as_ref().and_then(|v| match v {
            crate::model::rag_corpus::BackendConfig::VertexAiSearchConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backend_config][crate::model::RagCorpus::backend_config]
    /// to hold a `VectorDbConfig`.
    ///
    /// Note that all the setters affecting `backend_config` are
    /// mutually exclusive.
    pub fn set_vector_db_config<
        T: std::convert::Into<std::boxed::Box<crate::model::RagVectorDbConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_config = std::option::Option::Some(
            crate::model::rag_corpus::BackendConfig::VectorDbConfig(v.into()),
        );
        self
    }

    /// Sets the value of [backend_config][crate::model::RagCorpus::backend_config]
    /// to hold a `VertexAiSearchConfig`.
    ///
    /// Note that all the setters affecting `backend_config` are
    /// mutually exclusive.
    pub fn set_vertex_ai_search_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexAiSearchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_config = std::option::Option::Some(
            crate::model::rag_corpus::BackendConfig::VertexAiSearchConfig(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagCorpus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagCorpus"
    }
}

/// Defines additional types related to [RagCorpus].
#[cfg(feature = "vertex_rag_data_service")]
pub mod rag_corpus {
    #[allow(unused_imports)]
    use super::*;

    /// The backend config of the RagCorpus.
    /// It can be data store and/or retrieval engine.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BackendConfig {
        /// Optional. Immutable. The config for the Vector DBs.
        VectorDbConfig(std::boxed::Box<crate::model::RagVectorDbConfig>),
        /// Optional. Immutable. The config for the Vertex AI Search.
        VertexAiSearchConfig(std::boxed::Box<crate::model::VertexAiSearchConfig>),
    }
}

/// A RagFile contains user data for chunking, embedding and indexing.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFile {
    /// Output only. The resource name of the RagFile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the RagFile.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The description of the RagFile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this RagFile was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this RagFile was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the RagFile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_status: std::option::Option<crate::model::FileStatus>,

    /// The origin location of the RagFile if it is imported from Google Cloud
    /// Storage or Google Drive.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_source: std::option::Option<crate::model::rag_file::RagFileSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RagFile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RagFile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::RagFile::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RagFile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::RagFile::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [file_status][crate::model::RagFile::file_status].
    pub fn set_file_status<T: std::convert::Into<std::option::Option<crate::model::FileStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_status = v.into();
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source].
    ///
    /// Note that all the setters affecting `rag_file_source` are mutually
    /// exclusive.
    pub fn set_rag_file_source<
        T: std::convert::Into<std::option::Option<crate::model::rag_file::RagFileSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = v.into();
        self
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `GoogleDriveSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_drive_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleDriveSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::GoogleDriveSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `DirectUploadSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn direct_upload_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DirectUploadSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::DirectUploadSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `SlackSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slack_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::SlackSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::SlackSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `JiraSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jira_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::JiraSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::JiraSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `SharePointSources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn share_point_sources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SharePointSources>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::SharePointSources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source =
            std::option::Option::Some(crate::model::rag_file::RagFileSource::GcsSource(v.into()));
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `GoogleDriveSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_google_drive_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleDriveSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = std::option::Option::Some(
            crate::model::rag_file::RagFileSource::GoogleDriveSource(v.into()),
        );
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `DirectUploadSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_direct_upload_source<
        T: std::convert::Into<std::boxed::Box<crate::model::DirectUploadSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = std::option::Option::Some(
            crate::model::rag_file::RagFileSource::DirectUploadSource(v.into()),
        );
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `SlackSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_slack_source<T: std::convert::Into<std::boxed::Box<crate::model::SlackSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source =
            std::option::Option::Some(crate::model::rag_file::RagFileSource::SlackSource(v.into()));
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `JiraSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_jira_source<T: std::convert::Into<std::boxed::Box<crate::model::JiraSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source =
            std::option::Option::Some(crate::model::rag_file::RagFileSource::JiraSource(v.into()));
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `SharePointSources`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_share_point_sources<
        T: std::convert::Into<std::boxed::Box<crate::model::SharePointSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = std::option::Option::Some(
            crate::model::rag_file::RagFileSource::SharePointSources(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFile"
    }
}

/// Defines additional types related to [RagFile].
#[cfg(feature = "vertex_rag_data_service")]
pub mod rag_file {
    #[allow(unused_imports)]
    use super::*;

    /// The origin location of the RagFile if it is imported from Google Cloud
    /// Storage or Google Drive.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RagFileSource {
        /// Output only. Google Cloud Storage location of the RagFile.
        /// It does not support wildcards in the Cloud Storage uri for now.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// Output only. Google Drive location. Supports importing individual files
        /// as well as Google Drive folders.
        GoogleDriveSource(std::boxed::Box<crate::model::GoogleDriveSource>),
        /// Output only. The RagFile is encapsulated and uploaded in the
        /// UploadRagFile request.
        DirectUploadSource(std::boxed::Box<crate::model::DirectUploadSource>),
        /// The RagFile is imported from a Slack channel.
        SlackSource(std::boxed::Box<crate::model::SlackSource>),
        /// The RagFile is imported from a Jira query.
        JiraSource(std::boxed::Box<crate::model::JiraSource>),
        /// The RagFile is imported from a SharePoint source.
        SharePointSources(std::boxed::Box<crate::model::SharePointSources>),
    }
}

/// A RagChunk includes the content of a chunk of a RagFile, and associated
/// metadata.
#[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagChunk {
    /// The content of the chunk.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,

    /// If populated, represents where the chunk starts and ends in the document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub page_span: std::option::Option<crate::model::rag_chunk::PageSpan>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
impl RagChunk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::RagChunk::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [page_span][crate::model::RagChunk::page_span].
    pub fn set_page_span<
        T: std::convert::Into<std::option::Option<crate::model::rag_chunk::PageSpan>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.page_span = v.into();
        self
    }
}

#[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
impl wkt::message::Message for RagChunk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagChunk"
    }
}

/// Defines additional types related to [RagChunk].
#[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
pub mod rag_chunk {
    #[allow(unused_imports)]
    use super::*;

    /// Represents where the chunk starts and ends in the document.
    #[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PageSpan {
        /// Page where chunk starts in the document. Inclusive. 1-indexed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub first_page: i32,

        /// Page where chunk ends in the document. Inclusive. 1-indexed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub last_page: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
    impl PageSpan {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [first_page][crate::model::rag_chunk::PageSpan::first_page].
        pub fn set_first_page<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.first_page = v.into();
            self
        }

        /// Sets the value of [last_page][crate::model::rag_chunk::PageSpan::last_page].
        pub fn set_last_page<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.last_page = v.into();
            self
        }
    }

    #[cfg(any(feature = "prediction_service", feature = "vertex_rag_service",))]
    impl wkt::message::Message for PageSpan {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagChunk.PageSpan"
        }
    }
}

/// Specifies the size and overlap of chunks for RagFiles.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFileChunkingConfig {
    /// Specifies the chunking config for RagFiles.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub chunking_config:
        std::option::Option<crate::model::rag_file_chunking_config::ChunkingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagFileChunkingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [chunking_config][crate::model::RagFileChunkingConfig::chunking_config].
    ///
    /// Note that all the setters affecting `chunking_config` are mutually
    /// exclusive.
    pub fn set_chunking_config<
        T: std::convert::Into<
                std::option::Option<crate::model::rag_file_chunking_config::ChunkingConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunking_config = v.into();
        self
    }

    /// The value of [chunking_config][crate::model::RagFileChunkingConfig::chunking_config]
    /// if it holds a `FixedLengthChunking`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed_length_chunking(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::rag_file_chunking_config::FixedLengthChunking>,
    > {
        #[allow(unreachable_patterns)]
        self.chunking_config.as_ref().and_then(|v| match v {
            crate::model::rag_file_chunking_config::ChunkingConfig::FixedLengthChunking(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [chunking_config][crate::model::RagFileChunkingConfig::chunking_config]
    /// to hold a `FixedLengthChunking`.
    ///
    /// Note that all the setters affecting `chunking_config` are
    /// mutually exclusive.
    pub fn set_fixed_length_chunking<
        T: std::convert::Into<
                std::boxed::Box<crate::model::rag_file_chunking_config::FixedLengthChunking>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunking_config = std::option::Option::Some(
            crate::model::rag_file_chunking_config::ChunkingConfig::FixedLengthChunking(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagFileChunkingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileChunkingConfig"
    }
}

/// Defines additional types related to [RagFileChunkingConfig].
#[cfg(feature = "vertex_rag_data_service")]
pub mod rag_file_chunking_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the fixed length chunking config.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FixedLengthChunking {
        /// The size of the chunks.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub chunk_size: i32,

        /// The overlap between chunks.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub chunk_overlap: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl FixedLengthChunking {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [chunk_size][crate::model::rag_file_chunking_config::FixedLengthChunking::chunk_size].
        pub fn set_chunk_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.chunk_size = v.into();
            self
        }

        /// Sets the value of [chunk_overlap][crate::model::rag_file_chunking_config::FixedLengthChunking::chunk_overlap].
        pub fn set_chunk_overlap<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.chunk_overlap = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for FixedLengthChunking {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagFileChunkingConfig.FixedLengthChunking"
        }
    }

    /// Specifies the chunking config for RagFiles.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ChunkingConfig {
        /// Specifies the fixed length chunking config.
        FixedLengthChunking(
            std::boxed::Box<crate::model::rag_file_chunking_config::FixedLengthChunking>,
        ),
    }
}

/// Specifies the transformation config for RagFiles.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFileTransformationConfig {
    /// Specifies the chunking config for RagFiles.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_chunking_config: std::option::Option<crate::model::RagFileChunkingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagFileTransformationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_file_chunking_config][crate::model::RagFileTransformationConfig::rag_file_chunking_config].
    pub fn set_rag_file_chunking_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileChunkingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_chunking_config = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagFileTransformationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileTransformationConfig"
    }
}

/// Specifies the parsing config for RagFiles.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFileParsingConfig {
    /// The parser to use for RagFiles.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub parser: std::option::Option<crate::model::rag_file_parsing_config::Parser>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl RagFileParsingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parser][crate::model::RagFileParsingConfig::parser].
    ///
    /// Note that all the setters affecting `parser` are mutually
    /// exclusive.
    pub fn set_parser<
        T: std::convert::Into<std::option::Option<crate::model::rag_file_parsing_config::Parser>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parser = v.into();
        self
    }

    /// The value of [parser][crate::model::RagFileParsingConfig::parser]
    /// if it holds a `LayoutParser`, `None` if the field is not set or
    /// holds a different branch.
    pub fn layout_parser(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_file_parsing_config::LayoutParser>>
    {
        #[allow(unreachable_patterns)]
        self.parser.as_ref().and_then(|v| match v {
            crate::model::rag_file_parsing_config::Parser::LayoutParser(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [parser][crate::model::RagFileParsingConfig::parser]
    /// to hold a `LayoutParser`.
    ///
    /// Note that all the setters affecting `parser` are
    /// mutually exclusive.
    pub fn set_layout_parser<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_file_parsing_config::LayoutParser>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parser = std::option::Option::Some(
            crate::model::rag_file_parsing_config::Parser::LayoutParser(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for RagFileParsingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileParsingConfig"
    }
}

/// Defines additional types related to [RagFileParsingConfig].
#[cfg(feature = "vertex_rag_data_service")]
pub mod rag_file_parsing_config {
    #[allow(unused_imports)]
    use super::*;

    /// Document AI Layout Parser config.
    #[cfg(feature = "vertex_rag_data_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LayoutParser {
        /// The full resource name of a Document AI processor or processor version.
        /// The processor must have type `LAYOUT_PARSER_PROCESSOR`. If specified, the
        /// `additional_config.parse_as_scanned_pdf` field must be false.
        /// Format:
        ///
        /// * `projects/{project_id}/locations/{location}/processors/{processor_id}`
        /// * `projects/{project_id}/locations/{location}/processors/{processor_id}/processorVersions/{processor_version_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub processor_name: std::string::String,

        /// The maximum number of requests the job is allowed to make to the Document
        /// AI processor per minute. Consult
        /// <https://cloud.google.com/document-ai/quotas> and the Quota page for your
        /// project to set an appropriate value here. If unspecified, a default value
        /// of 120 QPM would be used.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_parsing_requests_per_min: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl LayoutParser {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processor_name][crate::model::rag_file_parsing_config::LayoutParser::processor_name].
        pub fn set_processor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.processor_name = v.into();
            self
        }

        /// Sets the value of [max_parsing_requests_per_min][crate::model::rag_file_parsing_config::LayoutParser::max_parsing_requests_per_min].
        pub fn set_max_parsing_requests_per_min<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_parsing_requests_per_min = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_data_service")]
    impl wkt::message::Message for LayoutParser {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagFileParsingConfig.LayoutParser"
        }
    }

    /// The parser to use for RagFiles.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Parser {
        /// The Layout Parser to use for RagFiles.
        LayoutParser(std::boxed::Box<crate::model::rag_file_parsing_config::LayoutParser>),
    }
}

/// Config for uploading RagFile.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadRagFileConfig {
    /// Specifies the transformation config for RagFiles.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_transformation_config:
        std::option::Option<crate::model::RagFileTransformationConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl UploadRagFileConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_file_transformation_config][crate::model::UploadRagFileConfig::rag_file_transformation_config].
    pub fn set_rag_file_transformation_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileTransformationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_transformation_config = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for UploadRagFileConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileConfig"
    }
}

/// Config for importing RagFiles.
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesConfig {
    /// Specifies the transformation config for RagFiles.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_transformation_config:
        std::option::Option<crate::model::RagFileTransformationConfig>,

    /// Optional. Specifies the parsing config for RagFiles.
    /// RAG will use the default parser if this field is not set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_parsing_config: std::option::Option<crate::model::RagFileParsingConfig>,

    /// Optional. The max number of queries per minute that this job is allowed to
    /// make to the embedding model specified on the corpus. This value is specific
    /// to this job and not shared across other import jobs. Consult the Quotas
    /// page on the project to set an appropriate value here.
    /// If unspecified, a default value of 1,000 QPM would be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_embedding_requests_per_min: i32,

    /// The source of the import.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub import_source: std::option::Option<crate::model::import_rag_files_config::ImportSource>,

    /// Optional. If provided, all partial failures are written to the sink.
    /// Deprecated. Prefer to use the `import_result_sink`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub partial_failure_sink:
        std::option::Option<crate::model::import_rag_files_config::PartialFailureSink>,

    /// Optional. If provided, all successfully imported files and all partial
    /// failures are written to the sink.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub import_result_sink:
        std::option::Option<crate::model::import_rag_files_config::ImportResultSink>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ImportRagFilesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_file_transformation_config][crate::model::ImportRagFilesConfig::rag_file_transformation_config].
    pub fn set_rag_file_transformation_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileTransformationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_transformation_config = v.into();
        self
    }

    /// Sets the value of [rag_file_parsing_config][crate::model::ImportRagFilesConfig::rag_file_parsing_config].
    pub fn set_rag_file_parsing_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileParsingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_parsing_config = v.into();
        self
    }

    /// Sets the value of [max_embedding_requests_per_min][crate::model::ImportRagFilesConfig::max_embedding_requests_per_min].
    pub fn set_max_embedding_requests_per_min<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_embedding_requests_per_min = v.into();
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source].
    ///
    /// Note that all the setters affecting `import_source` are mutually
    /// exclusive.
    pub fn set_import_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_rag_files_config::ImportSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = v.into();
        self
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `GoogleDriveSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_drive_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleDriveSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::GoogleDriveSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `SlackSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slack_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::SlackSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::SlackSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `JiraSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jira_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::JiraSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::JiraSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `SharePointSources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn share_point_sources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SharePointSources>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::SharePointSources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::GcsSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `GoogleDriveSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_google_drive_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleDriveSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::GoogleDriveSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `SlackSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_slack_source<T: std::convert::Into<std::boxed::Box<crate::model::SlackSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::SlackSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `JiraSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_jira_source<T: std::convert::Into<std::boxed::Box<crate::model::JiraSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::JiraSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `SharePointSources`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_share_point_sources<
        T: std::convert::Into<std::boxed::Box<crate::model::SharePointSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::SharePointSources(v.into()),
        );
        self
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink].
    ///
    /// Note that all the setters affecting `partial_failure_sink` are mutually
    /// exclusive.
    pub fn set_partial_failure_sink<
        T: std::convert::Into<
                std::option::Option<crate::model::import_rag_files_config::PartialFailureSink>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = v.into();
        self
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// if it holds a `PartialFailureGcsSink`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn partial_failure_gcs_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureGcsSink(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// if it holds a `PartialFailureBigquerySink`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn partial_failure_bigquery_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureBigquerySink(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// to hold a `PartialFailureGcsSink`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_partial_failure_gcs_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureGcsSink(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// to hold a `PartialFailureBigquerySink`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_partial_failure_bigquery_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureBigquerySink(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [import_result_sink][crate::model::ImportRagFilesConfig::import_result_sink].
    ///
    /// Note that all the setters affecting `import_result_sink` are mutually
    /// exclusive.
    pub fn set_import_result_sink<
        T: std::convert::Into<
                std::option::Option<crate::model::import_rag_files_config::ImportResultSink>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_result_sink = v.into();
        self
    }

    /// The value of [import_result_sink][crate::model::ImportRagFilesConfig::import_result_sink]
    /// if it holds a `ImportResultGcsSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_result_gcs_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.import_result_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportResultSink::ImportResultGcsSink(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_result_sink][crate::model::ImportRagFilesConfig::import_result_sink]
    /// if it holds a `ImportResultBigquerySink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_result_bigquery_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.import_result_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportResultSink::ImportResultBigquerySink(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_result_sink][crate::model::ImportRagFilesConfig::import_result_sink]
    /// to hold a `ImportResultGcsSink`.
    ///
    /// Note that all the setters affecting `import_result_sink` are
    /// mutually exclusive.
    pub fn set_import_result_gcs_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_result_sink = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportResultSink::ImportResultGcsSink(v.into()),
        );
        self
    }

    /// Sets the value of [import_result_sink][crate::model::ImportRagFilesConfig::import_result_sink]
    /// to hold a `ImportResultBigquerySink`.
    ///
    /// Note that all the setters affecting `import_result_sink` are
    /// mutually exclusive.
    pub fn set_import_result_bigquery_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_result_sink = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportResultSink::ImportResultBigquerySink(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ImportRagFilesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesConfig"
    }
}

/// Defines additional types related to [ImportRagFilesConfig].
#[cfg(feature = "vertex_rag_data_service")]
pub mod import_rag_files_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the import.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ImportSource {
        /// Google Cloud Storage location. Supports importing individual files as
        /// well as entire Google Cloud Storage directories. Sample formats:
        ///
        /// - `gs://bucket_name/my_directory/object_name/my_file.txt`
        /// - `gs://bucket_name/my_directory`
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// Google Drive location. Supports importing individual files as
        /// well as Google Drive folders.
        GoogleDriveSource(std::boxed::Box<crate::model::GoogleDriveSource>),
        /// Slack channels with their corresponding access tokens.
        SlackSource(std::boxed::Box<crate::model::SlackSource>),
        /// Jira queries with their corresponding authentication.
        JiraSource(std::boxed::Box<crate::model::JiraSource>),
        /// SharePoint sources.
        SharePointSources(std::boxed::Box<crate::model::SharePointSources>),
    }

    /// Optional. If provided, all partial failures are written to the sink.
    /// Deprecated. Prefer to use the `import_result_sink`.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PartialFailureSink {
        /// The Cloud Storage path to write partial failures to.
        /// Deprecated. Prefer to use `import_result_gcs_sink`.
        #[deprecated]
        PartialFailureGcsSink(std::boxed::Box<crate::model::GcsDestination>),
        /// The BigQuery destination to write partial failures to. It should be a
        /// bigquery table resource name (e.g.
        /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
        /// table does not exist, it will be created with the expected schema. If the
        /// table exists, the schema will be validated and data will be added to this
        /// existing table.
        /// Deprecated. Prefer to use `import_result_bq_sink`.
        #[deprecated]
        PartialFailureBigquerySink(std::boxed::Box<crate::model::BigQueryDestination>),
    }

    /// Optional. If provided, all successfully imported files and all partial
    /// failures are written to the sink.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ImportResultSink {
        /// The Cloud Storage path to write import result to.
        ImportResultGcsSink(std::boxed::Box<crate::model::GcsDestination>),
        /// The BigQuery destination to write import result to. It should be a
        /// bigquery table resource name (e.g.
        /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
        /// table does not exist, it will be created with the expected schema. If the
        /// table exists, the schema will be validated and data will be added to this
        /// existing table.
        ImportResultBigquerySink(std::boxed::Box<crate::model::BigQueryDestination>),
    }
}

/// Request message for
/// [VertexRagDataService.CreateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus]: crate::client::VertexRagDataService::create_rag_corpus
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRagCorpusRequest {
    /// Required. The resource name of the Location to create the RagCorpus in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The RagCorpus to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_corpus: std::option::Option<crate::model::RagCorpus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl CreateRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRagCorpusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rag_corpus][crate::model::CreateRagCorpusRequest::rag_corpus].
    pub fn set_rag_corpus<T: std::convert::Into<std::option::Option<crate::model::RagCorpus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_corpus = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for CreateRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRagCorpusRequest"
    }
}

/// Request message for
/// [VertexRagDataService.GetRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.GetRagCorpus]
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.GetRagCorpus]: crate::client::VertexRagDataService::get_rag_corpus
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRagCorpusRequest {
    /// Required. The name of the RagCorpus resource.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl GetRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRagCorpusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for GetRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagCorpusRequest"
    }
}

/// Request message for
/// [VertexRagDataService.ListRagCorpora][google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]: crate::client::VertexRagDataService::list_rag_corpora
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagCorporaRequest {
    /// Required. The resource name of the Location from which to list the
    /// RagCorpora. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListRagCorporaResponse.next_page_token][google.cloud.aiplatform.v1.ListRagCorporaResponse.next_page_token]
    /// of the previous
    /// [VertexRagDataService.ListRagCorpora][google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListRagCorporaResponse.next_page_token]: crate::model::ListRagCorporaResponse::next_page_token
    /// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]: crate::client::VertexRagDataService::list_rag_corpora
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ListRagCorporaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRagCorporaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRagCorporaRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRagCorporaRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ListRagCorporaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagCorporaRequest"
    }
}

/// Response message for
/// [VertexRagDataService.ListRagCorpora][google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]: crate::client::VertexRagDataService::list_rag_corpora
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagCorporaResponse {
    /// List of RagCorpora in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rag_corpora: std::vec::Vec<crate::model::RagCorpus>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListRagCorporaRequest.page_token][google.cloud.aiplatform.v1.ListRagCorporaRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListRagCorporaRequest.page_token]: crate::model::ListRagCorporaRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ListRagCorporaResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRagCorporaResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [rag_corpora][crate::model::ListRagCorporaResponse::rag_corpora].
    pub fn set_rag_corpora<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RagCorpus>,
    {
        use std::iter::Iterator;
        self.rag_corpora = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ListRagCorporaResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagCorporaResponse"
    }
}

#[cfg(feature = "vertex_rag_data_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRagCorporaResponse {
    type PageItem = crate::model::RagCorpus;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rag_corpora
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VertexRagDataService.DeleteRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagCorpus]: crate::client::VertexRagDataService::delete_rag_corpus
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRagCorpusRequest {
    /// Required. The name of the RagCorpus resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, any RagFiles in this RagCorpus will also be
    /// deleted. Otherwise, the request will only work if the RagCorpus has no
    /// RagFiles.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl DeleteRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRagCorpusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRagCorpusRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for DeleteRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteRagCorpusRequest"
    }
}

/// Request message for
/// [VertexRagDataService.UploadRagFile][google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile]: crate::client::VertexRagDataService::upload_rag_file
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadRagFileRequest {
    /// Required. The name of the RagCorpus resource into which to upload the file.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The RagFile to upload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file: std::option::Option<crate::model::RagFile>,

    /// Required. The config for the RagFiles to be uploaded into the RagCorpus.
    /// [VertexRagDataService.UploadRagFile][google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile].
    ///
    /// [google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile]: crate::client::VertexRagDataService::upload_rag_file
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upload_rag_file_config: std::option::Option<crate::model::UploadRagFileConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl UploadRagFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UploadRagFileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rag_file][crate::model::UploadRagFileRequest::rag_file].
    pub fn set_rag_file<T: std::convert::Into<std::option::Option<crate::model::RagFile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file = v.into();
        self
    }

    /// Sets the value of [upload_rag_file_config][crate::model::UploadRagFileRequest::upload_rag_file_config].
    pub fn set_upload_rag_file_config<
        T: std::convert::Into<std::option::Option<crate::model::UploadRagFileConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upload_rag_file_config = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for UploadRagFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileRequest"
    }
}

/// Response message for
/// [VertexRagDataService.UploadRagFile][google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile]: crate::client::VertexRagDataService::upload_rag_file
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadRagFileResponse {
    /// The result of the upload.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::upload_rag_file_response::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl UploadRagFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::UploadRagFileResponse::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::upload_rag_file_response::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::UploadRagFileResponse::result]
    /// if it holds a `RagFile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rag_file(&self) -> std::option::Option<&std::boxed::Box<crate::model::RagFile>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::upload_rag_file_response::Result::RagFile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::UploadRagFileResponse::result]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::upload_rag_file_response::Result::Error(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::UploadRagFileResponse::result]
    /// to hold a `RagFile`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_rag_file<T: std::convert::Into<std::boxed::Box<crate::model::RagFile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::upload_rag_file_response::Result::RagFile(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::UploadRagFileResponse::result]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::upload_rag_file_response::Result::Error(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for UploadRagFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileResponse"
    }
}

/// Defines additional types related to [UploadRagFileResponse].
#[cfg(feature = "vertex_rag_data_service")]
pub mod upload_rag_file_response {
    #[allow(unused_imports)]
    use super::*;

    /// The result of the upload.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// The RagFile that had been uploaded into the RagCorpus.
        RagFile(std::boxed::Box<crate::model::RagFile>),
        /// The error that occurred while processing the RagFile.
        Error(std::boxed::Box<rpc::model::Status>),
    }
}

/// Request message for
/// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesRequest {
    /// Required. The name of the RagCorpus resource into which to import files.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The config for the RagFiles to be synced and imported into the
    /// RagCorpus.
    /// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
    ///
    /// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_rag_files_config: std::option::Option<crate::model::ImportRagFilesConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ImportRagFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportRagFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_rag_files_config][crate::model::ImportRagFilesRequest::import_rag_files_config].
    pub fn set_import_rag_files_config<
        T: std::convert::Into<std::option::Option<crate::model::ImportRagFilesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_rag_files_config = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ImportRagFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesRequest"
    }
}

/// Response message for
/// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesResponse {
    /// The number of RagFiles that had been imported into the RagCorpus.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_rag_files_count: i64,

    /// The number of RagFiles that had failed while importing into the RagCorpus.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_rag_files_count: i64,

    /// The number of RagFiles that was skipped while importing into the RagCorpus.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub skipped_rag_files_count: i64,

    /// The location into which the partial failures were written.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub partial_failure_sink:
        std::option::Option<crate::model::import_rag_files_response::PartialFailureSink>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ImportRagFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_rag_files_count][crate::model::ImportRagFilesResponse::imported_rag_files_count].
    pub fn set_imported_rag_files_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_rag_files_count = v.into();
        self
    }

    /// Sets the value of [failed_rag_files_count][crate::model::ImportRagFilesResponse::failed_rag_files_count].
    pub fn set_failed_rag_files_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_rag_files_count = v.into();
        self
    }

    /// Sets the value of [skipped_rag_files_count][crate::model::ImportRagFilesResponse::skipped_rag_files_count].
    pub fn set_skipped_rag_files_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.skipped_rag_files_count = v.into();
        self
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink].
    ///
    /// Note that all the setters affecting `partial_failure_sink` are mutually
    /// exclusive.
    pub fn set_partial_failure_sink<
        T: std::convert::Into<
                std::option::Option<crate::model::import_rag_files_response::PartialFailureSink>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = v.into();
        self
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// if it holds a `PartialFailuresGcsPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn partial_failures_gcs_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresGcsPath(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// if it holds a `PartialFailuresBigqueryTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn partial_failures_bigquery_table(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresBigqueryTable(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// to hold a `PartialFailuresGcsPath`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    pub fn set_partial_failures_gcs_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresGcsPath(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// to hold a `PartialFailuresBigqueryTable`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    pub fn set_partial_failures_bigquery_table<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresBigqueryTable(
                v.into()
            )
        );
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ImportRagFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesResponse"
    }
}

/// Defines additional types related to [ImportRagFilesResponse].
#[cfg(feature = "vertex_rag_data_service")]
pub mod import_rag_files_response {
    #[allow(unused_imports)]
    use super::*;

    /// The location into which the partial failures were written.
    #[cfg(feature = "vertex_rag_data_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PartialFailureSink {
        /// The Google Cloud Storage path into which the partial failures were
        /// written.
        PartialFailuresGcsPath(std::string::String),
        /// The BigQuery table into which the partial failures were written.
        PartialFailuresBigqueryTable(std::string::String),
    }
}

/// Request message for
/// [VertexRagDataService.GetRagFile][google.cloud.aiplatform.v1.VertexRagDataService.GetRagFile]
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.GetRagFile]: crate::client::VertexRagDataService::get_rag_file
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRagFileRequest {
    /// Required. The name of the RagFile resource.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl GetRagFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRagFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for GetRagFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagFileRequest"
    }
}

/// Request message for
/// [VertexRagDataService.ListRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]: crate::client::VertexRagDataService::list_rag_files
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagFilesRequest {
    /// Required. The resource name of the RagCorpus from which to list the
    /// RagFiles. Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListRagFilesResponse.next_page_token][google.cloud.aiplatform.v1.ListRagFilesResponse.next_page_token]
    /// of the previous
    /// [VertexRagDataService.ListRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListRagFilesResponse.next_page_token]: crate::model::ListRagFilesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]: crate::client::VertexRagDataService::list_rag_files
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ListRagFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRagFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRagFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRagFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ListRagFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagFilesRequest"
    }
}

/// Response message for
/// [VertexRagDataService.ListRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]: crate::client::VertexRagDataService::list_rag_files
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagFilesResponse {
    /// List of RagFiles in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rag_files: std::vec::Vec<crate::model::RagFile>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListRagFilesRequest.page_token][google.cloud.aiplatform.v1.ListRagFilesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListRagFilesRequest.page_token]: crate::model::ListRagFilesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ListRagFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRagFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [rag_files][crate::model::ListRagFilesResponse::rag_files].
    pub fn set_rag_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RagFile>,
    {
        use std::iter::Iterator;
        self.rag_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ListRagFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagFilesResponse"
    }
}

#[cfg(feature = "vertex_rag_data_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRagFilesResponse {
    type PageItem = crate::model::RagFile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rag_files
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VertexRagDataService.DeleteRagFile][google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagFile].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagFile]: crate::client::VertexRagDataService::delete_rag_file
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRagFileRequest {
    /// Required. The name of the RagFile resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl DeleteRagFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRagFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for DeleteRagFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteRagFileRequest"
    }
}

/// Runtime operation information for
/// [VertexRagDataService.CreateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus]: crate::client::VertexRagDataService::create_rag_corpus
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRagCorpusOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl CreateRagCorpusOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateRagCorpusOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for CreateRagCorpusOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRagCorpusOperationMetadata"
    }
}

/// Request message for
/// [VertexRagDataService.UpdateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus]: crate::client::VertexRagDataService::update_rag_corpus
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRagCorpusRequest {
    /// Required. The RagCorpus which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_corpus: std::option::Option<crate::model::RagCorpus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl UpdateRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_corpus][crate::model::UpdateRagCorpusRequest::rag_corpus].
    pub fn set_rag_corpus<T: std::convert::Into<std::option::Option<crate::model::RagCorpus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_corpus = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for UpdateRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagCorpusRequest"
    }
}

/// Runtime operation information for
/// [VertexRagDataService.UpdateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus]: crate::client::VertexRagDataService::update_rag_corpus
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRagCorpusOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl UpdateRagCorpusOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateRagCorpusOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for UpdateRagCorpusOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagCorpusOperationMetadata"
    }
}

/// Runtime operation information for
/// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
#[cfg(feature = "vertex_rag_data_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The resource ID of RagCorpus that this operation is executed on.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub rag_corpus_id: i64,

    /// Output only. The config that was passed in the ImportRagFilesRequest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_rag_files_config: std::option::Option<crate::model::ImportRagFilesConfig>,

    /// The progress percentage of the operation. Value is in the range [0, 100].
    /// This percentage is calculated as follows:
    /// progress_percentage = 100 * (successes + failures + skips) / total
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub progress_percentage: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_data_service")]
impl ImportRagFilesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ImportRagFilesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [rag_corpus_id][crate::model::ImportRagFilesOperationMetadata::rag_corpus_id].
    pub fn set_rag_corpus_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rag_corpus_id = v.into();
        self
    }

    /// Sets the value of [import_rag_files_config][crate::model::ImportRagFilesOperationMetadata::import_rag_files_config].
    pub fn set_import_rag_files_config<
        T: std::convert::Into<std::option::Option<crate::model::ImportRagFilesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_rag_files_config = v.into();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::ImportRagFilesOperationMetadata::progress_percentage].
    pub fn set_progress_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percentage = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_data_service")]
impl wkt::message::Message for ImportRagFilesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesOperationMetadata"
    }
}

/// A query to retrieve relevant contexts.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagQuery {
    /// Optional. The retrieval config for the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_retrieval_config: std::option::Option<crate::model::RagRetrievalConfig>,

    /// The query to retrieve contexts.
    /// Currently only text query is supported.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::rag_query::Query>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl RagQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_retrieval_config][crate::model::RagQuery::rag_retrieval_config].
    pub fn set_rag_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::RagRetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_retrieval_config = v.into();
        self
    }

    /// Sets the value of [query][crate::model::RagQuery::query].
    ///
    /// Note that all the setters affecting `query` are mutually
    /// exclusive.
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::rag_query::Query>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// The value of [query][crate::model::RagQuery::query]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::rag_query::Query::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::RagQuery::query]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(crate::model::rag_query::Query::Text(v.into()));
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for RagQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagQuery"
    }
}

/// Defines additional types related to [RagQuery].
#[cfg(feature = "vertex_rag_service")]
pub mod rag_query {
    #[allow(unused_imports)]
    use super::*;

    /// The query to retrieve contexts.
    /// Currently only text query is supported.
    #[cfg(feature = "vertex_rag_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Query {
        /// Optional. The query in text format to get relevant contexts.
        Text(std::string::String),
    }
}

/// Request message for
/// [VertexRagService.RetrieveContexts][google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts].
///
/// [google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts]: crate::client::VertexRagService::retrieve_contexts
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveContextsRequest {
    /// Required. The resource name of the Location from which to retrieve
    /// RagContexts. The users must have permission to make a call in the project.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Single RAG retrieve query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::RagQuery>,

    /// Data Source to retrieve contexts.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::retrieve_contexts_request::DataSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl RetrieveContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RetrieveContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::RetrieveContextsRequest::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::RagQuery>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::RetrieveContextsRequest::data_source].
    ///
    /// Note that all the setters affecting `data_source` are mutually
    /// exclusive.
    pub fn set_data_source<
        T: std::convert::Into<
                std::option::Option<crate::model::retrieve_contexts_request::DataSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::RetrieveContextsRequest::data_source]
    /// if it holds a `VertexRagStore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_rag_store(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::retrieve_contexts_request::VertexRagStore>,
    > {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::retrieve_contexts_request::DataSource::VertexRagStore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::RetrieveContextsRequest::data_source]
    /// to hold a `VertexRagStore`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_store<
        T: std::convert::Into<
                std::boxed::Box<crate::model::retrieve_contexts_request::VertexRagStore>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::retrieve_contexts_request::DataSource::VertexRagStore(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for RetrieveContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest"
    }
}

/// Defines additional types related to [RetrieveContextsRequest].
#[cfg(feature = "vertex_rag_service")]
pub mod retrieve_contexts_request {
    #[allow(unused_imports)]
    use super::*;

    /// The data source for Vertex RagStore.
    #[cfg(feature = "vertex_rag_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexRagStore {
        /// Optional. The representation of the rag source. It can be used to specify
        /// corpus only or ragfiles. Currently only support one corpus or multiple
        /// files from one corpus. In the future we may open up multiple corpora
        /// support.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rag_resources:
            std::vec::Vec<crate::model::retrieve_contexts_request::vertex_rag_store::RagResource>,

        /// Optional. Only return contexts with vector distance smaller than the
        /// threshold.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[deprecated]
        pub vector_distance_threshold: std::option::Option<f64>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_service")]
    impl VertexRagStore {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [vector_distance_threshold][crate::model::retrieve_contexts_request::VertexRagStore::vector_distance_threshold].
        #[deprecated]
        pub fn set_vector_distance_threshold<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.vector_distance_threshold = v.into();
            self
        }

        /// Sets the value of [rag_resources][crate::model::retrieve_contexts_request::VertexRagStore::rag_resources].
        pub fn set_rag_resources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::retrieve_contexts_request::vertex_rag_store::RagResource,
                >,
        {
            use std::iter::Iterator;
            self.rag_resources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "vertex_rag_service")]
    impl wkt::message::Message for VertexRagStore {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore"
        }
    }

    /// Defines additional types related to [VertexRagStore].
    #[cfg(feature = "vertex_rag_service")]
    pub mod vertex_rag_store {
        #[allow(unused_imports)]
        use super::*;

        /// The definition of the Rag resource.
        #[cfg(feature = "vertex_rag_service")]
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RagResource {
            /// Optional. RagCorpora resource name.
            /// Format:
            /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub rag_corpus: std::string::String,

            /// Optional. rag_file_id. The files should be in the same rag_corpus set
            /// in rag_corpus field.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub rag_file_ids: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "vertex_rag_service")]
        impl RagResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [rag_corpus][crate::model::retrieve_contexts_request::vertex_rag_store::RagResource::rag_corpus].
            pub fn set_rag_corpus<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.rag_corpus = v.into();
                self
            }

            /// Sets the value of [rag_file_ids][crate::model::retrieve_contexts_request::vertex_rag_store::RagResource::rag_file_ids].
            pub fn set_rag_file_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.rag_file_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "vertex_rag_service")]
        impl wkt::message::Message for RagResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore.RagResource"
            }
        }
    }

    /// Data Source to retrieve contexts.
    #[cfg(feature = "vertex_rag_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSource {
        /// The data source for Vertex RagStore.
        VertexRagStore(std::boxed::Box<crate::model::retrieve_contexts_request::VertexRagStore>),
    }
}

/// Relevant contexts for one query.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagContexts {
    /// All its contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contexts: std::vec::Vec<crate::model::rag_contexts::Context>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl RagContexts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contexts][crate::model::RagContexts::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rag_contexts::Context>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for RagContexts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagContexts"
    }
}

/// Defines additional types related to [RagContexts].
#[cfg(feature = "vertex_rag_service")]
pub mod rag_contexts {
    #[allow(unused_imports)]
    use super::*;

    /// A context of the query.
    #[cfg(feature = "vertex_rag_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Context {
        /// If the file is imported from Cloud Storage or Google Drive, source_uri
        /// will be original file URI in Cloud Storage or Google Drive; if file is
        /// uploaded, source_uri will be file display name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_uri: std::string::String,

        /// The file display name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_display_name: std::string::String,

        /// The text chunk.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,

        /// According to the underlying Vector DB and the selected metric type, the
        /// score can be either the distance or the similarity between the query and
        /// the context and its range depends on the metric type.
        ///
        /// For example, if the metric type is COSINE_DISTANCE, it represents the
        /// distance between the query and the context. The larger the distance, the
        /// less relevant the context is to the query. The range is [0, 2], while 0
        /// means the most relevant and 2 means the least relevant.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub score: std::option::Option<f64>,

        /// Context of the retrieved chunk.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub chunk: std::option::Option<crate::model::RagChunk>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_service")]
    impl Context {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_uri][crate::model::rag_contexts::Context::source_uri].
        pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_uri = v.into();
            self
        }

        /// Sets the value of [source_display_name][crate::model::rag_contexts::Context::source_display_name].
        pub fn set_source_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_display_name = v.into();
            self
        }

        /// Sets the value of [text][crate::model::rag_contexts::Context::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [score][crate::model::rag_contexts::Context::score].
        pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [chunk][crate::model::rag_contexts::Context::chunk].
        pub fn set_chunk<T: std::convert::Into<std::option::Option<crate::model::RagChunk>>>(
            mut self,
            v: T,
        ) -> Self {
            self.chunk = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_service")]
    impl wkt::message::Message for Context {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagContexts.Context"
        }
    }
}

/// Response message for
/// [VertexRagService.RetrieveContexts][google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts].
///
/// [google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts]: crate::client::VertexRagService::retrieve_contexts
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveContextsResponse {
    /// The contexts of the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub contexts: std::option::Option<crate::model::RagContexts>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl RetrieveContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contexts][crate::model::RetrieveContextsResponse::contexts].
    pub fn set_contexts<T: std::convert::Into<std::option::Option<crate::model::RagContexts>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contexts = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for RetrieveContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsResponse"
    }
}

/// Request message for AugmentPrompt.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AugmentPromptRequest {
    /// Required. The resource name of the Location from which to augment prompt.
    /// The users must have permission to make a call in the project.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Input content to augment, only text format is supported for now.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. Metadata of the backend deployed model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::augment_prompt_request::Model>,

    /// The data source for retrieving contexts.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::augment_prompt_request::DataSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl AugmentPromptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AugmentPromptRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::AugmentPromptRequest::model].
    pub fn set_model<
        T: std::convert::Into<std::option::Option<crate::model::augment_prompt_request::Model>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::AugmentPromptRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_source][crate::model::AugmentPromptRequest::data_source].
    ///
    /// Note that all the setters affecting `data_source` are mutually
    /// exclusive.
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::augment_prompt_request::DataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::AugmentPromptRequest::data_source]
    /// if it holds a `VertexRagStore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertex_rag_store(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexRagStore>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::augment_prompt_request::DataSource::VertexRagStore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::AugmentPromptRequest::data_source]
    /// to hold a `VertexRagStore`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_store<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexRagStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::augment_prompt_request::DataSource::VertexRagStore(v.into()),
        );
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for AugmentPromptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptRequest"
    }
}

/// Defines additional types related to [AugmentPromptRequest].
#[cfg(feature = "vertex_rag_service")]
pub mod augment_prompt_request {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of the backend deployed model.
    #[cfg(feature = "vertex_rag_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Model {
        /// Optional. The model that the user will send the augmented prompt for
        /// content generation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// Optional. The model version of the backend deployed model.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_service")]
    impl Model {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::augment_prompt_request::Model::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_version][crate::model::augment_prompt_request::Model::model_version].
        pub fn set_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_version = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_service")]
    impl wkt::message::Message for Model {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptRequest.Model"
        }
    }

    /// The data source for retrieving contexts.
    #[cfg(feature = "vertex_rag_service")]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSource {
        /// Optional. Retrieves contexts from the Vertex RagStore.
        VertexRagStore(std::boxed::Box<crate::model::VertexRagStore>),
    }
}

/// Response message for AugmentPrompt.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AugmentPromptResponse {
    /// Augmented prompt, only text format is supported for now.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub augmented_prompt: std::vec::Vec<crate::model::Content>,

    /// Retrieved facts from RAG data sources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facts: std::vec::Vec<crate::model::Fact>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl AugmentPromptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [augmented_prompt][crate::model::AugmentPromptResponse::augmented_prompt].
    pub fn set_augmented_prompt<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.augmented_prompt = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [facts][crate::model::AugmentPromptResponse::facts].
    pub fn set_facts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Fact>,
    {
        use std::iter::Iterator;
        self.facts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for AugmentPromptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptResponse"
    }
}

/// Request message for CorroborateContent.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CorroborateContentRequest {
    /// Required. The resource name of the Location from which to corroborate text.
    /// The users must have permission to make a call in the project.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Input content to corroborate, only text format is supported for
    /// now.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::Content>,

    /// Optional. Facts used to generate the text can also be used to corroborate
    /// the text.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facts: std::vec::Vec<crate::model::Fact>,

    /// Optional. Parameters that can be set to override default settings per
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::corroborate_content_request::Parameters>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl CorroborateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CorroborateContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [content][crate::model::CorroborateContentRequest::content].
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::CorroborateContentRequest::parameters].
    pub fn set_parameters<
        T: std::convert::Into<
                std::option::Option<crate::model::corroborate_content_request::Parameters>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [facts][crate::model::CorroborateContentRequest::facts].
    pub fn set_facts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Fact>,
    {
        use std::iter::Iterator;
        self.facts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for CorroborateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentRequest"
    }
}

/// Defines additional types related to [CorroborateContentRequest].
#[cfg(feature = "vertex_rag_service")]
pub mod corroborate_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters that can be overrided per request.
    #[cfg(feature = "vertex_rag_service")]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Parameters {
        /// Optional. Only return claims with citation score larger than the
        /// threshold.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub citation_threshold: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "vertex_rag_service")]
    impl Parameters {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [citation_threshold][crate::model::corroborate_content_request::Parameters::citation_threshold].
        pub fn set_citation_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.citation_threshold = v.into();
            self
        }
    }

    #[cfg(feature = "vertex_rag_service")]
    impl wkt::message::Message for Parameters {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentRequest.Parameters"
        }
    }
}

/// Response message for CorroborateContent.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CorroborateContentResponse {
    /// Confidence score of corroborating content. Value is [0,1] with 1 is the
    /// most confidence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub corroboration_score: std::option::Option<f32>,

    /// Claims that are extracted from the input content and facts that support the
    /// claims.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub claims: std::vec::Vec<crate::model::Claim>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl CorroborateContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [corroboration_score][crate::model::CorroborateContentResponse::corroboration_score].
    pub fn set_corroboration_score<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.corroboration_score = v.into();
        self
    }

    /// Sets the value of [claims][crate::model::CorroborateContentResponse::claims].
    pub fn set_claims<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Claim>,
    {
        use std::iter::Iterator;
        self.claims = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for CorroborateContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentResponse"
    }
}

/// The fact used in grounding.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Fact {
    /// Query that is used to retrieve this fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<std::string::String>,

    /// If present, it refers to the title of this fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub title: std::option::Option<std::string::String>,

    /// If present, this uri links to the source of the fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub uri: std::option::Option<std::string::String>,

    /// If present, the summary/snippet of the fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summary: std::option::Option<std::string::String>,

    /// If present, the distance between the query vector and this fact vector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub vector_distance: std::option::Option<f64>,

    /// If present, according to the underlying Vector DB and the selected metric
    /// type, the score can be either the distance or the similarity between the
    /// query and the fact and its range depends on the metric type.
    ///
    /// For example, if the metric type is COSINE_DISTANCE, it represents the
    /// distance between the query and the fact. The larger the distance, the less
    /// relevant the fact is to the query. The range is [0, 2], while 0 means the
    /// most relevant and 2 means the least relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f64>,

    /// If present, chunk properties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub chunk: std::option::Option<crate::model::RagChunk>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl Fact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::Fact::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Fact::title].
    pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Fact::uri].
    pub fn set_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [summary][crate::model::Fact::summary].
    pub fn set_summary<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.summary = v.into();
        self
    }

    /// Sets the value of [vector_distance][crate::model::Fact::vector_distance].
    #[deprecated]
    pub fn set_vector_distance<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vector_distance = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Fact::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [chunk][crate::model::Fact::chunk].
    pub fn set_chunk<T: std::convert::Into<std::option::Option<crate::model::RagChunk>>>(
        mut self,
        v: T,
    ) -> Self {
        self.chunk = v.into();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for Fact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Fact"
    }
}

/// Claim that is extracted from the input text and facts that support it.
#[cfg(feature = "vertex_rag_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Claim {
    /// Index in the input text where the claim starts (inclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_index: std::option::Option<i32>,

    /// Index in the input text where the claim ends (exclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_index: std::option::Option<i32>,

    /// Indexes of the facts supporting this claim.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fact_indexes: std::vec::Vec<i32>,

    /// Confidence score of this corroboration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vertex_rag_service")]
impl Claim {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_index][crate::model::Claim::start_index].
    pub fn set_start_index<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_index = v.into();
        self
    }

    /// Sets the value of [end_index][crate::model::Claim::end_index].
    pub fn set_end_index<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.end_index = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Claim::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [fact_indexes][crate::model::Claim::fact_indexes].
    pub fn set_fact_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.fact_indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vertex_rag_service")]
impl wkt::message::Message for Claim {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Claim"
    }
}

/// Request message for
/// [VizierService.GetStudy][google.cloud.aiplatform.v1.VizierService.GetStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.GetStudy]: crate::client::VizierService::get_study
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStudyRequest {
    /// Required. The name of the Study resource.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl GetStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStudyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for GetStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetStudyRequest"
    }
}

/// Request message for
/// [VizierService.CreateStudy][google.cloud.aiplatform.v1.VizierService.CreateStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.CreateStudy]: crate::client::VizierService::create_study
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStudyRequest {
    /// Required. The resource name of the Location to create the CustomJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Study configuration used to create the Study.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study: std::option::Option<crate::model::Study>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl CreateStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStudyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [study][crate::model::CreateStudyRequest::study].
    pub fn set_study<T: std::convert::Into<std::option::Option<crate::model::Study>>>(
        mut self,
        v: T,
    ) -> Self {
        self.study = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for CreateStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateStudyRequest"
    }
}

/// Request message for
/// [VizierService.ListStudies][google.cloud.aiplatform.v1.VizierService.ListStudies].
///
/// [google.cloud.aiplatform.v1.VizierService.ListStudies]: crate::client::VizierService::list_studies
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStudiesRequest {
    /// Required. The resource name of the Location to list the Study from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. A page token to request the next page of results.
    /// If unspecified, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of studies to return per "page" of results.
    /// If unspecified, service will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl ListStudiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStudiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStudiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStudiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for ListStudiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListStudiesRequest"
    }
}

/// Response message for
/// [VizierService.ListStudies][google.cloud.aiplatform.v1.VizierService.ListStudies].
///
/// [google.cloud.aiplatform.v1.VizierService.ListStudies]: crate::client::VizierService::list_studies
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStudiesResponse {
    /// The studies associated with the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub studies: std::vec::Vec<crate::model::Study>,

    /// Passes this token as the `page_token` field of the request for a
    /// subsequent call.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl ListStudiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListStudiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [studies][crate::model::ListStudiesResponse::studies].
    pub fn set_studies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Study>,
    {
        use std::iter::Iterator;
        self.studies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for ListStudiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListStudiesResponse"
    }
}

#[cfg(feature = "vizier_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStudiesResponse {
    type PageItem = crate::model::Study;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.studies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VizierService.DeleteStudy][google.cloud.aiplatform.v1.VizierService.DeleteStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.DeleteStudy]: crate::client::VizierService::delete_study
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteStudyRequest {
    /// Required. The name of the Study resource to be deleted.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl DeleteStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStudyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for DeleteStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteStudyRequest"
    }
}

/// Request message for
/// [VizierService.LookupStudy][google.cloud.aiplatform.v1.VizierService.LookupStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.LookupStudy]: crate::client::VizierService::lookup_study
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LookupStudyRequest {
    /// Required. The resource name of the Location to get the Study from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-defined display name of the Study
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl LookupStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupStudyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::LookupStudyRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for LookupStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LookupStudyRequest"
    }
}

/// Request message for
/// [VizierService.SuggestTrials][google.cloud.aiplatform.v1.VizierService.SuggestTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.SuggestTrials]: crate::client::VizierService::suggest_trials
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestTrialsRequest {
    /// Required. The project and location that the Study belongs to.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The number of suggestions requested. It must be positive.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub suggestion_count: i32,

    /// Required. The identifier of the client that is requesting the suggestion.
    ///
    /// If multiple SuggestTrialsRequests have the same `client_id`,
    /// the service will return the identical suggested Trial if the Trial is
    /// pending, and provide a new Trial if the last suggested Trial was completed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,

    /// Optional. This allows you to specify the "context" for a Trial; a context
    /// is a slice (a subspace) of the search space.
    ///
    /// Typical uses for contexts:
    ///
    /// ) You are using Vizier to tune a server for best performance, but there's
    ///   a strong weekly cycle.  The context specifies the day-of-week.
    ///   This allows Tuesday to generalize from Wednesday without assuming that
    ///   everything is identical.
    /// ) Imagine you're optimizing some medical treatment for people.
    ///   As they walk in the door, you know certain facts about them
    ///   (e.g. sex, weight, height, blood-pressure).  Put that information in the
    ///   context, and Vizier will adapt its suggestions to the patient.
    /// ) You want to do a fair A/B test efficiently.  Specify the "A" and "B"
    ///   conditions as contexts, and Vizier will generalize between "A" and "B"
    ///   conditions.  If they are similar, this will allow Vizier to converge
    ///   to the optimum faster than if "A" and "B" were separate Studies.
    ///   NOTE: You can also enter contexts as REQUESTED Trials, e.g. via the
    ///   CreateTrial() RPC; that's the asynchronous option where you don't need a
    ///   close association between contexts and suggestions.
    ///
    /// NOTE: All the Parameters you set in a context MUST be defined in the
    /// Study.
    /// NOTE: You must supply 0 or $suggestion_count contexts.
    /// If you don't supply any contexts, Vizier will make suggestions
    /// from the full search space specified in the StudySpec; if you supply
    /// a full set of context, each suggestion will match the corresponding
    /// context.
    /// NOTE: A Context with no features set matches anything, and allows
    /// suggestions from the full search space.
    /// NOTE: Contexts MUST lie within the search space specified in the
    /// StudySpec.  It's an error if they don't.
    /// NOTE: Contexts preferentially match ACTIVE then REQUESTED trials before
    /// new suggestions are generated.
    /// NOTE: Generation of suggestions involves a match between a Context and
    /// (optionally) a REQUESTED trial; if that match is not fully specified, a
    /// suggestion will be geneated in the merged subspace.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contexts: std::vec::Vec<crate::model::TrialContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl SuggestTrialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SuggestTrialsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [suggestion_count][crate::model::SuggestTrialsRequest::suggestion_count].
    pub fn set_suggestion_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.suggestion_count = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::SuggestTrialsRequest::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [contexts][crate::model::SuggestTrialsRequest::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrialContext>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for SuggestTrialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsRequest"
    }
}

/// Response message for
/// [VizierService.SuggestTrials][google.cloud.aiplatform.v1.VizierService.SuggestTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.SuggestTrials]: crate::client::VizierService::suggest_trials
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestTrialsResponse {
    /// A list of Trials.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trials: std::vec::Vec<crate::model::Trial>,

    /// The state of the Study.
    pub study_state: crate::model::study::State,

    /// The time at which the operation was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which operation processing completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl SuggestTrialsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [study_state][crate::model::SuggestTrialsResponse::study_state].
    pub fn set_study_state<T: std::convert::Into<crate::model::study::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.study_state = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::SuggestTrialsResponse::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::SuggestTrialsResponse::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [trials][crate::model::SuggestTrialsResponse::trials].
    pub fn set_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for SuggestTrialsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsResponse"
    }
}

/// Details of operations that perform Trials suggestion.
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestTrialsMetadata {
    /// Operation metadata for suggesting Trials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The identifier of the client that is requesting the suggestion.
    ///
    /// If multiple SuggestTrialsRequests have the same `client_id`,
    /// the service will return the identical suggested Trial if the Trial is
    /// pending, and provide a new Trial if the last suggested Trial was completed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl SuggestTrialsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::SuggestTrialsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::SuggestTrialsMetadata::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for SuggestTrialsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsMetadata"
    }
}

/// Request message for
/// [VizierService.CreateTrial][google.cloud.aiplatform.v1.VizierService.CreateTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.CreateTrial]: crate::client::VizierService::create_trial
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTrialRequest {
    /// Required. The resource name of the Study to create the Trial in.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Trial to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trial: std::option::Option<crate::model::Trial>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl CreateTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTrialRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [trial][crate::model::CreateTrialRequest::trial].
    pub fn set_trial<T: std::convert::Into<std::option::Option<crate::model::Trial>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trial = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for CreateTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTrialRequest"
    }
}

/// Request message for
/// [VizierService.GetTrial][google.cloud.aiplatform.v1.VizierService.GetTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.GetTrial]: crate::client::VizierService::get_trial
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTrialRequest {
    /// Required. The name of the Trial resource.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl GetTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for GetTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTrialRequest"
    }
}

/// Request message for
/// [VizierService.ListTrials][google.cloud.aiplatform.v1.VizierService.ListTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListTrials]: crate::client::VizierService::list_trials
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrialsRequest {
    /// Required. The resource name of the Study to list the Trial from.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. A page token to request the next page of results.
    /// If unspecified, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The number of Trials to retrieve per "page" of results.
    /// If unspecified, the service will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl ListTrialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTrialsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTrialsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTrialsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for ListTrialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrialsRequest"
    }
}

/// Response message for
/// [VizierService.ListTrials][google.cloud.aiplatform.v1.VizierService.ListTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListTrials]: crate::client::VizierService::list_trials
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrialsResponse {
    /// The Trials associated with the Study.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trials: std::vec::Vec<crate::model::Trial>,

    /// Pass this token as the `page_token` field of the request for a
    /// subsequent call.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl ListTrialsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTrialsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [trials][crate::model::ListTrialsResponse::trials].
    pub fn set_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for ListTrialsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrialsResponse"
    }
}

#[cfg(feature = "vizier_service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTrialsResponse {
    type PageItem = crate::model::Trial;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.trials
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [VizierService.AddTrialMeasurement][google.cloud.aiplatform.v1.VizierService.AddTrialMeasurement].
///
/// [google.cloud.aiplatform.v1.VizierService.AddTrialMeasurement]: crate::client::VizierService::add_trial_measurement
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddTrialMeasurementRequest {
    /// Required. The name of the trial to add measurement.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trial_name: std::string::String,

    /// Required. The measurement to be added to a Trial.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub measurement: std::option::Option<crate::model::Measurement>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl AddTrialMeasurementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trial_name][crate::model::AddTrialMeasurementRequest::trial_name].
    pub fn set_trial_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trial_name = v.into();
        self
    }

    /// Sets the value of [measurement][crate::model::AddTrialMeasurementRequest::measurement].
    pub fn set_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.measurement = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for AddTrialMeasurementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddTrialMeasurementRequest"
    }
}

/// Request message for
/// [VizierService.CompleteTrial][google.cloud.aiplatform.v1.VizierService.CompleteTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.CompleteTrial]: crate::client::VizierService::complete_trial
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompleteTrialRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, it will be used as the completed Trial's
    /// final_measurement; Otherwise, the service will auto-select a
    /// previously reported measurement as the final-measurement
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_measurement: std::option::Option<crate::model::Measurement>,

    /// Optional. True if the Trial cannot be run with the given Parameter, and
    /// final_measurement will be ignored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub trial_infeasible: bool,

    /// Optional. A human readable reason why the trial was infeasible. This should
    /// only be provided if `trial_infeasible` is true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub infeasible_reason: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl CompleteTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompleteTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [final_measurement][crate::model::CompleteTrialRequest::final_measurement].
    pub fn set_final_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.final_measurement = v.into();
        self
    }

    /// Sets the value of [trial_infeasible][crate::model::CompleteTrialRequest::trial_infeasible].
    pub fn set_trial_infeasible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.trial_infeasible = v.into();
        self
    }

    /// Sets the value of [infeasible_reason][crate::model::CompleteTrialRequest::infeasible_reason].
    pub fn set_infeasible_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.infeasible_reason = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for CompleteTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CompleteTrialRequest"
    }
}

/// Request message for
/// [VizierService.DeleteTrial][google.cloud.aiplatform.v1.VizierService.DeleteTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.DeleteTrial]: crate::client::VizierService::delete_trial
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTrialRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl DeleteTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for DeleteTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTrialRequest"
    }
}

/// Request message for
/// [VizierService.CheckTrialEarlyStoppingState][google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState].
///
/// [google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState]: crate::client::VizierService::check_trial_early_stopping_state
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckTrialEarlyStoppingStateRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trial_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl CheckTrialEarlyStoppingStateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trial_name][crate::model::CheckTrialEarlyStoppingStateRequest::trial_name].
    pub fn set_trial_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trial_name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for CheckTrialEarlyStoppingStateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateRequest"
    }
}

/// Response message for
/// [VizierService.CheckTrialEarlyStoppingState][google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState].
///
/// [google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState]: crate::client::VizierService::check_trial_early_stopping_state
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckTrialEarlyStoppingStateResponse {
    /// True if the Trial should stop.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub should_stop: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl CheckTrialEarlyStoppingStateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [should_stop][crate::model::CheckTrialEarlyStoppingStateResponse::should_stop].
    pub fn set_should_stop<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.should_stop = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for CheckTrialEarlyStoppingStateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateResponse"
    }
}

/// This message will be placed in the metadata field of a
/// google.longrunning.Operation associated with a CheckTrialEarlyStoppingState
/// request.
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckTrialEarlyStoppingStateMetatdata {
    /// Operation metadata for suggesting Trials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The name of the Study that the Trial belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub study: std::string::String,

    /// The Trial name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trial: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl CheckTrialEarlyStoppingStateMetatdata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CheckTrialEarlyStoppingStateMetatdata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [study][crate::model::CheckTrialEarlyStoppingStateMetatdata::study].
    pub fn set_study<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.study = v.into();
        self
    }

    /// Sets the value of [trial][crate::model::CheckTrialEarlyStoppingStateMetatdata::trial].
    pub fn set_trial<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trial = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for CheckTrialEarlyStoppingStateMetatdata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateMetatdata"
    }
}

/// Request message for
/// [VizierService.StopTrial][google.cloud.aiplatform.v1.VizierService.StopTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.StopTrial]: crate::client::VizierService::stop_trial
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopTrialRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl StopTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for StopTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopTrialRequest"
    }
}

/// Request message for
/// [VizierService.ListOptimalTrials][google.cloud.aiplatform.v1.VizierService.ListOptimalTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListOptimalTrials]: crate::client::VizierService::list_optimal_trials
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOptimalTrialsRequest {
    /// Required. The name of the Study that the optimal Trial belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl ListOptimalTrialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOptimalTrialsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for ListOptimalTrialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListOptimalTrialsRequest"
    }
}

/// Response message for
/// [VizierService.ListOptimalTrials][google.cloud.aiplatform.v1.VizierService.ListOptimalTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListOptimalTrials]: crate::client::VizierService::list_optimal_trials
#[cfg(feature = "vizier_service")]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOptimalTrialsResponse {
    /// The pareto-optimal Trials for multiple objective Study or the
    /// optimal trial for single objective Study. The definition of
    /// pareto-optimal can be checked in wiki page.
    /// <https://en.wikipedia.org/wiki/Pareto_efficiency>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub optimal_trials: std::vec::Vec<crate::model::Trial>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "vizier_service")]
impl ListOptimalTrialsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [optimal_trials][crate::model::ListOptimalTrialsResponse::optimal_trials].
    pub fn set_optimal_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.optimal_trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "vizier_service")]
impl wkt::message::Message for ListOptimalTrialsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListOptimalTrialsResponse"
    }
}

/// Represents a hardware accelerator type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AcceleratorType {
    /// Unspecified accelerator type, which means no accelerator.
    Unspecified,
    /// Deprecated: Nvidia Tesla K80 GPU has reached end of support,
    /// see <https://cloud.google.com/compute/docs/eol/k80-eol>.
    #[deprecated]
    NvidiaTeslaK80,
    /// Nvidia Tesla P100 GPU.
    NvidiaTeslaP100,
    /// Nvidia Tesla V100 GPU.
    NvidiaTeslaV100,
    /// Nvidia Tesla P4 GPU.
    NvidiaTeslaP4,
    /// Nvidia Tesla T4 GPU.
    NvidiaTeslaT4,
    /// Nvidia Tesla A100 GPU.
    NvidiaTeslaA100,
    /// Nvidia A100 80GB GPU.
    NvidiaA10080Gb,
    /// Nvidia L4 GPU.
    NvidiaL4,
    /// Nvidia H100 80Gb GPU.
    NvidiaH10080Gb,
    /// Nvidia H100 Mega 80Gb GPU.
    NvidiaH100Mega80Gb,
    /// TPU v2.
    TpuV2,
    /// TPU v3.
    TpuV3,
    /// TPU v4.
    TpuV4Pod,
    /// TPU v5.
    TpuV5Litepod,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AcceleratorType::value] or
    /// [AcceleratorType::name].
    UnknownValue(accelerator_type::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
pub mod accelerator_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl AcceleratorType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NvidiaTeslaK80 => std::option::Option::Some(1),
            Self::NvidiaTeslaP100 => std::option::Option::Some(2),
            Self::NvidiaTeslaV100 => std::option::Option::Some(3),
            Self::NvidiaTeslaP4 => std::option::Option::Some(4),
            Self::NvidiaTeslaT4 => std::option::Option::Some(5),
            Self::NvidiaTeslaA100 => std::option::Option::Some(8),
            Self::NvidiaA10080Gb => std::option::Option::Some(9),
            Self::NvidiaL4 => std::option::Option::Some(11),
            Self::NvidiaH10080Gb => std::option::Option::Some(13),
            Self::NvidiaH100Mega80Gb => std::option::Option::Some(14),
            Self::TpuV2 => std::option::Option::Some(6),
            Self::TpuV3 => std::option::Option::Some(7),
            Self::TpuV4Pod => std::option::Option::Some(10),
            Self::TpuV5Litepod => std::option::Option::Some(12),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ACCELERATOR_TYPE_UNSPECIFIED"),
            Self::NvidiaTeslaK80 => std::option::Option::Some("NVIDIA_TESLA_K80"),
            Self::NvidiaTeslaP100 => std::option::Option::Some("NVIDIA_TESLA_P100"),
            Self::NvidiaTeslaV100 => std::option::Option::Some("NVIDIA_TESLA_V100"),
            Self::NvidiaTeslaP4 => std::option::Option::Some("NVIDIA_TESLA_P4"),
            Self::NvidiaTeslaT4 => std::option::Option::Some("NVIDIA_TESLA_T4"),
            Self::NvidiaTeslaA100 => std::option::Option::Some("NVIDIA_TESLA_A100"),
            Self::NvidiaA10080Gb => std::option::Option::Some("NVIDIA_A100_80GB"),
            Self::NvidiaL4 => std::option::Option::Some("NVIDIA_L4"),
            Self::NvidiaH10080Gb => std::option::Option::Some("NVIDIA_H100_80GB"),
            Self::NvidiaH100Mega80Gb => std::option::Option::Some("NVIDIA_H100_MEGA_80GB"),
            Self::TpuV2 => std::option::Option::Some("TPU_V2"),
            Self::TpuV3 => std::option::Option::Some("TPU_V3"),
            Self::TpuV4Pod => std::option::Option::Some("TPU_V4_POD"),
            Self::TpuV5Litepod => std::option::Option::Some("TPU_V5_LITEPOD"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl std::default::Default for AcceleratorType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl std::fmt::Display for AcceleratorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl std::convert::From<i32> for AcceleratorType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NvidiaTeslaK80,
            2 => Self::NvidiaTeslaP100,
            3 => Self::NvidiaTeslaV100,
            4 => Self::NvidiaTeslaP4,
            5 => Self::NvidiaTeslaT4,
            6 => Self::TpuV2,
            7 => Self::TpuV3,
            8 => Self::NvidiaTeslaA100,
            9 => Self::NvidiaA10080Gb,
            10 => Self::TpuV4Pod,
            11 => Self::NvidiaL4,
            12 => Self::TpuV5Litepod,
            13 => Self::NvidiaH10080Gb,
            14 => Self::NvidiaH100Mega80Gb,
            _ => Self::UnknownValue(accelerator_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl std::convert::From<&str> for AcceleratorType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ACCELERATOR_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NVIDIA_TESLA_K80" => Self::NvidiaTeslaK80,
            "NVIDIA_TESLA_P100" => Self::NvidiaTeslaP100,
            "NVIDIA_TESLA_V100" => Self::NvidiaTeslaV100,
            "NVIDIA_TESLA_P4" => Self::NvidiaTeslaP4,
            "NVIDIA_TESLA_T4" => Self::NvidiaTeslaT4,
            "NVIDIA_TESLA_A100" => Self::NvidiaTeslaA100,
            "NVIDIA_A100_80GB" => Self::NvidiaA10080Gb,
            "NVIDIA_L4" => Self::NvidiaL4,
            "NVIDIA_H100_80GB" => Self::NvidiaH10080Gb,
            "NVIDIA_H100_MEGA_80GB" => Self::NvidiaH100Mega80Gb,
            "TPU_V2" => Self::TpuV2,
            "TPU_V3" => Self::TpuV3,
            "TPU_V4_POD" => Self::TpuV4Pod,
            "TPU_V5_LITEPOD" => Self::TpuV5Litepod,
            _ => Self::UnknownValue(accelerator_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl serde::ser::Serialize for AcceleratorType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NvidiaTeslaK80 => serializer.serialize_i32(1),
            Self::NvidiaTeslaP100 => serializer.serialize_i32(2),
            Self::NvidiaTeslaV100 => serializer.serialize_i32(3),
            Self::NvidiaTeslaP4 => serializer.serialize_i32(4),
            Self::NvidiaTeslaT4 => serializer.serialize_i32(5),
            Self::NvidiaTeslaA100 => serializer.serialize_i32(8),
            Self::NvidiaA10080Gb => serializer.serialize_i32(9),
            Self::NvidiaL4 => serializer.serialize_i32(11),
            Self::NvidiaH10080Gb => serializer.serialize_i32(13),
            Self::NvidiaH100Mega80Gb => serializer.serialize_i32(14),
            Self::TpuV2 => serializer.serialize_i32(6),
            Self::TpuV3 => serializer.serialize_i32(7),
            Self::TpuV4Pod => serializer.serialize_i32(10),
            Self::TpuV5Litepod => serializer.serialize_i32(12),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "deployment_resource_pool_service",
    feature = "endpoint_service",
    feature = "index_endpoint_service",
    feature = "job_service",
    feature = "model_garden_service",
    feature = "notebook_service",
    feature = "persistent_resource_service",
    feature = "schedule_service",
))]
impl<'de> serde::de::Deserialize<'de> for AcceleratorType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AcceleratorType>::new(
            ".google.cloud.aiplatform.v1.AcceleratorType",
        ))
    }
}

/// Harm categories that will block the content.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "prediction_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HarmCategory {
    /// The harm category is unspecified.
    Unspecified,
    /// The harm category is hate speech.
    HateSpeech,
    /// The harm category is dangerous content.
    DangerousContent,
    /// The harm category is harassment.
    Harassment,
    /// The harm category is sexually explicit content.
    SexuallyExplicit,
    /// The harm category is civic integrity.
    CivicIntegrity,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HarmCategory::value] or
    /// [HarmCategory::name].
    UnknownValue(harm_category::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "prediction_service")]
pub mod harm_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "prediction_service")]
impl HarmCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::HateSpeech => std::option::Option::Some(1),
            Self::DangerousContent => std::option::Option::Some(2),
            Self::Harassment => std::option::Option::Some(3),
            Self::SexuallyExplicit => std::option::Option::Some(4),
            Self::CivicIntegrity => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("HARM_CATEGORY_UNSPECIFIED"),
            Self::HateSpeech => std::option::Option::Some("HARM_CATEGORY_HATE_SPEECH"),
            Self::DangerousContent => std::option::Option::Some("HARM_CATEGORY_DANGEROUS_CONTENT"),
            Self::Harassment => std::option::Option::Some("HARM_CATEGORY_HARASSMENT"),
            Self::SexuallyExplicit => std::option::Option::Some("HARM_CATEGORY_SEXUALLY_EXPLICIT"),
            Self::CivicIntegrity => std::option::Option::Some("HARM_CATEGORY_CIVIC_INTEGRITY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "prediction_service")]
impl std::default::Default for HarmCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "prediction_service")]
impl std::fmt::Display for HarmCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "prediction_service")]
impl std::convert::From<i32> for HarmCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::HateSpeech,
            2 => Self::DangerousContent,
            3 => Self::Harassment,
            4 => Self::SexuallyExplicit,
            5 => Self::CivicIntegrity,
            _ => Self::UnknownValue(harm_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "prediction_service")]
impl std::convert::From<&str> for HarmCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HARM_CATEGORY_UNSPECIFIED" => Self::Unspecified,
            "HARM_CATEGORY_HATE_SPEECH" => Self::HateSpeech,
            "HARM_CATEGORY_DANGEROUS_CONTENT" => Self::DangerousContent,
            "HARM_CATEGORY_HARASSMENT" => Self::Harassment,
            "HARM_CATEGORY_SEXUALLY_EXPLICIT" => Self::SexuallyExplicit,
            "HARM_CATEGORY_CIVIC_INTEGRITY" => Self::CivicIntegrity,
            _ => Self::UnknownValue(harm_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "prediction_service")]
impl serde::ser::Serialize for HarmCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::HateSpeech => serializer.serialize_i32(1),
            Self::DangerousContent => serializer.serialize_i32(2),
            Self::Harassment => serializer.serialize_i32(3),
            Self::SexuallyExplicit => serializer.serialize_i32(4),
            Self::CivicIntegrity => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "prediction_service")]
impl<'de> serde::de::Deserialize<'de> for HarmCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmCategory>::new(
            ".google.cloud.aiplatform.v1.HarmCategory",
        ))
    }
}

/// Content Part modality
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Modality {
    /// Unspecified modality.
    Unspecified,
    /// Plain text.
    Text,
    /// Image.
    Image,
    /// Video.
    Video,
    /// Audio.
    Audio,
    /// Document, e.g. PDF.
    Document,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Modality::value] or
    /// [Modality::name].
    UnknownValue(modality::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
pub mod modality {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl Modality {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Text => std::option::Option::Some(1),
            Self::Image => std::option::Option::Some(2),
            Self::Video => std::option::Option::Some(3),
            Self::Audio => std::option::Option::Some(4),
            Self::Document => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MODALITY_UNSPECIFIED"),
            Self::Text => std::option::Option::Some("TEXT"),
            Self::Image => std::option::Option::Some("IMAGE"),
            Self::Video => std::option::Option::Some("VIDEO"),
            Self::Audio => std::option::Option::Some("AUDIO"),
            Self::Document => std::option::Option::Some("DOCUMENT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl std::default::Default for Modality {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl std::fmt::Display for Modality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl std::convert::From<i32> for Modality {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Text,
            2 => Self::Image,
            3 => Self::Video,
            4 => Self::Audio,
            5 => Self::Document,
            _ => Self::UnknownValue(modality::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl std::convert::From<&str> for Modality {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MODALITY_UNSPECIFIED" => Self::Unspecified,
            "TEXT" => Self::Text,
            "IMAGE" => Self::Image,
            "VIDEO" => Self::Video,
            "AUDIO" => Self::Audio,
            "DOCUMENT" => Self::Document,
            _ => Self::UnknownValue(modality::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl serde::ser::Serialize for Modality {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Text => serializer.serialize_i32(1),
            Self::Image => serializer.serialize_i32(2),
            Self::Video => serializer.serialize_i32(3),
            Self::Audio => serializer.serialize_i32(4),
            Self::Document => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "llm_utility_service", feature = "prediction_service",))]
impl<'de> serde::de::Deserialize<'de> for Modality {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Modality>::new(
            ".google.cloud.aiplatform.v1.Modality",
        ))
    }
}

/// Pairwise prediction autorater preference.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "evaluation_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PairwiseChoice {
    /// Unspecified prediction choice.
    Unspecified,
    /// Baseline prediction wins
    Baseline,
    /// Candidate prediction wins
    Candidate,
    /// Winner cannot be determined
    Tie,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PairwiseChoice::value] or
    /// [PairwiseChoice::name].
    UnknownValue(pairwise_choice::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "evaluation_service")]
pub mod pairwise_choice {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "evaluation_service")]
impl PairwiseChoice {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Baseline => std::option::Option::Some(1),
            Self::Candidate => std::option::Option::Some(2),
            Self::Tie => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PAIRWISE_CHOICE_UNSPECIFIED"),
            Self::Baseline => std::option::Option::Some("BASELINE"),
            Self::Candidate => std::option::Option::Some("CANDIDATE"),
            Self::Tie => std::option::Option::Some("TIE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "evaluation_service")]
impl std::default::Default for PairwiseChoice {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "evaluation_service")]
impl std::fmt::Display for PairwiseChoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "evaluation_service")]
impl std::convert::From<i32> for PairwiseChoice {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Baseline,
            2 => Self::Candidate,
            3 => Self::Tie,
            _ => Self::UnknownValue(pairwise_choice::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "evaluation_service")]
impl std::convert::From<&str> for PairwiseChoice {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PAIRWISE_CHOICE_UNSPECIFIED" => Self::Unspecified,
            "BASELINE" => Self::Baseline,
            "CANDIDATE" => Self::Candidate,
            "TIE" => Self::Tie,
            _ => Self::UnknownValue(pairwise_choice::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "evaluation_service")]
impl serde::ser::Serialize for PairwiseChoice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Baseline => serializer.serialize_i32(1),
            Self::Candidate => serializer.serialize_i32(2),
            Self::Tie => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "evaluation_service")]
impl<'de> serde::de::Deserialize<'de> for PairwiseChoice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PairwiseChoice>::new(
            ".google.cloud.aiplatform.v1.PairwiseChoice",
        ))
    }
}

/// Format of the data in the Feature View.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "feature_online_store_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FeatureViewDataFormat {
    /// Not set. Will be treated as the KeyValue format.
    Unspecified,
    /// Return response data in key-value format.
    KeyValue,
    /// Return response data in proto Struct format.
    ProtoStruct,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FeatureViewDataFormat::value] or
    /// [FeatureViewDataFormat::name].
    UnknownValue(feature_view_data_format::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "feature_online_store_service")]
pub mod feature_view_data_format {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "feature_online_store_service")]
impl FeatureViewDataFormat {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::KeyValue => std::option::Option::Some(1),
            Self::ProtoStruct => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED"),
            Self::KeyValue => std::option::Option::Some("KEY_VALUE"),
            Self::ProtoStruct => std::option::Option::Some("PROTO_STRUCT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "feature_online_store_service")]
impl std::default::Default for FeatureViewDataFormat {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "feature_online_store_service")]
impl std::fmt::Display for FeatureViewDataFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "feature_online_store_service")]
impl std::convert::From<i32> for FeatureViewDataFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::KeyValue,
            2 => Self::ProtoStruct,
            _ => Self::UnknownValue(feature_view_data_format::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "feature_online_store_service")]
impl std::convert::From<&str> for FeatureViewDataFormat {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
            "KEY_VALUE" => Self::KeyValue,
            "PROTO_STRUCT" => Self::ProtoStruct,
            _ => Self::UnknownValue(feature_view_data_format::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "feature_online_store_service")]
impl serde::ser::Serialize for FeatureViewDataFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::KeyValue => serializer.serialize_i32(1),
            Self::ProtoStruct => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "feature_online_store_service")]
impl<'de> serde::de::Deserialize<'de> for FeatureViewDataFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FeatureViewDataFormat>::new(
            ".google.cloud.aiplatform.v1.FeatureViewDataFormat",
        ))
    }
}

/// Describes the state of a job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JobState {
    /// The job state is unspecified.
    Unspecified,
    /// The job has been just created or resumed and processing has not yet begun.
    Queued,
    /// The service is preparing to run the job.
    Pending,
    /// The job is in progress.
    Running,
    /// The job completed successfully.
    Succeeded,
    /// The job failed.
    Failed,
    /// The job is being cancelled. From this state the job may only go to
    /// either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    Cancelling,
    /// The job has been cancelled.
    Cancelled,
    /// The job has been stopped, and can be resumed.
    Paused,
    /// The job has expired.
    Expired,
    /// The job is being updated. Only jobs in the `RUNNING` state can be updated.
    /// After updating, the job goes back to the `RUNNING` state.
    Updating,
    /// The job is partially succeeded, some results may be missing due to errors.
    PartiallySucceeded,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JobState::value] or
    /// [JobState::name].
    UnknownValue(job_state::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
pub mod job_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl JobState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Queued => std::option::Option::Some(1),
            Self::Pending => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Succeeded => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::Cancelling => std::option::Option::Some(6),
            Self::Cancelled => std::option::Option::Some(7),
            Self::Paused => std::option::Option::Some(8),
            Self::Expired => std::option::Option::Some(9),
            Self::Updating => std::option::Option::Some(10),
            Self::PartiallySucceeded => std::option::Option::Some(11),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JOB_STATE_UNSPECIFIED"),
            Self::Queued => std::option::Option::Some("JOB_STATE_QUEUED"),
            Self::Pending => std::option::Option::Some("JOB_STATE_PENDING"),
            Self::Running => std::option::Option::Some("JOB_STATE_RUNNING"),
            Self::Succeeded => std::option::Option::Some("JOB_STATE_SUCCEEDED"),
            Self::Failed => std::option::Option::Some("JOB_STATE_FAILED"),
            Self::Cancelling => std::option::Option::Some("JOB_STATE_CANCELLING"),
            Self::Cancelled => std::option::Option::Some("JOB_STATE_CANCELLED"),
            Self::Paused => std::option::Option::Some("JOB_STATE_PAUSED"),
            Self::Expired => std::option::Option::Some("JOB_STATE_EXPIRED"),
            Self::Updating => std::option::Option::Some("JOB_STATE_UPDATING"),
            Self::PartiallySucceeded => std::option::Option::Some("JOB_STATE_PARTIALLY_SUCCEEDED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl std::default::Default for JobState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl std::fmt::Display for JobState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl std::convert::From<i32> for JobState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Queued,
            2 => Self::Pending,
            3 => Self::Running,
            4 => Self::Succeeded,
            5 => Self::Failed,
            6 => Self::Cancelling,
            7 => Self::Cancelled,
            8 => Self::Paused,
            9 => Self::Expired,
            10 => Self::Updating,
            11 => Self::PartiallySucceeded,
            _ => Self::UnknownValue(job_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl std::convert::From<&str> for JobState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JOB_STATE_UNSPECIFIED" => Self::Unspecified,
            "JOB_STATE_QUEUED" => Self::Queued,
            "JOB_STATE_PENDING" => Self::Pending,
            "JOB_STATE_RUNNING" => Self::Running,
            "JOB_STATE_SUCCEEDED" => Self::Succeeded,
            "JOB_STATE_FAILED" => Self::Failed,
            "JOB_STATE_CANCELLING" => Self::Cancelling,
            "JOB_STATE_CANCELLED" => Self::Cancelled,
            "JOB_STATE_PAUSED" => Self::Paused,
            "JOB_STATE_EXPIRED" => Self::Expired,
            "JOB_STATE_UPDATING" => Self::Updating,
            "JOB_STATE_PARTIALLY_SUCCEEDED" => Self::PartiallySucceeded,
            _ => Self::UnknownValue(job_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl serde::ser::Serialize for JobState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Queued => serializer.serialize_i32(1),
            Self::Pending => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Succeeded => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::Cancelling => serializer.serialize_i32(6),
            Self::Cancelled => serializer.serialize_i32(7),
            Self::Paused => serializer.serialize_i32(8),
            Self::Expired => serializer.serialize_i32(9),
            Self::Updating => serializer.serialize_i32(10),
            Self::PartiallySucceeded => serializer.serialize_i32(11),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_tuning_service",
    feature = "job_service",
    feature = "notebook_service",
    feature = "schedule_service",
))]
impl<'de> serde::de::Deserialize<'de> for JobState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobState>::new(
            ".google.cloud.aiplatform.v1.JobState",
        ))
    }
}

/// The Model Monitoring Objective types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "job_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ModelDeploymentMonitoringObjectiveType {
    /// Default value, should not be set.
    Unspecified,
    /// Raw feature values' stats to detect skew between Training-Prediction
    /// datasets.
    RawFeatureSkew,
    /// Raw feature values' stats to detect drift between Serving-Prediction
    /// datasets.
    RawFeatureDrift,
    /// Feature attribution scores to detect skew between Training-Prediction
    /// datasets.
    FeatureAttributionSkew,
    /// Feature attribution scores to detect skew between Prediction datasets
    /// collected within different time windows.
    FeatureAttributionDrift,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ModelDeploymentMonitoringObjectiveType::value] or
    /// [ModelDeploymentMonitoringObjectiveType::name].
    UnknownValue(model_deployment_monitoring_objective_type::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "job_service")]
pub mod model_deployment_monitoring_objective_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "job_service")]
impl ModelDeploymentMonitoringObjectiveType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RawFeatureSkew => std::option::Option::Some(1),
            Self::RawFeatureDrift => std::option::Option::Some(2),
            Self::FeatureAttributionSkew => std::option::Option::Some(3),
            Self::FeatureAttributionDrift => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED")
            }
            Self::RawFeatureSkew => std::option::Option::Some("RAW_FEATURE_SKEW"),
            Self::RawFeatureDrift => std::option::Option::Some("RAW_FEATURE_DRIFT"),
            Self::FeatureAttributionSkew => std::option::Option::Some("FEATURE_ATTRIBUTION_SKEW"),
            Self::FeatureAttributionDrift => std::option::Option::Some("FEATURE_ATTRIBUTION_DRIFT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "job_service")]
impl std::default::Default for ModelDeploymentMonitoringObjectiveType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "job_service")]
impl std::fmt::Display for ModelDeploymentMonitoringObjectiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "job_service")]
impl std::convert::From<i32> for ModelDeploymentMonitoringObjectiveType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RawFeatureSkew,
            2 => Self::RawFeatureDrift,
            3 => Self::FeatureAttributionSkew,
            4 => Self::FeatureAttributionDrift,
            _ => Self::UnknownValue(model_deployment_monitoring_objective_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "job_service")]
impl std::convert::From<&str> for ModelDeploymentMonitoringObjectiveType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RAW_FEATURE_SKEW" => Self::RawFeatureSkew,
            "RAW_FEATURE_DRIFT" => Self::RawFeatureDrift,
            "FEATURE_ATTRIBUTION_SKEW" => Self::FeatureAttributionSkew,
            "FEATURE_ATTRIBUTION_DRIFT" => Self::FeatureAttributionDrift,
            _ => Self::UnknownValue(model_deployment_monitoring_objective_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "job_service")]
impl serde::ser::Serialize for ModelDeploymentMonitoringObjectiveType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RawFeatureSkew => serializer.serialize_i32(1),
            Self::RawFeatureDrift => serializer.serialize_i32(2),
            Self::FeatureAttributionSkew => serializer.serialize_i32(3),
            Self::FeatureAttributionDrift => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "job_service")]
impl<'de> serde::de::Deserialize<'de> for ModelDeploymentMonitoringObjectiveType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<
            ModelDeploymentMonitoringObjectiveType,
        >::new(
            ".google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType",
        ))
    }
}

/// View enumeration of PublisherModel.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "model_garden_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PublisherModelView {
    /// The default / unset value. The API will default to the BASIC view.
    Unspecified,
    /// Include basic metadata about the publisher model, but not the full
    /// contents.
    Basic,
    /// Include everything.
    Full,
    /// Include: VersionId, ModelVersionExternalName, and SupportedActions.
    PublisherModelVersionViewBasic,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PublisherModelView::value] or
    /// [PublisherModelView::name].
    UnknownValue(publisher_model_view::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "model_garden_service")]
pub mod publisher_model_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "model_garden_service")]
impl PublisherModelView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::PublisherModelVersionViewBasic => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PUBLISHER_MODEL_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("PUBLISHER_MODEL_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("PUBLISHER_MODEL_VIEW_FULL"),
            Self::PublisherModelVersionViewBasic => {
                std::option::Option::Some("PUBLISHER_MODEL_VERSION_VIEW_BASIC")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "model_garden_service")]
impl std::default::Default for PublisherModelView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "model_garden_service")]
impl std::fmt::Display for PublisherModelView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "model_garden_service")]
impl std::convert::From<i32> for PublisherModelView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            3 => Self::PublisherModelVersionViewBasic,
            _ => Self::UnknownValue(publisher_model_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "model_garden_service")]
impl std::convert::From<&str> for PublisherModelView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PUBLISHER_MODEL_VIEW_UNSPECIFIED" => Self::Unspecified,
            "PUBLISHER_MODEL_VIEW_BASIC" => Self::Basic,
            "PUBLISHER_MODEL_VIEW_FULL" => Self::Full,
            "PUBLISHER_MODEL_VERSION_VIEW_BASIC" => Self::PublisherModelVersionViewBasic,
            _ => Self::UnknownValue(publisher_model_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "model_garden_service")]
impl serde::ser::Serialize for PublisherModelView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::PublisherModelVersionViewBasic => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "model_garden_service")]
impl<'de> serde::de::Deserialize<'de> for PublisherModelView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PublisherModelView>::new(
            ".google.cloud.aiplatform.v1.PublisherModelView",
        ))
    }
}

/// Represents a notebook runtime type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "notebook_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NotebookRuntimeType {
    /// Unspecified notebook runtime type, NotebookRuntimeType will default to
    /// USER_DEFINED.
    Unspecified,
    /// runtime or template with coustomized configurations from user.
    UserDefined,
    /// runtime or template with system defined configurations.
    OneClick,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NotebookRuntimeType::value] or
    /// [NotebookRuntimeType::name].
    UnknownValue(notebook_runtime_type::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "notebook_service")]
pub mod notebook_runtime_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "notebook_service")]
impl NotebookRuntimeType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UserDefined => std::option::Option::Some(1),
            Self::OneClick => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED"),
            Self::UserDefined => std::option::Option::Some("USER_DEFINED"),
            Self::OneClick => std::option::Option::Some("ONE_CLICK"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl std::default::Default for NotebookRuntimeType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "notebook_service")]
impl std::fmt::Display for NotebookRuntimeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "notebook_service")]
impl std::convert::From<i32> for NotebookRuntimeType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UserDefined,
            2 => Self::OneClick,
            _ => Self::UnknownValue(notebook_runtime_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl std::convert::From<&str> for NotebookRuntimeType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" => Self::Unspecified,
            "USER_DEFINED" => Self::UserDefined,
            "ONE_CLICK" => Self::OneClick,
            _ => Self::UnknownValue(notebook_runtime_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl serde::ser::Serialize for NotebookRuntimeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UserDefined => serializer.serialize_i32(1),
            Self::OneClick => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl<'de> serde::de::Deserialize<'de> for NotebookRuntimeType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NotebookRuntimeType>::new(
            ".google.cloud.aiplatform.v1.NotebookRuntimeType",
        ))
    }
}

/// Views for Get/List NotebookExecutionJob
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "notebook_service")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NotebookExecutionJobView {
    /// When unspecified, the API defaults to the BASIC view.
    Unspecified,
    /// Includes all fields except for direct notebook inputs.
    Basic,
    /// Includes all fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NotebookExecutionJobView::value] or
    /// [NotebookExecutionJobView::name].
    UnknownValue(notebook_execution_job_view::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "notebook_service")]
pub mod notebook_execution_job_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "notebook_service")]
impl NotebookExecutionJobView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED")
            }
            Self::Basic => std::option::Option::Some("NOTEBOOK_EXECUTION_JOB_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("NOTEBOOK_EXECUTION_JOB_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl std::default::Default for NotebookExecutionJobView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "notebook_service")]
impl std::fmt::Display for NotebookExecutionJobView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "notebook_service")]
impl std::convert::From<i32> for NotebookExecutionJobView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(notebook_execution_job_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl std::convert::From<&str> for NotebookExecutionJobView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" => Self::Unspecified,
            "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" => Self::Basic,
            "NOTEBOOK_EXECUTION_JOB_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(notebook_execution_job_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl serde::ser::Serialize for NotebookExecutionJobView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "notebook_service")]
impl<'de> serde::de::Deserialize<'de> for NotebookExecutionJobView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NotebookExecutionJobView>::new(
            ".google.cloud.aiplatform.v1.NotebookExecutionJobView",
        ))
    }
}

/// Type contains the list of OpenAPI data types as defined by
/// <https://swagger.io/docs/specification/data-models/data-types/>
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Type {
    /// Not specified, should not be used.
    Unspecified,
    /// OpenAPI string type
    String,
    /// OpenAPI number type
    Number,
    /// OpenAPI integer type
    Integer,
    /// OpenAPI boolean type
    Boolean,
    /// OpenAPI array type
    Array,
    /// OpenAPI object type
    Object,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Type::value] or
    /// [Type::name].
    UnknownValue(r#type::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
pub mod r#type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl Type {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::String => std::option::Option::Some(1),
            Self::Number => std::option::Option::Some(2),
            Self::Integer => std::option::Option::Some(3),
            Self::Boolean => std::option::Option::Some(4),
            Self::Array => std::option::Option::Some(5),
            Self::Object => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
            Self::String => std::option::Option::Some("STRING"),
            Self::Number => std::option::Option::Some("NUMBER"),
            Self::Integer => std::option::Option::Some("INTEGER"),
            Self::Boolean => std::option::Option::Some("BOOLEAN"),
            Self::Array => std::option::Option::Some("ARRAY"),
            Self::Object => std::option::Option::Some("OBJECT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl std::default::Default for Type {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl std::convert::From<i32> for Type {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::String,
            2 => Self::Number,
            3 => Self::Integer,
            4 => Self::Boolean,
            5 => Self::Array,
            6 => Self::Object,
            _ => Self::UnknownValue(r#type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl std::convert::From<&str> for Type {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TYPE_UNSPECIFIED" => Self::Unspecified,
            "STRING" => Self::String,
            "NUMBER" => Self::Number,
            "INTEGER" => Self::Integer,
            "BOOLEAN" => Self::Boolean,
            "ARRAY" => Self::Array,
            "OBJECT" => Self::Object,
            _ => Self::UnknownValue(r#type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl serde::ser::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::String => serializer.serialize_i32(1),
            Self::Number => serializer.serialize_i32(2),
            Self::Integer => serializer.serialize_i32(3),
            Self::Boolean => serializer.serialize_i32(4),
            Self::Array => serializer.serialize_i32(5),
            Self::Object => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "gen_ai_cache_service",
    feature = "llm_utility_service",
    feature = "prediction_service",
))]
impl<'de> serde::de::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
            ".google.cloud.aiplatform.v1.Type",
        ))
    }
}

/// Represents the failure policy of a pipeline. Currently, the default of a
/// pipeline is that the pipeline will continue to run until no more tasks can be
/// executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a
/// pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling
/// any new tasks when a task has failed. Any scheduled tasks will continue to
/// completion.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PipelineFailurePolicy {
    /// Default value, and follows fail slow behavior.
    Unspecified,
    /// Indicates that the pipeline should continue to run until all possible
    /// tasks have been scheduled and completed.
    FailSlow,
    /// Indicates that the pipeline should stop scheduling new tasks after a task
    /// has failed.
    FailFast,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PipelineFailurePolicy::value] or
    /// [PipelineFailurePolicy::name].
    UnknownValue(pipeline_failure_policy::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
pub mod pipeline_failure_policy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineFailurePolicy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::FailSlow => std::option::Option::Some(1),
            Self::FailFast => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PIPELINE_FAILURE_POLICY_UNSPECIFIED"),
            Self::FailSlow => std::option::Option::Some("PIPELINE_FAILURE_POLICY_FAIL_SLOW"),
            Self::FailFast => std::option::Option::Some("PIPELINE_FAILURE_POLICY_FAIL_FAST"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::default::Default for PipelineFailurePolicy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::fmt::Display for PipelineFailurePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::convert::From<i32> for PipelineFailurePolicy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::FailSlow,
            2 => Self::FailFast,
            _ => Self::UnknownValue(pipeline_failure_policy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::convert::From<&str> for PipelineFailurePolicy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PIPELINE_FAILURE_POLICY_UNSPECIFIED" => Self::Unspecified,
            "PIPELINE_FAILURE_POLICY_FAIL_SLOW" => Self::FailSlow,
            "PIPELINE_FAILURE_POLICY_FAIL_FAST" => Self::FailFast,
            _ => Self::UnknownValue(pipeline_failure_policy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl serde::ser::Serialize for PipelineFailurePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::FailSlow => serializer.serialize_i32(1),
            Self::FailFast => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl<'de> serde::de::Deserialize<'de> for PipelineFailurePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PipelineFailurePolicy>::new(
            ".google.cloud.aiplatform.v1.PipelineFailurePolicy",
        ))
    }
}

/// Describes the state of a pipeline.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PipelineState {
    /// The pipeline state is unspecified.
    Unspecified,
    /// The pipeline has been created or resumed, and processing has not yet
    /// begun.
    Queued,
    /// The service is preparing to run the pipeline.
    Pending,
    /// The pipeline is in progress.
    Running,
    /// The pipeline completed successfully.
    Succeeded,
    /// The pipeline failed.
    Failed,
    /// The pipeline is being cancelled. From this state, the pipeline may only go
    /// to either PIPELINE_STATE_SUCCEEDED, PIPELINE_STATE_FAILED or
    /// PIPELINE_STATE_CANCELLED.
    Cancelling,
    /// The pipeline has been cancelled.
    Cancelled,
    /// The pipeline has been stopped, and can be resumed.
    Paused,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PipelineState::value] or
    /// [PipelineState::name].
    UnknownValue(pipeline_state::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
pub mod pipeline_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl PipelineState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Queued => std::option::Option::Some(1),
            Self::Pending => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Succeeded => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::Cancelling => std::option::Option::Some(6),
            Self::Cancelled => std::option::Option::Some(7),
            Self::Paused => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PIPELINE_STATE_UNSPECIFIED"),
            Self::Queued => std::option::Option::Some("PIPELINE_STATE_QUEUED"),
            Self::Pending => std::option::Option::Some("PIPELINE_STATE_PENDING"),
            Self::Running => std::option::Option::Some("PIPELINE_STATE_RUNNING"),
            Self::Succeeded => std::option::Option::Some("PIPELINE_STATE_SUCCEEDED"),
            Self::Failed => std::option::Option::Some("PIPELINE_STATE_FAILED"),
            Self::Cancelling => std::option::Option::Some("PIPELINE_STATE_CANCELLING"),
            Self::Cancelled => std::option::Option::Some("PIPELINE_STATE_CANCELLED"),
            Self::Paused => std::option::Option::Some("PIPELINE_STATE_PAUSED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::default::Default for PipelineState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::fmt::Display for PipelineState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::convert::From<i32> for PipelineState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Queued,
            2 => Self::Pending,
            3 => Self::Running,
            4 => Self::Succeeded,
            5 => Self::Failed,
            6 => Self::Cancelling,
            7 => Self::Cancelled,
            8 => Self::Paused,
            _ => Self::UnknownValue(pipeline_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl std::convert::From<&str> for PipelineState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PIPELINE_STATE_UNSPECIFIED" => Self::Unspecified,
            "PIPELINE_STATE_QUEUED" => Self::Queued,
            "PIPELINE_STATE_PENDING" => Self::Pending,
            "PIPELINE_STATE_RUNNING" => Self::Running,
            "PIPELINE_STATE_SUCCEEDED" => Self::Succeeded,
            "PIPELINE_STATE_FAILED" => Self::Failed,
            "PIPELINE_STATE_CANCELLING" => Self::Cancelling,
            "PIPELINE_STATE_CANCELLED" => Self::Cancelled,
            "PIPELINE_STATE_PAUSED" => Self::Paused,
            _ => Self::UnknownValue(pipeline_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl serde::ser::Serialize for PipelineState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Queued => serializer.serialize_i32(1),
            Self::Pending => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Succeeded => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::Cancelling => serializer.serialize_i32(6),
            Self::Cancelled => serializer.serialize_i32(7),
            Self::Paused => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "pipeline_service", feature = "schedule_service",))]
impl<'de> serde::de::Deserialize<'de> for PipelineState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PipelineState>::new(
            ".google.cloud.aiplatform.v1.PipelineState",
        ))
    }
}
