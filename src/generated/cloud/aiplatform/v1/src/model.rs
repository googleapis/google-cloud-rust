// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::invalid_html_tags)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Annotation {
    /// Output only. Resource name of the Annotation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Google Cloud Storage URI points to a YAML file describing
    /// [payload][google.cloud.aiplatform.v1.Annotation.payload]. The schema is
    /// defined as an [OpenAPI 3.0.2 Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// The schema files that can be used here are found in
    /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
    /// chosen schema must be consistent with the parent Dataset's
    /// [metadata][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Annotation.payload]: crate::model::Annotation::payload
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payload_schema_uri: std::string::String,

    /// Required. The schema of the payload can be found in
    /// [payload_schema][google.cloud.aiplatform.v1.Annotation.payload_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Annotation.payload_schema_uri]: crate::model::Annotation::payload_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this Annotation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Annotation was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The source of the Annotation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotation_source: std::option::Option<crate::model::UserActionReference>,

    /// Optional. The labels with user-defined metadata to organize your
    /// Annotations.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Annotation(System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for each Annotation:
    ///
    /// * "aiplatform.googleapis.com/annotation_set_name":
    ///   optional, name of the UI's annotation set this Annotation belongs to.
    ///   If not set, the Annotation is not visible in the UI.
    ///
    /// * "aiplatform.googleapis.com/payload_schema":
    ///   output only, its value is the
    ///   [payload_schema's][google.cloud.aiplatform.v1.Annotation.payload_schema_uri]
    ///   title.
    ///
    ///
    /// [google.cloud.aiplatform.v1.Annotation.payload_schema_uri]: crate::model::Annotation::payload_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Annotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Annotation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [payload_schema_uri][crate::model::Annotation::payload_schema_uri].
    pub fn set_payload_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload_schema_uri = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::Annotation::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Annotation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Annotation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Annotation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotation_source][crate::model::Annotation::annotation_source].
    pub fn set_annotation_source<
        T: std::convert::Into<std::option::Option<crate::model::UserActionReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_source = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Annotation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Annotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Annotation"
    }
}

/// Identifies a concept with which DataItems may be annotated with.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotationSpec {
    /// Output only. Resource name of the AnnotationSpec.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the AnnotationSpec.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp when this AnnotationSpec was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when AnnotationSpec was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl AnnotationSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnnotationSpec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AnnotationSpec::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AnnotationSpec::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AnnotationSpec::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AnnotationSpec::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for AnnotationSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AnnotationSpec"
    }
}

/// The generic reusable api auth config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiAuth {
    /// The auth config.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub auth_config: std::option::Option<crate::model::api_auth::AuthConfig>,
}

impl ApiAuth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `auth_config`.
    pub fn set_auth_config<
        T: std::convert::Into<std::option::Option<crate::model::api_auth::AuthConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_config = v.into();
        self
    }

    /// The value of [auth_config][crate::model::ApiAuth::auth_config]
    /// if it holds a `ApiKeyConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_api_key_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::api_auth::ApiKeyConfig>> {
        #[allow(unreachable_patterns)]
        self.auth_config.as_ref().and_then(|v| match v {
            crate::model::api_auth::AuthConfig::ApiKeyConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [auth_config][crate::model::ApiAuth::auth_config]
    /// to hold a `ApiKeyConfig`.
    ///
    /// Note that all the setters affecting `auth_config` are
    /// mutually exclusive.
    pub fn set_api_key_config<
        T: std::convert::Into<std::boxed::Box<crate::model::api_auth::ApiKeyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_config =
            std::option::Option::Some(crate::model::api_auth::AuthConfig::ApiKeyConfig(v.into()));
        self
    }
}

impl wkt::message::Message for ApiAuth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ApiAuth"
    }
}

/// Defines additional types related to ApiAuth
pub mod api_auth {
    #[allow(unused_imports)]
    use super::*;

    /// The API secret.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ApiKeyConfig {
        /// Required. The SecretManager secret version resource name storing API key.
        /// e.g. projects/{project}/secrets/{secret}/versions/{version}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub api_key_secret_version: std::string::String,
    }

    impl ApiKeyConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [api_key_secret_version][crate::model::api_auth::ApiKeyConfig::api_key_secret_version].
        pub fn set_api_key_secret_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.api_key_secret_version = v.into();
            self
        }
    }

    impl wkt::message::Message for ApiKeyConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ApiAuth.ApiKeyConfig"
        }
    }

    /// The auth config.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthConfig {
        /// The API secret.
        ApiKeyConfig(std::boxed::Box<crate::model::api_auth::ApiKeyConfig>),
    }
}

/// Instance of a general artifact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Artifact {
    /// Output only. The resource name of the Artifact.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name of the Artifact.
    /// May be up to 128 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The uniform resource identifier of the artifact file.
    /// May be empty if there is no actual artifact file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// An eTag used to perform consistent read-modify-write updates. If not set, a
    /// blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Artifacts.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Artifact (System
    /// labels are excluded).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Artifact was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Artifact was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The state of this Artifact. This is a property of the Artifact, and does
    /// not imply or capture any ongoing process. This property is managed by
    /// clients (such as Vertex AI Pipelines), and the system does not prescribe
    /// or check the validity of state transitions.
    pub state: crate::model::artifact::State,

    /// The title of the schema describing the metadata.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_title: std::string::String,

    /// The version of the schema in schema_name to use.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Properties of the Artifact.
    /// Top level metadata keys' heading and trailing spaces will be trimmed.
    /// The size of this field should not exceed 200KB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Description of the Artifact
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl Artifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Artifact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Artifact::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Artifact::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Artifact::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Artifact::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Artifact::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Artifact::state].
    pub fn set_state<T: std::convert::Into<crate::model::artifact::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schema_title][crate::model::Artifact::schema_title].
    pub fn set_schema_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_title = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::Artifact::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Artifact::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Artifact::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Artifact::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Artifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Artifact"
    }
}

/// Defines additional types related to Artifact
pub mod artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the state of the Artifact.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state for the Artifact.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// A state used by systems like Vertex AI Pipelines to indicate that the
        /// underlying data item represented by this Artifact is being created.
        pub const PENDING: State = State::new("PENDING");

        /// A state indicating that the Artifact should exist, unless something
        /// external to the system deletes it.
        pub const LIVE: State = State::new("LIVE");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A job that uses a
/// [Model][google.cloud.aiplatform.v1.BatchPredictionJob.model] to produce
/// predictions on multiple [input
/// instances][google.cloud.aiplatform.v1.BatchPredictionJob.input_config]. If
/// predictions for significant portion of the instances fail, the job may finish
/// without attempting predictions for all remaining instances.
///
/// [google.cloud.aiplatform.v1.BatchPredictionJob.input_config]: crate::model::BatchPredictionJob::input_config
/// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchPredictionJob {
    /// Output only. Resource name of the BatchPredictionJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of this BatchPredictionJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The name of the Model resource that produces the predictions via this job,
    /// must share the same ancestor Location.
    /// Starting this job has no impact on any existing deployments of the Model
    /// and their resources.
    /// Exactly one of model and unmanaged_container_model must be set.
    ///
    /// The model resource name may contain version id or version alias to specify
    /// the version.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// if no version is specified, the default version will be deployed.
    ///
    /// The model resource could also be a publisher model.
    /// Example: `publishers/{publisher}/models/{model}`
    /// or
    /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the Model that produces the predictions via
    /// this job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    /// Contains model information necessary to perform batch prediction without
    /// requiring uploading to model registry.
    /// Exactly one of model and unmanaged_container_model must be set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub unmanaged_container_model: std::option::Option<crate::model::UnmanagedContainerModel>,

    /// Required. Input configuration of the instances on which predictions are
    /// performed. The schema of any single instance may be specified via the
    /// [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::batch_prediction_job::InputConfig>,

    /// Configuration for how to convert batch prediction input instances to the
    /// prediction instances that are sent to the Model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_config: std::option::Option<crate::model::batch_prediction_job::InstanceConfig>,

    /// The parameters that govern the predictions. The schema of the parameters
    /// may be specified via the
    /// [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [parameters_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_parameters: std::option::Option<wkt::Value>,

    /// Required. The Configuration specifying where output predictions should
    /// be written.
    /// The schema of any single prediction may be specified as a concatenation
    /// of [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// and
    /// [prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]: crate::model::PredictSchemata::prediction_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::batch_prediction_job::OutputConfig>,

    /// The config of resources used by the Model during the batch prediction. If
    /// the Model
    /// [supports][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]
    /// DEDICATED_RESOURCES this config may be provided (and the job will use these
    /// resources), if the Model doesn't support AUTOMATIC_RESOURCES, this config
    /// must be provided.
    ///
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_resources: std::option::Option<crate::model::BatchDedicatedResources>,

    /// The service account that the DeployedModel's container runs as. If not
    /// specified, a system generated one will be used, which
    /// has minimal permissions and the custom container, if used, may not have
    /// enough permission to access other Google Cloud resources.
    ///
    /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Immutable. Parameters configuring the batch behavior. Currently only
    /// applicable when
    /// [dedicated_resources][google.cloud.aiplatform.v1.BatchPredictionJob.dedicated_resources]
    /// are used (in other cases Vertex AI does the tuning itself).
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.dedicated_resources]: crate::model::BatchPredictionJob::dedicated_resources
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub manual_batch_tuning_parameters:
        std::option::Option<crate::model::ManualBatchTuningParameters>,

    /// Generate explanation with the batch prediction results.
    ///
    /// When set to `true`, the batch prediction output changes based on the
    /// `predictions_format` field of the
    /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config]
    /// object:
    ///
    /// * `bigquery`: output includes a column named `explanation`. The value
    ///   is a struct that conforms to the
    ///   [Explanation][google.cloud.aiplatform.v1.Explanation] object.
    /// * `jsonl`: The JSON objects on each line include an additional entry
    ///   keyed `explanation`. The value of the entry is a JSON object that
    ///   conforms to the [Explanation][google.cloud.aiplatform.v1.Explanation]
    ///   object.
    /// * `csv`: Generating explanations for CSV format is not supported.
    ///
    /// If this field is set to true, either the
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// or
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// must be populated.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]: crate::model::BatchPredictionJob::explanation_spec
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    /// [google.cloud.aiplatform.v1.Explanation]: crate::model::Explanation
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    pub generate_explanation: bool,

    /// Explanation configuration for this BatchPredictionJob. Can be
    /// specified only if
    /// [generate_explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
    /// is set to `true`.
    ///
    /// This value overrides the value of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec].
    /// All fields of
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// are optional in the request. If a field of the
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// object is not populated, the corresponding field of the
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// object is inherited.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]: crate::model::BatchPredictionJob::explanation_spec
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]: crate::model::BatchPredictionJob::generate_explanation
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

    /// Output only. Information further describing the output of this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_info: std::option::Option<crate::model::batch_prediction_job::OutputInfo>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Only populated when the job's state is JOB_STATE_FAILED or
    /// JOB_STATE_CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Partial failures encountered.
    /// For example, single files that can't be read.
    /// This field never exceeds 20 entries.
    /// Status details fields contain standard Google Cloud error details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_failures: std::vec::Vec<rpc::model::Status>,

    /// Output only. Information about resources that had been consumed by this
    /// job. Provided in real time at best effort basis, as well as a final value
    /// once the job completes.
    ///
    /// Note: This field currently may be not populated for batch predictions that
    /// use AutoML Models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resources_consumed: std::option::Option<crate::model::ResourcesConsumed>,

    /// Output only. Statistics on completed and failed prediction instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_stats: std::option::Option<crate::model::CompletionStats>,

    /// Output only. Time when the BatchPredictionJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the BatchPredictionJob for the first time entered
    /// the `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the BatchPredictionJob entered any of the following
    /// states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the BatchPredictionJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize BatchPredictionJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a BatchPredictionJob. If this
    /// is set, then all resources created by the BatchPredictionJob will be
    /// encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// For custom-trained Models and AutoML Tabular Models, the container of the
    /// DeployedModel instances will send `stderr` and `stdout` streams to
    /// Cloud Logging by default. Please note that the logs incur cost,
    /// which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging/pricing).
    ///
    /// User can disable container logging by setting this flag to true.
    pub disable_container_logging: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl BatchPredictionJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchPredictionJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::BatchPredictionJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model][crate::model::BatchPredictionJob::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::BatchPredictionJob::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }

    /// Sets the value of [unmanaged_container_model][crate::model::BatchPredictionJob::unmanaged_container_model].
    pub fn set_unmanaged_container_model<
        T: std::convert::Into<std::option::Option<crate::model::UnmanagedContainerModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.unmanaged_container_model = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::BatchPredictionJob::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::InputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }

    /// Sets the value of [instance_config][crate::model::BatchPredictionJob::instance_config].
    pub fn set_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::InstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_config = v.into();
        self
    }

    /// Sets the value of [model_parameters][crate::model::BatchPredictionJob::model_parameters].
    pub fn set_model_parameters<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_parameters = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::BatchPredictionJob::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }

    /// Sets the value of [dedicated_resources][crate::model::BatchPredictionJob::dedicated_resources].
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::option::Option<crate::model::BatchDedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_resources = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BatchPredictionJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [manual_batch_tuning_parameters][crate::model::BatchPredictionJob::manual_batch_tuning_parameters].
    pub fn set_manual_batch_tuning_parameters<
        T: std::convert::Into<std::option::Option<crate::model::ManualBatchTuningParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.manual_batch_tuning_parameters = v.into();
        self
    }

    /// Sets the value of [generate_explanation][crate::model::BatchPredictionJob::generate_explanation].
    pub fn set_generate_explanation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.generate_explanation = v.into();
        self
    }

    /// Sets the value of [explanation_spec][crate::model::BatchPredictionJob::explanation_spec].
    pub fn set_explanation_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec = v.into();
        self
    }

    /// Sets the value of [output_info][crate::model::BatchPredictionJob::output_info].
    pub fn set_output_info<
        T: std::convert::Into<std::option::Option<crate::model::batch_prediction_job::OutputInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_info = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BatchPredictionJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchPredictionJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [resources_consumed][crate::model::BatchPredictionJob::resources_consumed].
    pub fn set_resources_consumed<
        T: std::convert::Into<std::option::Option<crate::model::ResourcesConsumed>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resources_consumed = v.into();
        self
    }

    /// Sets the value of [completion_stats][crate::model::BatchPredictionJob::completion_stats].
    pub fn set_completion_stats<
        T: std::convert::Into<std::option::Option<crate::model::CompletionStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_stats = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BatchPredictionJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BatchPredictionJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BatchPredictionJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BatchPredictionJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::BatchPredictionJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [disable_container_logging][crate::model::BatchPredictionJob::disable_container_logging].
    pub fn set_disable_container_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_container_logging = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::BatchPredictionJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::BatchPredictionJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [partial_failures][crate::model::BatchPredictionJob::partial_failures].
    pub fn set_partial_failures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_failures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::BatchPredictionJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchPredictionJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob"
    }
}

/// Defines additional types related to BatchPredictionJob
pub mod batch_prediction_job {
    #[allow(unused_imports)]
    use super::*;

    /// Configures the input to
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob]. See
    /// [Model.supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats]
    /// for Model's supported input formats, and how instances should be expressed
    /// via any of them.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.Model.supported_input_storage_formats]: crate::model::Model::supported_input_storage_formats
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputConfig {
        /// Required. The format in which instances are given, must be one of the
        /// [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
        /// [supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats].
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
        /// [google.cloud.aiplatform.v1.Model.supported_input_storage_formats]: crate::model::Model::supported_input_storage_formats
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub instances_format: std::string::String,

        /// Required. The source of the input.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::batch_prediction_job::input_config::Source>,
    }

    impl InputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instances_format][crate::model::batch_prediction_job::InputConfig::instances_format].
        pub fn set_instances_format<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instances_format = v.into();
            self
        }

        /// Sets the value of `source`.
        pub fn set_source<
            T: std::convert::Into<
                std::option::Option<crate::model::batch_prediction_job::input_config::Source>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// if it holds a `GcsSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gcs_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::input_config::Source::GcsSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// if it holds a `BigquerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_bigquery_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::input_config::Source::BigquerySource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// to hold a `GcsSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::batch_prediction_job::input_config::Source::GcsSource(v.into()),
            );
            self
        }

        /// Sets the value of [source][crate::model::batch_prediction_job::InputConfig::source]
        /// to hold a `BigquerySource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_bigquery_source<
            T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::batch_prediction_job::input_config::Source::BigquerySource(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig"
        }
    }

    /// Defines additional types related to InputConfig
    pub mod input_config {
        #[allow(unused_imports)]
        use super::*;

        /// Required. The source of the input.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// The Cloud Storage location for the input instances.
            GcsSource(std::boxed::Box<crate::model::GcsSource>),
            /// The BigQuery location of the input table.
            /// The schema of the table should be in the format described by the given
            /// context OpenAPI Schema, if one is provided. The table may contain
            /// additional columns that are not described by the schema, and they will
            /// be ignored.
            BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        }
    }

    /// Configuration defining how to transform batch prediction input instances to
    /// the instances that the Model accepts.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceConfig {
        /// The format of the instance that the Model accepts. Vertex AI will
        /// convert compatible
        /// [batch prediction input instance
        /// formats][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.instances_format]
        /// to the specified format.
        ///
        /// Supported values are:
        ///
        /// * `object`: Each input is converted to JSON object format.
        ///
        ///   * For `bigquery`, each row is converted to an object.
        ///   * For `jsonl`, each line of the JSONL input must be an object.
        ///   * Does not apply to `csv`, `file-list`, `tf-record`, or
        ///     `tf-record-gzip`.
        /// * `array`: Each input is converted to JSON array format.
        ///
        ///   * For `bigquery`, each row is converted to an array. The order
        ///     of columns is determined by the BigQuery column order, unless
        ///     [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///     is populated.
        ///     [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///     must be populated for specifying field orders.
        ///   * For `jsonl`, if each line of the JSONL input is an object,
        ///     [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///     must be populated for specifying field orders.
        ///   * Does not apply to `csv`, `file-list`, `tf-record`, or
        ///     `tf-record-gzip`.
        ///
        /// If not specified, Vertex AI converts the batch prediction input as
        /// follows:
        ///
        /// * For `bigquery` and `csv`, the behavior is the same as `array`. The
        ///   order of columns is the same as defined in the file or table, unless
        ///   [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        ///   is populated.
        /// * For `jsonl`, the prediction instance format is determined by
        ///   each line of the input.
        /// * For `tf-record`/`tf-record-gzip`, each record will be converted to
        ///   an object in the format of `{"b64": <value>}`, where `<value>` is
        ///   the Base64-encoded string of the content of the record.
        /// * For `file-list`, each file in the list will be converted to an
        ///   object in the format of `{"b64": <value>}`, where `<value>` is
        ///   the Base64-encoded string of the content of the file.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.instances_format]: crate::model::batch_prediction_job::InputConfig::instances_format
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]: crate::model::batch_prediction_job::InstanceConfig::included_fields
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub instance_type: std::string::String,

        /// The name of the field that is considered as a key.
        ///
        /// The values identified by the key field is not included in the transformed
        /// instances that is sent to the Model. This is similar to
        /// specifying this name of the field in
        /// [excluded_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields].
        /// In addition, the batch prediction output will not include the instances.
        /// Instead the output will only include the value of the key field, in a
        /// field named `key` in the output:
        ///
        /// * For `jsonl` output format, the output will have a `key` field
        ///   instead of the `instance` field.
        /// * For `csv`/`bigquery` output format, the output will have have a `key`
        ///   column instead of the instance feature columns.
        ///
        /// The input must be JSONL with objects at each line, CSV, BigQuery
        /// or TfRecord.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields]: crate::model::batch_prediction_job::InstanceConfig::excluded_fields
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key_field: std::string::String,

        /// Fields that will be included in the prediction instance that is
        /// sent to the Model.
        ///
        /// If
        /// [instance_type][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.instance_type]
        /// is `array`, the order of field names in included_fields also determines
        /// the order of the values in the array.
        ///
        /// When included_fields is populated,
        /// [excluded_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields]
        /// must be empty.
        ///
        /// The input must be JSONL with objects at each line, BigQuery
        /// or TfRecord.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.excluded_fields]: crate::model::batch_prediction_job::InstanceConfig::excluded_fields
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.instance_type]: crate::model::batch_prediction_job::InstanceConfig::instance_type
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub included_fields: std::vec::Vec<std::string::String>,

        /// Fields that will be excluded in the prediction instance that is
        /// sent to the Model.
        ///
        /// Excluded will be attached to the batch prediction output if
        /// [key_field][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.key_field]
        /// is not specified.
        ///
        /// When excluded_fields is populated,
        /// [included_fields][google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]
        /// must be empty.
        ///
        /// The input must be JSONL with objects at each line, BigQuery
        /// or TfRecord.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.included_fields]: crate::model::batch_prediction_job::InstanceConfig::included_fields
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig.key_field]: crate::model::batch_prediction_job::InstanceConfig::key_field
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub excluded_fields: std::vec::Vec<std::string::String>,
    }

    impl InstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_type][crate::model::batch_prediction_job::InstanceConfig::instance_type].
        pub fn set_instance_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_type = v.into();
            self
        }

        /// Sets the value of [key_field][crate::model::batch_prediction_job::InstanceConfig::key_field].
        pub fn set_key_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key_field = v.into();
            self
        }

        /// Sets the value of [included_fields][crate::model::batch_prediction_job::InstanceConfig::included_fields].
        pub fn set_included_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.included_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_fields][crate::model::batch_prediction_job::InstanceConfig::excluded_fields].
        pub fn set_excluded_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig"
        }
    }

    /// Configures the output of
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob]. See
    /// [Model.supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats]
    /// for supported output formats, and how predictions are expressed via any of
    /// them.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.Model.supported_output_storage_formats]: crate::model::Model::supported_output_storage_formats
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputConfig {
        /// Required. The format in which Vertex AI gives the predictions, must be
        /// one of the [Model's][google.cloud.aiplatform.v1.BatchPredictionJob.model]
        /// [supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats].
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob.model]: crate::model::BatchPredictionJob::model
        /// [google.cloud.aiplatform.v1.Model.supported_output_storage_formats]: crate::model::Model::supported_output_storage_formats
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub predictions_format: std::string::String,

        /// Required. The destination of the output.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub destination:
            std::option::Option<crate::model::batch_prediction_job::output_config::Destination>,
    }

    impl OutputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [predictions_format][crate::model::batch_prediction_job::OutputConfig::predictions_format].
        pub fn set_predictions_format<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.predictions_format = v.into();
            self
        }

        /// Sets the value of `destination`.
        pub fn set_destination<
            T: std::convert::Into<
                std::option::Option<crate::model::batch_prediction_job::output_config::Destination>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination = v.into();
            self
        }

        /// The value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// if it holds a `GcsDestination`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gcs_destination(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
            #[allow(unreachable_patterns)]
            self.destination.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_config::Destination::GcsDestination(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// if it holds a `BigqueryDestination`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_bigquery_destination(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
            #[allow(unreachable_patterns)]
            self.destination.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_config::Destination::BigqueryDestination(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// to hold a `GcsDestination`.
        ///
        /// Note that all the setters affecting `destination` are
        /// mutually exclusive.
        pub fn set_gcs_destination<
            T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination = std::option::Option::Some(
                crate::model::batch_prediction_job::output_config::Destination::GcsDestination(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [destination][crate::model::batch_prediction_job::OutputConfig::destination]
        /// to hold a `BigqueryDestination`.
        ///
        /// Note that all the setters affecting `destination` are
        /// mutually exclusive.
        pub fn set_bigquery_destination<
            T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination = std::option::Option::Some(
                crate::model::batch_prediction_job::output_config::Destination::BigqueryDestination(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for OutputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig"
        }
    }

    /// Defines additional types related to OutputConfig
    pub mod output_config {
        #[allow(unused_imports)]
        use super::*;

        /// Required. The destination of the output.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Destination {
            /// The Cloud Storage location of the directory where the output is
            /// to be written to. In the given directory a new directory is created.
            /// Its name is `prediction-<model-display-name>-<job-create-time>`,
            /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
            /// Inside of it files `predictions_0001.<extension>`,
            /// `predictions_0002.<extension>`, ..., `predictions_N.<extension>`
            /// are created where `<extension>` depends on chosen
            /// [predictions_format][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.predictions_format],
            /// and N may equal 0001 and depends on the total number of successfully
            /// predicted instances. If the Model has both
            /// [instance][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
            /// and
            /// [prediction][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]
            /// schemata defined then each such file contains predictions as per the
            /// [predictions_format][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.predictions_format].
            /// If prediction for any instance failed (partially or completely), then
            /// an additional `errors_0001.<extension>`, `errors_0002.<extension>`,...,
            /// `errors_N.<extension>` files are created (N depends on total number
            /// of failed predictions). These files contain the failed instances,
            /// as per their schema, followed by an additional `error` field which as
            /// value has [google.rpc.Status][google.rpc.Status]
            /// containing only `code` and `message` fields.
            ///
            /// [google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.predictions_format]: crate::model::batch_prediction_job::OutputConfig::predictions_format
            /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
            /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
            /// [google.rpc.Status]: rpc::model::Status
            GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
            /// The BigQuery project or dataset location where the output is to be
            /// written to. If project is provided, a new dataset is created with name
            /// `prediction_<model-display-name>_<job-create-time>`
            /// where \<model-display-name\> is made
            /// BigQuery-dataset-name compatible (for example, most special characters
            /// become underscores), and timestamp is in
            /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset
            /// two tables will be created, `predictions`, and `errors`.
            /// If the Model has both
            /// [instance][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
            /// and
            /// [prediction][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]
            /// schemata defined then the tables have columns as follows: The
            /// `predictions` table contains instances for which the prediction
            /// succeeded, it has columns as per a concatenation of the Model's
            /// instance and prediction schemata. The `errors` table contains rows for
            /// which the prediction has failed, it has instance columns, as per the
            /// instance schema, followed by a single "errors" column, which as values
            /// has [google.rpc.Status][google.rpc.Status]
            /// represented as a STRUCT, and containing only `code` and `message`.
            ///
            /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
            /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
            /// [google.rpc.Status]: rpc::model::Status
            BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
        }
    }

    /// Further describes this job's output.
    /// Supplements
    /// [output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputInfo {
        /// Output only. The name of the BigQuery table created, in
        /// `predictions_<timestamp>`
        /// format, into which the prediction output is written.
        /// Can be used by UI to generate the BigQuery output path, for example.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub bigquery_output_table: std::string::String,

        /// The output location into which prediction output is written.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub output_location:
            std::option::Option<crate::model::batch_prediction_job::output_info::OutputLocation>,
    }

    impl OutputInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_output_table][crate::model::batch_prediction_job::OutputInfo::bigquery_output_table].
        pub fn set_bigquery_output_table<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.bigquery_output_table = v.into();
            self
        }

        /// Sets the value of `output_location`.
        pub fn set_output_location<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::batch_prediction_job::output_info::OutputLocation,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.output_location = v.into();
            self
        }

        /// The value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// if it holds a `GcsOutputDirectory`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gcs_output_directory(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output_location.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_info::OutputLocation::GcsOutputDirectory(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// if it holds a `BigqueryOutputDataset`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_bigquery_output_dataset(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.output_location.as_ref().and_then(|v| match v {
                crate::model::batch_prediction_job::output_info::OutputLocation::BigqueryOutputDataset(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// to hold a `GcsOutputDirectory`.
        ///
        /// Note that all the setters affecting `output_location` are
        /// mutually exclusive.
        pub fn set_gcs_output_directory<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_location = std::option::Option::Some(
                crate::model::batch_prediction_job::output_info::OutputLocation::GcsOutputDirectory(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [output_location][crate::model::batch_prediction_job::OutputInfo::output_location]
        /// to hold a `BigqueryOutputDataset`.
        ///
        /// Note that all the setters affecting `output_location` are
        /// mutually exclusive.
        pub fn set_bigquery_output_dataset<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_location = std::option::Option::Some(
                crate::model::batch_prediction_job::output_info::OutputLocation::BigqueryOutputDataset(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for OutputInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.OutputInfo"
        }
    }

    /// Defines additional types related to OutputInfo
    pub mod output_info {
        #[allow(unused_imports)]
        use super::*;

        /// The output location into which prediction output is written.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum OutputLocation {
            /// Output only. The full path of the Cloud Storage directory created, into
            /// which the prediction output is written.
            GcsOutputDirectory(std::string::String),
            /// Output only. The path of the BigQuery dataset created, in
            /// `bq://projectId.bqDatasetId`
            /// format, into which the prediction output is written.
            BigqueryOutputDataset(std::string::String),
        }
    }
}

/// A resource used in LLM queries for users to explicitly specify what to cache
/// and how to cache.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CachedContent {
    /// Immutable. Identifier. The server-generated resource name of the cached
    /// content Format:
    /// projects/{project}/locations/{location}/cachedContents/{cached_content}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Immutable. The user-generated meaningful display name of the
    /// cached content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Immutable. The name of the publisher model to use for cached content.
    /// Format:
    /// projects/{project}/locations/{location}/publishers/{publisher}/models/{model}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. Input only. Immutable. Developer set system instruction.
    /// Currently, text only
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::Content>,

    /// Optional. Input only. Immutable. The content to cache
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. Input only. Immutable. A list of `Tools` the model may use to
    /// generate the next response
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tools: std::vec::Vec<crate::model::Tool>,

    /// Optional. Input only. Immutable. Tool config. This config is shared for all
    /// tools
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tool_config: std::option::Option<crate::model::ToolConfig>,

    /// Output only. Creatation time of the cache entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. When the cache entry was last updated in UTC time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Metadata on the usage of the cached content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub usage_metadata: std::option::Option<crate::model::cached_content::UsageMetadata>,

    /// Expiration time of the cached content.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<crate::model::cached_content::Expiration>,
}

impl CachedContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CachedContent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CachedContent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CachedContent::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::CachedContent::system_instruction].
    pub fn set_system_instruction<
        T: std::convert::Into<std::option::Option<crate::model::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_instruction = v.into();
        self
    }

    /// Sets the value of [tool_config][crate::model::CachedContent::tool_config].
    pub fn set_tool_config<T: std::convert::Into<std::option::Option<crate::model::ToolConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tool_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CachedContent::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CachedContent::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [usage_metadata][crate::model::CachedContent::usage_metadata].
    pub fn set_usage_metadata<
        T: std::convert::Into<std::option::Option<crate::model::cached_content::UsageMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.usage_metadata = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::CachedContent::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tools][crate::model::CachedContent::tools].
    pub fn set_tools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tool>,
    {
        use std::iter::Iterator;
        self.tools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `expiration`.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::cached_content::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::CachedContent::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::cached_content::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [expiration][crate::model::CachedContent::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::cached_content::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::CachedContent::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::cached_content::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// Sets the value of [expiration][crate::model::CachedContent::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::cached_content::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for CachedContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CachedContent"
    }
}

/// Defines additional types related to CachedContent
pub mod cached_content {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata on the usage of the cached content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UsageMetadata {
        /// Total number of tokens that the cached content consumes.
        pub total_token_count: i32,

        /// Number of text characters.
        pub text_count: i32,

        /// Number of images.
        pub image_count: i32,

        /// Duration of video in seconds.
        pub video_duration_seconds: i32,

        /// Duration of audio in seconds.
        pub audio_duration_seconds: i32,
    }

    impl UsageMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_token_count][crate::model::cached_content::UsageMetadata::total_token_count].
        pub fn set_total_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_token_count = v.into();
            self
        }

        /// Sets the value of [text_count][crate::model::cached_content::UsageMetadata::text_count].
        pub fn set_text_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.text_count = v.into();
            self
        }

        /// Sets the value of [image_count][crate::model::cached_content::UsageMetadata::image_count].
        pub fn set_image_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.image_count = v.into();
            self
        }

        /// Sets the value of [video_duration_seconds][crate::model::cached_content::UsageMetadata::video_duration_seconds].
        pub fn set_video_duration_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.video_duration_seconds = v.into();
            self
        }

        /// Sets the value of [audio_duration_seconds][crate::model::cached_content::UsageMetadata::audio_duration_seconds].
        pub fn set_audio_duration_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.audio_duration_seconds = v.into();
            self
        }
    }

    impl wkt::message::Message for UsageMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.CachedContent.UsageMetadata"
        }
    }

    /// Expiration time of the cached content.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Expiration {
        /// Timestamp of when this resource is considered expired.
        /// This is *always* provided on output, regardless of what was sent
        /// on input.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The TTL for this resource. The expiration time is computed:
        /// now + TTL.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// Success and error statistics of processing multiple entities
/// (for example, DataItems or structured data rows) in batch.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompletionStats {
    /// Output only. The number of entities that had been processed successfully.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub successful_count: i64,

    /// Output only. The number of entities for which any error was encountered.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_count: i64,

    /// Output only. In cases when enough errors are encountered a job, pipeline,
    /// or operation may be failed as a whole. Below is the number of entities for
    /// which the processing had not been finished (either in successful or failed
    /// state). Set to -1 if the number is unknown (for example, the operation
    /// failed before the total entity number could be collected).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub incomplete_count: i64,

    /// Output only. The number of the successful forecast points that are
    /// generated by the forecasting model. This is ONLY used by the forecasting
    /// batch prediction.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub successful_forecast_point_count: i64,
}

impl CompletionStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [successful_count][crate::model::CompletionStats::successful_count].
    pub fn set_successful_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.successful_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::CompletionStats::failed_count].
    pub fn set_failed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [incomplete_count][crate::model::CompletionStats::incomplete_count].
    pub fn set_incomplete_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.incomplete_count = v.into();
        self
    }

    /// Sets the value of [successful_forecast_point_count][crate::model::CompletionStats::successful_forecast_point_count].
    pub fn set_successful_forecast_point_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.successful_forecast_point_count = v.into();
        self
    }
}

impl wkt::message::Message for CompletionStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CompletionStats"
    }
}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the `Content`
/// and a `parts` field containing multi-part data that contains the content of
/// the message turn.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Content {
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    ///
    /// Useful to set for multi-turn conversations, otherwise can be left blank
    /// or unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// Required. Ordered `Parts` that constitute a single message. Parts may have
    /// different IANA MIME types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parts: std::vec::Vec<crate::model::Part>,
}

impl Content {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::Content::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [parts][crate::model::Content::parts].
    pub fn set_parts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Part>,
    {
        use std::iter::Iterator;
        self.parts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Content {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Content"
    }
}

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `Part` must have a fixed IANA MIME type identifying the type and subtype
/// of the media if `inline_data` or `file_data` field is filled with raw bytes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Part {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::part::Data>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::part::Metadata>,
}

impl Part {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `data`.
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::part::Data>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `InlineData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_inline_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::Blob>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::InlineData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `FileData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_file_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::FileData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::FileData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `FunctionCall`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_function_call(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionCall>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::FunctionCall(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `FunctionResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_function_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionResponse>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::FunctionResponse(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `ExecutableCode`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_executable_code(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExecutableCode>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::ExecutableCode(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::Part::data]
    /// if it holds a `CodeExecutionResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_code_execution_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CodeExecutionResult>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::part::Data::CodeExecutionResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::Text(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `InlineData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_inline_data<T: std::convert::Into<std::boxed::Box<crate::model::Blob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::InlineData(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `FileData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_file_data<T: std::convert::Into<std::boxed::Box<crate::model::FileData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::FileData(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `FunctionCall`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_function_call<T: std::convert::Into<std::boxed::Box<crate::model::FunctionCall>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::FunctionCall(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `FunctionResponse`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_function_response<
        T: std::convert::Into<std::boxed::Box<crate::model::FunctionResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::FunctionResponse(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `ExecutableCode`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_executable_code<
        T: std::convert::Into<std::boxed::Box<crate::model::ExecutableCode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::part::Data::ExecutableCode(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::Part::data]
    /// to hold a `CodeExecutionResult`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_code_execution_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CodeExecutionResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::part::Data::CodeExecutionResult(v.into()));
        self
    }

    /// Sets the value of `metadata`.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::part::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::Part::metadata]
    /// if it holds a `VideoMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_video_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VideoMetadata>> {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::part::Metadata::VideoMetadata(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::Part::metadata]
    /// to hold a `VideoMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_video_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::VideoMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata =
            std::option::Option::Some(crate::model::part::Metadata::VideoMetadata(v.into()));
        self
    }
}

impl wkt::message::Message for Part {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Part"
    }
}

/// Defines additional types related to Part
pub mod part {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// Optional. Text part (can be code).
        Text(std::string::String),
        /// Optional. Inlined bytes data.
        InlineData(std::boxed::Box<crate::model::Blob>),
        /// Optional. URI based data.
        FileData(std::boxed::Box<crate::model::FileData>),
        /// Optional. A predicted [FunctionCall] returned from the model that
        /// contains a string representing the [FunctionDeclaration.name] with the
        /// parameters and their values.
        FunctionCall(std::boxed::Box<crate::model::FunctionCall>),
        /// Optional. The result output of a [FunctionCall] that contains a string
        /// representing the [FunctionDeclaration.name] and a structured JSON object
        /// containing any output from the function call. It is used as context to
        /// the model.
        FunctionResponse(std::boxed::Box<crate::model::FunctionResponse>),
        /// Optional. Code generated by the model that is meant to be executed.
        ExecutableCode(std::boxed::Box<crate::model::ExecutableCode>),
        /// Optional. Result of executing the [ExecutableCode].
        CodeExecutionResult(std::boxed::Box<crate::model::CodeExecutionResult>),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Metadata {
        /// Optional. Video metadata. The metadata should only be specified while the
        /// video data is presented in inline_data or file_data.
        VideoMetadata(std::boxed::Box<crate::model::VideoMetadata>),
    }
}

/// Content blob.
///
/// It's preferred to send as [text][google.cloud.aiplatform.v1.Part.text]
/// directly rather than raw bytes.
///
/// [google.cloud.aiplatform.v1.Part.text]: crate::model::Part::data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Blob {
    /// Required. The IANA standard MIME type of the source data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Required. Raw bytes.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: bytes::Bytes,
}

impl Blob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::Blob::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [data][crate::model::Blob::data].
    pub fn set_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

impl wkt::message::Message for Blob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Blob"
    }
}

/// URI based data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileData {
    /// Required. The IANA standard MIME type of the source data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Required. URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_uri: std::string::String,
}

impl FileData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::FileData::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [file_uri][crate::model::FileData::file_uri].
    pub fn set_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_uri = v.into();
        self
    }
}

impl wkt::message::Message for FileData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FileData"
    }
}

/// Metadata describes the input video content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VideoMetadata {
    /// Optional. The start offset of the video.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_offset: std::option::Option<wkt::Duration>,

    /// Optional. The end offset of the video.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_offset: std::option::Option<wkt::Duration>,
}

impl VideoMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_offset][crate::model::VideoMetadata::start_offset].
    pub fn set_start_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_offset = v.into();
        self
    }

    /// Sets the value of [end_offset][crate::model::VideoMetadata::end_offset].
    pub fn set_end_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_offset = v.into();
        self
    }
}

impl wkt::message::Message for VideoMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VideoMetadata"
    }
}

/// Generation config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerationConfig {
    /// Optional. Controls the randomness of predictions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub temperature: std::option::Option<f32>,

    /// Optional. If specified, nucleus sampling will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub top_p: std::option::Option<f32>,

    /// Optional. If specified, top-k sampling will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub top_k: std::option::Option<f32>,

    /// Optional. Number of candidates to generate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub candidate_count: std::option::Option<i32>,

    /// Optional. The maximum number of output tokens to generate per message.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_output_tokens: std::option::Option<i32>,

    /// Optional. Stop sequences.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stop_sequences: std::vec::Vec<std::string::String>,

    /// Optional. If true, export the logprobs results in response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_logprobs: std::option::Option<bool>,

    /// Optional. Logit probabilities.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logprobs: std::option::Option<i32>,

    /// Optional. Positive penalties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub presence_penalty: std::option::Option<f32>,

    /// Optional. Frequency penalties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub frequency_penalty: std::option::Option<f32>,

    /// Optional. Seed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub seed: std::option::Option<i32>,

    /// Optional. Output response mimetype of the generated candidate text.
    /// Supported mimetype:
    ///
    /// - `text/plain`: (default) Text output.
    /// - `application/json`: JSON response in the candidates.
    ///   The model needs to be prompted to output the appropriate response type,
    ///   otherwise the behavior is undefined.
    ///   This is a preview feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub response_mime_type: std::string::String,

    /// Optional. The `Schema` object allows the definition of input and output
    /// data types. These types can be objects, but also primitives and arrays.
    /// Represents a select subset of an [OpenAPI 3.0 schema
    /// object](https://spec.openapis.org/oas/v3.0.3#schema).
    /// If set, a compatible response_mime_type must also be set.
    /// Compatible mimetypes:
    /// `application/json`: Schema for JSON response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_schema: std::option::Option<crate::model::Schema>,

    /// Optional. Routing configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routing_config: std::option::Option<crate::model::generation_config::RoutingConfig>,
}

impl GenerationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [temperature][crate::model::GenerationConfig::temperature].
    pub fn set_temperature<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.temperature = v.into();
        self
    }

    /// Sets the value of [top_p][crate::model::GenerationConfig::top_p].
    pub fn set_top_p<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.top_p = v.into();
        self
    }

    /// Sets the value of [top_k][crate::model::GenerationConfig::top_k].
    pub fn set_top_k<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.top_k = v.into();
        self
    }

    /// Sets the value of [candidate_count][crate::model::GenerationConfig::candidate_count].
    pub fn set_candidate_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.candidate_count = v.into();
        self
    }

    /// Sets the value of [max_output_tokens][crate::model::GenerationConfig::max_output_tokens].
    pub fn set_max_output_tokens<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_output_tokens = v.into();
        self
    }

    /// Sets the value of [response_logprobs][crate::model::GenerationConfig::response_logprobs].
    pub fn set_response_logprobs<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_logprobs = v.into();
        self
    }

    /// Sets the value of [logprobs][crate::model::GenerationConfig::logprobs].
    pub fn set_logprobs<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.logprobs = v.into();
        self
    }

    /// Sets the value of [presence_penalty][crate::model::GenerationConfig::presence_penalty].
    pub fn set_presence_penalty<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.presence_penalty = v.into();
        self
    }

    /// Sets the value of [frequency_penalty][crate::model::GenerationConfig::frequency_penalty].
    pub fn set_frequency_penalty<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency_penalty = v.into();
        self
    }

    /// Sets the value of [seed][crate::model::GenerationConfig::seed].
    pub fn set_seed<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.seed = v.into();
        self
    }

    /// Sets the value of [response_mime_type][crate::model::GenerationConfig::response_mime_type].
    pub fn set_response_mime_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_mime_type = v.into();
        self
    }

    /// Sets the value of [response_schema][crate::model::GenerationConfig::response_schema].
    pub fn set_response_schema<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_schema = v.into();
        self
    }

    /// Sets the value of [routing_config][crate::model::GenerationConfig::routing_config].
    pub fn set_routing_config<
        T: std::convert::Into<std::option::Option<crate::model::generation_config::RoutingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_config = v.into();
        self
    }

    /// Sets the value of [stop_sequences][crate::model::GenerationConfig::stop_sequences].
    pub fn set_stop_sequences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stop_sequences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig"
    }
}

/// Defines additional types related to GenerationConfig
pub mod generation_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration for routing the request to a specific model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RoutingConfig {
        /// Routing mode.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub routing_config:
            std::option::Option<crate::model::generation_config::routing_config::RoutingConfig>,
    }

    impl RoutingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `routing_config`.
        pub fn set_routing_config<
            T: std::convert::Into<
                std::option::Option<crate::model::generation_config::routing_config::RoutingConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.routing_config = v.into();
            self
        }

        /// The value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// if it holds a `AutoMode`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_auto_mode(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::generation_config::routing_config::AutoRoutingMode>,
        > {
            #[allow(unreachable_patterns)]
            self.routing_config.as_ref().and_then(|v| match v {
                crate::model::generation_config::routing_config::RoutingConfig::AutoMode(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// if it holds a `ManualMode`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_manual_mode(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::generation_config::routing_config::ManualRoutingMode>,
        > {
            #[allow(unreachable_patterns)]
            self.routing_config.as_ref().and_then(|v| match v {
                crate::model::generation_config::routing_config::RoutingConfig::ManualMode(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// to hold a `AutoMode`.
        ///
        /// Note that all the setters affecting `routing_config` are
        /// mutually exclusive.
        pub fn set_auto_mode<
            T: std::convert::Into<
                std::boxed::Box<crate::model::generation_config::routing_config::AutoRoutingMode>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.routing_config = std::option::Option::Some(
                crate::model::generation_config::routing_config::RoutingConfig::AutoMode(v.into()),
            );
            self
        }

        /// Sets the value of [routing_config][crate::model::generation_config::RoutingConfig::routing_config]
        /// to hold a `ManualMode`.
        ///
        /// Note that all the setters affecting `routing_config` are
        /// mutually exclusive.
        pub fn set_manual_mode<
            T: std::convert::Into<
                std::boxed::Box<crate::model::generation_config::routing_config::ManualRoutingMode>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.routing_config = std::option::Option::Some(
                crate::model::generation_config::routing_config::RoutingConfig::ManualMode(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for RoutingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig"
        }
    }

    /// Defines additional types related to RoutingConfig
    pub mod routing_config {
        #[allow(unused_imports)]
        use super::*;

        /// When automated routing is specified, the routing will be determined by
        /// the pretrained routing model and customer provided model routing
        /// preference.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AutoRoutingMode {

            /// The model routing preference.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_routing_preference: std::option::Option<crate::model::generation_config::routing_config::auto_routing_mode::ModelRoutingPreference>,
        }

        impl AutoRoutingMode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_routing_preference][crate::model::generation_config::routing_config::AutoRoutingMode::model_routing_preference].
            pub fn set_model_routing_preference<T: std::convert::Into<std::option::Option<crate::model::generation_config::routing_config::auto_routing_mode::ModelRoutingPreference>>>(mut self, v: T) -> Self{
                self.model_routing_preference = v.into();
                self
            }
        }

        impl wkt::message::Message for AutoRoutingMode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.AutoRoutingMode"
            }
        }

        /// Defines additional types related to AutoRoutingMode
        pub mod auto_routing_mode {
            #[allow(unused_imports)]
            use super::*;

            /// The model routing preference.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct ModelRoutingPreference(std::borrow::Cow<'static, str>);

            impl ModelRoutingPreference {
                /// Creates a new ModelRoutingPreference instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [ModelRoutingPreference](ModelRoutingPreference)
            pub mod model_routing_preference {
                use super::ModelRoutingPreference;

                /// Unspecified model routing preference.
                pub const UNKNOWN: ModelRoutingPreference = ModelRoutingPreference::new("UNKNOWN");

                /// Prefer higher quality over low cost.
                pub const PRIORITIZE_QUALITY: ModelRoutingPreference =
                    ModelRoutingPreference::new("PRIORITIZE_QUALITY");

                /// Balanced model routing preference.
                pub const BALANCED: ModelRoutingPreference =
                    ModelRoutingPreference::new("BALANCED");

                /// Prefer lower cost over higher quality.
                pub const PRIORITIZE_COST: ModelRoutingPreference =
                    ModelRoutingPreference::new("PRIORITIZE_COST");
            }

            impl std::convert::From<std::string::String> for ModelRoutingPreference {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// When manual routing is set, the specified model will be used directly.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ManualRoutingMode {
            /// The model name to use. Only the public LLM models are accepted. e.g.
            /// 'gemini-1.5-pro-001'.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_name: std::option::Option<std::string::String>,
        }

        impl ManualRoutingMode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_name][crate::model::generation_config::routing_config::ManualRoutingMode::model_name].
            pub fn set_model_name<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.model_name = v.into();
                self
            }
        }

        impl wkt::message::Message for ManualRoutingMode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.ManualRoutingMode"
            }
        }

        /// Routing mode.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum RoutingConfig {
            /// Automated routing.
            AutoMode(
                std::boxed::Box<crate::model::generation_config::routing_config::AutoRoutingMode>,
            ),
            /// Manual routing.
            ManualMode(
                std::boxed::Box<crate::model::generation_config::routing_config::ManualRoutingMode>,
            ),
        }
    }
}

/// Safety settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetySetting {
    /// Required. Harm category.
    pub category: crate::model::HarmCategory,

    /// Required. The harm block threshold.
    pub threshold: crate::model::safety_setting::HarmBlockThreshold,

    /// Optional. Specify if the threshold is used for probability or severity
    /// score. If not specified, the threshold is used for probability score.
    pub method: crate::model::safety_setting::HarmBlockMethod,
}

impl SafetySetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::SafetySetting::category].
    pub fn set_category<T: std::convert::Into<crate::model::HarmCategory>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [threshold][crate::model::SafetySetting::threshold].
    pub fn set_threshold<
        T: std::convert::Into<crate::model::safety_setting::HarmBlockThreshold>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threshold = v.into();
        self
    }

    /// Sets the value of [method][crate::model::SafetySetting::method].
    pub fn set_method<T: std::convert::Into<crate::model::safety_setting::HarmBlockMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }
}

impl wkt::message::Message for SafetySetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetySetting"
    }
}

/// Defines additional types related to SafetySetting
pub mod safety_setting {
    #[allow(unused_imports)]
    use super::*;

    /// Probability based thresholds levels for blocking.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HarmBlockThreshold(std::borrow::Cow<'static, str>);

    impl HarmBlockThreshold {
        /// Creates a new HarmBlockThreshold instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HarmBlockThreshold](HarmBlockThreshold)
    pub mod harm_block_threshold {
        use super::HarmBlockThreshold;

        /// Unspecified harm block threshold.
        pub const HARM_BLOCK_THRESHOLD_UNSPECIFIED: HarmBlockThreshold =
            HarmBlockThreshold::new("HARM_BLOCK_THRESHOLD_UNSPECIFIED");

        /// Block low threshold and above (i.e. block more).
        pub const BLOCK_LOW_AND_ABOVE: HarmBlockThreshold =
            HarmBlockThreshold::new("BLOCK_LOW_AND_ABOVE");

        /// Block medium threshold and above.
        pub const BLOCK_MEDIUM_AND_ABOVE: HarmBlockThreshold =
            HarmBlockThreshold::new("BLOCK_MEDIUM_AND_ABOVE");

        /// Block only high threshold (i.e. block less).
        pub const BLOCK_ONLY_HIGH: HarmBlockThreshold = HarmBlockThreshold::new("BLOCK_ONLY_HIGH");

        /// Block none.
        pub const BLOCK_NONE: HarmBlockThreshold = HarmBlockThreshold::new("BLOCK_NONE");

        /// Turn off the safety filter.
        pub const OFF: HarmBlockThreshold = HarmBlockThreshold::new("OFF");
    }

    impl std::convert::From<std::string::String> for HarmBlockThreshold {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Probability vs severity.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HarmBlockMethod(std::borrow::Cow<'static, str>);

    impl HarmBlockMethod {
        /// Creates a new HarmBlockMethod instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HarmBlockMethod](HarmBlockMethod)
    pub mod harm_block_method {
        use super::HarmBlockMethod;

        /// The harm block method is unspecified.
        pub const HARM_BLOCK_METHOD_UNSPECIFIED: HarmBlockMethod =
            HarmBlockMethod::new("HARM_BLOCK_METHOD_UNSPECIFIED");

        /// The harm block method uses both probability and severity scores.
        pub const SEVERITY: HarmBlockMethod = HarmBlockMethod::new("SEVERITY");

        /// The harm block method uses the probability score.
        pub const PROBABILITY: HarmBlockMethod = HarmBlockMethod::new("PROBABILITY");
    }

    impl std::convert::From<std::string::String> for HarmBlockMethod {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Safety rating corresponding to the generated content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyRating {
    /// Output only. Harm category.
    pub category: crate::model::HarmCategory,

    /// Output only. Harm probability levels in the content.
    pub probability: crate::model::safety_rating::HarmProbability,

    /// Output only. Harm probability score.
    pub probability_score: f32,

    /// Output only. Harm severity levels in the content.
    pub severity: crate::model::safety_rating::HarmSeverity,

    /// Output only. Harm severity score.
    pub severity_score: f32,

    /// Output only. Indicates whether the content was filtered out because of this
    /// rating.
    pub blocked: bool,
}

impl SafetyRating {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::SafetyRating::category].
    pub fn set_category<T: std::convert::Into<crate::model::HarmCategory>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [probability][crate::model::SafetyRating::probability].
    pub fn set_probability<T: std::convert::Into<crate::model::safety_rating::HarmProbability>>(
        mut self,
        v: T,
    ) -> Self {
        self.probability = v.into();
        self
    }

    /// Sets the value of [probability_score][crate::model::SafetyRating::probability_score].
    pub fn set_probability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability_score = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::SafetyRating::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::safety_rating::HarmSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [severity_score][crate::model::SafetyRating::severity_score].
    pub fn set_severity_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity_score = v.into();
        self
    }

    /// Sets the value of [blocked][crate::model::SafetyRating::blocked].
    pub fn set_blocked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.blocked = v.into();
        self
    }
}

impl wkt::message::Message for SafetyRating {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyRating"
    }
}

/// Defines additional types related to SafetyRating
pub mod safety_rating {
    #[allow(unused_imports)]
    use super::*;

    /// Harm probability levels in the content.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HarmProbability(std::borrow::Cow<'static, str>);

    impl HarmProbability {
        /// Creates a new HarmProbability instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HarmProbability](HarmProbability)
    pub mod harm_probability {
        use super::HarmProbability;

        /// Harm probability unspecified.
        pub const HARM_PROBABILITY_UNSPECIFIED: HarmProbability =
            HarmProbability::new("HARM_PROBABILITY_UNSPECIFIED");

        /// Negligible level of harm.
        pub const NEGLIGIBLE: HarmProbability = HarmProbability::new("NEGLIGIBLE");

        /// Low level of harm.
        pub const LOW: HarmProbability = HarmProbability::new("LOW");

        /// Medium level of harm.
        pub const MEDIUM: HarmProbability = HarmProbability::new("MEDIUM");

        /// High level of harm.
        pub const HIGH: HarmProbability = HarmProbability::new("HIGH");
    }

    impl std::convert::From<std::string::String> for HarmProbability {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Harm severity levels.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HarmSeverity(std::borrow::Cow<'static, str>);

    impl HarmSeverity {
        /// Creates a new HarmSeverity instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HarmSeverity](HarmSeverity)
    pub mod harm_severity {
        use super::HarmSeverity;

        /// Harm severity unspecified.
        pub const HARM_SEVERITY_UNSPECIFIED: HarmSeverity =
            HarmSeverity::new("HARM_SEVERITY_UNSPECIFIED");

        /// Negligible level of harm severity.
        pub const HARM_SEVERITY_NEGLIGIBLE: HarmSeverity =
            HarmSeverity::new("HARM_SEVERITY_NEGLIGIBLE");

        /// Low level of harm severity.
        pub const HARM_SEVERITY_LOW: HarmSeverity = HarmSeverity::new("HARM_SEVERITY_LOW");

        /// Medium level of harm severity.
        pub const HARM_SEVERITY_MEDIUM: HarmSeverity = HarmSeverity::new("HARM_SEVERITY_MEDIUM");

        /// High level of harm severity.
        pub const HARM_SEVERITY_HIGH: HarmSeverity = HarmSeverity::new("HARM_SEVERITY_HIGH");
    }

    impl std::convert::From<std::string::String> for HarmSeverity {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A collection of source attributions for a piece of content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CitationMetadata {
    /// Output only. List of citations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub citations: std::vec::Vec<crate::model::Citation>,
}

impl CitationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [citations][crate::model::CitationMetadata::citations].
    pub fn set_citations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Citation>,
    {
        use std::iter::Iterator;
        self.citations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CitationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CitationMetadata"
    }
}

/// Source attributions for content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Citation {
    /// Output only. Start index into the content.
    pub start_index: i32,

    /// Output only. End index into the content.
    pub end_index: i32,

    /// Output only. Url reference of the attribution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Output only. Title of the attribution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Output only. License of the attribution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub license: std::string::String,

    /// Output only. Publication date of the attribution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub publication_date: std::option::Option<gtype::model::Date>,
}

impl Citation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_index][crate::model::Citation::start_index].
    pub fn set_start_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.start_index = v.into();
        self
    }

    /// Sets the value of [end_index][crate::model::Citation::end_index].
    pub fn set_end_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.end_index = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Citation::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Citation::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [license][crate::model::Citation::license].
    pub fn set_license<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.license = v.into();
        self
    }

    /// Sets the value of [publication_date][crate::model::Citation::publication_date].
    pub fn set_publication_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.publication_date = v.into();
        self
    }
}

impl wkt::message::Message for Citation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Citation"
    }
}

/// A response candidate generated from the model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Candidate {
    /// Output only. Index of the candidate.
    pub index: i32,

    /// Output only. Content parts of the candidate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::Content>,

    /// Output only. Confidence score of the candidate.
    pub score: f64,

    /// Output only. Average log probability score of the candidate.
    pub avg_logprobs: f64,

    /// Output only. Log-likelihood scores for the response tokens and top tokens
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logprobs_result: std::option::Option<crate::model::LogprobsResult>,

    /// Output only. The reason why the model stopped generating tokens.
    /// If empty, the model has not stopped generating the tokens.
    pub finish_reason: crate::model::candidate::FinishReason,

    /// Output only. List of ratings for the safety of a response candidate.
    ///
    /// There is at most one rating per category.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub safety_ratings: std::vec::Vec<crate::model::SafetyRating>,

    /// Output only. Describes the reason the mode stopped generating tokens in
    /// more detail. This is only filled when `finish_reason` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_message: std::option::Option<std::string::String>,

    /// Output only. Source attribution of the generated content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub citation_metadata: std::option::Option<crate::model::CitationMetadata>,

    /// Output only. Metadata specifies sources used to ground generated content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub grounding_metadata: std::option::Option<crate::model::GroundingMetadata>,
}

impl Candidate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::Candidate::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Candidate::content].
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Candidate::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [avg_logprobs][crate::model::Candidate::avg_logprobs].
    pub fn set_avg_logprobs<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.avg_logprobs = v.into();
        self
    }

    /// Sets the value of [logprobs_result][crate::model::Candidate::logprobs_result].
    pub fn set_logprobs_result<
        T: std::convert::Into<std::option::Option<crate::model::LogprobsResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logprobs_result = v.into();
        self
    }

    /// Sets the value of [finish_reason][crate::model::Candidate::finish_reason].
    pub fn set_finish_reason<T: std::convert::Into<crate::model::candidate::FinishReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_reason = v.into();
        self
    }

    /// Sets the value of [finish_message][crate::model::Candidate::finish_message].
    pub fn set_finish_message<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_message = v.into();
        self
    }

    /// Sets the value of [citation_metadata][crate::model::Candidate::citation_metadata].
    pub fn set_citation_metadata<
        T: std::convert::Into<std::option::Option<crate::model::CitationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.citation_metadata = v.into();
        self
    }

    /// Sets the value of [grounding_metadata][crate::model::Candidate::grounding_metadata].
    pub fn set_grounding_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GroundingMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.grounding_metadata = v.into();
        self
    }

    /// Sets the value of [safety_ratings][crate::model::Candidate::safety_ratings].
    pub fn set_safety_ratings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SafetyRating>,
    {
        use std::iter::Iterator;
        self.safety_ratings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Candidate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Candidate"
    }
}

/// Defines additional types related to Candidate
pub mod candidate {
    #[allow(unused_imports)]
    use super::*;

    /// The reason why the model stopped generating tokens.
    /// If empty, the model has not stopped generating the tokens.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FinishReason(std::borrow::Cow<'static, str>);

    impl FinishReason {
        /// Creates a new FinishReason instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [FinishReason](FinishReason)
    pub mod finish_reason {
        use super::FinishReason;

        /// The finish reason is unspecified.
        pub const FINISH_REASON_UNSPECIFIED: FinishReason =
            FinishReason::new("FINISH_REASON_UNSPECIFIED");

        /// Token generation reached a natural stopping point or a configured stop
        /// sequence.
        pub const STOP: FinishReason = FinishReason::new("STOP");

        /// Token generation reached the configured maximum output tokens.
        pub const MAX_TOKENS: FinishReason = FinishReason::new("MAX_TOKENS");

        /// Token generation stopped because the content potentially contains safety
        /// violations. NOTE: When streaming,
        /// [content][google.cloud.aiplatform.v1.Candidate.content] is empty if
        /// content filters blocks the output.
        ///
        /// [google.cloud.aiplatform.v1.Candidate.content]: crate::model::Candidate::content
        pub const SAFETY: FinishReason = FinishReason::new("SAFETY");

        /// Token generation stopped because the content potentially contains
        /// copyright violations.
        pub const RECITATION: FinishReason = FinishReason::new("RECITATION");

        /// All other reasons that stopped the token generation.
        pub const OTHER: FinishReason = FinishReason::new("OTHER");

        /// Token generation stopped because the content contains forbidden terms.
        pub const BLOCKLIST: FinishReason = FinishReason::new("BLOCKLIST");

        /// Token generation stopped for potentially containing prohibited content.
        pub const PROHIBITED_CONTENT: FinishReason = FinishReason::new("PROHIBITED_CONTENT");

        /// Token generation stopped because the content potentially contains
        /// Sensitive Personally Identifiable Information (SPII).
        pub const SPII: FinishReason = FinishReason::new("SPII");

        /// The function call generated by the model is invalid.
        pub const MALFORMED_FUNCTION_CALL: FinishReason =
            FinishReason::new("MALFORMED_FUNCTION_CALL");
    }

    impl std::convert::From<std::string::String> for FinishReason {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Logprobs Result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogprobsResult {
    /// Length = total number of decoding steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub top_candidates: std::vec::Vec<crate::model::logprobs_result::TopCandidates>,

    /// Length = total number of decoding steps.
    /// The chosen candidates may or may not be in top_candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub chosen_candidates: std::vec::Vec<crate::model::logprobs_result::Candidate>,
}

impl LogprobsResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top_candidates][crate::model::LogprobsResult::top_candidates].
    pub fn set_top_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logprobs_result::TopCandidates>,
    {
        use std::iter::Iterator;
        self.top_candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [chosen_candidates][crate::model::LogprobsResult::chosen_candidates].
    pub fn set_chosen_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logprobs_result::Candidate>,
    {
        use std::iter::Iterator;
        self.chosen_candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LogprobsResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult"
    }
}

/// Defines additional types related to LogprobsResult
pub mod logprobs_result {
    #[allow(unused_imports)]
    use super::*;

    /// Candidate for the logprobs token and score.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Candidate {
        /// The candidate’s token string value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub token: std::option::Option<std::string::String>,

        /// The candidate’s token id value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub token_id: std::option::Option<i32>,

        /// The candidate's log probability.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub log_probability: std::option::Option<f32>,
    }

    impl Candidate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [token][crate::model::logprobs_result::Candidate::token].
        pub fn set_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.token = v.into();
            self
        }

        /// Sets the value of [token_id][crate::model::logprobs_result::Candidate::token_id].
        pub fn set_token_id<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.token_id = v.into();
            self
        }

        /// Sets the value of [log_probability][crate::model::logprobs_result::Candidate::log_probability].
        pub fn set_log_probability<T: std::convert::Into<std::option::Option<f32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.log_probability = v.into();
            self
        }
    }

    impl wkt::message::Message for Candidate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult.Candidate"
        }
    }

    /// Candidates with top log probabilities at each decoding step.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TopCandidates {
        /// Sorted by log probability in descending order.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub candidates: std::vec::Vec<crate::model::logprobs_result::Candidate>,
    }

    impl TopCandidates {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [candidates][crate::model::logprobs_result::TopCandidates::candidates].
        pub fn set_candidates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::logprobs_result::Candidate>,
        {
            use std::iter::Iterator;
            self.candidates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TopCandidates {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult.TopCandidates"
        }
    }
}

/// Segment of the content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Segment {
    /// Output only. The index of a Part object within its parent Content object.
    pub part_index: i32,

    /// Output only. Start index in the given Part, measured in bytes. Offset from
    /// the start of the Part, inclusive, starting at zero.
    pub start_index: i32,

    /// Output only. End index in the given Part, measured in bytes. Offset from
    /// the start of the Part, exclusive, starting at zero.
    pub end_index: i32,

    /// Output only. The text corresponding to the segment from the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,
}

impl Segment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [part_index][crate::model::Segment::part_index].
    pub fn set_part_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.part_index = v.into();
        self
    }

    /// Sets the value of [start_index][crate::model::Segment::start_index].
    pub fn set_start_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.start_index = v.into();
        self
    }

    /// Sets the value of [end_index][crate::model::Segment::end_index].
    pub fn set_end_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.end_index = v.into();
        self
    }

    /// Sets the value of [text][crate::model::Segment::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

impl wkt::message::Message for Segment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Segment"
    }
}

/// Grounding chunk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingChunk {
    /// Chunk type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub chunk_type: std::option::Option<crate::model::grounding_chunk::ChunkType>,
}

impl GroundingChunk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `chunk_type`.
    pub fn set_chunk_type<
        T: std::convert::Into<std::option::Option<crate::model::grounding_chunk::ChunkType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunk_type = v.into();
        self
    }

    /// The value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// if it holds a `Web`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_web(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::grounding_chunk::Web>> {
        #[allow(unreachable_patterns)]
        self.chunk_type.as_ref().and_then(|v| match v {
            crate::model::grounding_chunk::ChunkType::Web(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// if it holds a `RetrievedContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_retrieved_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::grounding_chunk::RetrievedContext>>
    {
        #[allow(unreachable_patterns)]
        self.chunk_type.as_ref().and_then(|v| match v {
            crate::model::grounding_chunk::ChunkType::RetrievedContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// to hold a `Web`.
    ///
    /// Note that all the setters affecting `chunk_type` are
    /// mutually exclusive.
    pub fn set_web<T: std::convert::Into<std::boxed::Box<crate::model::grounding_chunk::Web>>>(
        mut self,
        v: T,
    ) -> Self {
        self.chunk_type =
            std::option::Option::Some(crate::model::grounding_chunk::ChunkType::Web(v.into()));
        self
    }

    /// Sets the value of [chunk_type][crate::model::GroundingChunk::chunk_type]
    /// to hold a `RetrievedContext`.
    ///
    /// Note that all the setters affecting `chunk_type` are
    /// mutually exclusive.
    pub fn set_retrieved_context<
        T: std::convert::Into<std::boxed::Box<crate::model::grounding_chunk::RetrievedContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunk_type = std::option::Option::Some(
            crate::model::grounding_chunk::ChunkType::RetrievedContext(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GroundingChunk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk"
    }
}

/// Defines additional types related to GroundingChunk
pub mod grounding_chunk {
    #[allow(unused_imports)]
    use super::*;

    /// Chunk from the web.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Web {
        /// URI reference of the chunk.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub uri: std::option::Option<std::string::String>,

        /// Title of the chunk.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub title: std::option::Option<std::string::String>,
    }

    impl Web {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::grounding_chunk::Web::uri].
        pub fn set_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [title][crate::model::grounding_chunk::Web::title].
        pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.title = v.into();
            self
        }
    }

    impl wkt::message::Message for Web {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.Web"
        }
    }

    /// Chunk from context retrieved by the retrieval tools.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RetrievedContext {
        /// URI reference of the attribution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub uri: std::option::Option<std::string::String>,

        /// Title of the attribution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub title: std::option::Option<std::string::String>,

        /// Text of the attribution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub text: std::option::Option<std::string::String>,
    }

    impl RetrievedContext {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::grounding_chunk::RetrievedContext::uri].
        pub fn set_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [title][crate::model::grounding_chunk::RetrievedContext::title].
        pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [text][crate::model::grounding_chunk::RetrievedContext::text].
        pub fn set_text<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for RetrievedContext {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.RetrievedContext"
        }
    }

    /// Chunk type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ChunkType {
        /// Grounding chunk from the web.
        Web(std::boxed::Box<crate::model::grounding_chunk::Web>),
        /// Grounding chunk from context retrieved by the retrieval tools.
        RetrievedContext(std::boxed::Box<crate::model::grounding_chunk::RetrievedContext>),
    }
}

/// Grounding support.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingSupport {
    /// Segment of the content this support belongs to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub segment: std::option::Option<crate::model::Segment>,

    /// A list of indices (into 'grounding_chunk') specifying the
    /// citations associated with the claim. For instance [1,3,4] means
    /// that grounding_chunk[1], grounding_chunk[3],
    /// grounding_chunk[4] are the retrieved content attributed to the claim.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_chunk_indices: std::vec::Vec<i32>,

    /// Confidence score of the support references. Ranges from 0 to 1. 1 is the
    /// most confident. This list must have the same size as the
    /// grounding_chunk_indices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub confidence_scores: std::vec::Vec<f32>,
}

impl GroundingSupport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [segment][crate::model::GroundingSupport::segment].
    pub fn set_segment<T: std::convert::Into<std::option::Option<crate::model::Segment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.segment = v.into();
        self
    }

    /// Sets the value of [grounding_chunk_indices][crate::model::GroundingSupport::grounding_chunk_indices].
    pub fn set_grounding_chunk_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.grounding_chunk_indices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [confidence_scores][crate::model::GroundingSupport::confidence_scores].
    pub fn set_confidence_scores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.confidence_scores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GroundingSupport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingSupport"
    }
}

/// Metadata returned to client when grounding is enabled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingMetadata {
    /// Optional. Web search queries for the following-up web search.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub web_search_queries: std::vec::Vec<std::string::String>,

    /// Optional. Google search entry for the following-up web searches.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_entry_point: std::option::Option<crate::model::SearchEntryPoint>,

    /// List of supporting references retrieved from specified grounding source.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_chunks: std::vec::Vec<crate::model::GroundingChunk>,

    /// Optional. List of grounding support.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_supports: std::vec::Vec<crate::model::GroundingSupport>,

    /// Optional. Output only. Retrieval metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retrieval_metadata: std::option::Option<crate::model::RetrievalMetadata>,
}

impl GroundingMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_entry_point][crate::model::GroundingMetadata::search_entry_point].
    pub fn set_search_entry_point<
        T: std::convert::Into<std::option::Option<crate::model::SearchEntryPoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.search_entry_point = v.into();
        self
    }

    /// Sets the value of [retrieval_metadata][crate::model::GroundingMetadata::retrieval_metadata].
    pub fn set_retrieval_metadata<
        T: std::convert::Into<std::option::Option<crate::model::RetrievalMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retrieval_metadata = v.into();
        self
    }

    /// Sets the value of [web_search_queries][crate::model::GroundingMetadata::web_search_queries].
    pub fn set_web_search_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.web_search_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_chunks][crate::model::GroundingMetadata::grounding_chunks].
    pub fn set_grounding_chunks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroundingChunk>,
    {
        use std::iter::Iterator;
        self.grounding_chunks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_supports][crate::model::GroundingMetadata::grounding_supports].
    pub fn set_grounding_supports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroundingSupport>,
    {
        use std::iter::Iterator;
        self.grounding_supports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GroundingMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingMetadata"
    }
}

/// Google search entry point.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntryPoint {
    /// Optional. Web content snippet that can be embedded in a web page or an app
    /// webview.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rendered_content: std::string::String,

    /// Optional. Base64 encoded JSON representing array of <search term, search
    /// url> tuple.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub sdk_blob: bytes::Bytes,
}

impl SearchEntryPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rendered_content][crate::model::SearchEntryPoint::rendered_content].
    pub fn set_rendered_content<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rendered_content = v.into();
        self
    }

    /// Sets the value of [sdk_blob][crate::model::SearchEntryPoint::sdk_blob].
    pub fn set_sdk_blob<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.sdk_blob = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntryPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchEntryPoint"
    }
}

/// Metadata related to retrieval in the grounding flow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrievalMetadata {
    /// Optional. Score indicating how likely information from Google Search could
    /// help answer the prompt. The score is in the range `[0, 1]`, where 0 is the
    /// least likely and 1 is the most likely. This score is only populated when
    /// Google Search grounding and dynamic retrieval is enabled. It will be
    /// compared to the threshold to determine whether to trigger Google Search.
    pub google_search_dynamic_retrieval_score: f32,
}

impl RetrievalMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [google_search_dynamic_retrieval_score][crate::model::RetrievalMetadata::google_search_dynamic_retrieval_score].
    pub fn set_google_search_dynamic_retrieval_score<T: std::convert::Into<f32>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_search_dynamic_retrieval_score = v.into();
        self
    }
}

impl wkt::message::Message for RetrievalMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrievalMetadata"
    }
}

/// Represents token counting info for a single modality.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModalityTokenCount {
    /// The modality associated with this token count.
    pub modality: crate::model::Modality,

    /// Number of tokens.
    pub token_count: i32,
}

impl ModalityTokenCount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [modality][crate::model::ModalityTokenCount::modality].
    pub fn set_modality<T: std::convert::Into<crate::model::Modality>>(mut self, v: T) -> Self {
        self.modality = v.into();
        self
    }

    /// Sets the value of [token_count][crate::model::ModalityTokenCount::token_count].
    pub fn set_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.token_count = v.into();
        self
    }
}

impl wkt::message::Message for ModalityTokenCount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModalityTokenCount"
    }
}

/// Instance of a general context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Context {
    /// Immutable. The resource name of the Context.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name of the Context.
    /// May be up to 128 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// An eTag used to perform consistent read-modify-write updates. If not set, a
    /// blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Contexts.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Context (System
    /// labels are excluded).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Context was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Context was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A list of resource names of Contexts that are parents of this
    /// Context. A Context may have at most 10 parent_contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parent_contexts: std::vec::Vec<std::string::String>,

    /// The title of the schema describing the metadata.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_title: std::string::String,

    /// The version of the schema in schema_name to use.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Properties of the Context.
    /// Top level metadata keys' heading and trailing spaces will be trimmed.
    /// The size of this field should not exceed 200KB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Description of the Context
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl Context {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Context::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Context::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Context::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Context::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Context::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [schema_title][crate::model::Context::schema_title].
    pub fn set_schema_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_title = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::Context::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Context::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Context::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parent_contexts][crate::model::Context::parent_contexts].
    pub fn set_parent_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parent_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Context::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Context {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Context"
    }
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package. A CustomJob can have multiple worker pools and each worker
/// pool can have its own machine and input spec. A CustomJob will be cleaned up
/// once the job enters terminal state (failed or succeeded).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomJob {
    /// Output only. Resource name of a CustomJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the CustomJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Job spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_spec: std::option::Option<crate::model::CustomJobSpec>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the CustomJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the CustomJob for the first time entered the
    /// `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the CustomJob entered any of the following states:
    /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the CustomJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize CustomJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a CustomJob. If this is set,
    /// then all resources created by the CustomJob will be encrypted with the
    /// provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. URIs for accessing [interactive
    /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
    /// (one URI for each training node). Only available if
    /// [job_spec.enable_web_access][google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]
    /// is `true`.
    ///
    /// The keys are names of each node in the training job; for example,
    /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
    /// the second worker pool, and `workerpool1-1` for the second node in the
    /// second worker pool.
    ///
    /// The values are the URIs for each node's interactive shell.
    ///
    /// [google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]: crate::model::CustomJobSpec::enable_web_access
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub web_access_uris: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl CustomJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [job_spec][crate::model::CustomJob::job_spec].
    pub fn set_job_spec<T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CustomJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CustomJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CustomJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CustomJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CustomJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::CustomJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::CustomJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::CustomJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CustomJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [web_access_uris][crate::model::CustomJob::web_access_uris].
    pub fn set_web_access_uris<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.web_access_uris = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CustomJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CustomJob"
    }
}

/// Represents the spec of a CustomJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomJobSpec {
    /// Optional. The ID of the PersistentResource in the same Project and Location
    /// which to run
    ///
    /// If this is specified, the job will be run on existing machines held by the
    /// PersistentResource instead of on-demand short-live machines.
    /// The network and CMEK configs on the job should be consistent with those on
    /// the PersistentResource, otherwise, the job will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub persistent_resource_id: std::string::String,

    /// Required. The spec of the worker pools including machine type and Docker
    /// image. All worker pools except the first one are optional and can be
    /// skipped by providing an empty value.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub worker_pool_specs: std::vec::Vec<crate::model::WorkerPoolSpec>,

    /// Scheduling options for a CustomJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// Specifies the service account for workload run-as account.
    /// Users submitting jobs must have act-as permission on this run-as account.
    /// If unspecified, the [Vertex AI Custom Code Service
    /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
    /// for the CustomJob's project is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. The full name of the Compute Engine
    /// [network](/compute/docs/networks-and-firewalls#networks) to which the Job
    /// should be peered. For example, `projects/12345/global/networks/myVPC`.
    /// [Format](/compute/docs/reference/rest/v1/networks/insert)
    /// is of the form `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in `12345`, and {network} is a
    /// network name.
    ///
    /// To specify this field, you must have already [configured VPC Network
    /// Peering for Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
    ///
    /// If this field is left unspecified, the job is not peered with any network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. A list of names for the reserved ip ranges under the VPC network
    /// that can be used for this job.
    ///
    /// If set, we will deploy the job within the provided ip ranges. Otherwise,
    /// the job will be deployed to any ip ranges under the provided VPC
    /// network.
    ///
    /// Example: ['vertex-ai-ip-range'].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    /// The Cloud Storage location to store the output of this CustomJob or
    /// HyperparameterTuningJob. For HyperparameterTuningJob,
    /// the baseOutputDirectory of
    /// each child CustomJob backing a Trial is set to a subdirectory of name
    /// [id][google.cloud.aiplatform.v1.Trial.id] under its parent
    /// HyperparameterTuningJob's baseOutputDirectory.
    ///
    /// The following Vertex AI environment variables will be passed to
    /// containers or python modules when this field is set:
    ///
    /// For CustomJob:
    ///
    /// * AIP_MODEL_DIR = `<base_output_directory>/model/`
    /// * AIP_CHECKPOINT_DIR = `<base_output_directory>/checkpoints/`
    /// * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/logs/`
    ///
    /// For CustomJob backing a Trial of HyperparameterTuningJob:
    ///
    /// * AIP_MODEL_DIR = `<base_output_directory>/<trial_id>/model/`
    /// * AIP_CHECKPOINT_DIR = `<base_output_directory>/<trial_id>/checkpoints/`
    /// * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/<trial_id>/logs/`
    ///
    /// [google.cloud.aiplatform.v1.Trial.id]: crate::model::Trial::id
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_output_directory: std::option::Option<crate::model::GcsDestination>,

    /// The ID of the location to store protected artifacts. e.g. us-central1.
    /// Populate only when the location is different than CustomJob location.
    /// List of supported locations:
    /// <https://cloud.google.com/vertex-ai/docs/general/locations>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protected_artifact_location_id: std::string::String,

    /// Optional. The name of a Vertex AI
    /// [Tensorboard][google.cloud.aiplatform.v1.Tensorboard] resource to which
    /// this CustomJob will upload Tensorboard logs. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    ///
    /// [google.cloud.aiplatform.v1.Tensorboard]: crate::model::Tensorboard
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,

    /// Optional. Whether you want Vertex AI to enable [interactive shell
    /// access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
    /// to training containers.
    ///
    /// If set to `true`, you can access interactive shells at the URIs given
    /// by
    /// [CustomJob.web_access_uris][google.cloud.aiplatform.v1.CustomJob.web_access_uris]
    /// or
    /// [Trial.web_access_uris][google.cloud.aiplatform.v1.Trial.web_access_uris]
    /// (within
    /// [HyperparameterTuningJob.trials][google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]).
    ///
    /// [google.cloud.aiplatform.v1.CustomJob.web_access_uris]: crate::model::CustomJob::web_access_uris
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]: crate::model::HyperparameterTuningJob::trials
    /// [google.cloud.aiplatform.v1.Trial.web_access_uris]: crate::model::Trial::web_access_uris
    pub enable_web_access: bool,

    /// Optional. Whether you want Vertex AI to enable access to the customized
    /// dashboard in training chief container.
    ///
    /// If set to `true`, you can access the dashboard at the URIs given
    /// by
    /// [CustomJob.web_access_uris][google.cloud.aiplatform.v1.CustomJob.web_access_uris]
    /// or
    /// [Trial.web_access_uris][google.cloud.aiplatform.v1.Trial.web_access_uris]
    /// (within
    /// [HyperparameterTuningJob.trials][google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]).
    ///
    /// [google.cloud.aiplatform.v1.CustomJob.web_access_uris]: crate::model::CustomJob::web_access_uris
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]: crate::model::HyperparameterTuningJob::trials
    /// [google.cloud.aiplatform.v1.Trial.web_access_uris]: crate::model::Trial::web_access_uris
    pub enable_dashboard_access: bool,

    /// Optional. The Experiment associated with this job.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub experiment: std::string::String,

    /// Optional. The Experiment Run associated with this job.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub experiment_run: std::string::String,

    /// Optional. The name of the Model resources for which to generate a mapping
    /// to artifact URIs. Applicable only to some of the Google-provided custom
    /// jobs. Format: `projects/{project}/locations/{location}/models/{model}`
    ///
    /// In order to retrieve a specific version of the model, also provide
    /// the version ID or version alias.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// If no version ID or alias is specified, the "default" version will be
    /// returned. The "default" version alias is created for the first version of
    /// the model, and can be moved to other versions later on. There will be
    /// exactly one default version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<std::string::String>,
}

impl CustomJobSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [persistent_resource_id][crate::model::CustomJobSpec::persistent_resource_id].
    pub fn set_persistent_resource_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource_id = v.into();
        self
    }

    /// Sets the value of [scheduling][crate::model::CustomJobSpec::scheduling].
    pub fn set_scheduling<T: std::convert::Into<std::option::Option<crate::model::Scheduling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scheduling = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::CustomJobSpec::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [network][crate::model::CustomJobSpec::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [base_output_directory][crate::model::CustomJobSpec::base_output_directory].
    pub fn set_base_output_directory<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_output_directory = v.into();
        self
    }

    /// Sets the value of [protected_artifact_location_id][crate::model::CustomJobSpec::protected_artifact_location_id].
    pub fn set_protected_artifact_location_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.protected_artifact_location_id = v.into();
        self
    }

    /// Sets the value of [tensorboard][crate::model::CustomJobSpec::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }

    /// Sets the value of [enable_web_access][crate::model::CustomJobSpec::enable_web_access].
    pub fn set_enable_web_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_web_access = v.into();
        self
    }

    /// Sets the value of [enable_dashboard_access][crate::model::CustomJobSpec::enable_dashboard_access].
    pub fn set_enable_dashboard_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_dashboard_access = v.into();
        self
    }

    /// Sets the value of [experiment][crate::model::CustomJobSpec::experiment].
    pub fn set_experiment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment = v.into();
        self
    }

    /// Sets the value of [experiment_run][crate::model::CustomJobSpec::experiment_run].
    pub fn set_experiment_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment_run = v.into();
        self
    }

    /// Sets the value of [worker_pool_specs][crate::model::CustomJobSpec::worker_pool_specs].
    pub fn set_worker_pool_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkerPoolSpec>,
    {
        use std::iter::Iterator;
        self.worker_pool_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::CustomJobSpec::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [models][crate::model::CustomJobSpec::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomJobSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CustomJobSpec"
    }
}

/// Represents the spec of a worker pool in a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkerPoolSpec {
    /// Optional. Immutable. The specification of a single machine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Optional. The number of worker replicas to use for this worker pool.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub replica_count: i64,

    /// Optional. List of NFS mount spec.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_mounts: std::vec::Vec<crate::model::NfsMount>,

    /// Disk spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_spec: std::option::Option<crate::model::DiskSpec>,

    /// The custom task to be executed in this worker pool.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub task: std::option::Option<crate::model::worker_pool_spec::Task>,
}

impl WorkerPoolSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_spec][crate::model::WorkerPoolSpec::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::WorkerPoolSpec::replica_count].
    pub fn set_replica_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [disk_spec][crate::model::WorkerPoolSpec::disk_spec].
    pub fn set_disk_spec<T: std::convert::Into<std::option::Option<crate::model::DiskSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_spec = v.into();
        self
    }

    /// Sets the value of [nfs_mounts][crate::model::WorkerPoolSpec::nfs_mounts].
    pub fn set_nfs_mounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsMount>,
    {
        use std::iter::Iterator;
        self.nfs_mounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `task`.
    pub fn set_task<
        T: std::convert::Into<std::option::Option<crate::model::worker_pool_spec::Task>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = v.into();
        self
    }

    /// The value of [task][crate::model::WorkerPoolSpec::task]
    /// if it holds a `ContainerSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_container_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContainerSpec>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::worker_pool_spec::Task::ContainerSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [task][crate::model::WorkerPoolSpec::task]
    /// if it holds a `PythonPackageSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_python_package_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PythonPackageSpec>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::worker_pool_spec::Task::PythonPackageSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::WorkerPoolSpec::task]
    /// to hold a `ContainerSpec`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_container_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::ContainerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::worker_pool_spec::Task::ContainerSpec(
            v.into(),
        ));
        self
    }

    /// Sets the value of [task][crate::model::WorkerPoolSpec::task]
    /// to hold a `PythonPackageSpec`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_python_package_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::PythonPackageSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(
            crate::model::worker_pool_spec::Task::PythonPackageSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkerPoolSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WorkerPoolSpec"
    }
}

/// Defines additional types related to WorkerPoolSpec
pub mod worker_pool_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The custom task to be executed in this worker pool.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Task {
        /// The custom container task.
        ContainerSpec(std::boxed::Box<crate::model::ContainerSpec>),
        /// The Python packaged task.
        PythonPackageSpec(std::boxed::Box<crate::model::PythonPackageSpec>),
    }
}

/// The spec of a Container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerSpec {
    /// Required. The URI of a container image in the Container Registry that is to
    /// be run on each worker replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// The command to be invoked when the container is started.
    /// It overrides the entrypoint instruction in Dockerfile when provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub command: std::vec::Vec<std::string::String>,

    /// The arguments to be passed when starting the container.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Environment variables to be passed to the container.
    /// Maximum limit is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,
}

impl ContainerSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_uri][crate::model::ContainerSpec::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [command][crate::model::ContainerSpec::command].
    pub fn set_command<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.command = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::ContainerSpec::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::ContainerSpec::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ContainerSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ContainerSpec"
    }
}

/// The spec of a Python packaged code.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PythonPackageSpec {
    /// Required. The URI of a container image in Artifact Registry that will run
    /// the provided Python package. Vertex AI provides a wide range of executor
    /// images with pre-installed packages to meet users' various use cases. See
    /// the list of [pre-built containers for
    /// training](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
    /// You must use an image from this list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub executor_image_uri: std::string::String,

    /// Required. The Google Cloud Storage location of the Python package files
    /// which are the training program and its dependent packages. The maximum
    /// number of package URIs is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub package_uris: std::vec::Vec<std::string::String>,

    /// Required. The Python module name to run after installing the packages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub python_module: std::string::String,

    /// Command line arguments to be passed to the Python task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Environment variables to be passed to the python module.
    /// Maximum limit is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,
}

impl PythonPackageSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [executor_image_uri][crate::model::PythonPackageSpec::executor_image_uri].
    pub fn set_executor_image_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.executor_image_uri = v.into();
        self
    }

    /// Sets the value of [python_module][crate::model::PythonPackageSpec::python_module].
    pub fn set_python_module<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.python_module = v.into();
        self
    }

    /// Sets the value of [package_uris][crate::model::PythonPackageSpec::package_uris].
    pub fn set_package_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.package_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::PythonPackageSpec::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::PythonPackageSpec::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PythonPackageSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PythonPackageSpec"
    }
}

/// All parameters related to queuing and scheduling of custom jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scheduling {
    /// Optional. The maximum job running time. The default is 7 days.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Restarts the entire CustomJob if a worker gets restarted.
    /// This feature can be used by distributed training jobs that are not
    /// resilient to workers leaving and joining a job.
    pub restart_job_on_worker_restart: bool,

    /// Optional. This determines which type of scheduling strategy to use.
    pub strategy: crate::model::scheduling::Strategy,

    /// Optional. Indicates if the job should retry for internal errors after the
    /// job starts running. If true, overrides
    /// `Scheduling.restart_job_on_worker_restart` to false.
    pub disable_retries: bool,

    /// Optional. This is the maximum duration that a job will wait for the
    /// requested resources to be provisioned if the scheduling strategy is set to
    /// [Strategy.DWS_FLEX_START].
    /// If set to 0, the job will wait indefinitely. The default is 24 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_wait_duration: std::option::Option<wkt::Duration>,
}

impl Scheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timeout][crate::model::Scheduling::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [restart_job_on_worker_restart][crate::model::Scheduling::restart_job_on_worker_restart].
    pub fn set_restart_job_on_worker_restart<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.restart_job_on_worker_restart = v.into();
        self
    }

    /// Sets the value of [strategy][crate::model::Scheduling::strategy].
    pub fn set_strategy<T: std::convert::Into<crate::model::scheduling::Strategy>>(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = v.into();
        self
    }

    /// Sets the value of [disable_retries][crate::model::Scheduling::disable_retries].
    pub fn set_disable_retries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_retries = v.into();
        self
    }

    /// Sets the value of [max_wait_duration][crate::model::Scheduling::max_wait_duration].
    pub fn set_max_wait_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_wait_duration = v.into();
        self
    }
}

impl wkt::message::Message for Scheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Scheduling"
    }
}

/// Defines additional types related to Scheduling
pub mod scheduling {
    #[allow(unused_imports)]
    use super::*;

    /// Optional. This determines which type of scheduling strategy to use. Right
    /// now users have two options such as STANDARD which will use regular on
    /// demand resources to schedule the job, the other is SPOT which would
    /// leverage spot resources alongwith regular resources to schedule
    /// the job.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Strategy(std::borrow::Cow<'static, str>);

    impl Strategy {
        /// Creates a new Strategy instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Strategy](Strategy)
    pub mod strategy {
        use super::Strategy;

        /// Strategy will default to STANDARD.
        pub const STRATEGY_UNSPECIFIED: Strategy = Strategy::new("STRATEGY_UNSPECIFIED");

        /// Deprecated. Regular on-demand provisioning strategy.
        pub const ON_DEMAND: Strategy = Strategy::new("ON_DEMAND");

        /// Deprecated. Low cost by making potential use of spot resources.
        pub const LOW_COST: Strategy = Strategy::new("LOW_COST");

        /// Standard provisioning strategy uses regular on-demand resources.
        pub const STANDARD: Strategy = Strategy::new("STANDARD");

        /// Spot provisioning strategy uses spot resources.
        pub const SPOT: Strategy = Strategy::new("SPOT");

        /// Flex Start strategy uses DWS to queue for resources.
        pub const FLEX_START: Strategy = Strategy::new("FLEX_START");
    }

    impl std::convert::From<std::string::String> for Strategy {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A piece of data in a Dataset. Could be an image, a video, a document or plain
/// text.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataItem {
    /// Output only. The resource name of the DataItem.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this DataItem was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this DataItem was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize your DataItems.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one DataItem(System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The data that the DataItem represents (for example, an image or a
    /// text snippet). The schema of the payload is stored in the parent Dataset's
    /// [metadata schema's][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]
    /// dataItemSchemaUri field.
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<wkt::Value>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl DataItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataItem::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataItem::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataItem::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::DataItem::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataItem::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DataItem::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DataItem::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataItem::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DataItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataItem"
    }
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataLabelingJob {
    /// Output only. Resource name of the DataLabelingJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the DataLabelingJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    /// Display name of a DataLabelingJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Dataset resource names. Right now we only support labeling from a
    /// single Dataset. Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<std::string::String>,

    /// Labels to assign to annotations generated by this DataLabelingJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotation_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Number of labelers to work on each DataItem.
    pub labeler_count: i32,

    /// Required. The Google Cloud Storage location of the instruction pdf. This
    /// pdf is shared with labelers, and provides detailed description on how to
    /// label DataItems in Datasets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instruction_uri: std::string::String,

    /// Required. Points to a YAML file stored on Google Cloud Storage describing
    /// the config for a specific type of DataLabelingJob. The schema files that
    /// can be used here are found in the
    /// <https://storage.googleapis.com/google-cloud-aiplatform> bucket in the
    /// /schema/datalabelingjob/inputs/ folder.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inputs_schema_uri: std::string::String,

    /// Required. Input config parameters for the DataLabelingJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inputs: std::option::Option<wkt::Value>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Current labeling job progress percentage scaled in interval
    /// [0, 100], indicating the percentage of DataItems that has been finished.
    pub labeling_progress: i32,

    /// Output only. Estimated cost(in US dollars) that the DataLabelingJob has
    /// incurred to date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_spend: std::option::Option<gtype::model::Money>,

    /// Output only. Timestamp when this DataLabelingJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this DataLabelingJob was updated most recently.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. DataLabelingJob errors. It is only populated when job's state
    /// is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize your DataLabelingJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for each DataLabelingJob:
    ///
    /// * "aiplatform.googleapis.com/schema": output only, its value is the
    ///   [inputs_schema][google.cloud.aiplatform.v1.DataLabelingJob.inputs_schema_uri]'s
    ///   title.
    ///
    /// [google.cloud.aiplatform.v1.DataLabelingJob.inputs_schema_uri]: crate::model::DataLabelingJob::inputs_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The SpecialistPools' resource names associated with this job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_pools: std::vec::Vec<std::string::String>,

    /// Customer-managed encryption key spec for a DataLabelingJob. If set, this
    /// DataLabelingJob will be secured by this key.
    ///
    /// Note: Annotations created in the DataLabelingJob are associated with
    /// the EncryptionSpec of the Dataset they are exported to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Parameters that configure the active learning pipeline. Active learning
    /// will label the data incrementally via several iterations. For every
    /// iteration, it will select a batch of data based on the sampling strategy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_learning_config: std::option::Option<crate::model::ActiveLearningConfig>,
}

impl DataLabelingJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataLabelingJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataLabelingJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labeler_count][crate::model::DataLabelingJob::labeler_count].
    pub fn set_labeler_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.labeler_count = v.into();
        self
    }

    /// Sets the value of [instruction_uri][crate::model::DataLabelingJob::instruction_uri].
    pub fn set_instruction_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instruction_uri = v.into();
        self
    }

    /// Sets the value of [inputs_schema_uri][crate::model::DataLabelingJob::inputs_schema_uri].
    pub fn set_inputs_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inputs_schema_uri = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::DataLabelingJob::inputs].
    pub fn set_inputs<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.inputs = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataLabelingJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labeling_progress][crate::model::DataLabelingJob::labeling_progress].
    pub fn set_labeling_progress<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.labeling_progress = v.into();
        self
    }

    /// Sets the value of [current_spend][crate::model::DataLabelingJob::current_spend].
    pub fn set_current_spend<T: std::convert::Into<std::option::Option<gtype::model::Money>>>(
        mut self,
        v: T,
    ) -> Self {
        self.current_spend = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataLabelingJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataLabelingJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::DataLabelingJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::DataLabelingJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [active_learning_config][crate::model::DataLabelingJob::active_learning_config].
    pub fn set_active_learning_config<
        T: std::convert::Into<std::option::Option<crate::model::ActiveLearningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.active_learning_config = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::DataLabelingJob::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [specialist_pools][crate::model::DataLabelingJob::specialist_pools].
    pub fn set_specialist_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specialist_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotation_labels][crate::model::DataLabelingJob::annotation_labels].
    pub fn set_annotation_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotation_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::DataLabelingJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DataLabelingJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataLabelingJob"
    }
}

/// Parameters that configure the active learning pipeline. Active learning will
/// label the data incrementally by several iterations. For every iteration, it
/// will select a batch of data based on the sampling strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActiveLearningConfig {
    /// Active learning data sampling config. For every active learning labeling
    /// iteration, it will select a batch of data based on the sampling strategy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_config: std::option::Option<crate::model::SampleConfig>,

    /// CMLE training config. For every active learning labeling iteration, system
    /// will train a machine learning model on CMLE. The trained model will be used
    /// by data sampling algorithm to select DataItems.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_config: std::option::Option<crate::model::TrainingConfig>,

    /// Required. Max human labeling DataItems. The rest part will be labeled by
    /// machine.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub human_labeling_budget:
        std::option::Option<crate::model::active_learning_config::HumanLabelingBudget>,
}

impl ActiveLearningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sample_config][crate::model::ActiveLearningConfig::sample_config].
    pub fn set_sample_config<
        T: std::convert::Into<std::option::Option<crate::model::SampleConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_config = v.into();
        self
    }

    /// Sets the value of [training_config][crate::model::ActiveLearningConfig::training_config].
    pub fn set_training_config<
        T: std::convert::Into<std::option::Option<crate::model::TrainingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_config = v.into();
        self
    }

    /// Sets the value of `human_labeling_budget`.
    pub fn set_human_labeling_budget<
        T: std::convert::Into<
            std::option::Option<crate::model::active_learning_config::HumanLabelingBudget>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.human_labeling_budget = v.into();
        self
    }

    /// The value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// if it holds a `MaxDataItemCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_max_data_item_count(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.human_labeling_budget.as_ref().and_then(|v| match v {
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// if it holds a `MaxDataItemPercentage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_max_data_item_percentage(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.human_labeling_budget.as_ref().and_then(|v| match v {
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemPercentage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// to hold a `MaxDataItemCount`.
    ///
    /// Note that all the setters affecting `human_labeling_budget` are
    /// mutually exclusive.
    pub fn set_max_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.human_labeling_budget = std::option::Option::Some(
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemCount(v.into()),
        );
        self
    }

    /// Sets the value of [human_labeling_budget][crate::model::ActiveLearningConfig::human_labeling_budget]
    /// to hold a `MaxDataItemPercentage`.
    ///
    /// Note that all the setters affecting `human_labeling_budget` are
    /// mutually exclusive.
    pub fn set_max_data_item_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.human_labeling_budget = std::option::Option::Some(
            crate::model::active_learning_config::HumanLabelingBudget::MaxDataItemPercentage(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ActiveLearningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ActiveLearningConfig"
    }
}

/// Defines additional types related to ActiveLearningConfig
pub mod active_learning_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Max human labeling DataItems. The rest part will be labeled by
    /// machine.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum HumanLabelingBudget {
        /// Max number of human labeled DataItems.
        MaxDataItemCount(i64),
        /// Max percent of total DataItems for human labeling.
        MaxDataItemPercentage(i32),
    }
}

/// Active learning data sampling config. For every active learning labeling
/// iteration, it will select a batch of data based on the sampling strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SampleConfig {
    /// Field to choose sampling strategy. Sampling strategy will decide which data
    /// should be selected for human labeling in every batch.
    pub sample_strategy: crate::model::sample_config::SampleStrategy,

    /// Decides sample size for the initial batch. initial_batch_sample_percentage
    /// is used by default.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub initial_batch_sample_size:
        std::option::Option<crate::model::sample_config::InitialBatchSampleSize>,

    /// Decides sample size for the following batches.
    /// following_batch_sample_percentage is used by default.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub following_batch_sample_size:
        std::option::Option<crate::model::sample_config::FollowingBatchSampleSize>,
}

impl SampleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sample_strategy][crate::model::SampleConfig::sample_strategy].
    pub fn set_sample_strategy<
        T: std::convert::Into<crate::model::sample_config::SampleStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sample_strategy = v.into();
        self
    }

    /// Sets the value of `initial_batch_sample_size`.
    pub fn set_initial_batch_sample_size<
        T: std::convert::Into<
            std::option::Option<crate::model::sample_config::InitialBatchSampleSize>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initial_batch_sample_size = v.into();
        self
    }

    /// The value of [initial_batch_sample_size][crate::model::SampleConfig::initial_batch_sample_size]
    /// if it holds a `InitialBatchSamplePercentage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_initial_batch_sample_percentage(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.initial_batch_sample_size.as_ref().and_then(|v| match v {
            crate::model::sample_config::InitialBatchSampleSize::InitialBatchSamplePercentage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [initial_batch_sample_size][crate::model::SampleConfig::initial_batch_sample_size]
    /// to hold a `InitialBatchSamplePercentage`.
    ///
    /// Note that all the setters affecting `initial_batch_sample_size` are
    /// mutually exclusive.
    pub fn set_initial_batch_sample_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_batch_sample_size = std::option::Option::Some(
            crate::model::sample_config::InitialBatchSampleSize::InitialBatchSamplePercentage(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of `following_batch_sample_size`.
    pub fn set_following_batch_sample_size<
        T: std::convert::Into<
            std::option::Option<crate::model::sample_config::FollowingBatchSampleSize>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.following_batch_sample_size = v.into();
        self
    }

    /// The value of [following_batch_sample_size][crate::model::SampleConfig::following_batch_sample_size]
    /// if it holds a `FollowingBatchSamplePercentage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_following_batch_sample_percentage(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.following_batch_sample_size.as_ref().and_then(|v| match v {
            crate::model::sample_config::FollowingBatchSampleSize::FollowingBatchSamplePercentage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [following_batch_sample_size][crate::model::SampleConfig::following_batch_sample_size]
    /// to hold a `FollowingBatchSamplePercentage`.
    ///
    /// Note that all the setters affecting `following_batch_sample_size` are
    /// mutually exclusive.
    pub fn set_following_batch_sample_percentage<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.following_batch_sample_size = std::option::Option::Some(
            crate::model::sample_config::FollowingBatchSampleSize::FollowingBatchSamplePercentage(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SampleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SampleConfig"
    }
}

/// Defines additional types related to SampleConfig
pub mod sample_config {
    #[allow(unused_imports)]
    use super::*;

    /// Sample strategy decides which subset of DataItems should be selected for
    /// human labeling in every batch.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SampleStrategy(std::borrow::Cow<'static, str>);

    impl SampleStrategy {
        /// Creates a new SampleStrategy instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SampleStrategy](SampleStrategy)
    pub mod sample_strategy {
        use super::SampleStrategy;

        /// Default will be treated as UNCERTAINTY.
        pub const SAMPLE_STRATEGY_UNSPECIFIED: SampleStrategy =
            SampleStrategy::new("SAMPLE_STRATEGY_UNSPECIFIED");

        /// Sample the most uncertain data to label.
        pub const UNCERTAINTY: SampleStrategy = SampleStrategy::new("UNCERTAINTY");
    }

    impl std::convert::From<std::string::String> for SampleStrategy {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Decides sample size for the initial batch. initial_batch_sample_percentage
    /// is used by default.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum InitialBatchSampleSize {
        /// The percentage of data needed to be labeled in the first batch.
        InitialBatchSamplePercentage(i32),
    }

    /// Decides sample size for the following batches.
    /// following_batch_sample_percentage is used by default.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FollowingBatchSampleSize {
        /// The percentage of data needed to be labeled in each following batch
        /// (except the first batch).
        FollowingBatchSamplePercentage(i32),
    }
}

/// CMLE training config. For every active learning labeling iteration, system
/// will train a machine learning model on CMLE. The trained model will be used
/// by data sampling algorithm to select DataItems.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainingConfig {
    /// The timeout hours for the CMLE training job, expressed in milli hours
    /// i.e. 1,000 value in this field means 1 hour.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub timeout_training_milli_hours: i64,
}

impl TrainingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timeout_training_milli_hours][crate::model::TrainingConfig::timeout_training_milli_hours].
    pub fn set_timeout_training_milli_hours<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.timeout_training_milli_hours = v.into();
        self
    }
}

impl wkt::message::Message for TrainingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrainingConfig"
    }
}

/// A collection of DataItems and Annotations on them.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dataset {
    /// Output only. Identifier. The resource name of the Dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the Dataset.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Points to a YAML file stored on Google Cloud Storage describing
    /// additional information about the Dataset. The schema is defined as an
    /// OpenAPI 3.0.2 Schema Object. The schema files that can be used here are
    /// found in gs://google-cloud-aiplatform/schema/dataset/metadata/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_uri: std::string::String,

    /// Required. Additional information about the Dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. The number of DataItems in this Dataset. Only apply for
    /// non-structured Dataset.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub data_item_count: i64,

    /// Output only. Timestamp when this Dataset was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Dataset was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Datasets.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Dataset (System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for each Dataset:
    ///
    /// * "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
    ///   value is the
    ///   [metadata_schema's][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]
    ///   title.
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// All SavedQueries belong to the Dataset will be returned in List/Get
    /// Dataset response. The annotation_specs field
    /// will not be populated except for UI cases which will only use
    /// [annotation_spec_count][google.cloud.aiplatform.v1.SavedQuery.annotation_spec_count].
    /// In CreateDataset request, a SavedQuery is created together if
    /// this field is set, up to one SavedQuery can be set in CreateDatasetRequest.
    /// The SavedQuery should not contain any AnnotationSpec.
    ///
    /// [google.cloud.aiplatform.v1.SavedQuery.annotation_spec_count]: crate::model::SavedQuery::annotation_spec_count
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub saved_queries: std::vec::Vec<crate::model::SavedQuery>,

    /// Customer-managed encryption key spec for a Dataset. If set, this Dataset
    /// and all sub-resources of this Dataset will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. The resource name of the Artifact that was created in
    /// MetadataStore when creating the Dataset. The Artifact resource name pattern
    /// is
    /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_artifact: std::string::String,

    /// Optional. Reference to the public base model last used by the dataset. Only
    /// set for prompt datasets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_reference: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Dataset::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [metadata_schema_uri][crate::model::Dataset::metadata_schema_uri].
    pub fn set_metadata_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Dataset::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [data_item_count][crate::model::Dataset::data_item_count].
    pub fn set_data_item_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_item_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Dataset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Dataset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dataset::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Dataset::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [metadata_artifact][crate::model::Dataset::metadata_artifact].
    pub fn set_metadata_artifact<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_artifact = v.into();
        self
    }

    /// Sets the value of [model_reference][crate::model::Dataset::model_reference].
    pub fn set_model_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_reference = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Dataset::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Dataset::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [saved_queries][crate::model::Dataset::saved_queries].
    pub fn set_saved_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SavedQuery>,
    {
        use std::iter::Iterator;
        self.saved_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Dataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Dataset"
    }
}

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataConfig {
    /// Labels that will be applied to newly imported DataItems. If an identical
    /// DataItem as one being imported already exists in the Dataset, then these
    /// labels will be appended to these of the already existing one, and if labels
    /// with identical key is imported before, the old label value will be
    /// overwritten. If two DataItems are identical in the same import data
    /// operation, the labels will be combined and if key collision happens in this
    /// case, one of the values will be picked randomly. Two DataItems are
    /// considered identical if their content bytes are identical (e.g. image bytes
    /// or pdf bytes).
    /// These labels will be overridden by Annotation labels specified inside index
    /// file referenced by
    /// [import_schema_uri][google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri],
    /// e.g. jsonl file.
    ///
    /// [google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri]: crate::model::ImportDataConfig::import_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub data_item_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels that will be applied to newly imported Annotations. If two
    /// Annotations are identical, one of them will be deduped. Two Annotations are
    /// considered identical if their
    /// [payload][google.cloud.aiplatform.v1.Annotation.payload],
    /// [payload_schema_uri][google.cloud.aiplatform.v1.Annotation.payload_schema_uri]
    /// and all of their [labels][google.cloud.aiplatform.v1.Annotation.labels] are
    /// the same. These labels will be overridden by Annotation labels specified
    /// inside index file referenced by
    /// [import_schema_uri][google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri],
    /// e.g. jsonl file.
    ///
    /// [google.cloud.aiplatform.v1.Annotation.labels]: crate::model::Annotation::labels
    /// [google.cloud.aiplatform.v1.Annotation.payload]: crate::model::Annotation::payload
    /// [google.cloud.aiplatform.v1.Annotation.payload_schema_uri]: crate::model::Annotation::payload_schema_uri
    /// [google.cloud.aiplatform.v1.ImportDataConfig.import_schema_uri]: crate::model::ImportDataConfig::import_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotation_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Points to a YAML file stored on Google Cloud Storage describing
    /// the import format. Validation will be done against the schema. The schema
    /// is defined as an [OpenAPI 3.0.2 Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_schema_uri: std::string::String,

    /// The source of the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_data_config::Source>,
}

impl ImportDataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_schema_uri][crate::model::ImportDataConfig::import_schema_uri].
    pub fn set_import_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_schema_uri = v.into();
        self
    }

    /// Sets the value of [data_item_labels][crate::model::ImportDataConfig::data_item_labels].
    pub fn set_data_item_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_item_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotation_labels][crate::model::ImportDataConfig::annotation_labels].
    pub fn set_annotation_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotation_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_data_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportDataConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_data_config::Source::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDataConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_data_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportDataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataConfig"
    }
}

/// Defines additional types related to ImportDataConfig
pub mod import_data_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the input.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Google Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Describes what part of the Dataset is to be exported, the destination of
/// the export and how to export.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataConfig {
    /// An expression for filtering what part of the Dataset is to be exported.
    /// Only Annotations that match this filter will be exported. The filter syntax
    /// is the same as in
    /// [ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations].
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotations_filter: std::string::String,

    /// The ID of a SavedQuery (annotation set) under the Dataset specified by
    /// [ExportDataRequest.name][google.cloud.aiplatform.v1.ExportDataRequest.name]
    /// used for filtering Annotations for training.
    ///
    /// Only used for custom training data export use cases.
    /// Only applicable to Datasets that have SavedQueries.
    ///
    /// Only Annotations that are associated with this SavedQuery are used in
    /// respectively training. When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [saved_query_id][google.cloud.aiplatform.v1.ExportDataConfig.saved_query_id]
    /// and
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter].
    ///
    /// Only one of
    /// [saved_query_id][google.cloud.aiplatform.v1.ExportDataConfig.saved_query_id]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri]
    /// should be specified as both of them represent the same thing: problem type.
    ///
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri]: crate::model::ExportDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter]: crate::model::ExportDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.ExportDataConfig.saved_query_id]: crate::model::ExportDataConfig::saved_query_id
    /// [google.cloud.aiplatform.v1.ExportDataRequest.name]: crate::model::ExportDataRequest::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub saved_query_id: std::string::String,

    /// The Cloud Storage URI that points to a YAML file describing the annotation
    /// schema. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// The schema files that can be used here are found in
    /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
    /// chosen schema must be consistent with
    /// [metadata][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri] of the
    /// Dataset specified by
    /// [ExportDataRequest.name][google.cloud.aiplatform.v1.ExportDataRequest.name].
    ///
    /// Only used for custom training data export use cases.
    /// Only applicable to Datasets that have DataItems and Annotations.
    ///
    /// Only Annotations that both match this schema and belong to DataItems not
    /// ignored by the split method are used in respectively training, validation
    /// or test role, depending on the role of the DataItem they are on.
    ///
    /// When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [annotations_filter][google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotation_schema_uri]: crate::model::ExportDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.ExportDataConfig.annotations_filter]: crate::model::ExportDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.ExportDataRequest.name]: crate::model::ExportDataRequest::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_schema_uri: std::string::String,

    /// Indicates the usage of the exported files.
    pub export_use: crate::model::export_data_config::ExportUse,

    /// The destination of the output.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_data_config::Destination>,

    /// The instructions how the export data should be split between the
    /// training, validation and test sets.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::export_data_config::Split>,
}

impl ExportDataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [annotations_filter][crate::model::ExportDataConfig::annotations_filter].
    pub fn set_annotations_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotations_filter = v.into();
        self
    }

    /// Sets the value of [saved_query_id][crate::model::ExportDataConfig::saved_query_id].
    pub fn set_saved_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query_id = v.into();
        self
    }

    /// Sets the value of [annotation_schema_uri][crate::model::ExportDataConfig::annotation_schema_uri].
    pub fn set_annotation_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_schema_uri = v.into();
        self
    }

    /// Sets the value of [export_use][crate::model::ExportDataConfig::export_use].
    pub fn set_export_use<T: std::convert::Into<crate::model::export_data_config::ExportUse>>(
        mut self,
        v: T,
    ) -> Self {
        self.export_use = v.into();
        self
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_data_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportDataConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_data_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportDataConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_data_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// Sets the value of `split`.
    pub fn set_split<
        T: std::convert::Into<std::option::Option<crate::model::export_data_config::Split>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = v.into();
        self
    }

    /// The value of [split][crate::model::ExportDataConfig::split]
    /// if it holds a `FractionSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fraction_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExportFractionSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::export_data_config::Split::FractionSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::ExportDataConfig::split]
    /// if it holds a `FilterSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_filter_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExportFilterSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::export_data_config::Split::FilterSplit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [split][crate::model::ExportDataConfig::split]
    /// to hold a `FractionSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_fraction_split<
        T: std::convert::Into<std::boxed::Box<crate::model::ExportFractionSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::export_data_config::Split::FractionSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::ExportDataConfig::split]
    /// to hold a `FilterSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_filter_split<
        T: std::convert::Into<std::boxed::Box<crate::model::ExportFilterSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::export_data_config::Split::FilterSplit(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportDataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataConfig"
    }
}

/// Defines additional types related to ExportDataConfig
pub mod export_data_config {
    #[allow(unused_imports)]
    use super::*;

    /// ExportUse indicates the usage of the exported files. It restricts file
    /// destination, format, annotations to be exported, whether to allow
    /// unannotated data to be exported and whether to clone files to temp Cloud
    /// Storage bucket.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ExportUse(std::borrow::Cow<'static, str>);

    impl ExportUse {
        /// Creates a new ExportUse instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ExportUse](ExportUse)
    pub mod export_use {
        use super::ExportUse;

        /// Regular user export.
        pub const EXPORT_USE_UNSPECIFIED: ExportUse = ExportUse::new("EXPORT_USE_UNSPECIFIED");

        /// Export for custom code training.
        pub const CUSTOM_CODE_TRAINING: ExportUse = ExportUse::new("CUSTOM_CODE_TRAINING");
    }

    impl std::convert::From<std::string::String> for ExportUse {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The destination of the output.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// The Google Cloud Storage location where the output is to be written to.
        /// In the given directory a new directory will be created with name:
        /// `export-data-<dataset-display-name>-<timestamp-of-export-call>` where
        /// timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All export
        /// output will be written into that directory. Inside that directory,
        /// annotations with the same schema will be grouped into sub directories
        /// which are named with the corresponding annotations' schema title. Inside
        /// these sub directories, a schema.yaml will be created to describe the
        /// output format.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }

    /// The instructions how the export data should be split between the
    /// training, validation and test sets.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Split {
        /// Split based on fractions defining the size of each set.
        FractionSplit(std::boxed::Box<crate::model::ExportFractionSplit>),
        /// Split based on the provided filters for each set.
        FilterSplit(std::boxed::Box<crate::model::ExportFilterSplit>),
    }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFractionSplit {
    /// The fraction of the input data that is to be used to train the Model.
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    pub test_fraction: f64,
}

impl ExportFractionSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::ExportFractionSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::ExportFractionSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::ExportFractionSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }
}

impl wkt::message::Message for ExportFractionSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFractionSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored. Currently only
/// supported for Datasets containing DataItems.
/// If any of the filters in this message are to match nothing, then they can be
/// set as '-' (the minus sign).
///
/// Supported only for unstructured Datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFilterSplit {
    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to train the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to validate the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub validation_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to test the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub test_filter: std::string::String,
}

impl ExportFilterSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_filter][crate::model::ExportFilterSplit::training_filter].
    pub fn set_training_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.training_filter = v.into();
        self
    }

    /// Sets the value of [validation_filter][crate::model::ExportFilterSplit::validation_filter].
    pub fn set_validation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_filter = v.into();
        self
    }

    /// Sets the value of [test_filter][crate::model::ExportFilterSplit::test_filter].
    pub fn set_test_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_filter = v.into();
        self
    }
}

impl wkt::message::Message for ExportFilterSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFilterSplit"
    }
}

/// Request message for
/// [DatasetService.CreateDataset][google.cloud.aiplatform.v1.DatasetService.CreateDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDataset]: crate::client::DatasetService::create_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetRequest {
    /// Required. The resource name of the Location to create the Dataset in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Dataset to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,
}

impl CreateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetRequest"
    }
}

/// Runtime operation information for
/// [DatasetService.CreateDataset][google.cloud.aiplatform.v1.DatasetService.CreateDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDataset]: crate::client::DatasetService::create_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateDatasetOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateDatasetOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.GetDataset][google.cloud.aiplatform.v1.DatasetService.GetDataset].
/// Next ID: 4
///
/// [google.cloud.aiplatform.v1.DatasetService.GetDataset]: crate::client::DatasetService::get_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. The name of the Dataset resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetDatasetRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDatasetRequest"
    }
}

/// Request message for
/// [DatasetService.UpdateDataset][google.cloud.aiplatform.v1.DatasetService.UpdateDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.UpdateDataset]: crate::client::DatasetService::update_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatasetRequest {
    /// Required. The Dataset which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. Updatable fields:
    ///
    /// * `display_name`
    /// * `description`
    /// * `labels`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::UpdateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatasetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDatasetRequest"
    }
}

/// Request message for
/// [DatasetService.UpdateDatasetVersion][google.cloud.aiplatform.v1.DatasetService.UpdateDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.UpdateDatasetVersion]: crate::client::DatasetService::update_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatasetVersionRequest {
    /// Required. The DatasetVersion which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_version: std::option::Option<crate::model::DatasetVersion>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. Updatable fields:
    ///
    /// * `display_name`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_version][crate::model::UpdateDatasetVersionRequest::dataset_version].
    pub fn set_dataset_version<
        T: std::convert::Into<std::option::Option<crate::model::DatasetVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_version = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatasetVersionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDatasetVersionRequest"
    }
}

/// Request message for
/// [DatasetService.ListDatasets][google.cloud.aiplatform.v1.DatasetService.ListDatasets].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasets]: crate::client::DatasetService::list_datasets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. The name of the Dataset's parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. For field names
    /// both snake_case and camelCase are supported.
    ///
    /// * `display_name`: supports = and !=
    /// * `metadata_schema_uri`: supports = and !=
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    ///
    /// Some examples:
    ///
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDatasetsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatasetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetsRequest"
    }
}

/// Response message for
/// [DatasetService.ListDatasets][google.cloud.aiplatform.v1.DatasetService.ListDatasets].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasets]: crate::client::DatasetService::list_datasets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsResponse {
    /// A list of Datasets that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<crate::model::Dataset>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::ListDatasetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDatasetsResponse {
    type PageItem = crate::model::Dataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [DatasetService.DeleteDataset][google.cloud.aiplatform.v1.DatasetService.DeleteDataset].
///
/// [google.cloud.aiplatform.v1.DatasetService.DeleteDataset]: crate::client::DatasetService::delete_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. The resource name of the Dataset to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDatasetRequest"
    }
}

/// Request message for
/// [DatasetService.ImportData][google.cloud.aiplatform.v1.DatasetService.ImportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ImportData]: crate::client::DatasetService::import_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataRequest {
    /// Required. The name of the Dataset resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The desired input locations. The contents of all input locations
    /// will be imported in one batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub import_configs: std::vec::Vec<crate::model::ImportDataConfig>,
}

impl ImportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportDataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [import_configs][crate::model::ImportDataRequest::import_configs].
    pub fn set_import_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportDataConfig>,
    {
        use std::iter::Iterator;
        self.import_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataRequest"
    }
}

/// Response message for
/// [DatasetService.ImportData][google.cloud.aiplatform.v1.DatasetService.ImportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ImportData]: crate::client::DatasetService::import_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataResponse {}

impl ImportDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ImportDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataResponse"
    }
}

/// Runtime operation information for
/// [DatasetService.ImportData][google.cloud.aiplatform.v1.DatasetService.ImportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ImportData]: crate::client::DatasetService::import_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl ImportDataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ImportDataOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for ImportDataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.ExportData][google.cloud.aiplatform.v1.DatasetService.ExportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ExportData]: crate::client::DatasetService::export_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataRequest {
    /// Required. The name of the Dataset resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The desired output location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_config: std::option::Option<crate::model::ExportDataConfig>,
}

impl ExportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportDataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [export_config][crate::model::ExportDataRequest::export_config].
    pub fn set_export_config<
        T: std::convert::Into<std::option::Option<crate::model::ExportDataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_config = v.into();
        self
    }
}

impl wkt::message::Message for ExportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataRequest"
    }
}

/// Response message for
/// [DatasetService.ExportData][google.cloud.aiplatform.v1.DatasetService.ExportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ExportData]: crate::client::DatasetService::export_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataResponse {
    /// All of the files that are exported in this export operation. For custom
    /// code training export, only three (training, validation and test)
    /// Cloud Storage paths in wildcard format are populated
    /// (for example, gs://.../training-*).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exported_files: std::vec::Vec<std::string::String>,

    /// Only present for custom code training export use case. Records data stats,
    /// i.e., train/validation/test item/annotation counts calculated during
    /// the export operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_stats: std::option::Option<crate::model::model::DataStats>,
}

impl ExportDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_stats][crate::model::ExportDataResponse::data_stats].
    pub fn set_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::model::DataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_stats = v.into();
        self
    }

    /// Sets the value of [exported_files][crate::model::ExportDataResponse::exported_files].
    pub fn set_exported_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exported_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataResponse"
    }
}

/// Runtime operation information for
/// [DatasetService.ExportData][google.cloud.aiplatform.v1.DatasetService.ExportData].
///
/// [google.cloud.aiplatform.v1.DatasetService.ExportData]: crate::client::DatasetService::export_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A Google Cloud Storage directory which path ends with '/'. The exported
    /// data is stored in the directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_output_directory: std::string::String,
}

impl ExportDataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ExportDataOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [gcs_output_directory][crate::model::ExportDataOperationMetadata::gcs_output_directory].
    pub fn set_gcs_output_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_output_directory = v.into();
        self
    }
}

impl wkt::message::Message for ExportDataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.CreateDatasetVersion][google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion]: crate::client::DatasetService::create_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetVersionRequest {
    /// Required. The name of the Dataset resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The version to be created. The same CMEK policies with the
    /// original Dataset will be applied the dataset version. So here we don't need
    /// to specify the EncryptionSpecType here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_version: std::option::Option<crate::model::DatasetVersion>,
}

impl CreateDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset_version][crate::model::CreateDatasetVersionRequest::dataset_version].
    pub fn set_dataset_version<
        T: std::convert::Into<std::option::Option<crate::model::DatasetVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_version = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetVersionRequest"
    }
}

/// Runtime operation information for
/// [DatasetService.CreateDatasetVersion][google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.CreateDatasetVersion]: crate::client::DatasetService::create_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetVersionOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateDatasetVersionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateDatasetVersionOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetVersionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetVersionOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.DeleteDatasetVersion][google.cloud.aiplatform.v1.DatasetService.DeleteDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.DeleteDatasetVersion]: crate::client::DatasetService::delete_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetVersionRequest {
    /// Required. The resource name of the Dataset version to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDatasetVersionRequest"
    }
}

/// Request message for
/// [DatasetService.GetDatasetVersion][google.cloud.aiplatform.v1.DatasetService.GetDatasetVersion].
/// Next ID: 4
///
/// [google.cloud.aiplatform.v1.DatasetService.GetDatasetVersion]: crate::client::DatasetService::get_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetVersionRequest {
    /// Required. The resource name of the Dataset version to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl GetDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetDatasetVersionRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDatasetVersionRequest"
    }
}

/// Request message for
/// [DatasetService.ListDatasetVersions][google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions]: crate::client::DatasetService::list_dataset_versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetVersionsRequest {
    /// Required. The resource name of the Dataset to list DatasetVersions from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDatasetVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDatasetVersionsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatasetVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetVersionsRequest"
    }
}

/// Response message for
/// [DatasetService.ListDatasetVersions][google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDatasetVersions]: crate::client::DatasetService::list_dataset_versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetVersionsResponse {
    /// A list of DatasetVersions that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dataset_versions: std::vec::Vec<crate::model::DatasetVersion>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDatasetVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [dataset_versions][crate::model::ListDatasetVersionsResponse::dataset_versions].
    pub fn set_dataset_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatasetVersion>,
    {
        use std::iter::Iterator;
        self.dataset_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatasetVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetVersionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDatasetVersionsResponse {
    type PageItem = crate::model::DatasetVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dataset_versions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [DatasetService.RestoreDatasetVersion][google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion]: crate::client::DatasetService::restore_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatasetVersionRequest {
    /// Required. The name of the DatasetVersion resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RestoreDatasetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreDatasetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestoreDatasetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RestoreDatasetVersionRequest"
    }
}

/// Runtime operation information for
/// [DatasetService.RestoreDatasetVersion][google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion].
///
/// [google.cloud.aiplatform.v1.DatasetService.RestoreDatasetVersion]: crate::client::DatasetService::restore_dataset_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreDatasetVersionOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl RestoreDatasetVersionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::RestoreDatasetVersionOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for RestoreDatasetVersionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RestoreDatasetVersionOperationMetadata"
    }
}

/// Request message for
/// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataItemsRequest {
    /// Required. The resource name of the Dataset to list DataItems from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDataItemsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataItemsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataItemsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataItemsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataItemsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDataItemsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataItemsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataItemsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataItemsRequest"
    }
}

/// Response message for
/// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataItemsResponse {
    /// A list of DataItems that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_items: std::vec::Vec<crate::model::DataItem>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDataItemsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDataItemsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [data_items][crate::model::ListDataItemsResponse::data_items].
    pub fn set_data_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataItem>,
    {
        use std::iter::Iterator;
        self.data_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataItemsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataItemsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDataItemsResponse {
    type PageItem = crate::model::DataItem;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_items
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [DatasetService.SearchDataItems][google.cloud.aiplatform.v1.DatasetService.SearchDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.SearchDataItems]: crate::client::DatasetService::search_data_items
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDataItemsRequest {
    /// Required. The resource name of the Dataset from which to search DataItems.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// The resource name of a SavedQuery(annotation set in UI).
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
    /// All of the search will be done in the context of this SavedQuery.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub saved_query: std::string::String,

    /// The resource name of a DataLabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    /// If this field is set, all of the search will be done in the context of
    /// this DataLabelingJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_labeling_job: std::string::String,

    /// An expression for filtering the DataItem that will be returned.
    ///
    /// * `data_item_id` - for = or !=.
    /// * `labeled` - for = or !=.
    /// * `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that
    ///   have at least one annotation with annotation_spec_id =
    ///   `ANNOTATION_SPEC_ID` in the context of SavedQuery or DataLabelingJob.
    ///
    /// For example:
    ///
    /// * `data_item=1`
    /// * `has_annotation(5)`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_item_filter: std::string::String,

    /// An expression for filtering the Annotations that will be returned per
    /// DataItem.
    ///
    /// * `annotation_spec_id` - for = or !=.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotations_filter: std::string::String,

    /// An expression that specifies what Annotations will be returned per
    /// DataItem. Annotations satisfied either of the conditions will be returned.
    ///
    /// * `annotation_spec_id` - for = or !=.
    ///   Must specify `saved_query_id=` - saved query id that annotations should
    ///   belong to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub annotation_filters: std::vec::Vec<std::string::String>,

    /// Mask specifying which fields of
    /// [DataItemView][google.cloud.aiplatform.v1.DataItemView] to read.
    ///
    /// [google.cloud.aiplatform.v1.DataItemView]: crate::model::DataItemView
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_mask: std::option::Option<wkt::FieldMask>,

    /// If set, only up to this many of Annotations will be returned per
    /// DataItemView. The maximum value is 1000. If not set, the maximum value will
    /// be used.
    pub annotations_limit: i32,

    /// Requested page size. Server may return fewer results than requested.
    /// Default and maximum page size is 100.
    pub page_size: i32,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// A token identifying a page of results for the server to return
    /// Typically obtained via
    /// [SearchDataItemsResponse.next_page_token][google.cloud.aiplatform.v1.SearchDataItemsResponse.next_page_token]
    /// of the previous
    /// [DatasetService.SearchDataItems][google.cloud.aiplatform.v1.DatasetService.SearchDataItems]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.SearchDataItems]: crate::client::DatasetService::search_data_items
    /// [google.cloud.aiplatform.v1.SearchDataItemsResponse.next_page_token]: crate::model::SearchDataItemsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub order: std::option::Option<crate::model::search_data_items_request::Order>,
}

impl SearchDataItemsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::SearchDataItemsRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [saved_query][crate::model::SearchDataItemsRequest::saved_query].
    pub fn set_saved_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query = v.into();
        self
    }

    /// Sets the value of [data_labeling_job][crate::model::SearchDataItemsRequest::data_labeling_job].
    pub fn set_data_labeling_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_labeling_job = v.into();
        self
    }

    /// Sets the value of [data_item_filter][crate::model::SearchDataItemsRequest::data_item_filter].
    pub fn set_data_item_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item_filter = v.into();
        self
    }

    /// Sets the value of [annotations_filter][crate::model::SearchDataItemsRequest::annotations_filter].
    pub fn set_annotations_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotations_filter = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::SearchDataItemsRequest::field_mask].
    pub fn set_field_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_mask = v.into();
        self
    }

    /// Sets the value of [annotations_limit][crate::model::SearchDataItemsRequest::annotations_limit].
    pub fn set_annotations_limit<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.annotations_limit = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchDataItemsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchDataItemsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchDataItemsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [annotation_filters][crate::model::SearchDataItemsRequest::annotation_filters].
    pub fn set_annotation_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotation_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `order`.
    pub fn set_order<
        T: std::convert::Into<std::option::Option<crate::model::search_data_items_request::Order>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.order = v.into();
        self
    }

    /// The value of [order][crate::model::SearchDataItemsRequest::order]
    /// if it holds a `OrderByDataItem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_order_by_data_item(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.order.as_ref().and_then(|v| match v {
            crate::model::search_data_items_request::Order::OrderByDataItem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [order][crate::model::SearchDataItemsRequest::order]
    /// if it holds a `OrderByAnnotation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_order_by_annotation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::search_data_items_request::OrderByAnnotation>,
    > {
        #[allow(unreachable_patterns)]
        self.order.as_ref().and_then(|v| match v {
            crate::model::search_data_items_request::Order::OrderByAnnotation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [order][crate::model::SearchDataItemsRequest::order]
    /// to hold a `OrderByDataItem`.
    ///
    /// Note that all the setters affecting `order` are
    /// mutually exclusive.
    pub fn set_order_by_data_item<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.order = std::option::Option::Some(
            crate::model::search_data_items_request::Order::OrderByDataItem(v.into()),
        );
        self
    }

    /// Sets the value of [order][crate::model::SearchDataItemsRequest::order]
    /// to hold a `OrderByAnnotation`.
    ///
    /// Note that all the setters affecting `order` are
    /// mutually exclusive.
    pub fn set_order_by_annotation<
        T: std::convert::Into<
            std::boxed::Box<crate::model::search_data_items_request::OrderByAnnotation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.order = std::option::Option::Some(
            crate::model::search_data_items_request::Order::OrderByAnnotation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SearchDataItemsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsRequest"
    }
}

/// Defines additional types related to SearchDataItemsRequest
pub mod search_data_items_request {
    #[allow(unused_imports)]
    use super::*;

    /// Expression that allows ranking results based on annotation's property.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OrderByAnnotation {
        /// Required. Saved query of the Annotation. Only Annotations belong to this
        /// saved query will be considered for ordering.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub saved_query: std::string::String,

        /// A comma-separated list of annotation fields to order by, sorted in
        /// ascending order. Use "desc" after a field name for descending. Must also
        /// specify saved_query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub order_by: std::string::String,
    }

    impl OrderByAnnotation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [saved_query][crate::model::search_data_items_request::OrderByAnnotation::saved_query].
        pub fn set_saved_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.saved_query = v.into();
            self
        }

        /// Sets the value of [order_by][crate::model::search_data_items_request::OrderByAnnotation::order_by].
        pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.order_by = v.into();
            self
        }
    }

    impl wkt::message::Message for OrderByAnnotation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsRequest.OrderByAnnotation"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Order {
        /// A comma-separated list of data item fields to order by, sorted in
        /// ascending order. Use "desc" after a field name for descending.
        OrderByDataItem(std::string::String),
        /// Expression that allows ranking results based on annotation's property.
        OrderByAnnotation(
            std::boxed::Box<crate::model::search_data_items_request::OrderByAnnotation>,
        ),
    }
}

/// Response message for
/// [DatasetService.SearchDataItems][google.cloud.aiplatform.v1.DatasetService.SearchDataItems].
///
/// [google.cloud.aiplatform.v1.DatasetService.SearchDataItems]: crate::client::DatasetService::search_data_items
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDataItemsResponse {
    /// The DataItemViews read.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_item_views: std::vec::Vec<crate::model::DataItemView>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [SearchDataItemsRequest.page_token][google.cloud.aiplatform.v1.SearchDataItemsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.SearchDataItemsRequest.page_token]: crate::model::SearchDataItemsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchDataItemsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchDataItemsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [data_item_views][crate::model::SearchDataItemsResponse::data_item_views].
    pub fn set_data_item_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataItemView>,
    {
        use std::iter::Iterator;
        self.data_item_views = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchDataItemsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchDataItemsResponse {
    type PageItem = crate::model::DataItemView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_item_views
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A container for a single DataItem and Annotations on it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataItemView {
    /// The DataItem.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_item: std::option::Option<crate::model::DataItem>,

    /// The Annotations on the DataItem. If too many Annotations should be returned
    /// for the DataItem, this field will be truncated per annotations_limit in
    /// request. If it was, then the has_truncated_annotations will be set to true.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub annotations: std::vec::Vec<crate::model::Annotation>,

    /// True if and only if the Annotations field has been truncated. It happens if
    /// more Annotations for this DataItem met the request's annotation_filter than
    /// are allowed to be returned by annotations_limit.
    /// Note that if Annotations field is not being returned due to field mask,
    /// then this field will not be set to true no matter how many Annotations are
    /// there.
    pub has_truncated_annotations: bool,
}

impl DataItemView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_item][crate::model::DataItemView::data_item].
    pub fn set_data_item<T: std::convert::Into<std::option::Option<crate::model::DataItem>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item = v.into();
        self
    }

    /// Sets the value of [has_truncated_annotations][crate::model::DataItemView::has_truncated_annotations].
    pub fn set_has_truncated_annotations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_truncated_annotations = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::DataItemView::annotations].
    pub fn set_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Annotation>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataItemView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataItemView"
    }
}

/// Request message for
/// [DatasetService.ListSavedQueries][google.cloud.aiplatform.v1.DatasetService.ListSavedQueries].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListSavedQueries]: crate::client::DatasetService::list_saved_queries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSavedQueriesRequest {
    /// Required. The resource name of the Dataset to list SavedQueries from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListSavedQueriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSavedQueriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSavedQueriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSavedQueriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSavedQueriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListSavedQueriesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSavedQueriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSavedQueriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSavedQueriesRequest"
    }
}

/// Response message for
/// [DatasetService.ListSavedQueries][google.cloud.aiplatform.v1.DatasetService.ListSavedQueries].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListSavedQueries]: crate::client::DatasetService::list_saved_queries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSavedQueriesResponse {
    /// A list of SavedQueries that match the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub saved_queries: std::vec::Vec<crate::model::SavedQuery>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSavedQueriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSavedQueriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [saved_queries][crate::model::ListSavedQueriesResponse::saved_queries].
    pub fn set_saved_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SavedQuery>,
    {
        use std::iter::Iterator;
        self.saved_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSavedQueriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSavedQueriesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSavedQueriesResponse {
    type PageItem = crate::model::SavedQuery;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.saved_queries
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [DatasetService.DeleteSavedQuery][google.cloud.aiplatform.v1.DatasetService.DeleteSavedQuery].
///
/// [google.cloud.aiplatform.v1.DatasetService.DeleteSavedQuery]: crate::client::DatasetService::delete_saved_query
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSavedQueryRequest {
    /// Required. The resource name of the SavedQuery to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteSavedQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSavedQueryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSavedQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteSavedQueryRequest"
    }
}

/// Request message for
/// [DatasetService.GetAnnotationSpec][google.cloud.aiplatform.v1.DatasetService.GetAnnotationSpec].
///
/// [google.cloud.aiplatform.v1.DatasetService.GetAnnotationSpec]: crate::client::DatasetService::get_annotation_spec
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAnnotationSpecRequest {
    /// Required. The name of the AnnotationSpec resource.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl GetAnnotationSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnnotationSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetAnnotationSpecRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for GetAnnotationSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetAnnotationSpecRequest"
    }
}

/// Request message for
/// [DatasetService.ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnnotationsRequest {
    /// Required. The resource name of the DataItem to list Annotations from.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListAnnotationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnnotationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAnnotationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnnotationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnnotationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListAnnotationsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAnnotationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAnnotationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListAnnotationsRequest"
    }
}

/// Response message for
/// [DatasetService.ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations].
///
/// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnnotationsResponse {
    /// A list of Annotations that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub annotations: std::vec::Vec<crate::model::Annotation>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAnnotationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAnnotationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::ListAnnotationsResponse::annotations].
    pub fn set_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Annotation>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAnnotationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListAnnotationsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAnnotationsResponse {
    type PageItem = crate::model::Annotation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.annotations
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Describes the dataset version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetVersion {
    /// Output only. Identifier. The resource name of the DatasetVersion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this DatasetVersion was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this DatasetVersion was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Name of the associated BigQuery dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub big_query_dataset_name: std::string::String,

    /// The user-defined name of the DatasetVersion.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Output only. Additional information about the DatasetVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. Reference to the public base model last used by the dataset
    /// version. Only set for prompt dataset versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_reference: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl DatasetVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatasetVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DatasetVersion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DatasetVersion::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DatasetVersion::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [big_query_dataset_name][crate::model::DatasetVersion::big_query_dataset_name].
    pub fn set_big_query_dataset_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.big_query_dataset_name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DatasetVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::DatasetVersion::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [model_reference][crate::model::DatasetVersion::model_reference].
    pub fn set_model_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_reference = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DatasetVersion::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DatasetVersion::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for DatasetVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DatasetVersion"
    }
}

/// Points to a DeployedIndex.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedIndexRef {
    /// Immutable. A resource name of the IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Immutable. The ID of the DeployedIndex in the above IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    /// Output only. The display name of the DeployedIndex.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl DeployedIndexRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::DeployedIndexRef::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::DeployedIndexRef::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeployedIndexRef::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for DeployedIndexRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexRef"
    }
}

/// Points to a DeployedModel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedModelRef {
    /// Immutable. A resource name of an Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Immutable. An ID of a DeployedModel in the above Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,
}

impl DeployedModelRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DeployedModelRef::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::DeployedModelRef::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }
}

impl wkt::message::Message for DeployedModelRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModelRef"
    }
}

/// A description of resources that can be shared by multiple DeployedModels,
/// whose underlying specification consists of a DedicatedResources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeploymentResourcePool {
    /// Immutable. The resource name of the DeploymentResourcePool.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The underlying DedicatedResources that the DeploymentResourcePool
    /// uses.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_resources: std::option::Option<crate::model::DedicatedResources>,

    /// Customer-managed encryption key spec for a DeploymentResourcePool. If set,
    /// this DeploymentResourcePool will be secured by this key. Endpoints and the
    /// DeploymentResourcePool they deploy in need to have the same EncryptionSpec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The service account that the DeploymentResourcePool's container(s) run as.
    /// Specify the email address of the service account. If this service account
    /// is not specified, the container(s) run as a service account that doesn't
    /// have access to the resource project.
    ///
    /// Users deploying the Models to this DeploymentResourcePool must have the
    /// `iam.serviceAccounts.actAs` permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// If the DeploymentResourcePool is deployed with custom-trained Models or
    /// AutoML Tabular Models, the container(s) of the DeploymentResourcePool will
    /// send `stderr` and `stdout` streams to Cloud Logging by default.
    /// Please note that the logs incur cost, which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging/pricing).
    ///
    /// User can disable container logging by setting this flag to true.
    pub disable_container_logging: bool,

    /// Output only. Timestamp when this DeploymentResourcePool was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl DeploymentResourcePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeploymentResourcePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [dedicated_resources][crate::model::DeploymentResourcePool::dedicated_resources].
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::option::Option<crate::model::DedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_resources = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::DeploymentResourcePool::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DeploymentResourcePool::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disable_container_logging][crate::model::DeploymentResourcePool::disable_container_logging].
    pub fn set_disable_container_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_container_logging = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeploymentResourcePool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DeploymentResourcePool::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DeploymentResourcePool::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for DeploymentResourcePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeploymentResourcePool"
    }
}

/// Request message for CreateDeploymentResourcePool method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeploymentResourcePoolRequest {
    /// Required. The parent location resource where this DeploymentResourcePool
    /// will be created. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DeploymentResourcePool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_resource_pool: std::option::Option<crate::model::DeploymentResourcePool>,

    /// Required. The ID to use for the DeploymentResourcePool, which
    /// will become the final component of the DeploymentResourcePool's resource
    /// name.
    ///
    /// The maximum length is 63 characters, and valid characters
    /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_resource_pool_id: std::string::String,
}

impl CreateDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeploymentResourcePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deployment_resource_pool][crate::model::CreateDeploymentResourcePoolRequest::deployment_resource_pool].
    pub fn set_deployment_resource_pool<
        T: std::convert::Into<std::option::Option<crate::model::DeploymentResourcePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool = v.into();
        self
    }

    /// Sets the value of [deployment_resource_pool_id][crate::model::CreateDeploymentResourcePoolRequest::deployment_resource_pool_id].
    pub fn set_deployment_resource_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDeploymentResourcePoolRequest"
    }
}

/// Runtime operation information for CreateDeploymentResourcePool method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeploymentResourcePoolOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateDeploymentResourcePoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateDeploymentResourcePoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeploymentResourcePoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDeploymentResourcePoolOperationMetadata"
    }
}

/// Request message for GetDeploymentResourcePool method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeploymentResourcePoolRequest {
    /// Required. The name of the DeploymentResourcePool to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeploymentResourcePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDeploymentResourcePoolRequest"
    }
}

/// Request message for ListDeploymentResourcePools method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentResourcePoolsRequest {
    /// Required. The parent Location which owns this collection of
    /// DeploymentResourcePools. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of DeploymentResourcePools to return. The service may
    /// return fewer than this value.
    pub page_size: i32,

    /// A page token, received from a previous `ListDeploymentResourcePools` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDeploymentResourcePools` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDeploymentResourcePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeploymentResourcePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentResourcePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentResourcePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentResourcePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDeploymentResourcePoolsRequest"
    }
}

/// Response message for ListDeploymentResourcePools method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentResourcePoolsResponse {
    /// The DeploymentResourcePools from the specified location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployment_resource_pools: std::vec::Vec<crate::model::DeploymentResourcePool>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDeploymentResourcePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentResourcePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [deployment_resource_pools][crate::model::ListDeploymentResourcePoolsResponse::deployment_resource_pools].
    pub fn set_deployment_resource_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeploymentResourcePool>,
    {
        use std::iter::Iterator;
        self.deployment_resource_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeploymentResourcePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDeploymentResourcePoolsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDeploymentResourcePoolsResponse {
    type PageItem = crate::model::DeploymentResourcePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployment_resource_pools
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for UpdateDeploymentResourcePool method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeploymentResourcePoolRequest {
    /// Required. The DeploymentResourcePool to update.
    ///
    /// The DeploymentResourcePool's `name` field is used to identify the
    /// DeploymentResourcePool to update.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_resource_pool: std::option::Option<crate::model::DeploymentResourcePool>,

    /// Required. The list of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment_resource_pool][crate::model::UpdateDeploymentResourcePoolRequest::deployment_resource_pool].
    pub fn set_deployment_resource_pool<
        T: std::convert::Into<std::option::Option<crate::model::DeploymentResourcePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeploymentResourcePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolRequest"
    }
}

/// Runtime operation information for UpdateDeploymentResourcePool method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeploymentResourcePoolOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateDeploymentResourcePoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateDeploymentResourcePoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeploymentResourcePoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolOperationMetadata"
    }
}

/// Request message for DeleteDeploymentResourcePool method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDeploymentResourcePoolRequest {
    /// Required. The name of the DeploymentResourcePool to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDeploymentResourcePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeploymentResourcePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeploymentResourcePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDeploymentResourcePoolRequest"
    }
}

/// Request message for QueryDeployedModels method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryDeployedModelsRequest {
    /// Required. The name of the target DeploymentResourcePool to query.
    /// Format:
    /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_resource_pool: std::string::String,

    /// The maximum number of DeployedModels to return. The service may return
    /// fewer than this value.
    pub page_size: i32,

    /// A page token, received from a previous `QueryDeployedModels` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryDeployedModels` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl QueryDeployedModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment_resource_pool][crate::model::QueryDeployedModelsRequest::deployment_resource_pool].
    pub fn set_deployment_resource_pool<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_resource_pool = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryDeployedModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryDeployedModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryDeployedModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryDeployedModelsRequest"
    }
}

/// Response message for QueryDeployedModels method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryDeployedModelsResponse {
    /// DEPRECATED Use deployed_model_refs instead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_models: std::vec::Vec<crate::model::DeployedModel>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// References to the DeployedModels that share the specified
    /// deploymentResourcePool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_model_refs: std::vec::Vec<crate::model::DeployedModelRef>,

    /// The total number of DeployedModels on this DeploymentResourcePool.
    pub total_deployed_model_count: i32,

    /// The total number of Endpoints that have DeployedModels on this
    /// DeploymentResourcePool.
    pub total_endpoint_count: i32,
}

impl QueryDeployedModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::QueryDeployedModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_deployed_model_count][crate::model::QueryDeployedModelsResponse::total_deployed_model_count].
    pub fn set_total_deployed_model_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_deployed_model_count = v.into();
        self
    }

    /// Sets the value of [total_endpoint_count][crate::model::QueryDeployedModelsResponse::total_endpoint_count].
    pub fn set_total_endpoint_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_endpoint_count = v.into();
        self
    }

    /// Sets the value of [deployed_models][crate::model::QueryDeployedModelsResponse::deployed_models].
    pub fn set_deployed_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModel>,
    {
        use std::iter::Iterator;
        self.deployed_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployed_model_refs][crate::model::QueryDeployedModelsResponse::deployed_model_refs].
    pub fn set_deployed_model_refs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModelRef>,
    {
        use std::iter::Iterator;
        self.deployed_model_refs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryDeployedModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryDeployedModelsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for QueryDeployedModelsResponse {
    type PageItem = crate::model::DeployedModel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployed_models
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Represents a customer-managed encryption key spec that can be applied to
/// a top-level resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionSpec {
    /// Required. The Cloud KMS resource identifier of the customer managed
    /// encryption key used to protect a resource. Has the form:
    /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
    /// The key needs to be in the same region as where the compute resource is
    /// created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,
}

impl EncryptionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionSpec::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EncryptionSpec"
    }
}

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Endpoint {
    /// Output only. The resource name of the Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the Endpoint.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The models deployed in this Endpoint.
    /// To add or remove DeployedModels use
    /// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel]
    /// and
    /// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel]
    /// respectively.
    ///
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_models: std::vec::Vec<crate::model::DeployedModel>,

    /// A map from a DeployedModel's ID to the percentage of this Endpoint's
    /// traffic that should be forwarded to that DeployedModel.
    ///
    /// If a DeployedModel's ID is not listed in this map, then it receives no
    /// traffic.
    ///
    /// The traffic percentage values must add up to 100, or map must be empty if
    /// the Endpoint is to not accept any traffic at a moment.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub traffic_split: std::collections::HashMap<std::string::String, i32>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Endpoints.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Endpoint was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Endpoint was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Customer-managed encryption key spec for an Endpoint. If set, this
    /// Endpoint and all sub-resources of this Endpoint will be secured by
    /// this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. The full name of the Google Compute Engine
    /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
    /// to which the Endpoint should be peered.
    ///
    /// Private services access must already be configured for the network. If left
    /// unspecified, the Endpoint is not peered with any network.
    ///
    /// Only one of the fields,
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] or
    /// [enable_private_service_connect][google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect],
    /// can be set.
    ///
    /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
    /// `projects/{project}/global/networks/{network}`.
    /// Where `{project}` is a project number, as in `12345`, and `{network}` is
    /// network name.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect]: crate::model::Endpoint::enable_private_service_connect
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Deprecated: If true, expose the Endpoint via private service connect.
    ///
    /// Only one of the fields,
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] or
    /// [enable_private_service_connect][google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect],
    /// can be set.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.enable_private_service_connect]: crate::model::Endpoint::enable_private_service_connect
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    pub enable_private_service_connect: bool,

    /// Optional. Configuration for private service connect.
    ///
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] and
    /// [private_service_connect_config][google.cloud.aiplatform.v1.Endpoint.private_service_connect_config]
    /// are mutually exclusive.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    /// [google.cloud.aiplatform.v1.Endpoint.private_service_connect_config]: crate::model::Endpoint::private_service_connect_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_service_connect_config:
        std::option::Option<crate::model::PrivateServiceConnectConfig>,

    /// Output only. Resource name of the Model Monitoring job associated with this
    /// Endpoint if monitoring is enabled by
    /// [JobService.CreateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob].
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    ///
    /// [google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob]: crate::client::JobService::create_model_deployment_monitoring_job
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_deployment_monitoring_job: std::string::String,

    /// Configures the request-response logging for online prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_request_response_logging_config:
        std::option::Option<crate::model::PredictRequestResponseLoggingConfig>,

    /// If true, the endpoint will be exposed through a dedicated
    /// DNS [Endpoint.dedicated_endpoint_dns]. Your request to the dedicated DNS
    /// will be isolated from other users' traffic and will have better performance
    /// and reliability.
    /// Note: Once you enabled dedicated endpoint, you won't be able to send
    /// request to the shared DNS {region}-aiplatform.googleapis.com. The
    /// limitation will be removed soon.
    pub dedicated_endpoint_enabled: bool,

    /// Output only. DNS of the dedicated endpoint. Will only be populated if
    /// dedicated_endpoint_enabled is true.
    /// Format:
    /// `https://{endpoint_id}.{region}-{project_number}.prediction.vertexai.goog`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dedicated_endpoint_dns: std::string::String,

    /// Configurations that are applied to the endpoint for online prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_connection_config: std::option::Option<crate::model::ClientConnectionConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl Endpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Endpoint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Endpoint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Endpoint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Endpoint::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Endpoint::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Endpoint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Endpoint::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Endpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [enable_private_service_connect][crate::model::Endpoint::enable_private_service_connect].
    pub fn set_enable_private_service_connect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_service_connect = v.into();
        self
    }

    /// Sets the value of [private_service_connect_config][crate::model::Endpoint::private_service_connect_config].
    pub fn set_private_service_connect_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateServiceConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_service_connect_config = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::Endpoint::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }

    /// Sets the value of [predict_request_response_logging_config][crate::model::Endpoint::predict_request_response_logging_config].
    pub fn set_predict_request_response_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::PredictRequestResponseLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_request_response_logging_config = v.into();
        self
    }

    /// Sets the value of [dedicated_endpoint_enabled][crate::model::Endpoint::dedicated_endpoint_enabled].
    pub fn set_dedicated_endpoint_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dedicated_endpoint_enabled = v.into();
        self
    }

    /// Sets the value of [dedicated_endpoint_dns][crate::model::Endpoint::dedicated_endpoint_dns].
    pub fn set_dedicated_endpoint_dns<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_endpoint_dns = v.into();
        self
    }

    /// Sets the value of [client_connection_config][crate::model::Endpoint::client_connection_config].
    pub fn set_client_connection_config<
        T: std::convert::Into<std::option::Option<crate::model::ClientConnectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_connection_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Endpoint::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Endpoint::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [deployed_models][crate::model::Endpoint::deployed_models].
    pub fn set_deployed_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModel>,
    {
        use std::iter::Iterator;
        self.deployed_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [traffic_split][crate::model::Endpoint::traffic_split].
    pub fn set_traffic_split<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.traffic_split = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Endpoint::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Endpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Endpoint"
    }
}

/// A deployment of a Model. Endpoints contain one or more DeployedModels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedModel {
    /// Immutable. The ID of the DeployedModel. If not provided upon deployment,
    /// Vertex AI will generate a value for this ID.
    ///
    /// This value should be 1-10 characters, and valid characters are `/[0-9]/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Required. The resource name of the Model that this is the deployment of.
    /// Note that the Model may be in a different location than the DeployedModel's
    /// Endpoint.
    ///
    /// The resource name may contain version id or version alias to specify the
    /// version.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// if no version is specified, the default version will be deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the model that is deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    /// The display name of the DeployedModel. If not provided upon creation,
    /// the Model's display_name is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp when the DeployedModel was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Explanation configuration for this DeployedModel.
    ///
    /// When deploying a Model using
    /// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel],
    /// this value overrides the value of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec].
    /// All fields of
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// are optional in the request. If a field of
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// is not populated, the value of the same field of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// is inherited. If the corresponding
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// is not populated, all fields of the
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// will be used for the explanation configuration.
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

    /// If true, deploy the model without explainable feature, regardless the
    /// existence of
    /// [Model.explanation_spec][google.cloud.aiplatform.v1.Model.explanation_spec]
    /// or
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    /// [google.cloud.aiplatform.v1.Model.explanation_spec]: crate::model::Model::explanation_spec
    pub disable_explanations: bool,

    /// The service account that the DeployedModel's container runs as. Specify the
    /// email address of the service account. If this service account is not
    /// specified, the container runs as a service account that doesn't have access
    /// to the resource project.
    ///
    /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// For custom-trained Models and AutoML Tabular Models, the container of the
    /// DeployedModel instances will send `stderr` and `stdout` streams to
    /// Cloud Logging by default. Please note that the logs incur cost,
    /// which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging/pricing).
    ///
    /// User can disable container logging by setting this flag to true.
    pub disable_container_logging: bool,

    /// If true, online prediction access logs are sent to Cloud
    /// Logging.
    /// These logs are like standard server access logs, containing
    /// information like timestamp and latency for each prediction request.
    ///
    /// Note that logs may incur a cost, especially if your project
    /// receives prediction requests at a high queries per second rate (QPS).
    /// Estimate your costs before enabling this option.
    pub enable_access_logging: bool,

    /// Output only. Provide paths for users to send predict/explain/health
    /// requests directly to the deployed model services running on Cloud via
    /// private services access. This field is populated if
    /// [network][google.cloud.aiplatform.v1.Endpoint.network] is configured.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.network]: crate::model::Endpoint::network
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_endpoints: std::option::Option<crate::model::PrivateEndpoints>,

    /// Configuration for faster model deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub faster_deployment_config: std::option::Option<crate::model::FasterDeploymentConfig>,

    /// Output only. Runtime status of the deployed model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::deployed_model::Status>,

    /// System labels to apply to Model Garden deployments.
    /// System labels are managed by Google for internal use only.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub system_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Spec for configuring speculative decoding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub speculative_decoding_spec: std::option::Option<crate::model::SpeculativeDecodingSpec>,

    /// The prediction (for example, the machine) resources that the DeployedModel
    /// uses. The user is billed for the resources (at least their minimal amount)
    /// even if the DeployedModel receives no traffic.
    /// Not all Models support all resources types. See
    /// [Model.supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types].
    /// Required except for Large Model Deploy use cases.
    ///
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub prediction_resources:
        std::option::Option<crate::model::deployed_model::PredictionResources>,
}

impl DeployedModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::DeployedModel::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::DeployedModel::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::DeployedModel::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeployedModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployedModel::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [explanation_spec][crate::model::DeployedModel::explanation_spec].
    pub fn set_explanation_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec = v.into();
        self
    }

    /// Sets the value of [disable_explanations][crate::model::DeployedModel::disable_explanations].
    pub fn set_disable_explanations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_explanations = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DeployedModel::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disable_container_logging][crate::model::DeployedModel::disable_container_logging].
    pub fn set_disable_container_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_container_logging = v.into();
        self
    }

    /// Sets the value of [enable_access_logging][crate::model::DeployedModel::enable_access_logging].
    pub fn set_enable_access_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_access_logging = v.into();
        self
    }

    /// Sets the value of [private_endpoints][crate::model::DeployedModel::private_endpoints].
    pub fn set_private_endpoints<
        T: std::convert::Into<std::option::Option<crate::model::PrivateEndpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoints = v.into();
        self
    }

    /// Sets the value of [faster_deployment_config][crate::model::DeployedModel::faster_deployment_config].
    pub fn set_faster_deployment_config<
        T: std::convert::Into<std::option::Option<crate::model::FasterDeploymentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.faster_deployment_config = v.into();
        self
    }

    /// Sets the value of [status][crate::model::DeployedModel::status].
    pub fn set_status<
        T: std::convert::Into<std::option::Option<crate::model::deployed_model::Status>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [speculative_decoding_spec][crate::model::DeployedModel::speculative_decoding_spec].
    pub fn set_speculative_decoding_spec<
        T: std::convert::Into<std::option::Option<crate::model::SpeculativeDecodingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculative_decoding_spec = v.into();
        self
    }

    /// Sets the value of [system_labels][crate::model::DeployedModel::system_labels].
    pub fn set_system_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.system_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `prediction_resources`.
    pub fn set_prediction_resources<
        T: std::convert::Into<std::option::Option<crate::model::deployed_model::PredictionResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = v.into();
        self
    }

    /// The value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// if it holds a `DedicatedResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dedicated_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DedicatedResources>> {
        #[allow(unreachable_patterns)]
        self.prediction_resources.as_ref().and_then(|v| match v {
            crate::model::deployed_model::PredictionResources::DedicatedResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// if it holds a `AutomaticResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_automatic_resources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticResources>> {
        #[allow(unreachable_patterns)]
        self.prediction_resources.as_ref().and_then(|v| match v {
            crate::model::deployed_model::PredictionResources::AutomaticResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// if it holds a `SharedResources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_shared_resources(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.prediction_resources.as_ref().and_then(|v| match v {
            crate::model::deployed_model::PredictionResources::SharedResources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// to hold a `DedicatedResources`.
    ///
    /// Note that all the setters affecting `prediction_resources` are
    /// mutually exclusive.
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::DedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = std::option::Option::Some(
            crate::model::deployed_model::PredictionResources::DedicatedResources(v.into()),
        );
        self
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// to hold a `AutomaticResources`.
    ///
    /// Note that all the setters affecting `prediction_resources` are
    /// mutually exclusive.
    pub fn set_automatic_resources<
        T: std::convert::Into<std::boxed::Box<crate::model::AutomaticResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = std::option::Option::Some(
            crate::model::deployed_model::PredictionResources::AutomaticResources(v.into()),
        );
        self
    }

    /// Sets the value of [prediction_resources][crate::model::DeployedModel::prediction_resources]
    /// to hold a `SharedResources`.
    ///
    /// Note that all the setters affecting `prediction_resources` are
    /// mutually exclusive.
    pub fn set_shared_resources<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_resources = std::option::Option::Some(
            crate::model::deployed_model::PredictionResources::SharedResources(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeployedModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModel"
    }
}

/// Defines additional types related to DeployedModel
pub mod deployed_model {
    #[allow(unused_imports)]
    use super::*;

    /// Runtime status of the deployed model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Status {
        /// Output only. The latest deployed model's status message (if any).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Output only. The time at which the status was last updated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The number of available replicas of the deployed model.
        pub available_replica_count: i32,
    }

    impl Status {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [message][crate::model::deployed_model::Status::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [last_update_time][crate::model::deployed_model::Status::last_update_time].
        pub fn set_last_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_update_time = v.into();
            self
        }

        /// Sets the value of [available_replica_count][crate::model::deployed_model::Status::available_replica_count].
        pub fn set_available_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.available_replica_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Status {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModel.Status"
        }
    }

    /// The prediction (for example, the machine) resources that the DeployedModel
    /// uses. The user is billed for the resources (at least their minimal amount)
    /// even if the DeployedModel receives no traffic.
    /// Not all Models support all resources types. See
    /// [Model.supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types].
    /// Required except for Large Model Deploy use cases.
    ///
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PredictionResources {
        /// A description of resources that are dedicated to the DeployedModel, and
        /// that need a higher degree of manual configuration.
        DedicatedResources(std::boxed::Box<crate::model::DedicatedResources>),
        /// A description of resources that to large degree are decided by Vertex
        /// AI, and require only a modest additional configuration.
        AutomaticResources(std::boxed::Box<crate::model::AutomaticResources>),
        /// The resource name of the shared DeploymentResourcePool to deploy on.
        /// Format:
        /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
        SharedResources(std::string::String),
    }
}

/// PrivateEndpoints proto is used to provide paths for users to send
/// requests privately.
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateEndpoints {
    /// Output only. Http(s) path to send prediction requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predict_http_uri: std::string::String,

    /// Output only. Http(s) path to send explain requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explain_http_uri: std::string::String,

    /// Output only. Http(s) path to send health check requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_http_uri: std::string::String,

    /// Output only. The name of the service attachment resource. Populated if
    /// private service connect is enabled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,
}

impl PrivateEndpoints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [predict_http_uri][crate::model::PrivateEndpoints::predict_http_uri].
    pub fn set_predict_http_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predict_http_uri = v.into();
        self
    }

    /// Sets the value of [explain_http_uri][crate::model::PrivateEndpoints::explain_http_uri].
    pub fn set_explain_http_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.explain_http_uri = v.into();
        self
    }

    /// Sets the value of [health_http_uri][crate::model::PrivateEndpoints::health_http_uri].
    pub fn set_health_http_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.health_http_uri = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PrivateEndpoints::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }
}

impl wkt::message::Message for PrivateEndpoints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PrivateEndpoints"
    }
}

/// Configuration for logging request-response to a BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictRequestResponseLoggingConfig {
    /// If logging is enabled or not.
    pub enabled: bool,

    /// Percentage of requests to be logged, expressed as a fraction in
    /// range(0,1].
    pub sampling_rate: f64,

    /// BigQuery table for logging.
    /// If only given a project, a new dataset will be created with name
    /// `logging_<endpoint-display-name>_<endpoint-id>` where
    /// \<endpoint-display-name\> will be made BigQuery-dataset-name compatible (e.g.
    /// most special characters will become underscores). If no table name is
    /// given, a new table will be created with name `request_response_logging`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_destination: std::option::Option<crate::model::BigQueryDestination>,
}

impl PredictRequestResponseLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PredictRequestResponseLoggingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [sampling_rate][crate::model::PredictRequestResponseLoggingConfig::sampling_rate].
    pub fn set_sampling_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.sampling_rate = v.into();
        self
    }

    /// Sets the value of [bigquery_destination][crate::model::PredictRequestResponseLoggingConfig::bigquery_destination].
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_destination = v.into();
        self
    }
}

impl wkt::message::Message for PredictRequestResponseLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictRequestResponseLoggingConfig"
    }
}

/// Configurations (e.g. inference timeout) that are applied on your endpoints.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClientConnectionConfig {
    /// Customizable online prediction request timeout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inference_timeout: std::option::Option<wkt::Duration>,
}

impl ClientConnectionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inference_timeout][crate::model::ClientConnectionConfig::inference_timeout].
    pub fn set_inference_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.inference_timeout = v.into();
        self
    }
}

impl wkt::message::Message for ClientConnectionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ClientConnectionConfig"
    }
}

/// Configuration for faster model deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FasterDeploymentConfig {
    /// If true, enable fast tryout feature for this deployed model.
    pub fast_tryout_enabled: bool,
}

impl FasterDeploymentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fast_tryout_enabled][crate::model::FasterDeploymentConfig::fast_tryout_enabled].
    pub fn set_fast_tryout_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fast_tryout_enabled = v.into();
        self
    }
}

impl wkt::message::Message for FasterDeploymentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FasterDeploymentConfig"
    }
}

/// Configuration for Speculative Decoding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeculativeDecodingSpec {
    /// The number of speculative tokens to generate at each step.
    pub speculative_token_count: i32,

    /// The type of speculation method to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub speculation: std::option::Option<crate::model::speculative_decoding_spec::Speculation>,
}

impl SpeculativeDecodingSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speculative_token_count][crate::model::SpeculativeDecodingSpec::speculative_token_count].
    pub fn set_speculative_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.speculative_token_count = v.into();
        self
    }

    /// Sets the value of `speculation`.
    pub fn set_speculation<
        T: std::convert::Into<
            std::option::Option<crate::model::speculative_decoding_spec::Speculation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculation = v.into();
        self
    }

    /// The value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// if it holds a `DraftModelSpeculation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_draft_model_speculation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::speculative_decoding_spec::DraftModelSpeculation>,
    > {
        #[allow(unreachable_patterns)]
        self.speculation.as_ref().and_then(|v| match v {
            crate::model::speculative_decoding_spec::Speculation::DraftModelSpeculation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// if it holds a `NgramSpeculation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ngram_speculation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::speculative_decoding_spec::NgramSpeculation>,
    > {
        #[allow(unreachable_patterns)]
        self.speculation.as_ref().and_then(|v| match v {
            crate::model::speculative_decoding_spec::Speculation::NgramSpeculation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// to hold a `DraftModelSpeculation`.
    ///
    /// Note that all the setters affecting `speculation` are
    /// mutually exclusive.
    pub fn set_draft_model_speculation<
        T: std::convert::Into<
            std::boxed::Box<crate::model::speculative_decoding_spec::DraftModelSpeculation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculation = std::option::Option::Some(
            crate::model::speculative_decoding_spec::Speculation::DraftModelSpeculation(v.into()),
        );
        self
    }

    /// Sets the value of [speculation][crate::model::SpeculativeDecodingSpec::speculation]
    /// to hold a `NgramSpeculation`.
    ///
    /// Note that all the setters affecting `speculation` are
    /// mutually exclusive.
    pub fn set_ngram_speculation<
        T: std::convert::Into<
            std::boxed::Box<crate::model::speculative_decoding_spec::NgramSpeculation>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speculation = std::option::Option::Some(
            crate::model::speculative_decoding_spec::Speculation::NgramSpeculation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SpeculativeDecodingSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec"
    }
}

/// Defines additional types related to SpeculativeDecodingSpec
pub mod speculative_decoding_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Draft model speculation works by using the smaller model to generate
    /// candidate tokens for speculative decoding.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DraftModelSpeculation {
        /// Required. The resource name of the draft model.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub draft_model: std::string::String,
    }

    impl DraftModelSpeculation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [draft_model][crate::model::speculative_decoding_spec::DraftModelSpeculation::draft_model].
        pub fn set_draft_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.draft_model = v.into();
            self
        }
    }

    impl wkt::message::Message for DraftModelSpeculation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec.DraftModelSpeculation"
        }
    }

    /// N-Gram speculation works by trying to find matching tokens in the
    /// previous prompt sequence and use those as speculation for generating
    /// new tokens.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NgramSpeculation {
        /// The number of last N input tokens used as ngram to search/match
        /// against the previous prompt sequence.
        /// This is equal to the N in N-Gram.
        /// The default value is 3 if not specified.
        pub ngram_size: i32,
    }

    impl NgramSpeculation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ngram_size][crate::model::speculative_decoding_spec::NgramSpeculation::ngram_size].
        pub fn set_ngram_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.ngram_size = v.into();
            self
        }
    }

    impl wkt::message::Message for NgramSpeculation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec.NgramSpeculation"
        }
    }

    /// The type of speculation method to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Speculation {
        /// draft model speculation.
        DraftModelSpeculation(
            std::boxed::Box<crate::model::speculative_decoding_spec::DraftModelSpeculation>,
        ),
        /// N-Gram speculation.
        NgramSpeculation(
            std::boxed::Box<crate::model::speculative_decoding_spec::NgramSpeculation>,
        ),
    }
}

/// Request message for
/// [EndpointService.CreateEndpoint][google.cloud.aiplatform.v1.EndpointService.CreateEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.CreateEndpoint]: crate::client::EndpointService::create_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEndpointRequest {
    /// Required. The resource name of the Location to create the Endpoint in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Endpoint to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    /// Immutable. The ID to use for endpoint, which will become the final
    /// component of the endpoint resource name.
    /// If not provided, Vertex AI will generate a value for this ID.
    ///
    /// If the first character is a letter, this value may be up to 63 characters,
    /// and valid characters are `[a-z0-9-]`. The last character must be a letter
    /// or number.
    ///
    /// If the first character is a number, this value may be up to 9 characters,
    /// and valid characters are `[0-9]` with no leading zeros.
    ///
    /// When using HTTP/JSON, this field is populated
    /// based on a query string argument, such as `?endpoint_id=12345`. This is the
    /// fallback for fields that are not included in either the URI or the body.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint_id: std::string::String,
}

impl CreateEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEndpointRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::CreateEndpointRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [endpoint_id][crate::model::CreateEndpointRequest::endpoint_id].
    pub fn set_endpoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEndpointRequest"
    }
}

/// Runtime operation information for
/// [EndpointService.CreateEndpoint][google.cloud.aiplatform.v1.EndpointService.CreateEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.CreateEndpoint]: crate::client::EndpointService::create_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEndpointOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateEndpointOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateEndpointOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateEndpointOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEndpointOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.GetEndpoint][google.cloud.aiplatform.v1.EndpointService.GetEndpoint]
///
/// [google.cloud.aiplatform.v1.EndpointService.GetEndpoint]: crate::client::EndpointService::get_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEndpointRequest {
    /// Required. The name of the Endpoint resource.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetEndpointRequest"
    }
}

/// Request message for
/// [EndpointService.ListEndpoints][google.cloud.aiplatform.v1.EndpointService.ListEndpoints].
///
/// [google.cloud.aiplatform.v1.EndpointService.ListEndpoints]: crate::client::EndpointService::list_endpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEndpointsRequest {
    /// Required. The resource name of the Location from which to list the
    /// Endpoints. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `endpoint` supports `=` and `!=`. `endpoint` represents the Endpoint
    ///   ID, i.e. the last segment of the Endpoint's
    ///   [resource name][google.cloud.aiplatform.v1.Endpoint.name].
    /// * `display_name` supports `=` and `!=`.
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:*` or `labels:key` - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    /// * `base_model_name` only supports `=`.
    ///
    /// Some examples:
    ///
    /// * `endpoint=1`
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    /// * `baseModelName="text-bison"`
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.name]: crate::model::Endpoint::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListEndpointsResponse.next_page_token][google.cloud.aiplatform.v1.ListEndpointsResponse.next_page_token]
    /// of the previous
    /// [EndpointService.ListEndpoints][google.cloud.aiplatform.v1.EndpointService.ListEndpoints]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.EndpointService.ListEndpoints]: crate::client::EndpointService::list_endpoints
    /// [google.cloud.aiplatform.v1.ListEndpointsResponse.next_page_token]: crate::model::ListEndpointsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListEndpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEndpointsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEndpointsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEndpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEndpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEndpointsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEndpointsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEndpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEndpointsRequest"
    }
}

/// Response message for
/// [EndpointService.ListEndpoints][google.cloud.aiplatform.v1.EndpointService.ListEndpoints].
///
/// [google.cloud.aiplatform.v1.EndpointService.ListEndpoints]: crate::client::EndpointService::list_endpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEndpointsResponse {
    /// List of Endpoints in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub endpoints: std::vec::Vec<crate::model::Endpoint>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListEndpointsRequest.page_token][google.cloud.aiplatform.v1.ListEndpointsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListEndpointsRequest.page_token]: crate::model::ListEndpointsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListEndpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEndpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::ListEndpointsResponse::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Endpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEndpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEndpointsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEndpointsResponse {
    type PageItem = crate::model::Endpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.endpoints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [EndpointService.UpdateEndpoint][google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint]: crate::client::EndpointService::update_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointRequest {
    /// Required. The Endpoint which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UpdateEndpointRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEndpointRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointRequest"
    }
}

/// Request message for
/// [EndpointService.UpdateEndpointLongRunning][google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning].
///
/// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning]: crate::client::EndpointService::update_endpoint_long_running
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointLongRunningRequest {
    /// Required. The Endpoint which replaces the resource on the server. Currently
    /// we only support updating the `client_connection_config` field, all the
    /// other fields' update will be blocked.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::Endpoint>,
}

impl UpdateEndpointLongRunningRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UpdateEndpointLongRunningRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEndpointLongRunningRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointLongRunningRequest"
    }
}

/// Runtime operation information for
/// [EndpointService.UpdateEndpointLongRunning][google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning].
///
/// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpointLongRunning]: crate::client::EndpointService::update_endpoint_long_running
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEndpointOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateEndpointOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateEndpointOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEndpointOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.DeleteEndpoint][google.cloud.aiplatform.v1.EndpointService.DeleteEndpoint].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeleteEndpoint]: crate::client::EndpointService::delete_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEndpointRequest {
    /// Required. The name of the Endpoint resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteEndpointRequest"
    }
}

/// Request message for
/// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployModelRequest {
    /// Required. The name of the Endpoint resource into which to deploy a Model.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The DeployedModel to be created within the Endpoint. Note that
    /// [Endpoint.traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split]
    /// must be updated for the DeployedModel to start receiving traffic, either as
    /// part of this call, or via
    /// [EndpointService.UpdateEndpoint][google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint].
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    /// [google.cloud.aiplatform.v1.EndpointService.UpdateEndpoint]: crate::client::EndpointService::update_endpoint
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,

    /// A map from a DeployedModel's ID to the percentage of this Endpoint's
    /// traffic that should be forwarded to that DeployedModel.
    ///
    /// If this field is non-empty, then the Endpoint's
    /// [traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split] will be
    /// overwritten with it. To refer to the ID of the just being deployed Model, a
    /// "0" should be used, and the actual ID of the new DeployedModel will be
    /// filled in its place by this method. The traffic percentage values must add
    /// up to 100.
    ///
    /// If this field is empty, then the Endpoint's
    /// [traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split] is not
    /// updated.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub traffic_split: std::collections::HashMap<std::string::String, i32>,
}

impl DeployModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DeployModelRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model][crate::model::DeployModelRequest::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }

    /// Sets the value of [traffic_split][crate::model::DeployModelRequest::traffic_split].
    pub fn set_traffic_split<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.traffic_split = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DeployModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelRequest"
    }
}

/// Response message for
/// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployModelResponse {
    /// The DeployedModel that had been deployed in the Endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,
}

impl DeployModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model][crate::model::DeployModelResponse::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }
}

impl wkt::message::Message for DeployModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelResponse"
    }
}

/// Runtime operation information for
/// [EndpointService.DeployModel][google.cloud.aiplatform.v1.EndpointService.DeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployModelOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl DeployModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeployModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for DeployModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployModelRequest {
    /// Required. The name of the Endpoint resource from which to undeploy a Model.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The ID of the DeployedModel to be undeployed from the Endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// If this field is provided, then the Endpoint's
    /// [traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split] will be
    /// overwritten with it. If last DeployedModel is being undeployed from the
    /// Endpoint, the [Endpoint.traffic_split] will always end up empty when this
    /// call returns. A DeployedModel will be successfully undeployed only if it
    /// doesn't have any traffic assigned to it when this method executes, or if
    /// this field unassigns any traffic to it.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub traffic_split: std::collections::HashMap<std::string::String, i32>,
}

impl UndeployModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::UndeployModelRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::UndeployModelRequest::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [traffic_split][crate::model::UndeployModelRequest::traffic_split].
    pub fn set_traffic_split<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.traffic_split = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for UndeployModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelRequest"
    }
}

/// Response message for
/// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployModelResponse {}

impl UndeployModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UndeployModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelResponse"
    }
}

/// Runtime operation information for
/// [EndpointService.UndeployModel][google.cloud.aiplatform.v1.EndpointService.UndeployModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.UndeployModel]: crate::client::EndpointService::undeploy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployModelOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UndeployModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UndeployModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UndeployModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelOperationMetadata"
    }
}

/// Request message for
/// [EndpointService.MutateDeployedModel][google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel]: crate::client::EndpointService::mutate_deployed_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedModelRequest {
    /// Required. The name of the Endpoint resource into which to mutate a
    /// DeployedModel. Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The DeployedModel to be mutated within the Endpoint. Only the
    /// following fields can be mutated:
    ///
    /// * `min_replica_count` in either
    ///   [DedicatedResources][google.cloud.aiplatform.v1.DedicatedResources] or
    ///   [AutomaticResources][google.cloud.aiplatform.v1.AutomaticResources]
    /// * `max_replica_count` in either
    ///   [DedicatedResources][google.cloud.aiplatform.v1.DedicatedResources] or
    ///   [AutomaticResources][google.cloud.aiplatform.v1.AutomaticResources]
    /// * [autoscaling_metric_specs][google.cloud.aiplatform.v1.DedicatedResources.autoscaling_metric_specs]
    /// * `disable_container_logging` (v1 only)
    /// * `enable_container_logging` (v1beta1 only)
    ///
    /// [google.cloud.aiplatform.v1.AutomaticResources]: crate::model::AutomaticResources
    /// [google.cloud.aiplatform.v1.DedicatedResources]: crate::model::DedicatedResources
    /// [google.cloud.aiplatform.v1.DedicatedResources.autoscaling_metric_specs]: crate::model::DedicatedResources::autoscaling_metric_specs
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl MutateDeployedModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::MutateDeployedModelRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_model][crate::model::MutateDeployedModelRequest::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::MutateDeployedModelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for MutateDeployedModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelRequest"
    }
}

/// Response message for
/// [EndpointService.MutateDeployedModel][google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel]: crate::client::EndpointService::mutate_deployed_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedModelResponse {
    /// The DeployedModel that's being mutated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_model: std::option::Option<crate::model::DeployedModel>,
}

impl MutateDeployedModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model][crate::model::MutateDeployedModelResponse::deployed_model].
    pub fn set_deployed_model<
        T: std::convert::Into<std::option::Option<crate::model::DeployedModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model = v.into();
        self
    }
}

impl wkt::message::Message for MutateDeployedModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelResponse"
    }
}

/// Runtime operation information for
/// [EndpointService.MutateDeployedModel][google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel].
///
/// [google.cloud.aiplatform.v1.EndpointService.MutateDeployedModel]: crate::client::EndpointService::mutate_deployed_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedModelOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl MutateDeployedModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::MutateDeployedModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for MutateDeployedModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelOperationMetadata"
    }
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about. For example, driver is an entity type, and
/// driver0 is an instance of an entity type driver.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityType {
    /// Immutable. Name of the EntityType.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    ///
    /// The last part entity_type is assigned by the client. The entity_type can be
    /// up to 64 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z and underscore(_), and ASCII digits 0-9 starting with a letter. The
    /// value will be unique given a featurestore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description of the EntityType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this EntityType was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this EntityType was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize your
    /// EntityTypes.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one EntityType (System
    /// labels are excluded)."
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Used to perform a consistent read-modify-write updates. If not
    /// set, a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The default monitoring configuration for all Features with value
    /// type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) BOOL,
    /// STRING, DOUBLE or INT64 under this EntityType.
    ///
    /// If this is populated with
    /// [FeaturestoreMonitoringConfig.monitoring_interval] specified, snapshot
    /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
    /// disabled.
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitoring_config: std::option::Option<crate::model::FeaturestoreMonitoringConfig>,

    /// Optional. Config for data retention policy in offline storage.
    /// TTL in days for feature values that will be stored in offline storage.
    /// The Feature Store offline storage periodically removes obsolete feature
    /// values older than `offline_storage_ttl_days` since the feature generation
    /// time. If unset (or explicitly set to 0), default to 4000 days TTL.
    pub offline_storage_ttl_days: i32,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl EntityType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntityType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntityType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EntityType::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EntityType::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::EntityType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::EntityType::monitoring_config].
    pub fn set_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::FeaturestoreMonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_config = v.into();
        self
    }

    /// Sets the value of [offline_storage_ttl_days][crate::model::EntityType::offline_storage_ttl_days].
    pub fn set_offline_storage_ttl_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.offline_storage_ttl_days = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::EntityType::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::EntityType::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntityType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for EntityType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EntityType"
    }
}

/// Represents an environment variable present in a Container or Python Module.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvVar {
    /// Required. Name of the environment variable. Must be a valid C identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Variables that reference a $(VAR_NAME) are expanded
    /// using the previous defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. The $(VAR_NAME)
    /// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
    /// references will never be expanded, regardless of whether the variable
    /// exists or not.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,
}

impl EnvVar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnvVar::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::EnvVar::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for EnvVar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EnvVar"
    }
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluatedAnnotation {
    /// Output only. Type of the EvaluatedAnnotation.
    #[serde(rename = "type")]
    pub r#type: crate::model::evaluated_annotation::EvaluatedAnnotationType,

    /// Output only. The model predicted annotations.
    ///
    /// For true positive, there is one and only one prediction, which matches the
    /// only one ground truth annotation in
    /// [ground_truths][google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths].
    ///
    /// For false positive, there is one and only one prediction, which doesn't
    /// match any ground truth annotation of the corresponding
    /// [data_item_view_id][google.cloud.aiplatform.v1.EvaluatedAnnotation.evaluated_data_item_view_id].
    ///
    /// For false negative, there are zero or more predictions which are similar to
    /// the only ground truth annotation in
    /// [ground_truths][google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths]
    /// but not enough for a match.
    ///
    /// The schema of the prediction is stored in
    /// [ModelEvaluation.annotation_schema_uri][google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.evaluated_data_item_view_id]: crate::model::EvaluatedAnnotation::evaluated_data_item_view_id
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths]: crate::model::EvaluatedAnnotation::ground_truths
    /// [google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]: crate::model::ModelEvaluation::annotation_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predictions: std::vec::Vec<wkt::Value>,

    /// Output only. The ground truth Annotations, i.e. the Annotations that exist
    /// in the test data the Model is evaluated on.
    ///
    /// For true positive, there is one and only one ground truth annotation, which
    /// matches the only prediction in
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions].
    ///
    /// For false positive, there are zero or more ground truth annotations that
    /// are similar to the only prediction in
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions],
    /// but not enough for a match.
    ///
    /// For false negative, there is one and only one ground truth annotation,
    /// which doesn't match any predictions created by the model.
    ///
    /// The schema of the ground truth is stored in
    /// [ModelEvaluation.annotation_schema_uri][google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]: crate::model::EvaluatedAnnotation::predictions
    /// [google.cloud.aiplatform.v1.ModelEvaluation.annotation_schema_uri]: crate::model::ModelEvaluation::annotation_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ground_truths: std::vec::Vec<wkt::Value>,

    /// Output only. The data item payload that the Model predicted this
    /// EvaluatedAnnotation on.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_item_payload: std::option::Option<wkt::Value>,

    /// Output only. ID of the EvaluatedDataItemView under the same ancestor
    /// ModelEvaluation. The EvaluatedDataItemView consists of all ground truths
    /// and predictions on
    /// [data_item_payload][google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload].
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload]: crate::model::EvaluatedAnnotation::data_item_payload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub evaluated_data_item_view_id: std::string::String,

    /// Explanations of
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions].
    /// Each element of the explanations indicates the explanation for one
    /// explanation Method.
    ///
    /// The attributions list in the
    /// [EvaluatedAnnotationExplanation.explanation][google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation.explanation]
    /// object corresponds to the
    /// [predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]
    /// list. For example, the second element in the attributions list explains the
    /// second element in the predictions list.
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]: crate::model::EvaluatedAnnotation::predictions
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation.explanation]: crate::model::EvaluatedAnnotationExplanation::explanation
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explanations: std::vec::Vec<crate::model::EvaluatedAnnotationExplanation>,

    /// Annotations of model error analysis results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_analysis_annotations: std::vec::Vec<crate::model::ErrorAnalysisAnnotation>,
}

impl EvaluatedAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::EvaluatedAnnotation::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::evaluated_annotation::EvaluatedAnnotationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [data_item_payload][crate::model::EvaluatedAnnotation::data_item_payload].
    pub fn set_data_item_payload<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item_payload = v.into();
        self
    }

    /// Sets the value of [evaluated_data_item_view_id][crate::model::EvaluatedAnnotation::evaluated_data_item_view_id].
    pub fn set_evaluated_data_item_view_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluated_data_item_view_id = v.into();
        self
    }

    /// Sets the value of [predictions][crate::model::EvaluatedAnnotation::predictions].
    pub fn set_predictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.predictions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ground_truths][crate::model::EvaluatedAnnotation::ground_truths].
    pub fn set_ground_truths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.ground_truths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [explanations][crate::model::EvaluatedAnnotation::explanations].
    pub fn set_explanations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedAnnotationExplanation>,
    {
        use std::iter::Iterator;
        self.explanations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_analysis_annotations][crate::model::EvaluatedAnnotation::error_analysis_annotations].
    pub fn set_error_analysis_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorAnalysisAnnotation>,
    {
        use std::iter::Iterator;
        self.error_analysis_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EvaluatedAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluatedAnnotation"
    }
}

/// Defines additional types related to EvaluatedAnnotation
pub mod evaluated_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the type of the EvaluatedAnnotation. The type is determined
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EvaluatedAnnotationType(std::borrow::Cow<'static, str>);

    impl EvaluatedAnnotationType {
        /// Creates a new EvaluatedAnnotationType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [EvaluatedAnnotationType](EvaluatedAnnotationType)
    pub mod evaluated_annotation_type {
        use super::EvaluatedAnnotationType;

        /// Invalid value.
        pub const EVALUATED_ANNOTATION_TYPE_UNSPECIFIED: EvaluatedAnnotationType =
            EvaluatedAnnotationType::new("EVALUATED_ANNOTATION_TYPE_UNSPECIFIED");

        /// The EvaluatedAnnotation is a true positive. It has a prediction created
        /// by the Model and a ground truth Annotation which the prediction matches.
        pub const TRUE_POSITIVE: EvaluatedAnnotationType =
            EvaluatedAnnotationType::new("TRUE_POSITIVE");

        /// The EvaluatedAnnotation is false positive. It has a prediction created by
        /// the Model which does not match any ground truth annotation.
        pub const FALSE_POSITIVE: EvaluatedAnnotationType =
            EvaluatedAnnotationType::new("FALSE_POSITIVE");

        /// The EvaluatedAnnotation is false negative. It has a ground truth
        /// annotation which is not matched by any of the model created predictions.
        pub const FALSE_NEGATIVE: EvaluatedAnnotationType =
            EvaluatedAnnotationType::new("FALSE_NEGATIVE");
    }

    impl std::convert::From<std::string::String> for EvaluatedAnnotationType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Explanation result of the prediction produced by the Model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluatedAnnotationExplanation {
    /// Explanation type.
    ///
    /// For AutoML Image Classification models, possible values are:
    ///
    /// * `image-integrated-gradients`
    /// * `image-xrai`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation_type: std::string::String,

    /// Explanation attribution response details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation: std::option::Option<crate::model::Explanation>,
}

impl EvaluatedAnnotationExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [explanation_type][crate::model::EvaluatedAnnotationExplanation::explanation_type].
    pub fn set_explanation_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_type = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::EvaluatedAnnotationExplanation::explanation].
    pub fn set_explanation<
        T: std::convert::Into<std::option::Option<crate::model::Explanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation = v.into();
        self
    }
}

impl wkt::message::Message for EvaluatedAnnotationExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation"
    }
}

/// Model error analysis for each annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorAnalysisAnnotation {
    /// Attributed items for a given annotation, typically representing neighbors
    /// from the training sets constrained by the query type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attributed_items: std::vec::Vec<crate::model::error_analysis_annotation::AttributedItem>,

    /// The query type used for finding the attributed items.
    pub query_type: crate::model::error_analysis_annotation::QueryType,

    /// The outlier score of this annotated item. Usually defined as the min of all
    /// distances from attributed items.
    pub outlier_score: f64,

    /// The threshold used to determine if this annotation is an outlier or not.
    pub outlier_threshold: f64,
}

impl ErrorAnalysisAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_type][crate::model::ErrorAnalysisAnnotation::query_type].
    pub fn set_query_type<
        T: std::convert::Into<crate::model::error_analysis_annotation::QueryType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query_type = v.into();
        self
    }

    /// Sets the value of [outlier_score][crate::model::ErrorAnalysisAnnotation::outlier_score].
    pub fn set_outlier_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.outlier_score = v.into();
        self
    }

    /// Sets the value of [outlier_threshold][crate::model::ErrorAnalysisAnnotation::outlier_threshold].
    pub fn set_outlier_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.outlier_threshold = v.into();
        self
    }

    /// Sets the value of [attributed_items][crate::model::ErrorAnalysisAnnotation::attributed_items].
    pub fn set_attributed_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::error_analysis_annotation::AttributedItem>,
    {
        use std::iter::Iterator;
        self.attributed_items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorAnalysisAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ErrorAnalysisAnnotation"
    }
}

/// Defines additional types related to ErrorAnalysisAnnotation
pub mod error_analysis_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Attributed items for a given annotation, typically representing neighbors
    /// from the training sets constrained by the query type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AttributedItem {
        /// The unique ID for each annotation. Used by FE to allocate the annotation
        /// in DB.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub annotation_resource_name: std::string::String,

        /// The distance of this item to the annotation.
        pub distance: f64,
    }

    impl AttributedItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [annotation_resource_name][crate::model::error_analysis_annotation::AttributedItem::annotation_resource_name].
        pub fn set_annotation_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.annotation_resource_name = v.into();
            self
        }

        /// Sets the value of [distance][crate::model::error_analysis_annotation::AttributedItem::distance].
        pub fn set_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.distance = v.into();
            self
        }
    }

    impl wkt::message::Message for AttributedItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ErrorAnalysisAnnotation.AttributedItem"
        }
    }

    /// The query type used for finding the attributed items.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct QueryType(std::borrow::Cow<'static, str>);

    impl QueryType {
        /// Creates a new QueryType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [QueryType](QueryType)
    pub mod query_type {
        use super::QueryType;

        /// Unspecified query type for model error analysis.
        pub const QUERY_TYPE_UNSPECIFIED: QueryType = QueryType::new("QUERY_TYPE_UNSPECIFIED");

        /// Query similar samples across all classes in the dataset.
        pub const ALL_SIMILAR: QueryType = QueryType::new("ALL_SIMILAR");

        /// Query similar samples from the same class of the input sample.
        pub const SAME_CLASS_SIMILAR: QueryType = QueryType::new("SAME_CLASS_SIMILAR");

        /// Query dissimilar samples from the same class of the input sample.
        pub const SAME_CLASS_DISSIMILAR: QueryType = QueryType::new("SAME_CLASS_DISSIMILAR");
    }

    impl std::convert::From<std::string::String> for QueryType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Request message for EvaluationService.EvaluateInstances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluateInstancesRequest {
    /// Required. The resource name of the Location to evaluate the instances.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Instances and specs for evaluation
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metric_inputs: std::option::Option<crate::model::evaluate_instances_request::MetricInputs>,
}

impl EvaluateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::EvaluateInstancesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of `metric_inputs`.
    pub fn set_metric_inputs<
        T: std::convert::Into<
            std::option::Option<crate::model::evaluate_instances_request::MetricInputs>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = v.into();
        self
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ExactMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exact_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExactMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ExactMatchInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `BleuInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bleu_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::BleuInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::BleuInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `RougeInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rouge_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RougeInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::RougeInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `FluencyInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fluency_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FluencyInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::FluencyInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `CoherenceInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_coherence_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CoherenceInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::CoherenceInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SafetyInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_safety_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SafetyInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SafetyInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `GroundednessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_groundedness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GroundednessInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::GroundednessInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `FulfillmentInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fulfillment_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FulfillmentInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::FulfillmentInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SummarizationQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_summarization_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationQualityInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SummarizationQualityInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PairwiseSummarizationQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pairwise_summarization_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseSummarizationQualityInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PairwiseSummarizationQualityInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SummarizationHelpfulnessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_summarization_helpfulness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationHelpfulnessInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SummarizationHelpfulnessInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `SummarizationVerbosityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_summarization_verbosity_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationVerbosityInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::SummarizationVerbosityInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringQualityInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringQualityInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PairwiseQuestionAnsweringQualityInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pairwise_question_answering_quality_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PairwiseQuestionAnsweringQualityInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringRelevanceInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_relevance_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringRelevanceInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringRelevanceInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringHelpfulnessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_helpfulness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringHelpfulnessInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `QuestionAnsweringCorrectnessInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_correctness_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringCorrectnessInput>>
    {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringCorrectnessInput(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PointwiseMetricInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pointwise_metric_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PointwiseMetricInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PointwiseMetricInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `PairwiseMetricInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pairwise_metric_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseMetricInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::PairwiseMetricInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolCallValidInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_call_valid_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolCallValidInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolCallValidInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolNameMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_name_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolNameMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolNameMatchInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolParameterKeyMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_parameter_key_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKeyMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKeyMatchInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `ToolParameterKvMatchInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_parameter_kv_match_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKVMatchInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKvMatchInput(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `CometInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_comet_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CometInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::CometInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// if it holds a `MetricxInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_metricx_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetricxInput>> {
        #[allow(unreachable_patterns)]
        self.metric_inputs.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_request::MetricInputs::MetricxInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ExactMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_exact_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ExactMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ExactMatchInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `BleuInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_bleu_input<T: std::convert::Into<std::boxed::Box<crate::model::BleuInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::BleuInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `RougeInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_rouge_input<T: std::convert::Into<std::boxed::Box<crate::model::RougeInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::RougeInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `FluencyInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_fluency_input<T: std::convert::Into<std::boxed::Box<crate::model::FluencyInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::FluencyInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `CoherenceInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_coherence_input<
        T: std::convert::Into<std::boxed::Box<crate::model::CoherenceInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::CoherenceInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SafetyInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_safety_input<T: std::convert::Into<std::boxed::Box<crate::model::SafetyInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SafetyInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `GroundednessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_groundedness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::GroundednessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::GroundednessInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `FulfillmentInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_fulfillment_input<
        T: std::convert::Into<std::boxed::Box<crate::model::FulfillmentInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::FulfillmentInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SummarizationQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_summarization_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SummarizationQualityInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PairwiseSummarizationQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pairwise_summarization_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseSummarizationQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PairwiseSummarizationQualityInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SummarizationHelpfulnessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_summarization_helpfulness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationHelpfulnessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SummarizationHelpfulnessInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `SummarizationVerbosityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_summarization_verbosity_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationVerbosityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::SummarizationVerbosityInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringQualityInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PairwiseQuestionAnsweringQualityInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pairwise_question_answering_quality_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PairwiseQuestionAnsweringQualityInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringRelevanceInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_relevance_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringRelevanceInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringRelevanceInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringHelpfulnessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_helpfulness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringHelpfulnessInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `QuestionAnsweringCorrectnessInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_question_answering_correctness_input<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringCorrectnessInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::QuestionAnsweringCorrectnessInput(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PointwiseMetricInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pointwise_metric_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PointwiseMetricInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PointwiseMetricInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `PairwiseMetricInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_pairwise_metric_input<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseMetricInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::PairwiseMetricInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolCallValidInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_call_valid_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolCallValidInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolCallValidInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolNameMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_name_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolNameMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolNameMatchInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolParameterKeyMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_parameter_key_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKeyMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKeyMatchInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `ToolParameterKvMatchInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_tool_parameter_kv_match_input<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKVMatchInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::ToolParameterKvMatchInput(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `CometInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_comet_input<T: std::convert::Into<std::boxed::Box<crate::model::CometInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::CometInput(v.into()),
        );
        self
    }

    /// Sets the value of [metric_inputs][crate::model::EvaluateInstancesRequest::metric_inputs]
    /// to hold a `MetricxInput`.
    ///
    /// Note that all the setters affecting `metric_inputs` are
    /// mutually exclusive.
    pub fn set_metricx_input<T: std::convert::Into<std::boxed::Box<crate::model::MetricxInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_inputs = std::option::Option::Some(
            crate::model::evaluate_instances_request::MetricInputs::MetricxInput(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EvaluateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluateInstancesRequest"
    }
}

/// Defines additional types related to EvaluateInstancesRequest
pub mod evaluate_instances_request {
    #[allow(unused_imports)]
    use super::*;

    /// Instances and specs for evaluation
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MetricInputs {
        /// Auto metric instances.
        /// Instances and metric spec for exact match metric.
        ExactMatchInput(std::boxed::Box<crate::model::ExactMatchInput>),
        /// Instances and metric spec for bleu metric.
        BleuInput(std::boxed::Box<crate::model::BleuInput>),
        /// Instances and metric spec for rouge metric.
        RougeInput(std::boxed::Box<crate::model::RougeInput>),
        /// LLM-based metric instance.
        /// General text generation metrics, applicable to other categories.
        /// Input for fluency metric.
        FluencyInput(std::boxed::Box<crate::model::FluencyInput>),
        /// Input for coherence metric.
        CoherenceInput(std::boxed::Box<crate::model::CoherenceInput>),
        /// Input for safety metric.
        SafetyInput(std::boxed::Box<crate::model::SafetyInput>),
        /// Input for groundedness metric.
        GroundednessInput(std::boxed::Box<crate::model::GroundednessInput>),
        /// Input for fulfillment metric.
        FulfillmentInput(std::boxed::Box<crate::model::FulfillmentInput>),
        /// Input for summarization quality metric.
        SummarizationQualityInput(std::boxed::Box<crate::model::SummarizationQualityInput>),
        /// Input for pairwise summarization quality metric.
        PairwiseSummarizationQualityInput(
            std::boxed::Box<crate::model::PairwiseSummarizationQualityInput>,
        ),
        /// Input for summarization helpfulness metric.
        SummarizationHelpfulnessInput(std::boxed::Box<crate::model::SummarizationHelpfulnessInput>),
        /// Input for summarization verbosity metric.
        SummarizationVerbosityInput(std::boxed::Box<crate::model::SummarizationVerbosityInput>),
        /// Input for question answering quality metric.
        QuestionAnsweringQualityInput(std::boxed::Box<crate::model::QuestionAnsweringQualityInput>),
        /// Input for pairwise question answering quality metric.
        PairwiseQuestionAnsweringQualityInput(
            std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityInput>,
        ),
        /// Input for question answering relevance metric.
        QuestionAnsweringRelevanceInput(
            std::boxed::Box<crate::model::QuestionAnsweringRelevanceInput>,
        ),
        /// Input for question answering helpfulness
        /// metric.
        QuestionAnsweringHelpfulnessInput(
            std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessInput>,
        ),
        /// Input for question answering correctness
        /// metric.
        QuestionAnsweringCorrectnessInput(
            std::boxed::Box<crate::model::QuestionAnsweringCorrectnessInput>,
        ),
        /// Input for pointwise metric.
        PointwiseMetricInput(std::boxed::Box<crate::model::PointwiseMetricInput>),
        /// Input for pairwise metric.
        PairwiseMetricInput(std::boxed::Box<crate::model::PairwiseMetricInput>),
        /// Tool call metric instances.
        /// Input for tool call valid metric.
        ToolCallValidInput(std::boxed::Box<crate::model::ToolCallValidInput>),
        /// Input for tool name match metric.
        ToolNameMatchInput(std::boxed::Box<crate::model::ToolNameMatchInput>),
        /// Input for tool parameter key match metric.
        ToolParameterKeyMatchInput(std::boxed::Box<crate::model::ToolParameterKeyMatchInput>),
        /// Input for tool parameter key value match metric.
        ToolParameterKvMatchInput(std::boxed::Box<crate::model::ToolParameterKVMatchInput>),
        /// Translation metrics.
        /// Input for Comet metric.
        CometInput(std::boxed::Box<crate::model::CometInput>),
        /// Input for Metricx metric.
        MetricxInput(std::boxed::Box<crate::model::MetricxInput>),
    }
}

/// Response message for EvaluationService.EvaluateInstances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvaluateInstancesResponse {
    /// Evaluation results will be served in the same order as presented in
    /// EvaluationRequest.instances.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub evaluation_results:
        std::option::Option<crate::model::evaluate_instances_response::EvaluationResults>,
}

impl EvaluateInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `evaluation_results`.
    pub fn set_evaluation_results<
        T: std::convert::Into<
            std::option::Option<crate::model::evaluate_instances_response::EvaluationResults>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = v.into();
        self
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ExactMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exact_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExactMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ExactMatchResults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `BleuResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bleu_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BleuResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::BleuResults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `RougeResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rouge_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RougeResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::RougeResults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `FluencyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fluency_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FluencyResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::FluencyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `CoherenceResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_coherence_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CoherenceResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::CoherenceResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SafetyResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_safety_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SafetyResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SafetyResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `GroundednessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_groundedness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GroundednessResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::GroundednessResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `FulfillmentResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fulfillment_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FulfillmentResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::FulfillmentResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SummarizationQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_summarization_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationQualityResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PairwiseSummarizationQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pairwise_summarization_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseSummarizationQualityResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseSummarizationQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SummarizationHelpfulnessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_summarization_helpfulness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationHelpfulnessResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationHelpfulnessResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `SummarizationVerbosityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_summarization_verbosity_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationVerbosityResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationVerbosityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringQualityResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PairwiseQuestionAnsweringQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pairwise_question_answering_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseQuestionAnsweringQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringRelevanceResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_relevance_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringRelevanceResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringRelevanceResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringHelpfulnessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_helpfulness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringHelpfulnessResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `QuestionAnsweringCorrectnessResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_question_answering_correctness_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::QuestionAnsweringCorrectnessResult>>
    {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringCorrectnessResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PointwiseMetricResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pointwise_metric_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PointwiseMetricResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PointwiseMetricResult(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `PairwiseMetricResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pairwise_metric_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PairwiseMetricResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseMetricResult(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolCallValidResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_call_valid_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolCallValidResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolCallValidResults(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolNameMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_name_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolNameMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolNameMatchResults(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolParameterKeyMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_parameter_key_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKeyMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKeyMatchResults(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `ToolParameterKvMatchResults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tool_parameter_kv_match_results(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ToolParameterKVMatchResults>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKvMatchResults(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `CometResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_comet_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CometResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::CometResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// if it holds a `MetricxResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_metricx_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MetricxResult>> {
        #[allow(unreachable_patterns)]
        self.evaluation_results.as_ref().and_then(|v| match v {
            crate::model::evaluate_instances_response::EvaluationResults::MetricxResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ExactMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_exact_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ExactMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ExactMatchResults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `BleuResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_bleu_results<T: std::convert::Into<std::boxed::Box<crate::model::BleuResults>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::BleuResults(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `RougeResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_rouge_results<T: std::convert::Into<std::boxed::Box<crate::model::RougeResults>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::RougeResults(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `FluencyResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_fluency_result<
        T: std::convert::Into<std::boxed::Box<crate::model::FluencyResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::FluencyResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `CoherenceResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_coherence_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CoherenceResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::CoherenceResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SafetyResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_safety_result<T: std::convert::Into<std::boxed::Box<crate::model::SafetyResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SafetyResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `GroundednessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_groundedness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::GroundednessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::GroundednessResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `FulfillmentResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_fulfillment_result<
        T: std::convert::Into<std::boxed::Box<crate::model::FulfillmentResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::FulfillmentResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SummarizationQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_summarization_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PairwiseSummarizationQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pairwise_summarization_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseSummarizationQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseSummarizationQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SummarizationHelpfulnessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_summarization_helpfulness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationHelpfulnessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationHelpfulnessResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `SummarizationVerbosityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_summarization_verbosity_result<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationVerbosityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::SummarizationVerbosityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PairwiseQuestionAnsweringQualityResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pairwise_question_answering_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseQuestionAnsweringQualityResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringRelevanceResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_relevance_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringRelevanceResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringRelevanceResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringHelpfulnessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_helpfulness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringHelpfulnessResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `QuestionAnsweringCorrectnessResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_question_answering_correctness_result<
        T: std::convert::Into<std::boxed::Box<crate::model::QuestionAnsweringCorrectnessResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::QuestionAnsweringCorrectnessResult(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PointwiseMetricResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pointwise_metric_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PointwiseMetricResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PointwiseMetricResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `PairwiseMetricResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_pairwise_metric_result<
        T: std::convert::Into<std::boxed::Box<crate::model::PairwiseMetricResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::PairwiseMetricResult(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolCallValidResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_call_valid_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolCallValidResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolCallValidResults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolNameMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_name_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolNameMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolNameMatchResults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolParameterKeyMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_parameter_key_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKeyMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKeyMatchResults(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `ToolParameterKvMatchResults`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_tool_parameter_kv_match_results<
        T: std::convert::Into<std::boxed::Box<crate::model::ToolParameterKVMatchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::ToolParameterKvMatchResults(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `CometResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_comet_result<T: std::convert::Into<std::boxed::Box<crate::model::CometResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::CometResult(v.into()),
        );
        self
    }

    /// Sets the value of [evaluation_results][crate::model::EvaluateInstancesResponse::evaluation_results]
    /// to hold a `MetricxResult`.
    ///
    /// Note that all the setters affecting `evaluation_results` are
    /// mutually exclusive.
    pub fn set_metricx_result<
        T: std::convert::Into<std::boxed::Box<crate::model::MetricxResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_results = std::option::Option::Some(
            crate::model::evaluate_instances_response::EvaluationResults::MetricxResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EvaluateInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluateInstancesResponse"
    }
}

/// Defines additional types related to EvaluateInstancesResponse
pub mod evaluate_instances_response {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluation results will be served in the same order as presented in
    /// EvaluationRequest.instances.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EvaluationResults {
        /// Auto metric evaluation results.
        /// Results for exact match metric.
        ExactMatchResults(std::boxed::Box<crate::model::ExactMatchResults>),
        /// Results for bleu metric.
        BleuResults(std::boxed::Box<crate::model::BleuResults>),
        /// Results for rouge metric.
        RougeResults(std::boxed::Box<crate::model::RougeResults>),
        /// LLM-based metric evaluation result.
        /// General text generation metrics, applicable to other categories.
        /// Result for fluency metric.
        FluencyResult(std::boxed::Box<crate::model::FluencyResult>),
        /// Result for coherence metric.
        CoherenceResult(std::boxed::Box<crate::model::CoherenceResult>),
        /// Result for safety metric.
        SafetyResult(std::boxed::Box<crate::model::SafetyResult>),
        /// Result for groundedness metric.
        GroundednessResult(std::boxed::Box<crate::model::GroundednessResult>),
        /// Result for fulfillment metric.
        FulfillmentResult(std::boxed::Box<crate::model::FulfillmentResult>),
        /// Summarization only metrics.
        /// Result for summarization quality metric.
        SummarizationQualityResult(std::boxed::Box<crate::model::SummarizationQualityResult>),
        /// Result for pairwise summarization quality metric.
        PairwiseSummarizationQualityResult(
            std::boxed::Box<crate::model::PairwiseSummarizationQualityResult>,
        ),
        /// Result for summarization helpfulness metric.
        SummarizationHelpfulnessResult(
            std::boxed::Box<crate::model::SummarizationHelpfulnessResult>,
        ),
        /// Result for summarization verbosity metric.
        SummarizationVerbosityResult(std::boxed::Box<crate::model::SummarizationVerbosityResult>),
        /// Question answering only metrics.
        /// Result for question answering quality metric.
        QuestionAnsweringQualityResult(
            std::boxed::Box<crate::model::QuestionAnsweringQualityResult>,
        ),
        /// Result for pairwise question answering quality metric.
        PairwiseQuestionAnsweringQualityResult(
            std::boxed::Box<crate::model::PairwiseQuestionAnsweringQualityResult>,
        ),
        /// Result for question answering relevance metric.
        QuestionAnsweringRelevanceResult(
            std::boxed::Box<crate::model::QuestionAnsweringRelevanceResult>,
        ),
        /// Result for question answering helpfulness metric.
        QuestionAnsweringHelpfulnessResult(
            std::boxed::Box<crate::model::QuestionAnsweringHelpfulnessResult>,
        ),
        /// Result for question answering correctness metric.
        QuestionAnsweringCorrectnessResult(
            std::boxed::Box<crate::model::QuestionAnsweringCorrectnessResult>,
        ),
        /// Generic metrics.
        /// Result for pointwise metric.
        PointwiseMetricResult(std::boxed::Box<crate::model::PointwiseMetricResult>),
        /// Result for pairwise metric.
        PairwiseMetricResult(std::boxed::Box<crate::model::PairwiseMetricResult>),
        /// Tool call metrics.
        /// Results for tool call valid metric.
        ToolCallValidResults(std::boxed::Box<crate::model::ToolCallValidResults>),
        /// Results for tool name match metric.
        ToolNameMatchResults(std::boxed::Box<crate::model::ToolNameMatchResults>),
        /// Results for tool parameter key match  metric.
        ToolParameterKeyMatchResults(std::boxed::Box<crate::model::ToolParameterKeyMatchResults>),
        /// Results for tool parameter key value match metric.
        ToolParameterKvMatchResults(std::boxed::Box<crate::model::ToolParameterKVMatchResults>),
        /// Translation metrics.
        /// Result for Comet metric.
        CometResult(std::boxed::Box<crate::model::CometResult>),
        /// Result for Metricx metric.
        MetricxResult(std::boxed::Box<crate::model::MetricxResult>),
    }
}

/// Input for exact match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchInput {
    /// Required. Spec for exact match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ExactMatchSpec>,

    /// Required. Repeated exact match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ExactMatchInstance>,
}

impl ExactMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ExactMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExactMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ExactMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExactMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExactMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchInput"
    }
}

/// Spec for exact match instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl ExactMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ExactMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ExactMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for ExactMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchInstance"
    }
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchSpec {}

impl ExactMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExactMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchSpec"
    }
}

/// Results for exact match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchResults {
    /// Output only. Exact match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exact_match_metric_values: std::vec::Vec<crate::model::ExactMatchMetricValue>,
}

impl ExactMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exact_match_metric_values][crate::model::ExactMatchResults::exact_match_metric_values].
    pub fn set_exact_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExactMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.exact_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExactMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchResults"
    }
}

/// Exact match metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchMetricValue {
    /// Output only. Exact match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl ExactMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ExactMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for ExactMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchMetricValue"
    }
}

/// Input for bleu metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuInput {
    /// Required. Spec for bleu score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::BleuSpec>,

    /// Required. Repeated bleu instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::BleuInstance>,
}

impl BleuInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::BleuInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::BleuSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::BleuInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BleuInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BleuInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuInput"
    }
}

/// Spec for bleu instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl BleuInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::BleuInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::BleuInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for BleuInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuInstance"
    }
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to 1.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuSpec {
    /// Optional. Whether to use_effective_order to compute bleu score.
    pub use_effective_order: bool,
}

impl BleuSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_effective_order][crate::model::BleuSpec::use_effective_order].
    pub fn set_use_effective_order<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_effective_order = v.into();
        self
    }
}

impl wkt::message::Message for BleuSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuSpec"
    }
}

/// Results for bleu metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuResults {
    /// Output only. Bleu metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bleu_metric_values: std::vec::Vec<crate::model::BleuMetricValue>,
}

impl BleuResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bleu_metric_values][crate::model::BleuResults::bleu_metric_values].
    pub fn set_bleu_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BleuMetricValue>,
    {
        use std::iter::Iterator;
        self.bleu_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BleuResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuResults"
    }
}

/// Bleu metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BleuMetricValue {
    /// Output only. Bleu score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl BleuMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::BleuMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for BleuMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuMetricValue"
    }
}

/// Input for rouge metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeInput {
    /// Required. Spec for rouge score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::RougeSpec>,

    /// Required. Repeated rouge instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::RougeInstance>,
}

impl RougeInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::RougeInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::RougeSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::RougeInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RougeInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RougeInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeInput"
    }
}

/// Spec for rouge instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl RougeInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::RougeInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::RougeInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for RougeInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeInstance"
    }
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeSpec {
    /// Optional. Supported rouge types are rougen[1-9], rougeL, and rougeLsum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rouge_type: std::string::String,

    /// Optional. Whether to use stemmer to compute rouge score.
    pub use_stemmer: bool,

    /// Optional. Whether to split summaries while using rougeLsum.
    pub split_summaries: bool,
}

impl RougeSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rouge_type][crate::model::RougeSpec::rouge_type].
    pub fn set_rouge_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rouge_type = v.into();
        self
    }

    /// Sets the value of [use_stemmer][crate::model::RougeSpec::use_stemmer].
    pub fn set_use_stemmer<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_stemmer = v.into();
        self
    }

    /// Sets the value of [split_summaries][crate::model::RougeSpec::split_summaries].
    pub fn set_split_summaries<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.split_summaries = v.into();
        self
    }
}

impl wkt::message::Message for RougeSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeSpec"
    }
}

/// Results for rouge metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeResults {
    /// Output only. Rouge metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rouge_metric_values: std::vec::Vec<crate::model::RougeMetricValue>,
}

impl RougeResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rouge_metric_values][crate::model::RougeResults::rouge_metric_values].
    pub fn set_rouge_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RougeMetricValue>,
    {
        use std::iter::Iterator;
        self.rouge_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RougeResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeResults"
    }
}

/// Rouge metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RougeMetricValue {
    /// Output only. Rouge score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl RougeMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::RougeMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for RougeMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeMetricValue"
    }
}

/// Input for coherence metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceInput {
    /// Required. Spec for coherence score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::CoherenceSpec>,

    /// Required. Coherence instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::CoherenceInstance>,
}

impl CoherenceInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::CoherenceInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::CoherenceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CoherenceInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::CoherenceInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for CoherenceInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceInput"
    }
}

/// Spec for coherence instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,
}

impl CoherenceInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::CoherenceInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }
}

impl wkt::message::Message for CoherenceInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceInstance"
    }
}

/// Spec for coherence score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceSpec {
    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl CoherenceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::CoherenceSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for CoherenceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceSpec"
    }
}

/// Spec for coherence result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CoherenceResult {
    /// Output only. Coherence score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for coherence score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for coherence score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl CoherenceResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::CoherenceResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::CoherenceResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::CoherenceResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for CoherenceResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceResult"
    }
}

/// Input for fluency metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencyInput {
    /// Required. Spec for fluency score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::FluencySpec>,

    /// Required. Fluency instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::FluencyInstance>,
}

impl FluencyInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::FluencyInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::FluencySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::FluencyInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::FluencyInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for FluencyInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyInput"
    }
}

/// Spec for fluency instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencyInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,
}

impl FluencyInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::FluencyInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }
}

impl wkt::message::Message for FluencyInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyInstance"
    }
}

/// Spec for fluency score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencySpec {
    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl FluencySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::FluencySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for FluencySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencySpec"
    }
}

/// Spec for fluency result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FluencyResult {
    /// Output only. Fluency score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for fluency score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for fluency score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl FluencyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::FluencyResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::FluencyResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::FluencyResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for FluencyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyResult"
    }
}

/// Input for safety metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyInput {
    /// Required. Spec for safety metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SafetySpec>,

    /// Required. Safety instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SafetyInstance>,
}

impl SafetyInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SafetyInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::SafetySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SafetyInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SafetyInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for SafetyInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyInput"
    }
}

/// Spec for safety instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,
}

impl SafetyInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SafetyInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }
}

impl wkt::message::Message for SafetyInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyInstance"
    }
}

/// Spec for safety metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetySpec {
    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl SafetySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::SafetySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SafetySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetySpec"
    }
}

/// Spec for safety result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyResult {
    /// Output only. Safety score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for safety score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for safety score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl SafetyResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SafetyResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SafetyResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SafetyResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for SafetyResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyResult"
    }
}

/// Input for groundedness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessInput {
    /// Required. Spec for groundedness metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::GroundednessSpec>,

    /// Required. Groundedness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::GroundednessInstance>,
}

impl GroundednessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::GroundednessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::GroundednessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::GroundednessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::GroundednessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for GroundednessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessInput"
    }
}

/// Spec for groundedness instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Background information provided in context used to compare
    /// against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,
}

impl GroundednessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::GroundednessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [context][crate::model::GroundednessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }
}

impl wkt::message::Message for GroundednessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessInstance"
    }
}

/// Spec for groundedness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessSpec {
    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl GroundednessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::GroundednessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GroundednessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessSpec"
    }
}

/// Spec for groundedness result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundednessResult {
    /// Output only. Groundedness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for groundedness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for groundedness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl GroundednessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::GroundednessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::GroundednessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::GroundednessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for GroundednessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessResult"
    }
}

/// Input for fulfillment metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentInput {
    /// Required. Spec for fulfillment score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::FulfillmentSpec>,

    /// Required. Fulfillment instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::FulfillmentInstance>,
}

impl FulfillmentInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::FulfillmentInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::FulfillmentSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::FulfillmentInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::FulfillmentInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for FulfillmentInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentInput"
    }
}

/// Spec for fulfillment instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Inference instruction prompt to compare prediction with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl FulfillmentInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::FulfillmentInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::FulfillmentInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for FulfillmentInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentInstance"
    }
}

/// Spec for fulfillment metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentSpec {
    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl FulfillmentSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::FulfillmentSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for FulfillmentSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentSpec"
    }
}

/// Spec for fulfillment result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FulfillmentResult {
    /// Output only. Fulfillment score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for fulfillment score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for fulfillment score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl FulfillmentResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::FulfillmentResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::FulfillmentResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::FulfillmentResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for FulfillmentResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentResult"
    }
}

/// Input for summarization quality metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualityInput {
    /// Required. Spec for summarization quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SummarizationQualitySpec>,

    /// Required. Summarization quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SummarizationQualityInstance>,
}

impl SummarizationQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SummarizationQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SummarizationQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationQualityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityInput"
    }
}

/// Spec for summarization quality instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualityInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl SummarizationQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SummarizationQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::SummarizationQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::SummarizationQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::SummarizationQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityInstance"
    }
}

/// Spec for summarization quality score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualitySpec {
    /// Optional. Whether to use instance.reference to compute summarization
    /// quality.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl SummarizationQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::SummarizationQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualitySpec"
    }
}

/// Spec for summarization quality result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationQualityResult {
    /// Output only. Summarization Quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for summarization quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl SummarizationQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SummarizationQualityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SummarizationQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SummarizationQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityResult"
    }
}

/// Input for pairwise summarization quality metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualityInput {
    /// Required. Spec for pairwise summarization quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PairwiseSummarizationQualitySpec>,

    /// Required. Pairwise summarization quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PairwiseSummarizationQualityInstance>,
}

impl PairwiseSummarizationQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PairwiseSummarizationQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseSummarizationQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PairwiseSummarizationQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseSummarizationQualityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseSummarizationQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityInput"
    }
}

/// Spec for pairwise summarization quality instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualityInstance {
    /// Required. Output of the candidate model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Output of the baseline model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub baseline_prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl PairwiseSummarizationQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::PairwiseSummarizationQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [baseline_prediction][crate::model::PairwiseSummarizationQualityInstance::baseline_prediction].
    pub fn set_baseline_prediction<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.baseline_prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::PairwiseSummarizationQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::PairwiseSummarizationQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::PairwiseSummarizationQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseSummarizationQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityInstance"
    }
}

/// Spec for pairwise summarization quality score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualitySpec {
    /// Optional. Whether to use instance.reference to compute pairwise
    /// summarization quality.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl PairwiseSummarizationQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::PairwiseSummarizationQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PairwiseSummarizationQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseSummarizationQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualitySpec"
    }
}

/// Spec for pairwise summarization quality result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseSummarizationQualityResult {
    /// Output only. Pairwise summarization prediction choice.
    pub pairwise_choice: crate::model::PairwiseChoice,

    /// Output only. Explanation for summarization quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl PairwiseSummarizationQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pairwise_choice][crate::model::PairwiseSummarizationQualityResult::pairwise_choice].
    pub fn set_pairwise_choice<T: std::convert::Into<crate::model::PairwiseChoice>>(
        mut self,
        v: T,
    ) -> Self {
        self.pairwise_choice = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PairwiseSummarizationQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::PairwiseSummarizationQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseSummarizationQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityResult"
    }
}

/// Input for summarization helpfulness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessInput {
    /// Required. Spec for summarization helpfulness score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SummarizationHelpfulnessSpec>,

    /// Required. Summarization helpfulness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SummarizationHelpfulnessInstance>,
}

impl SummarizationHelpfulnessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SummarizationHelpfulnessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationHelpfulnessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SummarizationHelpfulnessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationHelpfulnessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationHelpfulnessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessInput"
    }
}

/// Spec for summarization helpfulness instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Optional. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl SummarizationHelpfulnessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SummarizationHelpfulnessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::SummarizationHelpfulnessInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::SummarizationHelpfulnessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::SummarizationHelpfulnessInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationHelpfulnessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessInstance"
    }
}

/// Spec for summarization helpfulness score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessSpec {
    /// Optional. Whether to use instance.reference to compute summarization
    /// helpfulness.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl SummarizationHelpfulnessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::SummarizationHelpfulnessSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationHelpfulnessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationHelpfulnessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessSpec"
    }
}

/// Spec for summarization helpfulness result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationHelpfulnessResult {
    /// Output only. Summarization Helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for summarization helpfulness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl SummarizationHelpfulnessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SummarizationHelpfulnessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SummarizationHelpfulnessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SummarizationHelpfulnessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationHelpfulnessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessResult"
    }
}

/// Input for summarization verbosity metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbosityInput {
    /// Required. Spec for summarization verbosity score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::SummarizationVerbositySpec>,

    /// Required. Summarization verbosity instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::SummarizationVerbosityInstance>,
}

impl SummarizationVerbosityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::SummarizationVerbosityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationVerbositySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SummarizationVerbosityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::SummarizationVerbosityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationVerbosityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityInput"
    }
}

/// Spec for summarization verbosity instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbosityInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to be summarized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Optional. Summarization prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl SummarizationVerbosityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::SummarizationVerbosityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::SummarizationVerbosityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::SummarizationVerbosityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::SummarizationVerbosityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationVerbosityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityInstance"
    }
}

/// Spec for summarization verbosity score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbositySpec {
    /// Optional. Whether to use instance.reference to compute summarization
    /// verbosity.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl SummarizationVerbositySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::SummarizationVerbositySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationVerbositySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationVerbositySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbositySpec"
    }
}

/// Spec for summarization verbosity result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SummarizationVerbosityResult {
    /// Output only. Summarization Verbosity score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for summarization verbosity score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for summarization verbosity score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl SummarizationVerbosityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SummarizationVerbosityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::SummarizationVerbosityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SummarizationVerbosityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for SummarizationVerbosityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityResult"
    }
}

/// Input for question answering quality metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualityInput {
    /// Required. Spec for question answering quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringQualitySpec>,

    /// Required. Question answering quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringQualityInstance>,
}

impl QuestionAnsweringQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringQualityInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityInput"
    }
}

/// Spec for question answering quality instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualityInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Question Answering prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl QuestionAnsweringQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityInstance"
    }
}

/// Spec for question answering quality score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualitySpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// quality.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl QuestionAnsweringQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualitySpec"
    }
}

/// Spec for question answering quality result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringQualityResult {
    /// Output only. Question Answering Quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl QuestionAnsweringQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringQualityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityResult"
    }
}

/// Input for pairwise question answering quality metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualityInput {
    /// Required. Spec for pairwise question answering quality score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PairwiseQuestionAnsweringQualitySpec>,

    /// Required. Pairwise question answering quality instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PairwiseQuestionAnsweringQualityInstance>,
}

impl PairwiseQuestionAnsweringQualityInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PairwiseQuestionAnsweringQualityInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseQuestionAnsweringQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PairwiseQuestionAnsweringQualityInput::instance].
    pub fn set_instance<
        T: std::convert::Into<
            std::option::Option<crate::model::PairwiseQuestionAnsweringQualityInstance>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseQuestionAnsweringQualityInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInput"
    }
}

/// Spec for pairwise question answering quality instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualityInstance {
    /// Required. Output of the candidate model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Output of the baseline model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub baseline_prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Required. Text to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. Question Answering prompt for LLM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl PairwiseQuestionAnsweringQualityInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::PairwiseQuestionAnsweringQualityInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [baseline_prediction][crate::model::PairwiseQuestionAnsweringQualityInstance::baseline_prediction].
    pub fn set_baseline_prediction<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.baseline_prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::PairwiseQuestionAnsweringQualityInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::PairwiseQuestionAnsweringQualityInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::PairwiseQuestionAnsweringQualityInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseQuestionAnsweringQualityInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInstance"
    }
}

/// Spec for pairwise question answering quality score metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualitySpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// quality.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl PairwiseQuestionAnsweringQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::PairwiseQuestionAnsweringQualitySpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::PairwiseQuestionAnsweringQualitySpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseQuestionAnsweringQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualitySpec"
    }
}

/// Spec for pairwise question answering quality result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseQuestionAnsweringQualityResult {
    /// Output only. Pairwise question answering prediction choice.
    pub pairwise_choice: crate::model::PairwiseChoice,

    /// Output only. Explanation for question answering quality score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering quality score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl PairwiseQuestionAnsweringQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pairwise_choice][crate::model::PairwiseQuestionAnsweringQualityResult::pairwise_choice].
    pub fn set_pairwise_choice<T: std::convert::Into<crate::model::PairwiseChoice>>(
        mut self,
        v: T,
    ) -> Self {
        self.pairwise_choice = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PairwiseQuestionAnsweringQualityResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::PairwiseQuestionAnsweringQualityResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseQuestionAnsweringQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityResult"
    }
}

/// Input for question answering relevance metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceInput {
    /// Required. Spec for question answering relevance score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringRelevanceSpec>,

    /// Required. Question answering relevance instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringRelevanceInstance>,
}

impl QuestionAnsweringRelevanceInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringRelevanceInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringRelevanceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringRelevanceInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringRelevanceInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringRelevanceInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInput"
    }
}

/// Spec for question answering relevance instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Text provided as context to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. The question asked and other instruction in the inference prompt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl QuestionAnsweringRelevanceInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringRelevanceInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringRelevanceInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringRelevanceInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringRelevanceInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringRelevanceInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInstance"
    }
}

/// Spec for question answering relevance metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceSpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// relevance.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl QuestionAnsweringRelevanceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringRelevanceSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringRelevanceSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringRelevanceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceSpec"
    }
}

/// Spec for question answering relevance result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringRelevanceResult {
    /// Output only. Question Answering Relevance score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering relevance score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering relevance score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl QuestionAnsweringRelevanceResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringRelevanceResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringRelevanceResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringRelevanceResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringRelevanceResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceResult"
    }
}

/// Input for question answering helpfulness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessInput {
    /// Required. Spec for question answering helpfulness score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringHelpfulnessSpec>,

    /// Required. Question answering helpfulness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringHelpfulnessInstance>,
}

impl QuestionAnsweringHelpfulnessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringHelpfulnessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringHelpfulnessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringHelpfulnessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringHelpfulnessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringHelpfulnessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInput"
    }
}

/// Spec for question answering helpfulness instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Text provided as context to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. The question asked and other instruction in the inference prompt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl QuestionAnsweringHelpfulnessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringHelpfulnessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringHelpfulnessInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringHelpfulnessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringHelpfulnessInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringHelpfulnessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInstance"
    }
}

/// Spec for question answering helpfulness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessSpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// helpfulness.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl QuestionAnsweringHelpfulnessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringHelpfulnessSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringHelpfulnessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringHelpfulnessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessSpec"
    }
}

/// Spec for question answering helpfulness result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringHelpfulnessResult {
    /// Output only. Question Answering Helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering helpfulness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering helpfulness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl QuestionAnsweringHelpfulnessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringHelpfulnessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringHelpfulnessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringHelpfulnessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringHelpfulnessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessResult"
    }
}

/// Input for question answering correctness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessInput {
    /// Required. Spec for question answering correctness score metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::QuestionAnsweringCorrectnessSpec>,

    /// Required. Question answering correctness instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::QuestionAnsweringCorrectnessInstance>,
}

impl QuestionAnsweringCorrectnessInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::QuestionAnsweringCorrectnessInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringCorrectnessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::QuestionAnsweringCorrectnessInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::QuestionAnsweringCorrectnessInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringCorrectnessInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInput"
    }
}

/// Spec for question answering correctness instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Text provided as context to answer the question.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<std::string::String>,

    /// Required. The question asked and other instruction in the inference prompt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instruction: std::option::Option<std::string::String>,
}

impl QuestionAnsweringCorrectnessInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::QuestionAnsweringCorrectnessInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::QuestionAnsweringCorrectnessInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [context][crate::model::QuestionAnsweringCorrectnessInstance::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [instruction][crate::model::QuestionAnsweringCorrectnessInstance::instruction].
    pub fn set_instruction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instruction = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringCorrectnessInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInstance"
    }
}

/// Spec for question answering correctness metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessSpec {
    /// Optional. Whether to use instance.reference to compute question answering
    /// correctness.
    pub use_reference: bool,

    /// Optional. Which version to use for evaluation.
    pub version: i32,
}

impl QuestionAnsweringCorrectnessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_reference][crate::model::QuestionAnsweringCorrectnessSpec::use_reference].
    pub fn set_use_reference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_reference = v.into();
        self
    }

    /// Sets the value of [version][crate::model::QuestionAnsweringCorrectnessSpec::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringCorrectnessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessSpec"
    }
}

/// Spec for question answering correctness result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuestionAnsweringCorrectnessResult {
    /// Output only. Question Answering Correctness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for question answering correctness score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,

    /// Output only. Confidence for question answering correctness score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidence: std::option::Option<f32>,
}

impl QuestionAnsweringCorrectnessResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::QuestionAnsweringCorrectnessResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::QuestionAnsweringCorrectnessResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::QuestionAnsweringCorrectnessResult::confidence].
    pub fn set_confidence<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for QuestionAnsweringCorrectnessResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessResult"
    }
}

/// Input for pointwise metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricInput {
    /// Required. Spec for pointwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PointwiseMetricSpec>,

    /// Required. Pointwise metric instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PointwiseMetricInstance>,
}

impl PointwiseMetricInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PointwiseMetricInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PointwiseMetricSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PointwiseMetricInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::PointwiseMetricInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for PointwiseMetricInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricInput"
    }
}

/// Pointwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricInstance {
    /// Instance for pointwise metric.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::pointwise_metric_instance::Instance>,
}

impl PointwiseMetricInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `instance`.
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::pointwise_metric_instance::Instance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// The value of [instance][crate::model::PointwiseMetricInstance::instance]
    /// if it holds a `JsonInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_json_instance(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::pointwise_metric_instance::Instance::JsonInstance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance][crate::model::PointwiseMetricInstance::instance]
    /// to hold a `JsonInstance`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_json_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::pointwise_metric_instance::Instance::JsonInstance(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PointwiseMetricInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricInstance"
    }
}

/// Defines additional types related to PointwiseMetricInstance
pub mod pointwise_metric_instance {
    #[allow(unused_imports)]
    use super::*;

    /// Instance for pointwise metric.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Instance {
        /// Instance specified as a json string. String key-value pairs are expected
        /// in the json_instance to render
        /// PointwiseMetricSpec.instance_prompt_template.
        JsonInstance(std::string::String),
    }
}

/// Spec for pointwise metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricSpec {
    /// Required. Metric prompt template for pointwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_prompt_template: std::option::Option<std::string::String>,
}

impl PointwiseMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_prompt_template][crate::model::PointwiseMetricSpec::metric_prompt_template].
    pub fn set_metric_prompt_template<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_prompt_template = v.into();
        self
    }
}

impl wkt::message::Message for PointwiseMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricSpec"
    }
}

/// Spec for pointwise metric result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PointwiseMetricResult {
    /// Output only. Pointwise metric score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,

    /// Output only. Explanation for pointwise metric score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,
}

impl PointwiseMetricResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::PointwiseMetricResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PointwiseMetricResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }
}

impl wkt::message::Message for PointwiseMetricResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricResult"
    }
}

/// Input for pairwise metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricInput {
    /// Required. Spec for pairwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::PairwiseMetricSpec>,

    /// Required. Pairwise metric instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::PairwiseMetricInstance>,
}

impl PairwiseMetricInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::PairwiseMetricInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseMetricSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::PairwiseMetricInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::PairwiseMetricInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseMetricInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricInput"
    }
}

/// Pairwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricInstance {
    /// Instance for pairwise metric.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::pairwise_metric_instance::Instance>,
}

impl PairwiseMetricInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `instance`.
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::pairwise_metric_instance::Instance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// The value of [instance][crate::model::PairwiseMetricInstance::instance]
    /// if it holds a `JsonInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_json_instance(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::pairwise_metric_instance::Instance::JsonInstance(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance][crate::model::PairwiseMetricInstance::instance]
    /// to hold a `JsonInstance`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_json_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::pairwise_metric_instance::Instance::JsonInstance(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PairwiseMetricInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricInstance"
    }
}

/// Defines additional types related to PairwiseMetricInstance
pub mod pairwise_metric_instance {
    #[allow(unused_imports)]
    use super::*;

    /// Instance for pairwise metric.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Instance {
        /// Instance specified as a json string. String key-value pairs are expected
        /// in the json_instance to render
        /// PairwiseMetricSpec.instance_prompt_template.
        JsonInstance(std::string::String),
    }
}

/// Spec for pairwise metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricSpec {
    /// Required. Metric prompt template for pairwise metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_prompt_template: std::option::Option<std::string::String>,
}

impl PairwiseMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_prompt_template][crate::model::PairwiseMetricSpec::metric_prompt_template].
    pub fn set_metric_prompt_template<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_prompt_template = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricSpec"
    }
}

/// Spec for pairwise metric result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PairwiseMetricResult {
    /// Output only. Pairwise metric choice.
    pub pairwise_choice: crate::model::PairwiseChoice,

    /// Output only. Explanation for pairwise metric score.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub explanation: std::string::String,
}

impl PairwiseMetricResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pairwise_choice][crate::model::PairwiseMetricResult::pairwise_choice].
    pub fn set_pairwise_choice<T: std::convert::Into<crate::model::PairwiseChoice>>(
        mut self,
        v: T,
    ) -> Self {
        self.pairwise_choice = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::PairwiseMetricResult::explanation].
    pub fn set_explanation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.explanation = v.into();
        self
    }
}

impl wkt::message::Message for PairwiseMetricResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricResult"
    }
}

/// Input for tool call valid metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidInput {
    /// Required. Spec for tool call valid metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolCallValidSpec>,

    /// Required. Repeated tool call valid instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolCallValidInstance>,
}

impl ToolCallValidInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolCallValidInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolCallValidSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolCallValidInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolCallValidInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolCallValidInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidInput"
    }
}

/// Spec for tool call valid metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidSpec {}

impl ToolCallValidSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ToolCallValidSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidSpec"
    }
}

/// Spec for tool call valid instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl ToolCallValidInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolCallValidInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolCallValidInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for ToolCallValidInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidInstance"
    }
}

/// Results for tool call valid metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidResults {
    /// Output only. Tool call valid metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_call_valid_metric_values: std::vec::Vec<crate::model::ToolCallValidMetricValue>,
}

impl ToolCallValidResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_call_valid_metric_values][crate::model::ToolCallValidResults::tool_call_valid_metric_values].
    pub fn set_tool_call_valid_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolCallValidMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_call_valid_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolCallValidResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidResults"
    }
}

/// Tool call valid metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolCallValidMetricValue {
    /// Output only. Tool call valid score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl ToolCallValidMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolCallValidMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for ToolCallValidMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidMetricValue"
    }
}

/// Input for tool name match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchInput {
    /// Required. Spec for tool name match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolNameMatchSpec>,

    /// Required. Repeated tool name match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolNameMatchInstance>,
}

impl ToolNameMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolNameMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolNameMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolNameMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolNameMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolNameMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchInput"
    }
}

/// Spec for tool name match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchSpec {}

impl ToolNameMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ToolNameMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchSpec"
    }
}

/// Spec for tool name match instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl ToolNameMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolNameMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolNameMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for ToolNameMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchInstance"
    }
}

/// Results for tool name match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchResults {
    /// Output only. Tool name match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_name_match_metric_values: std::vec::Vec<crate::model::ToolNameMatchMetricValue>,
}

impl ToolNameMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_name_match_metric_values][crate::model::ToolNameMatchResults::tool_name_match_metric_values].
    pub fn set_tool_name_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolNameMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_name_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolNameMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchResults"
    }
}

/// Tool name match metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolNameMatchMetricValue {
    /// Output only. Tool name match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl ToolNameMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolNameMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for ToolNameMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchMetricValue"
    }
}

/// Input for tool parameter key match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchInput {
    /// Required. Spec for tool parameter key match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolParameterKeyMatchSpec>,

    /// Required. Repeated tool parameter key match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolParameterKeyMatchInstance>,
}

impl ToolParameterKeyMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolParameterKeyMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolParameterKeyMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolParameterKeyMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKeyMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolParameterKeyMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchInput"
    }
}

/// Spec for tool parameter key match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchSpec {}

impl ToolParameterKeyMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ToolParameterKeyMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchSpec"
    }
}

/// Spec for tool parameter key match instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl ToolParameterKeyMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolParameterKeyMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolParameterKeyMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for ToolParameterKeyMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchInstance"
    }
}

/// Results for tool parameter key match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchResults {
    /// Output only. Tool parameter key match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_parameter_key_match_metric_values:
        std::vec::Vec<crate::model::ToolParameterKeyMatchMetricValue>,
}

impl ToolParameterKeyMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_parameter_key_match_metric_values][crate::model::ToolParameterKeyMatchResults::tool_parameter_key_match_metric_values].
    pub fn set_tool_parameter_key_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKeyMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_parameter_key_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolParameterKeyMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchResults"
    }
}

/// Tool parameter key match metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKeyMatchMetricValue {
    /// Output only. Tool parameter key match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl ToolParameterKeyMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolParameterKeyMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for ToolParameterKeyMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchMetricValue"
    }
}

/// Input for tool parameter key value match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchInput {
    /// Required. Spec for tool parameter key value match metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::ToolParameterKVMatchSpec>,

    /// Required. Repeated tool parameter key value match instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::ToolParameterKVMatchInstance>,
}

impl ToolParameterKVMatchInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::ToolParameterKVMatchInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::ToolParameterKVMatchSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ToolParameterKVMatchInput::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKVMatchInstance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolParameterKVMatchInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchInput"
    }
}

/// Spec for tool parameter key value match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchSpec {
    /// Optional. Whether to use STRICT string match on parameter values.
    pub use_strict_string_match: bool,
}

impl ToolParameterKVMatchSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_strict_string_match][crate::model::ToolParameterKVMatchSpec::use_strict_string_match].
    pub fn set_use_strict_string_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_strict_string_match = v.into();
        self
    }
}

impl wkt::message::Message for ToolParameterKVMatchSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchSpec"
    }
}

/// Spec for tool parameter key value match instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Required. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,
}

impl ToolParameterKVMatchInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::ToolParameterKVMatchInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::ToolParameterKVMatchInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }
}

impl wkt::message::Message for ToolParameterKVMatchInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchInstance"
    }
}

/// Results for tool parameter key value match metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchResults {
    /// Output only. Tool parameter key value match metric values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tool_parameter_kv_match_metric_values:
        std::vec::Vec<crate::model::ToolParameterKVMatchMetricValue>,
}

impl ToolParameterKVMatchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tool_parameter_kv_match_metric_values][crate::model::ToolParameterKVMatchResults::tool_parameter_kv_match_metric_values].
    pub fn set_tool_parameter_kv_match_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ToolParameterKVMatchMetricValue>,
    {
        use std::iter::Iterator;
        self.tool_parameter_kv_match_metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToolParameterKVMatchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchResults"
    }
}

/// Tool parameter key value match metric value for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolParameterKVMatchMetricValue {
    /// Output only. Tool parameter key value match score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl ToolParameterKVMatchMetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::ToolParameterKVMatchMetricValue::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for ToolParameterKVMatchMetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchMetricValue"
    }
}

/// Input for Comet metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometInput {
    /// Required. Spec for comet metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::CometSpec>,

    /// Required. Comet instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::CometInstance>,
}

impl CometInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::CometInput::metric_spec].
    pub fn set_metric_spec<T: std::convert::Into<std::option::Option<crate::model::CometSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CometInput::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::CometInstance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for CometInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometInput"
    }
}

/// Spec for Comet metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometSpec {
    /// Required. Which version to use for evaluation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::comet_spec::CometVersion>,

    /// Optional. Source language in BCP-47 format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language: std::string::String,

    /// Optional. Target language in BCP-47 format. Covers both prediction and
    /// reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language: std::string::String,
}

impl CometSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::CometSpec::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::comet_spec::CometVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [source_language][crate::model::CometSpec::source_language].
    pub fn set_source_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_language = v.into();
        self
    }

    /// Sets the value of [target_language][crate::model::CometSpec::target_language].
    pub fn set_target_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_language = v.into();
        self
    }
}

impl wkt::message::Message for CometSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometSpec"
    }
}

/// Defines additional types related to CometSpec
pub mod comet_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Comet version options.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CometVersion(std::borrow::Cow<'static, str>);

    impl CometVersion {
        /// Creates a new CometVersion instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CometVersion](CometVersion)
    pub mod comet_version {
        use super::CometVersion;

        /// Comet version unspecified.
        pub const COMET_VERSION_UNSPECIFIED: CometVersion =
            CometVersion::new("COMET_VERSION_UNSPECIFIED");

        /// Comet 22 for translation + source + reference
        /// (source-reference-combined).
        pub const COMET_22_SRC_REF: CometVersion = CometVersion::new("COMET_22_SRC_REF");
    }

    impl std::convert::From<std::string::String> for CometVersion {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Spec for Comet instance - The fields used for evaluation are dependent on the
/// comet version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Source text in original language.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<std::string::String>,
}

impl CometInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::CometInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::CometInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CometInstance::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for CometInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometInstance"
    }
}

/// Spec for Comet result - calculates the comet score for the given instance
/// using the version specified in the spec.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CometResult {
    /// Output only. Comet score. Range depends on version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl CometResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::CometResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for CometResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometResult"
    }
}

/// Input for MetricX metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxInput {
    /// Required. Spec for Metricx metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_spec: std::option::Option<crate::model::MetricxSpec>,

    /// Required. Metricx instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::MetricxInstance>,
}

impl MetricxInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_spec][crate::model::MetricxInput::metric_spec].
    pub fn set_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::MetricxSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metric_spec = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::MetricxInput::instance].
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::MetricxInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }
}

impl wkt::message::Message for MetricxInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxInput"
    }
}

/// Spec for MetricX metric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxSpec {
    /// Required. Which version to use for evaluation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::metricx_spec::MetricxVersion>,

    /// Optional. Source language in BCP-47 format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language: std::string::String,

    /// Optional. Target language in BCP-47 format. Covers both prediction and
    /// reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language: std::string::String,
}

impl MetricxSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::MetricxSpec::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::metricx_spec::MetricxVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [source_language][crate::model::MetricxSpec::source_language].
    pub fn set_source_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_language = v.into();
        self
    }

    /// Sets the value of [target_language][crate::model::MetricxSpec::target_language].
    pub fn set_target_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_language = v.into();
        self
    }
}

impl wkt::message::Message for MetricxSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxSpec"
    }
}

/// Defines additional types related to MetricxSpec
pub mod metricx_spec {
    #[allow(unused_imports)]
    use super::*;

    /// MetricX Version options.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MetricxVersion(std::borrow::Cow<'static, str>);

    impl MetricxVersion {
        /// Creates a new MetricxVersion instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [MetricxVersion](MetricxVersion)
    pub mod metricx_version {
        use super::MetricxVersion;

        /// MetricX version unspecified.
        pub const METRICX_VERSION_UNSPECIFIED: MetricxVersion =
            MetricxVersion::new("METRICX_VERSION_UNSPECIFIED");

        /// MetricX 2024 (2.6) for translation + reference (reference-based).
        pub const METRICX_24_REF: MetricxVersion = MetricxVersion::new("METRICX_24_REF");

        /// MetricX 2024 (2.6) for translation + source (QE).
        pub const METRICX_24_SRC: MetricxVersion = MetricxVersion::new("METRICX_24_SRC");

        /// MetricX 2024 (2.6) for translation + source + reference
        /// (source-reference-combined).
        pub const METRICX_24_SRC_REF: MetricxVersion = MetricxVersion::new("METRICX_24_SRC_REF");
    }

    impl std::convert::From<std::string::String> for MetricxVersion {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Spec for MetricX instance - The fields used for evaluation are dependent on
/// the MetricX version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxInstance {
    /// Required. Output of the evaluated model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction: std::option::Option<std::string::String>,

    /// Optional. Ground truth used to compare against the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<std::string::String>,

    /// Optional. Source text in original language.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<std::string::String>,
}

impl MetricxInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction][crate::model::MetricxInstance::prediction].
    pub fn set_prediction<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction = v.into();
        self
    }

    /// Sets the value of [reference][crate::model::MetricxInstance::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [source][crate::model::MetricxInstance::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for MetricxInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxInstance"
    }
}

/// Spec for MetricX result - calculates the MetricX score for the given instance
/// using the version specified in the spec.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricxResult {
    /// Output only. MetricX score. Range depends on version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl MetricxResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::MetricxResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for MetricxResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxResult"
    }
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Required. The relative resource name of the Artifact in the Event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact: std::string::String,

    /// Output only. The relative resource name of the Execution in the Event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,

    /// Output only. Time the Event occurred.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_time: std::option::Option<wkt::Timestamp>,

    /// Required. The type of the Event.
    #[serde(rename = "type")]
    pub r#type: crate::model::event::Type,

    /// The labels with user-defined metadata to annotate Events.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Event (System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact][crate::model::Event::artifact].
    pub fn set_artifact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::Event::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::Event::event_time].
    pub fn set_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Event::type].
    pub fn set_type<T: std::convert::Into<crate::model::event::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Event::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Event"
    }
}

/// Defines additional types related to Event
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Describes whether an Event's Artifact is the Execution's input or output.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::borrow::Cow<'static, str>);

    impl Type {
        /// Creates a new Type instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// Unspecified whether input or output of the Execution.
        pub const TYPE_UNSPECIFIED: Type = Type::new("TYPE_UNSPECIFIED");

        /// An input of the Execution.
        pub const INPUT: Type = Type::new("INPUT");

        /// An output of the Execution.
        pub const OUTPUT: Type = Type::new("OUTPUT");
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Instance of a general execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Execution {
    /// Output only. The resource name of the Execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name of the Execution.
    /// May be up to 128 Unicode characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The state of this Execution. This is a property of the Execution, and does
    /// not imply or capture any ongoing process. This property is managed by
    /// clients (such as Vertex AI Pipelines) and the system does not prescribe
    /// or check the validity of state transitions.
    pub state: crate::model::execution::State,

    /// An eTag used to perform consistent read-modify-write updates. If not set, a
    /// blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Executions.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Execution (System
    /// labels are excluded).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Execution was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Execution was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The title of the schema describing the metadata.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_title: std::string::String,

    /// The version of the schema in `schema_title` to use.
    ///
    /// Schema title and version is expected to be registered in earlier Create
    /// Schema calls. And both are used together as unique identifiers to identify
    /// schemas within the local metadata store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Properties of the Execution.
    /// Top level metadata keys' heading and trailing spaces will be trimmed.
    /// The size of this field should not exceed 200KB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Struct>,

    /// Description of the Execution
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl Execution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Execution::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Execution::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Execution::state].
    pub fn set_state<T: std::convert::Into<crate::model::execution::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Execution::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Execution::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Execution::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [schema_title][crate::model::Execution::schema_title].
    pub fn set_schema_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_title = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::Execution::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Execution::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Execution::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Execution::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Execution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Execution"
    }
}

/// Defines additional types related to Execution
pub mod execution {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the state of the Execution.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified Execution state
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The Execution is new
        pub const NEW: State = State::new("NEW");

        /// The Execution is running
        pub const RUNNING: State = State::new("RUNNING");

        /// The Execution has finished running
        pub const COMPLETE: State = State::new("COMPLETE");

        /// The Execution has failed
        pub const FAILED: State = State::new("FAILED");

        /// The Execution completed through Cache hit.
        pub const CACHED: State = State::new("CACHED");

        /// The Execution was cancelled.
        pub const CANCELLED: State = State::new("CANCELLED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Explanation of a prediction (provided in
/// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions])
/// produced by the Model on a given
/// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances].
///
/// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
/// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Explanation {
    /// Output only. Feature attributions grouped by predicted outputs.
    ///
    /// For Models that predict only one output, such as regression Models that
    /// predict only one score, there is only one attibution that explains the
    /// predicted output. For Models that predict multiple outputs, such as
    /// multiclass Models that predict multiple classes, each element explains one
    /// specific item.
    /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// can be used to identify which output this attribution is explaining.
    ///
    /// By default, we provide Shapley values for the predicted class. However,
    /// you can configure the explanation request to generate Shapley values for
    /// any other classes too. For example, if a model predicts a probability of
    /// `0.4` for approving a loan application, the model's decision is to reject
    /// the application since `p(reject) = 0.6 > p(approve) = 0.4`, and the default
    /// Shapley values would be computed for rejection decision and not approval,
    /// even though the latter might be the positive class.
    ///
    /// If users set
    /// [ExplanationParameters.top_k][google.cloud.aiplatform.v1.ExplanationParameters.top_k],
    /// the attributions are sorted by
    /// [instance_output_value][google.cloud.aiplatform.v1.Attribution.instance_output_value]
    /// in descending order. If
    /// [ExplanationParameters.output_indices][google.cloud.aiplatform.v1.ExplanationParameters.output_indices]
    /// is specified, the attributions are stored by
    /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// in the same order as they appear in the output_indices.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.instance_output_value]: crate::model::Attribution::instance_output_value
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationParameters.output_indices]: crate::model::ExplanationParameters::output_indices
    /// [google.cloud.aiplatform.v1.ExplanationParameters.top_k]: crate::model::ExplanationParameters::top_k
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attributions: std::vec::Vec<crate::model::Attribution>,

    /// Output only. List of the nearest neighbors for example-based explanations.
    ///
    /// For models deployed with the examples explanations feature enabled, the
    /// attributions field is empty and instead the neighbors field is populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub neighbors: std::vec::Vec<crate::model::Neighbor>,
}

impl Explanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributions][crate::model::Explanation::attributions].
    pub fn set_attributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attribution>,
    {
        use std::iter::Iterator;
        self.attributions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [neighbors][crate::model::Explanation::neighbors].
    pub fn set_neighbors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Neighbor>,
    {
        use std::iter::Iterator;
        self.neighbors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Explanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Explanation"
    }
}

/// Aggregated explanation metrics for a Model over a set of instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelExplanation {
    /// Output only. Aggregated attributions explaining the Model's prediction
    /// outputs over the set of instances. The attributions are grouped by outputs.
    ///
    /// For Models that predict only one output, such as regression Models that
    /// predict only one score, there is only one attibution that explains the
    /// predicted output. For Models that predict multiple outputs, such as
    /// multiclass Models that predict multiple classes, each element explains one
    /// specific item.
    /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// can be used to identify which output this attribution is explaining.
    ///
    /// The
    /// [baselineOutputValue][google.cloud.aiplatform.v1.Attribution.baseline_output_value],
    /// [instanceOutputValue][google.cloud.aiplatform.v1.Attribution.instance_output_value]
    /// and
    /// [featureAttributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// fields are averaged over the test data.
    ///
    /// NOTE: Currently AutoML tabular classification Models produce only one
    /// attribution, which averages attributions over all the classes it predicts.
    /// [Attribution.approximation_error][google.cloud.aiplatform.v1.Attribution.approximation_error]
    /// is not populated.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.approximation_error]: crate::model::Attribution::approximation_error
    /// [google.cloud.aiplatform.v1.Attribution.baseline_output_value]: crate::model::Attribution::baseline_output_value
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    /// [google.cloud.aiplatform.v1.Attribution.instance_output_value]: crate::model::Attribution::instance_output_value
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mean_attributions: std::vec::Vec<crate::model::Attribution>,
}

impl ModelExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mean_attributions][crate::model::ModelExplanation::mean_attributions].
    pub fn set_mean_attributions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attribution>,
    {
        use std::iter::Iterator;
        self.mean_attributions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModelExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelExplanation"
    }
}

/// Attribution that explains a particular prediction output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Attribution {
    /// Output only. Model predicted output if the input instance is constructed
    /// from the baselines of all the features defined in
    /// [ExplanationMetadata.inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    /// The field name of the output is determined by the key in
    /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
    ///
    /// If the Model's predicted output has multiple dimensions (rank > 1), this is
    /// the value in the output located by
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index].
    ///
    /// If there are multiple baselines, their output values are averaged.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.outputs]: crate::model::ExplanationMetadata::outputs
    pub baseline_output_value: f64,

    /// Output only. Model predicted output on the corresponding [explanation
    /// instance][ExplainRequest.instances]. The field name of the output is
    /// determined by the key in
    /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
    ///
    /// If the Model predicted output has multiple dimensions, this is the value in
    /// the output located by
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index].
    ///
    /// [ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.outputs]: crate::model::ExplanationMetadata::outputs
    pub instance_output_value: f64,

    /// Output only. Attributions of each explained feature. Features are extracted
    /// from the [prediction
    /// instances][google.cloud.aiplatform.v1.ExplainRequest.instances] according
    /// to [explanation metadata for
    /// inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    ///
    /// The value is a struct, whose keys are the name of the feature. The values
    /// are how much the feature in the
    /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances] contributed
    /// to the predicted result.
    ///
    /// The format of the value is determined by the feature's input format:
    ///
    /// * If the feature is a scalar value, the attribution value is a
    ///   [floating number][google.protobuf.Value.number_value].
    ///
    /// * If the feature is an array of scalar values, the attribution value is
    ///   an [array][google.protobuf.Value.list_value].
    ///
    /// * If the feature is a struct, the attribution value is a
    ///   [struct][google.protobuf.Value.struct_value]. The keys in the
    ///   attribution value struct are the same as the keys in the feature
    ///   struct. The formats of the values in the attribution struct are
    ///   determined by the formats of the values in the feature struct.
    ///
    ///
    /// The
    /// [ExplanationMetadata.feature_attributions_schema_uri][google.cloud.aiplatform.v1.ExplanationMetadata.feature_attributions_schema_uri]
    /// field, pointed to by the
    /// [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] field of the
    /// [Endpoint.deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
    /// object, points to the schema file that describes the features and their
    /// attribution values (if it is populated).
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.deployed_models]: crate::model::Endpoint::deployed_models
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.feature_attributions_schema_uri]: crate::model::ExplanationMetadata::feature_attributions_schema_uri
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    /// [google.cloud.aiplatform.v1.ExplanationSpec]: crate::model::ExplanationSpec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_attributions: std::option::Option<wkt::Value>,

    /// Output only. The index that locates the explained prediction output.
    ///
    /// If the prediction output is a scalar value, output_index is not populated.
    /// If the prediction output has multiple dimensions, the length of the
    /// output_index list is the same as the number of dimensions of the output.
    /// The i-th element in output_index is the element index of the i-th dimension
    /// of the output vector. Indices start from 0.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub output_index: std::vec::Vec<i32>,

    /// Output only. The display name of the output identified by
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index]. For
    /// example, the predicted class name by a multi-classification Model.
    ///
    /// This field is only populated iff the Model predicts display names as a
    /// separate field along with the explained output. The predicted display name
    /// must has the same shape of the explained output, and can be located using
    /// output_index.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_display_name: std::string::String,

    /// Output only. Error of
    /// [feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// caused by approximation used in the explanation method. Lower value means
    /// more precise attributions.
    ///
    /// * For Sampled Shapley
    ///   [attribution][google.cloud.aiplatform.v1.ExplanationParameters.sampled_shapley_attribution],
    ///   increasing
    ///   [path_count][google.cloud.aiplatform.v1.SampledShapleyAttribution.path_count]
    ///   might reduce the error.
    /// * For Integrated Gradients
    ///   [attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution],
    ///   increasing
    ///   [step_count][google.cloud.aiplatform.v1.IntegratedGradientsAttribution.step_count]
    ///   might reduce the error.
    /// * For [XRAI
    ///   attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution],
    ///   increasing
    ///   [step_count][google.cloud.aiplatform.v1.XraiAttribution.step_count] might
    ///   reduce the error.
    ///
    /// See [this introduction](/vertex-ai/docs/explainable-ai/overview)
    /// for more information.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
    /// [google.cloud.aiplatform.v1.ExplanationParameters.sampled_shapley_attribution]: crate::model::ExplanationParameters::method
    /// [google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]: crate::model::ExplanationParameters::method
    /// [google.cloud.aiplatform.v1.IntegratedGradientsAttribution.step_count]: crate::model::IntegratedGradientsAttribution::step_count
    /// [google.cloud.aiplatform.v1.SampledShapleyAttribution.path_count]: crate::model::SampledShapleyAttribution::path_count
    /// [google.cloud.aiplatform.v1.XraiAttribution.step_count]: crate::model::XraiAttribution::step_count
    pub approximation_error: f64,

    /// Output only. Name of the explain output. Specified as the key in
    /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.outputs]: crate::model::ExplanationMetadata::outputs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_name: std::string::String,
}

impl Attribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [baseline_output_value][crate::model::Attribution::baseline_output_value].
    pub fn set_baseline_output_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.baseline_output_value = v.into();
        self
    }

    /// Sets the value of [instance_output_value][crate::model::Attribution::instance_output_value].
    pub fn set_instance_output_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.instance_output_value = v.into();
        self
    }

    /// Sets the value of [feature_attributions][crate::model::Attribution::feature_attributions].
    pub fn set_feature_attributions<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_attributions = v.into();
        self
    }

    /// Sets the value of [output_display_name][crate::model::Attribution::output_display_name].
    pub fn set_output_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_display_name = v.into();
        self
    }

    /// Sets the value of [approximation_error][crate::model::Attribution::approximation_error].
    pub fn set_approximation_error<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.approximation_error = v.into();
        self
    }

    /// Sets the value of [output_name][crate::model::Attribution::output_name].
    pub fn set_output_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_name = v.into();
        self
    }

    /// Sets the value of [output_index][crate::model::Attribution::output_index].
    pub fn set_output_index<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.output_index = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Attribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Attribution"
    }
}

/// Neighbors for example-based explanations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Neighbor {
    /// Output only. The neighbor id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub neighbor_id: std::string::String,

    /// Output only. The neighbor distance.
    pub neighbor_distance: f64,
}

impl Neighbor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_id][crate::model::Neighbor::neighbor_id].
    pub fn set_neighbor_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.neighbor_id = v.into();
        self
    }

    /// Sets the value of [neighbor_distance][crate::model::Neighbor::neighbor_distance].
    pub fn set_neighbor_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.neighbor_distance = v.into();
        self
    }
}

impl wkt::message::Message for Neighbor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Neighbor"
    }
}

/// Specification of Model explanation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationSpec {
    /// Required. Parameters that configure explaining of the Model's predictions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::ExplanationParameters>,

    /// Optional. Metadata describing the Model's input and output for explanation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::ExplanationMetadata>,
}

impl ExplanationSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::ExplanationSpec::parameters].
    pub fn set_parameters<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ExplanationSpec::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }
}

impl wkt::message::Message for ExplanationSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationSpec"
    }
}

/// Parameters to configure explaining for Model's predictions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationParameters {
    /// If populated, returns attributions for top K indices of outputs
    /// (defaults to 1). Only applies to Models that predicts more than one outputs
    /// (e,g, multi-class Models). When set to -1, returns explanations for all
    /// outputs.
    pub top_k: i32,

    /// If populated, only returns attributions that have
    /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index]
    /// contained in output_indices. It must be an ndarray of integers, with the
    /// same shape of the output it's explaining.
    ///
    /// If not populated, returns attributions for
    /// [top_k][google.cloud.aiplatform.v1.ExplanationParameters.top_k] indices of
    /// outputs. If neither top_k nor output_indices is populated, returns the
    /// argmax index of the outputs.
    ///
    /// Only applicable to Models that predict multiple outputs (e,g, multi-class
    /// Models that predict multiple classes).
    ///
    /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
    /// [google.cloud.aiplatform.v1.ExplanationParameters.top_k]: crate::model::ExplanationParameters::top_k
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_indices: std::option::Option<wkt::ListValue>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub method: std::option::Option<crate::model::explanation_parameters::Method>,
}

impl ExplanationParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top_k][crate::model::ExplanationParameters::top_k].
    pub fn set_top_k<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top_k = v.into();
        self
    }

    /// Sets the value of [output_indices][crate::model::ExplanationParameters::output_indices].
    pub fn set_output_indices<T: std::convert::Into<std::option::Option<wkt::ListValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_indices = v.into();
        self
    }

    /// Sets the value of `method`.
    pub fn set_method<
        T: std::convert::Into<std::option::Option<crate::model::explanation_parameters::Method>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = v.into();
        self
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `SampledShapleyAttribution`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sampled_shapley_attribution(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SampledShapleyAttribution>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::SampledShapleyAttribution(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `IntegratedGradientsAttribution`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_integrated_gradients_attribution(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntegratedGradientsAttribution>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::IntegratedGradientsAttribution(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `XraiAttribution`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_xrai_attribution(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::XraiAttribution>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::XraiAttribution(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [method][crate::model::ExplanationParameters::method]
    /// if it holds a `Examples`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_examples(&self) -> std::option::Option<&std::boxed::Box<crate::model::Examples>> {
        #[allow(unreachable_patterns)]
        self.method.as_ref().and_then(|v| match v {
            crate::model::explanation_parameters::Method::Examples(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `SampledShapleyAttribution`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_sampled_shapley_attribution<
        T: std::convert::Into<std::boxed::Box<crate::model::SampledShapleyAttribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::SampledShapleyAttribution(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `IntegratedGradientsAttribution`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_integrated_gradients_attribution<
        T: std::convert::Into<std::boxed::Box<crate::model::IntegratedGradientsAttribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::IntegratedGradientsAttribution(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `XraiAttribution`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_xrai_attribution<
        T: std::convert::Into<std::boxed::Box<crate::model::XraiAttribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::XraiAttribution(v.into()),
        );
        self
    }

    /// Sets the value of [method][crate::model::ExplanationParameters::method]
    /// to hold a `Examples`.
    ///
    /// Note that all the setters affecting `method` are
    /// mutually exclusive.
    pub fn set_examples<T: std::convert::Into<std::boxed::Box<crate::model::Examples>>>(
        mut self,
        v: T,
    ) -> Self {
        self.method = std::option::Option::Some(
            crate::model::explanation_parameters::Method::Examples(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExplanationParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationParameters"
    }
}

/// Defines additional types related to ExplanationParameters
pub mod explanation_parameters {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Method {
        /// An attribution method that approximates Shapley values for features that
        /// contribute to the label being predicted. A sampling strategy is used to
        /// approximate the value rather than considering all subsets of features.
        /// Refer to this paper for model details: <https://arxiv.org/abs/1306.4265>.
        SampledShapleyAttribution(std::boxed::Box<crate::model::SampledShapleyAttribution>),
        /// An attribution method that computes Aumann-Shapley values taking
        /// advantage of the model's fully differentiable structure. Refer to this
        /// paper for more details: <https://arxiv.org/abs/1703.01365>
        IntegratedGradientsAttribution(
            std::boxed::Box<crate::model::IntegratedGradientsAttribution>,
        ),
        /// An attribution method that redistributes Integrated Gradients
        /// attribution to segmented regions, taking advantage of the model's fully
        /// differentiable structure. Refer to this paper for
        /// more details: <https://arxiv.org/abs/1906.02825>
        ///
        /// XRAI currently performs better on natural images, like a picture of a
        /// house or an animal. If the images are taken in artificial environments,
        /// like a lab or manufacturing line, or from diagnostic equipment, like
        /// x-rays or quality-control cameras, use Integrated Gradients instead.
        XraiAttribution(std::boxed::Box<crate::model::XraiAttribution>),
        /// Example-based explanations that returns the nearest neighbors from the
        /// provided dataset.
        Examples(std::boxed::Box<crate::model::Examples>),
    }
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted. A sampling strategy is used to
/// approximate the value rather than considering all subsets of features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SampledShapleyAttribution {
    /// Required. The number of feature permutations to consider when approximating
    /// the Shapley values.
    ///
    /// Valid range of its value is [1, 50], inclusively.
    pub path_count: i32,
}

impl SampledShapleyAttribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path_count][crate::model::SampledShapleyAttribution::path_count].
    pub fn set_path_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.path_count = v.into();
        self
    }
}

impl wkt::message::Message for SampledShapleyAttribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SampledShapleyAttribution"
    }
}

/// An attribution method that computes the Aumann-Shapley value taking advantage
/// of the model's fully differentiable structure. Refer to this paper for
/// more details: <https://arxiv.org/abs/1703.01365>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IntegratedGradientsAttribution {
    /// Required. The number of steps for approximating the path integral.
    /// A good value to start is 50 and gradually increase until the
    /// sum to diff property is within the desired error range.
    ///
    /// Valid range of its value is [1, 100], inclusively.
    pub step_count: i32,

    /// Config for SmoothGrad approximation of gradients.
    ///
    /// When enabled, the gradients are approximated by averaging the gradients
    /// from noisy samples in the vicinity of the inputs. Adding
    /// noise can help improve the computed gradients. Refer to this paper for more
    /// details: <https://arxiv.org/pdf/1706.03825.pdf>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub smooth_grad_config: std::option::Option<crate::model::SmoothGradConfig>,

    /// Config for IG with blur baseline.
    ///
    /// When enabled, a linear path from the maximally blurred image to the input
    /// image is created. Using a blurred baseline instead of zero (black image) is
    /// motivated by the BlurIG approach explained here:
    /// <https://arxiv.org/abs/2004.03383>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blur_baseline_config: std::option::Option<crate::model::BlurBaselineConfig>,
}

impl IntegratedGradientsAttribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_count][crate::model::IntegratedGradientsAttribution::step_count].
    pub fn set_step_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.step_count = v.into();
        self
    }

    /// Sets the value of [smooth_grad_config][crate::model::IntegratedGradientsAttribution::smooth_grad_config].
    pub fn set_smooth_grad_config<
        T: std::convert::Into<std::option::Option<crate::model::SmoothGradConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.smooth_grad_config = v.into();
        self
    }

    /// Sets the value of [blur_baseline_config][crate::model::IntegratedGradientsAttribution::blur_baseline_config].
    pub fn set_blur_baseline_config<
        T: std::convert::Into<std::option::Option<crate::model::BlurBaselineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.blur_baseline_config = v.into();
        self
    }
}

impl wkt::message::Message for IntegratedGradientsAttribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IntegratedGradientsAttribution"
    }
}

/// An explanation method that redistributes Integrated Gradients
/// attributions to segmented regions, taking advantage of the model's fully
/// differentiable structure. Refer to this paper for more details:
/// <https://arxiv.org/abs/1906.02825>
///
/// Supported only by image Models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct XraiAttribution {
    /// Required. The number of steps for approximating the path integral.
    /// A good value to start is 50 and gradually increase until the
    /// sum to diff property is met within the desired error range.
    ///
    /// Valid range of its value is [1, 100], inclusively.
    pub step_count: i32,

    /// Config for SmoothGrad approximation of gradients.
    ///
    /// When enabled, the gradients are approximated by averaging the gradients
    /// from noisy samples in the vicinity of the inputs. Adding
    /// noise can help improve the computed gradients. Refer to this paper for more
    /// details: <https://arxiv.org/pdf/1706.03825.pdf>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub smooth_grad_config: std::option::Option<crate::model::SmoothGradConfig>,

    /// Config for XRAI with blur baseline.
    ///
    /// When enabled, a linear path from the maximally blurred image to the input
    /// image is created. Using a blurred baseline instead of zero (black image) is
    /// motivated by the BlurIG approach explained here:
    /// <https://arxiv.org/abs/2004.03383>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blur_baseline_config: std::option::Option<crate::model::BlurBaselineConfig>,
}

impl XraiAttribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_count][crate::model::XraiAttribution::step_count].
    pub fn set_step_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.step_count = v.into();
        self
    }

    /// Sets the value of [smooth_grad_config][crate::model::XraiAttribution::smooth_grad_config].
    pub fn set_smooth_grad_config<
        T: std::convert::Into<std::option::Option<crate::model::SmoothGradConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.smooth_grad_config = v.into();
        self
    }

    /// Sets the value of [blur_baseline_config][crate::model::XraiAttribution::blur_baseline_config].
    pub fn set_blur_baseline_config<
        T: std::convert::Into<std::option::Option<crate::model::BlurBaselineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.blur_baseline_config = v.into();
        self
    }
}

impl wkt::message::Message for XraiAttribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.XraiAttribution"
    }
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// <https://arxiv.org/pdf/1706.03825.pdf>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SmoothGradConfig {
    /// The number of gradient samples to use for
    /// approximation. The higher this number, the more accurate the gradient
    /// is, but the runtime complexity increases by this factor as well.
    /// Valid range of its value is [1, 50]. Defaults to 3.
    pub noisy_sample_count: i32,

    /// Represents the standard deviation of the gaussian kernel
    /// that will be used to add noise to the interpolated inputs
    /// prior to computing gradients.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub gradient_noise_sigma:
        std::option::Option<crate::model::smooth_grad_config::GradientNoiseSigma>,
}

impl SmoothGradConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noisy_sample_count][crate::model::SmoothGradConfig::noisy_sample_count].
    pub fn set_noisy_sample_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.noisy_sample_count = v.into();
        self
    }

    /// Sets the value of `gradient_noise_sigma`.
    pub fn set_gradient_noise_sigma<
        T: std::convert::Into<
            std::option::Option<crate::model::smooth_grad_config::GradientNoiseSigma>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gradient_noise_sigma = v.into();
        self
    }

    /// The value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// if it holds a `NoiseSigma`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_noise_sigma(&self) -> std::option::Option<&f32> {
        #[allow(unreachable_patterns)]
        self.gradient_noise_sigma.as_ref().and_then(|v| match v {
            crate::model::smooth_grad_config::GradientNoiseSigma::NoiseSigma(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// if it holds a `FeatureNoiseSigma`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_feature_noise_sigma(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureNoiseSigma>> {
        #[allow(unreachable_patterns)]
        self.gradient_noise_sigma.as_ref().and_then(|v| match v {
            crate::model::smooth_grad_config::GradientNoiseSigma::FeatureNoiseSigma(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// to hold a `NoiseSigma`.
    ///
    /// Note that all the setters affecting `gradient_noise_sigma` are
    /// mutually exclusive.
    pub fn set_noise_sigma<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.gradient_noise_sigma = std::option::Option::Some(
            crate::model::smooth_grad_config::GradientNoiseSigma::NoiseSigma(v.into()),
        );
        self
    }

    /// Sets the value of [gradient_noise_sigma][crate::model::SmoothGradConfig::gradient_noise_sigma]
    /// to hold a `FeatureNoiseSigma`.
    ///
    /// Note that all the setters affecting `gradient_noise_sigma` are
    /// mutually exclusive.
    pub fn set_feature_noise_sigma<
        T: std::convert::Into<std::boxed::Box<crate::model::FeatureNoiseSigma>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gradient_noise_sigma = std::option::Option::Some(
            crate::model::smooth_grad_config::GradientNoiseSigma::FeatureNoiseSigma(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SmoothGradConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SmoothGradConfig"
    }
}

/// Defines additional types related to SmoothGradConfig
pub mod smooth_grad_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the standard deviation of the gaussian kernel
    /// that will be used to add noise to the interpolated inputs
    /// prior to computing gradients.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GradientNoiseSigma {
        /// This is a single float value and will be used to add noise to all the
        /// features. Use this field when all features are normalized to have the
        /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
        /// features are normalized to have 0-mean and 1-variance. Learn more about
        /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
        ///
        /// For best results the recommended value is about 10% - 20% of the standard
        /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
        /// paper: <https://arxiv.org/pdf/1706.03825.pdf>. Defaults to 0.1.
        ///
        /// If the distribution is different per feature, set
        /// [feature_noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.feature_noise_sigma]
        /// instead for each feature.
        ///
        /// [google.cloud.aiplatform.v1.SmoothGradConfig.feature_noise_sigma]: crate::model::SmoothGradConfig::gradient_noise_sigma
        NoiseSigma(f32),
        /// This is similar to
        /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma],
        /// but provides additional flexibility. A separate noise sigma can be
        /// provided for each feature, which is useful if their distributions are
        /// different. No noise is added to features that are not set. If this field
        /// is unset,
        /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
        /// will be used for all features.
        ///
        /// [google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]: crate::model::SmoothGradConfig::gradient_noise_sigma
        FeatureNoiseSigma(std::boxed::Box<crate::model::FeatureNoiseSigma>),
    }
}

/// Noise sigma by features. Noise sigma represents the standard deviation of the
/// gaussian kernel that will be used to add noise to interpolated inputs prior
/// to computing gradients.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureNoiseSigma {
    /// Noise sigma per feature. No noise is added to features that are not set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub noise_sigma: std::vec::Vec<crate::model::feature_noise_sigma::NoiseSigmaForFeature>,
}

impl FeatureNoiseSigma {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [noise_sigma][crate::model::FeatureNoiseSigma::noise_sigma].
    pub fn set_noise_sigma<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::feature_noise_sigma::NoiseSigmaForFeature>,
    {
        use std::iter::Iterator;
        self.noise_sigma = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FeatureNoiseSigma {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureNoiseSigma"
    }
}

/// Defines additional types related to FeatureNoiseSigma
pub mod feature_noise_sigma {
    #[allow(unused_imports)]
    use super::*;

    /// Noise sigma for a single feature.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NoiseSigmaForFeature {
        /// The name of the input feature for which noise sigma is provided. The
        /// features are defined in
        /// [explanation metadata
        /// inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
        ///
        /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// This represents the standard deviation of the Gaussian kernel that will
        /// be used to add noise to the feature prior to computing gradients. Similar
        /// to [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
        /// but represents the noise added to the current feature. Defaults to 0.1.
        ///
        /// [google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]: crate::model::SmoothGradConfig::gradient_noise_sigma
        pub sigma: f32,
    }

    impl NoiseSigmaForFeature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::feature_noise_sigma::NoiseSigmaForFeature::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [sigma][crate::model::feature_noise_sigma::NoiseSigmaForFeature::sigma].
        pub fn set_sigma<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.sigma = v.into();
            self
        }
    }

    impl wkt::message::Message for NoiseSigmaForFeature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureNoiseSigma.NoiseSigmaForFeature"
        }
    }
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// <https://arxiv.org/abs/2004.03383>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BlurBaselineConfig {
    /// The standard deviation of the blur kernel for the blurred baseline. The
    /// same blurring parameter is used for both the height and the width
    /// dimension. If not set, the method defaults to the zero (i.e. black for
    /// images) baseline.
    pub max_blur_sigma: f32,
}

impl BlurBaselineConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_blur_sigma][crate::model::BlurBaselineConfig::max_blur_sigma].
    pub fn set_max_blur_sigma<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.max_blur_sigma = v.into();
        self
    }
}

impl wkt::message::Message for BlurBaselineConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BlurBaselineConfig"
    }
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Examples {
    /// The number of neighbors to return when querying for examples.
    pub neighbor_count: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::examples::Source>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::examples::Config>,
}

impl Examples {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_count][crate::model::Examples::neighbor_count].
    pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.neighbor_count = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::examples::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Examples::source]
    /// if it holds a `ExampleGcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_example_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::examples::ExampleGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::examples::Source::ExampleGcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Examples::source]
    /// to hold a `ExampleGcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_example_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::examples::ExampleGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::examples::Source::ExampleGcsSource(v.into()));
        self
    }

    /// Sets the value of `config`.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::examples::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::Examples::config]
    /// if it holds a `NearestNeighborSearchConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_nearest_neighbor_search_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Value>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::examples::Config::NearestNeighborSearchConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [config][crate::model::Examples::config]
    /// if it holds a `Presets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_presets(&self) -> std::option::Option<&std::boxed::Box<crate::model::Presets>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::examples::Config::Presets(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Examples::config]
    /// to hold a `NearestNeighborSearchConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_nearest_neighbor_search_config<
        T: std::convert::Into<std::boxed::Box<wkt::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::examples::Config::NearestNeighborSearchConfig(v.into()),
        );
        self
    }

    /// Sets the value of [config][crate::model::Examples::config]
    /// to hold a `Presets`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_presets<T: std::convert::Into<std::boxed::Box<crate::model::Presets>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(crate::model::examples::Config::Presets(v.into()));
        self
    }
}

impl wkt::message::Message for Examples {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Examples"
    }
}

/// Defines additional types related to Examples
pub mod examples {
    #[allow(unused_imports)]
    use super::*;

    /// The Cloud Storage input instances.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExampleGcsSource {
        /// The format in which instances are given, if not specified, assume it's
        /// JSONL format. Currently only JSONL format is supported.
        pub data_format: crate::model::examples::example_gcs_source::DataFormat,

        /// The Cloud Storage location for the input instances.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub gcs_source: std::option::Option<crate::model::GcsSource>,
    }

    impl ExampleGcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_format][crate::model::examples::ExampleGcsSource::data_format].
        pub fn set_data_format<
            T: std::convert::Into<crate::model::examples::example_gcs_source::DataFormat>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_format = v.into();
            self
        }

        /// Sets the value of [gcs_source][crate::model::examples::ExampleGcsSource::gcs_source].
        pub fn set_gcs_source<
            T: std::convert::Into<std::option::Option<crate::model::GcsSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.gcs_source = v.into();
            self
        }
    }

    impl wkt::message::Message for ExampleGcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Examples.ExampleGcsSource"
        }
    }

    /// Defines additional types related to ExampleGcsSource
    pub mod example_gcs_source {
        #[allow(unused_imports)]
        use super::*;

        /// The format of the input example instances.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct DataFormat(std::borrow::Cow<'static, str>);

        impl DataFormat {
            /// Creates a new DataFormat instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [DataFormat](DataFormat)
        pub mod data_format {
            use super::DataFormat;

            /// Format unspecified, used when unset.
            pub const DATA_FORMAT_UNSPECIFIED: DataFormat =
                DataFormat::new("DATA_FORMAT_UNSPECIFIED");

            /// Examples are stored in JSONL files.
            pub const JSONL: DataFormat = DataFormat::new("JSONL");
        }

        impl std::convert::From<std::string::String> for DataFormat {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Cloud Storage input instances.
        ExampleGcsSource(std::boxed::Box<crate::model::examples::ExampleGcsSource>),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// The full configuration for the generated index, the semantics are the
        /// same as [metadata][google.cloud.aiplatform.v1.Index.metadata] and should
        /// match
        /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
        ///
        /// [google.cloud.aiplatform.v1.Index.metadata]: crate::model::Index::metadata
        NearestNeighborSearchConfig(std::boxed::Box<wkt::Value>),
        /// Simplified preset configuration, which automatically sets configuration
        /// values based on the desired query speed-precision trade-off and modality.
        Presets(std::boxed::Box<crate::model::Presets>),
    }
}

/// Preset configuration for example-based explanations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Presets {
    /// Preset option controlling parameters for speed-precision trade-off when
    /// querying for examples. If omitted, defaults to `PRECISE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::presets::Query>,

    /// The modality of the uploaded model, which automatically configures the
    /// distance measurement and feature normalization for the underlying example
    /// index and queries. If your model does not precisely fit one of these types,
    /// it is okay to choose the closest type.
    pub modality: crate::model::presets::Modality,
}

impl Presets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::Presets::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::presets::Query>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [modality][crate::model::Presets::modality].
    pub fn set_modality<T: std::convert::Into<crate::model::presets::Modality>>(
        mut self,
        v: T,
    ) -> Self {
        self.modality = v.into();
        self
    }
}

impl wkt::message::Message for Presets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Presets"
    }
}

/// Defines additional types related to Presets
pub mod presets {
    #[allow(unused_imports)]
    use super::*;

    /// Preset option controlling parameters for query speed-precision trade-off
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Query(std::borrow::Cow<'static, str>);

    impl Query {
        /// Creates a new Query instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Query](Query)
    pub mod query {
        use super::Query;

        /// More precise neighbors as a trade-off against slower response.
        pub const PRECISE: Query = Query::new("PRECISE");

        /// Faster response as a trade-off against less precise neighbors.
        pub const FAST: Query = Query::new("FAST");
    }

    impl std::convert::From<std::string::String> for Query {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Preset option controlling parameters for different modalities
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Modality(std::borrow::Cow<'static, str>);

    impl Modality {
        /// Creates a new Modality instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Modality](Modality)
    pub mod modality {
        use super::Modality;

        /// Should not be set. Added as a recommended best practice for enums
        pub const MODALITY_UNSPECIFIED: Modality = Modality::new("MODALITY_UNSPECIFIED");

        /// IMAGE modality
        pub const IMAGE: Modality = Modality::new("IMAGE");

        /// TEXT modality
        pub const TEXT: Modality = Modality::new("TEXT");

        /// TABULAR modality
        pub const TABULAR: Modality = Modality::new("TABULAR");
    }

    impl std::convert::From<std::string::String> for Modality {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] entries
/// that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] time.
///
/// [google.cloud.aiplatform.v1.ExplanationSpec]: crate::model::ExplanationSpec
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationSpecOverride {
    /// The parameters to be overridden. Note that the
    /// attribution method cannot be changed. If not specified,
    /// no parameter is overridden.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::ExplanationParameters>,

    /// The metadata to be overridden. If not specified, no metadata is overridden.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::ExplanationMetadataOverride>,

    /// The example-based explanations parameter overrides.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub examples_override: std::option::Option<crate::model::ExamplesOverride>,
}

impl ExplanationSpecOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::ExplanationSpecOverride::parameters].
    pub fn set_parameters<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ExplanationSpecOverride::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationMetadataOverride>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [examples_override][crate::model::ExplanationSpecOverride::examples_override].
    pub fn set_examples_override<
        T: std::convert::Into<std::option::Option<crate::model::ExamplesOverride>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.examples_override = v.into();
        self
    }
}

impl wkt::message::Message for ExplanationSpecOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationSpecOverride"
    }
}

/// The [ExplanationMetadata][google.cloud.aiplatform.v1.ExplanationMetadata]
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] time.
///
/// [google.cloud.aiplatform.v1.ExplanationMetadata]: crate::model::ExplanationMetadata
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationMetadataOverride {
    /// Required. Overrides the [input
    /// metadata][google.cloud.aiplatform.v1.ExplanationMetadata.inputs] of the
    /// features. The key is the name of the feature to be overridden. The keys
    /// specified here must exist in the input metadata to be overridden. If a
    /// feature is not specified here, the corresponding feature's input metadata
    /// is not overridden.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub inputs: std::collections::HashMap<
        std::string::String,
        crate::model::explanation_metadata_override::InputMetadataOverride,
    >,
}

impl ExplanationMetadataOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::ExplanationMetadataOverride::inputs].
    pub fn set_inputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::explanation_metadata_override::InputMetadataOverride>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExplanationMetadataOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadataOverride"
    }
}

/// Defines additional types related to ExplanationMetadataOverride
pub mod explanation_metadata_override {
    #[allow(unused_imports)]
    use super::*;

    /// The [input
    /// metadata][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]
    /// entries to be overridden.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]: crate::model::explanation_metadata::InputMetadata
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputMetadataOverride {
        /// Baseline inputs for this feature.
        ///
        /// This overrides the `input_baseline` field of the
        /// [ExplanationMetadata.InputMetadata][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]
        /// object of the corresponding feature's input metadata. If it's not
        /// specified, the original baselines are not overridden.
        ///
        /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]: crate::model::explanation_metadata::InputMetadata
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub input_baselines: std::vec::Vec<wkt::Value>,
    }

    impl InputMetadataOverride {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_baselines][crate::model::explanation_metadata_override::InputMetadataOverride::input_baselines].
        pub fn set_input_baselines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.input_baselines = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InputMetadataOverride {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadataOverride.InputMetadataOverride"
        }
    }
}

/// Overrides for example-based explanations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExamplesOverride {
    /// The number of neighbors to return.
    pub neighbor_count: i32,

    /// The number of neighbors to return that have the same crowding tag.
    pub crowding_count: i32,

    /// Restrict the resulting nearest neighbors to respect these constraints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub restrictions: std::vec::Vec<crate::model::ExamplesRestrictionsNamespace>,

    /// If true, return the embeddings instead of neighbors.
    pub return_embeddings: bool,

    /// The format of the data being provided with each call.
    pub data_format: crate::model::examples_override::DataFormat,
}

impl ExamplesOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_count][crate::model::ExamplesOverride::neighbor_count].
    pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.neighbor_count = v.into();
        self
    }

    /// Sets the value of [crowding_count][crate::model::ExamplesOverride::crowding_count].
    pub fn set_crowding_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.crowding_count = v.into();
        self
    }

    /// Sets the value of [return_embeddings][crate::model::ExamplesOverride::return_embeddings].
    pub fn set_return_embeddings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_embeddings = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::ExamplesOverride::data_format].
    pub fn set_data_format<T: std::convert::Into<crate::model::examples_override::DataFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::ExamplesOverride::restrictions].
    pub fn set_restrictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExamplesRestrictionsNamespace>,
    {
        use std::iter::Iterator;
        self.restrictions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExamplesOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExamplesOverride"
    }
}

/// Defines additional types related to ExamplesOverride
pub mod examples_override {
    #[allow(unused_imports)]
    use super::*;

    /// Data format enum.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataFormat(std::borrow::Cow<'static, str>);

    impl DataFormat {
        /// Creates a new DataFormat instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DataFormat](DataFormat)
    pub mod data_format {
        use super::DataFormat;

        /// Unspecified format. Must not be used.
        pub const DATA_FORMAT_UNSPECIFIED: DataFormat = DataFormat::new("DATA_FORMAT_UNSPECIFIED");

        /// Provided data is a set of model inputs.
        pub const INSTANCES: DataFormat = DataFormat::new("INSTANCES");

        /// Provided data is a set of embeddings.
        pub const EMBEDDINGS: DataFormat = DataFormat::new("EMBEDDINGS");
    }

    impl std::convert::From<std::string::String> for DataFormat {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Restrictions namespace for example-based explanations overrides.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExamplesRestrictionsNamespace {
    /// The namespace name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespace_name: std::string::String,

    /// The list of allowed tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allow: std::vec::Vec<std::string::String>,

    /// The list of deny tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deny: std::vec::Vec<std::string::String>,
}

impl ExamplesRestrictionsNamespace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespace_name][crate::model::ExamplesRestrictionsNamespace::namespace_name].
    pub fn set_namespace_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace_name = v.into();
        self
    }

    /// Sets the value of [allow][crate::model::ExamplesRestrictionsNamespace::allow].
    pub fn set_allow<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allow = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deny][crate::model::ExamplesRestrictionsNamespace::deny].
    pub fn set_deny<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deny = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExamplesRestrictionsNamespace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExamplesRestrictionsNamespace"
    }
}

/// Metadata describing the Model's input and output for explanation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplanationMetadata {
    /// Required. Map from feature names to feature input metadata. Keys are the
    /// name of the features. Values are the specification of the feature.
    ///
    /// An empty InputMetadata is valid. It describes a text feature which has the
    /// name specified as the key in
    /// [ExplanationMetadata.inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    /// The baseline of the empty feature is chosen by Vertex AI.
    ///
    /// For Vertex AI-provided Tensorflow images, the key can be any friendly
    /// name of the feature. Once specified,
    /// [featureAttributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// are keyed by this key (if not grouped with another feature).
    ///
    /// For custom images, the key must match with the key in
    /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances].
    ///
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.inputs]: crate::model::ExplanationMetadata::inputs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub inputs: std::collections::HashMap<
        std::string::String,
        crate::model::explanation_metadata::InputMetadata,
    >,

    /// Required. Map from output names to output metadata.
    ///
    /// For Vertex AI-provided Tensorflow images, keys can be any user defined
    /// string that consists of any UTF-8 characters.
    ///
    /// For custom images, keys are the name of the output field in the prediction
    /// to be explained.
    ///
    /// Currently only one key is allowed.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub outputs: std::collections::HashMap<
        std::string::String,
        crate::model::explanation_metadata::OutputMetadata,
    >,

    /// Points to a YAML file stored on Google Cloud Storage describing the format
    /// of the [feature
    /// attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML tabular Models always have this field populated by Vertex AI.
    /// Note: The URI given on output may be different, including the URI scheme,
    /// than the one given on input. The output URI will point to a location where
    /// the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_attributions_schema_uri: std::string::String,

    /// Name of the source to generate embeddings for example based explanations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latent_space_source: std::string::String,
}

impl ExplanationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_attributions_schema_uri][crate::model::ExplanationMetadata::feature_attributions_schema_uri].
    pub fn set_feature_attributions_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_attributions_schema_uri = v.into();
        self
    }

    /// Sets the value of [latent_space_source][crate::model::ExplanationMetadata::latent_space_source].
    pub fn set_latent_space_source<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latent_space_source = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::ExplanationMetadata::inputs].
    pub fn set_inputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::explanation_metadata::InputMetadata>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [outputs][crate::model::ExplanationMetadata::outputs].
    pub fn set_outputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::explanation_metadata::OutputMetadata>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExplanationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata"
    }
}

/// Defines additional types related to ExplanationMetadata
pub mod explanation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of the input of a feature.
    ///
    /// Fields other than
    /// [InputMetadata.input_baselines][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.input_baselines]
    /// are applicable only for Models that are using Vertex AI-provided images for
    /// Tensorflow.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.input_baselines]: crate::model::explanation_metadata::InputMetadata::input_baselines
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputMetadata {
        /// Baseline inputs for this feature.
        ///
        /// If no baseline is specified, Vertex AI chooses the baseline for this
        /// feature. If multiple baselines are specified, Vertex AI returns the
        /// average attributions across them in
        /// [Attribution.feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions].
        ///
        /// For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape
        /// of each baseline must match the shape of the input tensor. If a scalar is
        /// provided, we broadcast to the same shape as the input tensor.
        ///
        /// For custom images, the element of the baselines must be in the same
        /// format as the feature's input in the
        /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances][]. The
        /// schema of any single instance may be specified via Endpoint's
        /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
        /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
        /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
        ///
        /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
        /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
        /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
        /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
        /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub input_baselines: std::vec::Vec<wkt::Value>,

        /// Name of the input tensor for this feature. Required and is only
        /// applicable to Vertex AI-provided images for Tensorflow.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub input_tensor_name: std::string::String,

        /// Defines how the feature is encoded into the input tensor. Defaults to
        /// IDENTITY.
        pub encoding: crate::model::explanation_metadata::input_metadata::Encoding,

        /// Modality of the feature. Valid values are: numeric, image. Defaults to
        /// numeric.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub modality: std::string::String,

        /// The domain details of the input feature value. Like min/max, original
        /// mean or standard deviation if normalized.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_value_domain: std::option::Option<
            crate::model::explanation_metadata::input_metadata::FeatureValueDomain,
        >,

        /// Specifies the index of the values of the input tensor.
        /// Required when the input tensor is a sparse representation. Refer to
        /// Tensorflow documentation for more details:
        /// <https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub indices_tensor_name: std::string::String,

        /// Specifies the shape of the values of the input if the input is a sparse
        /// representation. Refer to Tensorflow documentation for more details:
        /// <https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dense_shape_tensor_name: std::string::String,

        /// A list of feature names for each index in the input tensor.
        /// Required when the input
        /// [InputMetadata.encoding][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoding]
        /// is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
        ///
        /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoding]: crate::model::explanation_metadata::InputMetadata::encoding
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub index_feature_mapping: std::vec::Vec<std::string::String>,

        /// Encoded tensor is a transformation of the input tensor. Must be provided
        /// if choosing
        /// [Integrated Gradients
        /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]
        /// or [XRAI
        /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]
        /// and the input tensor is not differentiable.
        ///
        /// An encoded tensor is generated if the input tensor is encoded by a lookup
        /// table.
        ///
        /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
        /// [google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]: crate::model::ExplanationParameters::method
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub encoded_tensor_name: std::string::String,

        /// A list of baselines for the encoded tensor.
        ///
        /// The shape of each baseline should match the shape of the encoded tensor.
        /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
        /// encoded tensor.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub encoded_baselines: std::vec::Vec<wkt::Value>,

        /// Visualization configurations for image explanation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub visualization:
            std::option::Option<crate::model::explanation_metadata::input_metadata::Visualization>,

        /// Name of the group that the input belongs to. Features with the same group
        /// name will be treated as one feature when computing attributions. Features
        /// grouped together can have different shapes in value. If provided, there
        /// will be one single attribution generated in
        /// [Attribution.feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions],
        /// keyed by the group name.
        ///
        /// [google.cloud.aiplatform.v1.Attribution.feature_attributions]: crate::model::Attribution::feature_attributions
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub group_name: std::string::String,
    }

    impl InputMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_tensor_name][crate::model::explanation_metadata::InputMetadata::input_tensor_name].
        pub fn set_input_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.input_tensor_name = v.into();
            self
        }

        /// Sets the value of [encoding][crate::model::explanation_metadata::InputMetadata::encoding].
        pub fn set_encoding<
            T: std::convert::Into<crate::model::explanation_metadata::input_metadata::Encoding>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }

        /// Sets the value of [modality][crate::model::explanation_metadata::InputMetadata::modality].
        pub fn set_modality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.modality = v.into();
            self
        }

        /// Sets the value of [feature_value_domain][crate::model::explanation_metadata::InputMetadata::feature_value_domain].
        pub fn set_feature_value_domain<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::explanation_metadata::input_metadata::FeatureValueDomain,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_value_domain = v.into();
            self
        }

        /// Sets the value of [indices_tensor_name][crate::model::explanation_metadata::InputMetadata::indices_tensor_name].
        pub fn set_indices_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.indices_tensor_name = v.into();
            self
        }

        /// Sets the value of [dense_shape_tensor_name][crate::model::explanation_metadata::InputMetadata::dense_shape_tensor_name].
        pub fn set_dense_shape_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dense_shape_tensor_name = v.into();
            self
        }

        /// Sets the value of [encoded_tensor_name][crate::model::explanation_metadata::InputMetadata::encoded_tensor_name].
        pub fn set_encoded_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.encoded_tensor_name = v.into();
            self
        }

        /// Sets the value of [visualization][crate::model::explanation_metadata::InputMetadata::visualization].
        pub fn set_visualization<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::explanation_metadata::input_metadata::Visualization,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.visualization = v.into();
            self
        }

        /// Sets the value of [group_name][crate::model::explanation_metadata::InputMetadata::group_name].
        pub fn set_group_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group_name = v.into();
            self
        }

        /// Sets the value of [input_baselines][crate::model::explanation_metadata::InputMetadata::input_baselines].
        pub fn set_input_baselines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.input_baselines = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [index_feature_mapping][crate::model::explanation_metadata::InputMetadata::index_feature_mapping].
        pub fn set_index_feature_mapping<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.index_feature_mapping = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [encoded_baselines][crate::model::explanation_metadata::InputMetadata::encoded_baselines].
        pub fn set_encoded_baselines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.encoded_baselines = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InputMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata"
        }
    }

    /// Defines additional types related to InputMetadata
    pub mod input_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Domain details of the input feature value. Provides numeric information
        /// about the feature, such as its range (min, max). If the feature has been
        /// pre-processed, for example with z-scoring, then it provides information
        /// about how to recover the original feature. For example, if the input
        /// feature is an image and it has been pre-processed to obtain 0-mean and
        /// stddev = 1 values, then original_mean, and original_stddev refer to the
        /// mean and stddev of the original feature (e.g. image tensor) from which
        /// input feature (with mean = 0 and stddev = 1) was obtained.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FeatureValueDomain {
            /// The minimum permissible value for this feature.
            pub min_value: f32,

            /// The maximum permissible value for this feature.
            pub max_value: f32,

            /// If this input feature has been normalized to a mean value of 0,
            /// the original_mean specifies the mean value of the domain prior to
            /// normalization.
            pub original_mean: f32,

            /// If this input feature has been normalized to a standard deviation of
            /// 1.0, the original_stddev specifies the standard deviation of the domain
            /// prior to normalization.
            pub original_stddev: f32,
        }

        impl FeatureValueDomain {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_value][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::min_value].
            pub fn set_min_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::max_value].
            pub fn set_max_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [original_mean][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::original_mean].
            pub fn set_original_mean<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.original_mean = v.into();
                self
            }

            /// Sets the value of [original_stddev][crate::model::explanation_metadata::input_metadata::FeatureValueDomain::original_stddev].
            pub fn set_original_stddev<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.original_stddev = v.into();
                self
            }
        }

        impl wkt::message::Message for FeatureValueDomain {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.FeatureValueDomain"
            }
        }

        /// Visualization configurations for image explanation.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Visualization {
            /// Type of the image visualization. Only applicable to
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution].
            /// OUTLINES shows regions of attribution, while PIXELS shows per-pixel
            /// attribution. Defaults to OUTLINES.
            ///
            /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
            #[serde(rename = "type")]
            pub r#type: crate::model::explanation_metadata::input_metadata::visualization::Type,

            /// Whether to only highlight pixels with positive contributions, negative
            /// or both. Defaults to POSITIVE.
            pub polarity:
                crate::model::explanation_metadata::input_metadata::visualization::Polarity,

            /// The color scheme used for the highlighted areas.
            ///
            /// Defaults to PINK_GREEN for
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution],
            /// which shows positive attributions in green and negative in pink.
            ///
            /// Defaults to VIRIDIS for
            /// [XRAI
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution],
            /// which highlights the most influential regions in yellow and the least
            /// influential in blue.
            ///
            /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
            /// [google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]: crate::model::ExplanationParameters::method
            pub color_map:
                crate::model::explanation_metadata::input_metadata::visualization::ColorMap,

            /// Excludes attributions above the specified percentile from the
            /// highlighted areas. Using the clip_percent_upperbound and
            /// clip_percent_lowerbound together can be useful for filtering out noise
            /// and making it easier to see areas of strong attribution. Defaults to
            /// 99.9.
            pub clip_percent_upperbound: f32,

            /// Excludes attributions below the specified percentile, from the
            /// highlighted areas. Defaults to 62.
            pub clip_percent_lowerbound: f32,

            /// How the original image is displayed in the visualization.
            /// Adjusting the overlay can help increase visual clarity if the original
            /// image makes it difficult to view the visualization. Defaults to NONE.
            pub overlay_type:
                crate::model::explanation_metadata::input_metadata::visualization::OverlayType,
        }

        impl Visualization {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::explanation_metadata::input_metadata::Visualization::type].
            pub fn set_type<
                T: std::convert::Into<
                    crate::model::explanation_metadata::input_metadata::visualization::Type,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [polarity][crate::model::explanation_metadata::input_metadata::Visualization::polarity].
            pub fn set_polarity<
                T: std::convert::Into<
                    crate::model::explanation_metadata::input_metadata::visualization::Polarity,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.polarity = v.into();
                self
            }

            /// Sets the value of [color_map][crate::model::explanation_metadata::input_metadata::Visualization::color_map].
            pub fn set_color_map<
                T: std::convert::Into<
                    crate::model::explanation_metadata::input_metadata::visualization::ColorMap,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.color_map = v.into();
                self
            }

            /// Sets the value of [clip_percent_upperbound][crate::model::explanation_metadata::input_metadata::Visualization::clip_percent_upperbound].
            pub fn set_clip_percent_upperbound<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.clip_percent_upperbound = v.into();
                self
            }

            /// Sets the value of [clip_percent_lowerbound][crate::model::explanation_metadata::input_metadata::Visualization::clip_percent_lowerbound].
            pub fn set_clip_percent_lowerbound<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.clip_percent_lowerbound = v.into();
                self
            }

            /// Sets the value of [overlay_type][crate::model::explanation_metadata::input_metadata::Visualization::overlay_type].
            pub fn set_overlay_type<
                T: std::convert::Into<
                    crate::model::explanation_metadata::input_metadata::visualization::OverlayType,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.overlay_type = v.into();
                self
            }
        }

        impl wkt::message::Message for Visualization {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization"
            }
        }

        /// Defines additional types related to Visualization
        pub mod visualization {
            #[allow(unused_imports)]
            use super::*;

            /// Type of the image visualization. Only applicable to
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution].
            ///
            /// [google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]: crate::model::ExplanationParameters::method
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct Type(std::borrow::Cow<'static, str>);

            impl Type {
                /// Creates a new Type instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [Type](Type)
            pub mod r#type {
                use super::Type;

                /// Should not be used.
                pub const TYPE_UNSPECIFIED: Type = Type::new("TYPE_UNSPECIFIED");

                /// Shows which pixel contributed to the image prediction.
                pub const PIXELS: Type = Type::new("PIXELS");

                /// Shows which region contributed to the image prediction by outlining
                /// the region.
                pub const OUTLINES: Type = Type::new("OUTLINES");
            }

            impl std::convert::From<std::string::String> for Type {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }

            /// Whether to only highlight pixels with positive contributions, negative
            /// or both. Defaults to POSITIVE.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct Polarity(std::borrow::Cow<'static, str>);

            impl Polarity {
                /// Creates a new Polarity instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [Polarity](Polarity)
            pub mod polarity {
                use super::Polarity;

                /// Default value. This is the same as POSITIVE.
                pub const POLARITY_UNSPECIFIED: Polarity = Polarity::new("POLARITY_UNSPECIFIED");

                /// Highlights the pixels/outlines that were most influential to the
                /// model's prediction.
                pub const POSITIVE: Polarity = Polarity::new("POSITIVE");

                /// Setting polarity to negative highlights areas that does not lead to
                /// the models's current prediction.
                pub const NEGATIVE: Polarity = Polarity::new("NEGATIVE");

                /// Shows both positive and negative attributions.
                pub const BOTH: Polarity = Polarity::new("BOTH");
            }

            impl std::convert::From<std::string::String> for Polarity {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }

            /// The color scheme used for highlighting areas.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct ColorMap(std::borrow::Cow<'static, str>);

            impl ColorMap {
                /// Creates a new ColorMap instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [ColorMap](ColorMap)
            pub mod color_map {
                use super::ColorMap;

                /// Should not be used.
                pub const COLOR_MAP_UNSPECIFIED: ColorMap = ColorMap::new("COLOR_MAP_UNSPECIFIED");

                /// Positive: green. Negative: pink.
                pub const PINK_GREEN: ColorMap = ColorMap::new("PINK_GREEN");

                /// Viridis color map: A perceptually uniform color mapping which is
                /// easier to see by those with colorblindness and progresses from yellow
                /// to green to blue. Positive: yellow. Negative: blue.
                pub const VIRIDIS: ColorMap = ColorMap::new("VIRIDIS");

                /// Positive: red. Negative: red.
                pub const RED: ColorMap = ColorMap::new("RED");

                /// Positive: green. Negative: green.
                pub const GREEN: ColorMap = ColorMap::new("GREEN");

                /// Positive: green. Negative: red.
                pub const RED_GREEN: ColorMap = ColorMap::new("RED_GREEN");

                /// PiYG palette.
                pub const PINK_WHITE_GREEN: ColorMap = ColorMap::new("PINK_WHITE_GREEN");
            }

            impl std::convert::From<std::string::String> for ColorMap {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }

            /// How the original image is displayed in the visualization.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct OverlayType(std::borrow::Cow<'static, str>);

            impl OverlayType {
                /// Creates a new OverlayType instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [OverlayType](OverlayType)
            pub mod overlay_type {
                use super::OverlayType;

                /// Default value. This is the same as NONE.
                pub const OVERLAY_TYPE_UNSPECIFIED: OverlayType =
                    OverlayType::new("OVERLAY_TYPE_UNSPECIFIED");

                /// No overlay.
                pub const NONE: OverlayType = OverlayType::new("NONE");

                /// The attributions are shown on top of the original image.
                pub const ORIGINAL: OverlayType = OverlayType::new("ORIGINAL");

                /// The attributions are shown on top of grayscaled version of the
                /// original image.
                pub const GRAYSCALE: OverlayType = OverlayType::new("GRAYSCALE");

                /// The attributions are used as a mask to reveal predictive parts of
                /// the image and hide the un-predictive parts.
                pub const MASK_BLACK: OverlayType = OverlayType::new("MASK_BLACK");
            }

            impl std::convert::From<std::string::String> for OverlayType {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// Defines how a feature is encoded. Defaults to IDENTITY.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Encoding(std::borrow::Cow<'static, str>);

        impl Encoding {
            /// Creates a new Encoding instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Encoding](Encoding)
        pub mod encoding {
            use super::Encoding;

            /// Default value. This is the same as IDENTITY.
            pub const ENCODING_UNSPECIFIED: Encoding = Encoding::new("ENCODING_UNSPECIFIED");

            /// The tensor represents one feature.
            pub const IDENTITY: Encoding = Encoding::new("IDENTITY");

            /// The tensor represents a bag of features where each index maps to
            /// a feature.
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = [27, 6.0, 150]
            /// index_feature_mapping = ["age", "height", "weight"]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]: crate::model::explanation_metadata::InputMetadata::index_feature_mapping
            pub const BAG_OF_FEATURES: Encoding = Encoding::new("BAG_OF_FEATURES");

            /// The tensor represents a bag of features where each index maps to a
            /// feature. Zero values in the tensor indicates feature being
            /// non-existent.
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = [2, 0, 5, 0, 1]
            /// index_feature_mapping = ["a", "b", "c", "d", "e"]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]: crate::model::explanation_metadata::InputMetadata::index_feature_mapping
            pub const BAG_OF_FEATURES_SPARSE: Encoding = Encoding::new("BAG_OF_FEATURES_SPARSE");

            /// The tensor is a list of binaries representing whether a feature exists
            /// or not (1 indicates existence).
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = [1, 0, 1, 0, 1]
            /// index_feature_mapping = ["a", "b", "c", "d", "e"]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]: crate::model::explanation_metadata::InputMetadata::index_feature_mapping
            pub const INDICATOR: Encoding = Encoding::new("INDICATOR");

            /// The tensor is encoded into a 1-dimensional array represented by an
            /// encoded tensor.
            /// [InputMetadata.encoded_tensor_name][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]
            /// must be provided for this encoding. For example:
            ///
            /// ```norust
            /// input = ["This", "is", "a", "test", "."]
            /// encoded = [0.1, 0.2, 0.3, 0.4, 0.5]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]: crate::model::explanation_metadata::InputMetadata::encoded_tensor_name
            pub const COMBINED_EMBEDDING: Encoding = Encoding::new("COMBINED_EMBEDDING");

            /// Select this encoding when the input tensor is encoded into a
            /// 2-dimensional array represented by an encoded tensor.
            /// [InputMetadata.encoded_tensor_name][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]
            /// must be provided for this encoding. The first dimension of the encoded
            /// tensor's shape is the same as the input tensor's shape. For example:
            ///
            /// ```norust
            /// input = ["This", "is", "a", "test", "."]
            /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5],
            ///            [0.2, 0.1, 0.4, 0.3, 0.5],
            ///            [0.5, 0.1, 0.3, 0.5, 0.4],
            ///            [0.5, 0.3, 0.1, 0.2, 0.4],
            ///            [0.4, 0.3, 0.2, 0.5, 0.1]]
            /// ```
            ///
            /// [google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]: crate::model::explanation_metadata::InputMetadata::encoded_tensor_name
            pub const CONCAT_EMBEDDING: Encoding = Encoding::new("CONCAT_EMBEDDING");
        }

        impl std::convert::From<std::string::String> for Encoding {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Metadata of the prediction output to be explained.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputMetadata {
        /// Name of the output tensor. Required and is only applicable to Vertex
        /// AI provided images for Tensorflow.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub output_tensor_name: std::string::String,

        /// Defines how to map
        /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
        /// to
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name].
        ///
        /// If neither of the fields are specified,
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
        /// will not be populated.
        ///
        /// [google.cloud.aiplatform.v1.Attribution.output_display_name]: crate::model::Attribution::output_display_name
        /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub display_name_mapping: std::option::Option<
            crate::model::explanation_metadata::output_metadata::DisplayNameMapping,
        >,
    }

    impl OutputMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [output_tensor_name][crate::model::explanation_metadata::OutputMetadata::output_tensor_name].
        pub fn set_output_tensor_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_tensor_name = v.into();
            self
        }

        /// Sets the value of `display_name_mapping`.
        pub fn set_display_name_mapping<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::explanation_metadata::output_metadata::DisplayNameMapping,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.display_name_mapping = v.into();
            self
        }

        /// The value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// if it holds a `IndexDisplayNameMapping`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_index_display_name_mapping(
            &self,
        ) -> std::option::Option<&std::boxed::Box<wkt::Value>> {
            #[allow(unreachable_patterns)]
            self.display_name_mapping.as_ref().and_then(|v| match v {
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::IndexDisplayNameMapping(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// if it holds a `DisplayNameMappingKey`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_display_name_mapping_key(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.display_name_mapping.as_ref().and_then(|v| match v {
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::DisplayNameMappingKey(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// to hold a `IndexDisplayNameMapping`.
        ///
        /// Note that all the setters affecting `display_name_mapping` are
        /// mutually exclusive.
        pub fn set_index_display_name_mapping<
            T: std::convert::Into<std::boxed::Box<wkt::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.display_name_mapping = std::option::Option::Some(
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::IndexDisplayNameMapping(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [display_name_mapping][crate::model::explanation_metadata::OutputMetadata::display_name_mapping]
        /// to hold a `DisplayNameMappingKey`.
        ///
        /// Note that all the setters affecting `display_name_mapping` are
        /// mutually exclusive.
        pub fn set_display_name_mapping_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name_mapping = std::option::Option::Some(
                crate::model::explanation_metadata::output_metadata::DisplayNameMapping::DisplayNameMappingKey(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for OutputMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.OutputMetadata"
        }
    }

    /// Defines additional types related to OutputMetadata
    pub mod output_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Defines how to map
        /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
        /// to
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name].
        ///
        /// If neither of the fields are specified,
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
        /// will not be populated.
        ///
        /// [google.cloud.aiplatform.v1.Attribution.output_display_name]: crate::model::Attribution::output_display_name
        /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DisplayNameMapping {
            /// Static mapping between the index and display name.
            ///
            /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
            /// list of scores of all the classes in a pre-defined order for a
            /// multi-classification Model. It's not feasible if the outputs are
            /// non-deterministic, e.g. the Model produces top-k classes or sort the
            /// outputs by their values.
            ///
            /// The shape of the value must be an n-dimensional array of strings. The
            /// number of dimensions must match that of the outputs to be explained.
            /// The
            /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
            /// is populated by locating in the mapping with
            /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index].
            ///
            /// [google.cloud.aiplatform.v1.Attribution.output_display_name]: crate::model::Attribution::output_display_name
            /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
            IndexDisplayNameMapping(std::boxed::Box<wkt::Value>),
            /// Specify a field name in the prediction to look for the display name.
            ///
            /// Use this if the prediction contains the display names for the outputs.
            ///
            /// The display names in the prediction must have the same shape of the
            /// outputs, so that it can be located by
            /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
            /// for a specific output.
            ///
            /// [google.cloud.aiplatform.v1.Attribution.output_index]: crate::model::Attribution::output_index
            DisplayNameMappingKey(std::string::String),
        }
    }
}

/// Feature Metadata information.
/// For example, color is a feature that describes an apple.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Feature {
    /// Immutable. Name of the Feature.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
    ///
    /// The last part feature is assigned by the client. The feature can be up to
    /// 64 characters long and can consist only of ASCII Latin letters A-Z and a-z,
    /// underscore(_), and ASCII digits 0-9 starting with a letter. The value will
    /// be unique given an entity type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Description of the Feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Immutable. Only applicable for Vertex AI Feature Store (Legacy).
    /// Type of Feature value.
    pub value_type: crate::model::feature::ValueType,

    /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
    /// Timestamp when this EntityType was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
    /// Timestamp when this EntityType was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize your Features.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one Feature (System
    /// labels are excluded)."
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Only applicable for Vertex AI Feature Store (Legacy).
    /// If not set, use the monitoring_config defined for the EntityType this
    /// Feature belongs to.
    /// Only Features with type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) BOOL,
    /// STRING, DOUBLE or INT64 can enable monitoring.
    ///
    /// If set to true, all types of data monitoring are disabled despite the
    /// config on EntityType.
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    pub disable_monitoring: bool,

    /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
    /// The list of historical stats and anomalies with specified objectives.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub monitoring_stats_anomalies: std::vec::Vec<crate::model::feature::MonitoringStatsAnomaly>,

    /// Only applicable for Vertex AI Feature Store.
    /// The name of the BigQuery Table/View column hosting data for this version.
    /// If no value is provided, will use feature_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_column_name: std::string::String,

    /// Entity responsible for maintaining this feature. Can be comma separated
    /// list of email addresses or URIs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub point_of_contact: std::string::String,
}

impl Feature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Feature::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Feature::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::Feature::value_type].
    pub fn set_value_type<T: std::convert::Into<crate::model::feature::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Feature::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Feature::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Feature::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [disable_monitoring][crate::model::Feature::disable_monitoring].
    pub fn set_disable_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_monitoring = v.into();
        self
    }

    /// Sets the value of [version_column_name][crate::model::Feature::version_column_name].
    pub fn set_version_column_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_column_name = v.into();
        self
    }

    /// Sets the value of [point_of_contact][crate::model::Feature::point_of_contact].
    pub fn set_point_of_contact<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.point_of_contact = v.into();
        self
    }

    /// Sets the value of [monitoring_stats_anomalies][crate::model::Feature::monitoring_stats_anomalies].
    pub fn set_monitoring_stats_anomalies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::feature::MonitoringStatsAnomaly>,
    {
        use std::iter::Iterator;
        self.monitoring_stats_anomalies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Feature::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Feature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Feature"
    }
}

/// Defines additional types related to Feature
pub mod feature {
    #[allow(unused_imports)]
    use super::*;

    /// A list of historical
    /// [SnapshotAnalysis][google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis]
    /// or
    /// [ImportFeaturesAnalysis][google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis]
    /// stats requested by user, sorted by
    /// [FeatureStatsAnomaly.start_time][google.cloud.aiplatform.v1.FeatureStatsAnomaly.start_time]
    /// descending.
    ///
    /// [google.cloud.aiplatform.v1.FeatureStatsAnomaly.start_time]: crate::model::FeatureStatsAnomaly::start_time
    /// [google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis]: crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis
    /// [google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis]: crate::model::featurestore_monitoring_config::SnapshotAnalysis
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MonitoringStatsAnomaly {
        /// Output only. The objective for each stats.
        pub objective: crate::model::feature::monitoring_stats_anomaly::Objective,

        /// Output only. The stats and anomalies generated at specific timestamp.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_stats_anomaly: std::option::Option<crate::model::FeatureStatsAnomaly>,
    }

    impl MonitoringStatsAnomaly {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [objective][crate::model::feature::MonitoringStatsAnomaly::objective].
        pub fn set_objective<
            T: std::convert::Into<crate::model::feature::monitoring_stats_anomaly::Objective>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.objective = v.into();
            self
        }

        /// Sets the value of [feature_stats_anomaly][crate::model::feature::MonitoringStatsAnomaly::feature_stats_anomaly].
        pub fn set_feature_stats_anomaly<
            T: std::convert::Into<std::option::Option<crate::model::FeatureStatsAnomaly>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_stats_anomaly = v.into();
            self
        }
    }

    impl wkt::message::Message for MonitoringStatsAnomaly {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Feature.MonitoringStatsAnomaly"
        }
    }

    /// Defines additional types related to MonitoringStatsAnomaly
    pub mod monitoring_stats_anomaly {
        #[allow(unused_imports)]
        use super::*;

        /// If the objective in the request is both
        /// Import Feature Analysis and Snapshot Analysis, this objective could be
        /// one of them. Otherwise, this objective should be the same as the
        /// objective in the request.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Objective(std::borrow::Cow<'static, str>);

        impl Objective {
            /// Creates a new Objective instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Objective](Objective)
        pub mod objective {
            use super::Objective;

            /// If it's OBJECTIVE_UNSPECIFIED, monitoring_stats will be empty.
            pub const OBJECTIVE_UNSPECIFIED: Objective = Objective::new("OBJECTIVE_UNSPECIFIED");

            /// Stats are generated by Import Feature Analysis.
            pub const IMPORT_FEATURE_ANALYSIS: Objective =
                Objective::new("IMPORT_FEATURE_ANALYSIS");

            /// Stats are generated by Snapshot Analysis.
            pub const SNAPSHOT_ANALYSIS: Objective = Objective::new("SNAPSHOT_ANALYSIS");
        }

        impl std::convert::From<std::string::String> for Objective {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Only applicable for Vertex AI Legacy Feature Store.
    /// An enum representing the value type of a feature.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ValueType(std::borrow::Cow<'static, str>);

    impl ValueType {
        /// Creates a new ValueType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ValueType](ValueType)
    pub mod value_type {
        use super::ValueType;

        /// The value type is unspecified.
        pub const VALUE_TYPE_UNSPECIFIED: ValueType = ValueType::new("VALUE_TYPE_UNSPECIFIED");

        /// Used for Feature that is a boolean.
        pub const BOOL: ValueType = ValueType::new("BOOL");

        /// Used for Feature that is a list of boolean.
        pub const BOOL_ARRAY: ValueType = ValueType::new("BOOL_ARRAY");

        /// Used for Feature that is double.
        pub const DOUBLE: ValueType = ValueType::new("DOUBLE");

        /// Used for Feature that is a list of double.
        pub const DOUBLE_ARRAY: ValueType = ValueType::new("DOUBLE_ARRAY");

        /// Used for Feature that is INT64.
        pub const INT64: ValueType = ValueType::new("INT64");

        /// Used for Feature that is a list of INT64.
        pub const INT64_ARRAY: ValueType = ValueType::new("INT64_ARRAY");

        /// Used for Feature that is string.
        pub const STRING: ValueType = ValueType::new("STRING");

        /// Used for Feature that is a list of String.
        pub const STRING_ARRAY: ValueType = ValueType::new("STRING_ARRAY");

        /// Used for Feature that is bytes.
        pub const BYTES: ValueType = ValueType::new("BYTES");

        /// Used for Feature that is struct.
        pub const STRUCT: ValueType = ValueType::new("STRUCT");
    }

    impl std::convert::From<std::string::String> for ValueType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Vertex AI Feature Group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureGroup {
    /// Identifier. Name of the FeatureGroup. Format:
    /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this FeatureGroup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this FeatureGroup was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// FeatureGroup.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one
    /// FeatureGroup(System labels are excluded)." System reserved label keys
    /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the FeatureGroup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::feature_group::Source>,
}

impl FeatureGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureGroup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeatureGroup::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::FeatureGroup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FeatureGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::FeatureGroup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::feature_group::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FeatureGroup::source]
    /// if it holds a `BigQuery`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_big_query(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_group::BigQuery>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_group::Source::BigQuery(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FeatureGroup::source]
    /// to hold a `BigQuery`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_group::BigQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::feature_group::Source::BigQuery(v.into()));
        self
    }
}

impl wkt::message::Message for FeatureGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup"
    }
}

/// Defines additional types related to FeatureGroup
pub mod feature_group {
    #[allow(unused_imports)]
    use super::*;

    /// Input source type for BigQuery Tables and Views.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQuery {
        /// Required. Immutable. The BigQuery source URI that points to either a
        /// BigQuery Table or View.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub big_query_source: std::option::Option<crate::model::BigQuerySource>,

        /// Optional. Columns to construct entity_id / row keys.
        /// If not provided defaults to `entity_id`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub entity_id_columns: std::vec::Vec<std::string::String>,

        /// Optional. Set if the data source is not a time-series.
        pub static_data_source: bool,

        /// Optional. If the source is a time-series source, this can be set to
        /// control how downstream sources (ex:
        /// [FeatureView][google.cloud.aiplatform.v1.FeatureView] ) will treat
        /// time-series sources. If not set, will treat the source as a time-series
        /// source with `feature_timestamp` as timestamp column and no scan boundary.
        ///
        /// [google.cloud.aiplatform.v1.FeatureView]: crate::model::FeatureView
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series: std::option::Option<crate::model::feature_group::big_query::TimeSeries>,

        /// Optional. If set, all feature values will be fetched
        /// from a single row per unique entityId including nulls.
        /// If not set, will collapse all rows for each unique entityId into a singe
        /// row with any non-null values if present, if no non-null values are
        /// present will sync null.
        /// ex: If source has schema
        /// `(entity_id, feature_timestamp, f0, f1)` and the following rows:
        /// `(e1, 2020-01-01T10:00:00.123Z, 10, 15)`
        /// `(e1, 2020-02-01T10:00:00.123Z, 20, null)`
        /// If dense is set, `(e1, 20, null)` is synced to online stores. If dense is
        /// not set, `(e1, 20, 15)` is synced to online stores.
        pub dense: bool,
    }

    impl BigQuery {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [big_query_source][crate::model::feature_group::BigQuery::big_query_source].
        pub fn set_big_query_source<
            T: std::convert::Into<std::option::Option<crate::model::BigQuerySource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.big_query_source = v.into();
            self
        }

        /// Sets the value of [static_data_source][crate::model::feature_group::BigQuery::static_data_source].
        pub fn set_static_data_source<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.static_data_source = v.into();
            self
        }

        /// Sets the value of [time_series][crate::model::feature_group::BigQuery::time_series].
        pub fn set_time_series<
            T: std::convert::Into<
                std::option::Option<crate::model::feature_group::big_query::TimeSeries>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series = v.into();
            self
        }

        /// Sets the value of [dense][crate::model::feature_group::BigQuery::dense].
        pub fn set_dense<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.dense = v.into();
            self
        }

        /// Sets the value of [entity_id_columns][crate::model::feature_group::BigQuery::entity_id_columns].
        pub fn set_entity_id_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_id_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BigQuery {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup.BigQuery"
        }
    }

    /// Defines additional types related to BigQuery
    pub mod big_query {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TimeSeries {
            /// Optional. Column hosting timestamp values for a time-series source.
            /// Will be used to determine the latest `feature_values` for each entity.
            /// Optional. If not provided, column named `feature_timestamp` of
            /// type `TIMESTAMP` will be used.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub timestamp_column: std::string::String,
        }

        impl TimeSeries {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [timestamp_column][crate::model::feature_group::big_query::TimeSeries::timestamp_column].
            pub fn set_timestamp_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.timestamp_column = v.into();
                self
            }
        }

        impl wkt::message::Message for TimeSeries {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup.BigQuery.TimeSeries"
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Indicates that features for this group come from BigQuery Table/View.
        /// By default treats the source as a sparse time series source. The BigQuery
        /// source table or view must have at least one entity ID column and a column
        /// named `feature_timestamp`.
        BigQuery(std::boxed::Box<crate::model::feature_group::BigQuery>),
    }
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI
/// defined proto, for UI to display.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureStatsAnomaly {
    /// Feature importance score, only populated when cross-feature monitoring is
    /// enabled. For now only used to represent feature attribution score within
    /// range [0, 1] for
    /// [ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW][google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW]
    /// and
    /// [ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT][google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT].
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT]: crate::model::model_deployment_monitoring_objective_type::FEATURE_ATTRIBUTION_DRIFT
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW]: crate::model::model_deployment_monitoring_objective_type::FEATURE_ATTRIBUTION_SKEW
    pub score: f64,

    /// Path of the stats file for current feature values in Cloud Storage bucket.
    /// Format: gs://<bucket_name>/<object_name>/stats.
    /// Example: gs://monitoring_bucket/feature_name/stats.
    /// Stats are stored as binary format with Protobuf message
    /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub stats_uri: std::string::String,

    /// Path of the anomaly file for current feature values in Cloud Storage
    /// bucket.
    /// Format: gs://<bucket_name>/<object_name>/anomalies.
    /// Example: gs://monitoring_bucket/feature_name/anomalies.
    /// Stats are stored as binary format with Protobuf message
    /// Anoamlies are stored as binary format with Protobuf message
    /// [tensorflow.metadata.v0.AnomalyInfo]
    /// (<https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto>).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub anomaly_uri: std::string::String,

    /// Deviation from the current stats to baseline stats.
    ///
    /// . For categorical feature, the distribution distance is calculated by
    ///   L-inifinity norm.
    /// . For numerical feature, the distribution distance is calculated by
    ///   Jensen–Shannon divergence.
    pub distribution_deviation: f64,

    /// This is the threshold used when detecting anomalies.
    /// The threshold can be changed by user, so this one might be different from
    /// [ThresholdConfig.value][google.cloud.aiplatform.v1.ThresholdConfig.value].
    ///
    /// [google.cloud.aiplatform.v1.ThresholdConfig.value]: crate::model::ThresholdConfig::threshold
    pub anomaly_detection_threshold: f64,

    /// The start timestamp of window where stats were generated.
    /// For objectives where time window doesn't make sense (e.g. Featurestore
    /// Snapshot Monitoring), start_time is only used to indicate the monitoring
    /// intervals, so it always equals to (end_time - monitoring_interval).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end timestamp of window where stats were generated.
    /// For objectives where time window doesn't make sense (e.g. Featurestore
    /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
    /// generate stats (e.g. timestamp we take snapshots for feature values).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl FeatureStatsAnomaly {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::FeatureStatsAnomaly::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [stats_uri][crate::model::FeatureStatsAnomaly::stats_uri].
    pub fn set_stats_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.stats_uri = v.into();
        self
    }

    /// Sets the value of [anomaly_uri][crate::model::FeatureStatsAnomaly::anomaly_uri].
    pub fn set_anomaly_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.anomaly_uri = v.into();
        self
    }

    /// Sets the value of [distribution_deviation][crate::model::FeatureStatsAnomaly::distribution_deviation].
    pub fn set_distribution_deviation<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.distribution_deviation = v.into();
        self
    }

    /// Sets the value of [anomaly_detection_threshold][crate::model::FeatureStatsAnomaly::anomaly_detection_threshold].
    pub fn set_anomaly_detection_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.anomaly_detection_threshold = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::FeatureStatsAnomaly::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::FeatureStatsAnomaly::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for FeatureStatsAnomaly {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureStatsAnomaly"
    }
}

/// Vertex AI Feature Online Store provides a centralized repository for serving
/// ML features and embedding indexes at low latency. The Feature Online Store is
/// a top-level container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureOnlineStore {
    /// Identifier. Name of the FeatureOnlineStore. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this FeatureOnlineStore was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this FeatureOnlineStore was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// FeatureOnlineStore.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one
    /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
    /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the featureOnlineStore.
    pub state: crate::model::feature_online_store::State,

    /// Optional. The dedicated serving endpoint for this FeatureOnlineStore, which
    /// is different from common Vertex service endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_serving_endpoint:
        std::option::Option<crate::model::feature_online_store::DedicatedServingEndpoint>,

    /// Optional. Customer-managed encryption key spec for data storage. If set,
    /// online store will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub storage_type: std::option::Option<crate::model::feature_online_store::StorageType>,
}

impl FeatureOnlineStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureOnlineStore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureOnlineStore::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeatureOnlineStore::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::FeatureOnlineStore::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::FeatureOnlineStore::state].
    pub fn set_state<T: std::convert::Into<crate::model::feature_online_store::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [dedicated_serving_endpoint][crate::model::FeatureOnlineStore::dedicated_serving_endpoint].
    pub fn set_dedicated_serving_endpoint<
        T: std::convert::Into<
            std::option::Option<crate::model::feature_online_store::DedicatedServingEndpoint>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_serving_endpoint = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::FeatureOnlineStore::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::FeatureOnlineStore::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::FeatureOnlineStore::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::FeatureOnlineStore::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `storage_type`.
    pub fn set_storage_type<
        T: std::convert::Into<std::option::Option<crate::model::feature_online_store::StorageType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// The value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// if it holds a `Bigtable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigtable(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_online_store::Bigtable>> {
        #[allow(unreachable_patterns)]
        self.storage_type.as_ref().and_then(|v| match v {
            crate::model::feature_online_store::StorageType::Bigtable(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// if it holds a `Optimized`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_optimized(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_online_store::Optimized>> {
        #[allow(unreachable_patterns)]
        self.storage_type.as_ref().and_then(|v| match v {
            crate::model::feature_online_store::StorageType::Optimized(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// to hold a `Bigtable`.
    ///
    /// Note that all the setters affecting `storage_type` are
    /// mutually exclusive.
    pub fn set_bigtable<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_online_store::Bigtable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = std::option::Option::Some(
            crate::model::feature_online_store::StorageType::Bigtable(v.into()),
        );
        self
    }

    /// Sets the value of [storage_type][crate::model::FeatureOnlineStore::storage_type]
    /// to hold a `Optimized`.
    ///
    /// Note that all the setters affecting `storage_type` are
    /// mutually exclusive.
    pub fn set_optimized<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_online_store::Optimized>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = std::option::Option::Some(
            crate::model::feature_online_store::StorageType::Optimized(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeatureOnlineStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore"
    }
}

/// Defines additional types related to FeatureOnlineStore
pub mod feature_online_store {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Bigtable {
        /// Required. Autoscaling config applied to Bigtable Instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub auto_scaling:
            std::option::Option<crate::model::feature_online_store::bigtable::AutoScaling>,
    }

    impl Bigtable {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [auto_scaling][crate::model::feature_online_store::Bigtable::auto_scaling].
        pub fn set_auto_scaling<
            T: std::convert::Into<
                std::option::Option<crate::model::feature_online_store::bigtable::AutoScaling>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auto_scaling = v.into();
            self
        }
    }

    impl wkt::message::Message for Bigtable {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable"
        }
    }

    /// Defines additional types related to Bigtable
    pub mod bigtable {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AutoScaling {
            /// Required. The minimum number of nodes to scale down to. Must be greater
            /// than or equal to 1.
            pub min_node_count: i32,

            /// Required. The maximum number of nodes to scale up to. Must be greater
            /// than or equal to min_node_count, and less than or equal to 10 times of
            /// 'min_node_count'.
            pub max_node_count: i32,

            /// Optional. A percentage of the cluster's CPU capacity. Can be from 10%
            /// to 80%. When a cluster's CPU utilization exceeds the target that you
            /// have set, Bigtable immediately adds nodes to the cluster. When CPU
            /// utilization is substantially lower than the target, Bigtable removes
            /// nodes. If not set will default to 50%.
            pub cpu_utilization_target: i32,
        }

        impl AutoScaling {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_node_count][crate::model::feature_online_store::bigtable::AutoScaling::min_node_count].
            pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.min_node_count = v.into();
                self
            }

            /// Sets the value of [max_node_count][crate::model::feature_online_store::bigtable::AutoScaling::max_node_count].
            pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_node_count = v.into();
                self
            }

            /// Sets the value of [cpu_utilization_target][crate::model::feature_online_store::bigtable::AutoScaling::cpu_utilization_target].
            pub fn set_cpu_utilization_target<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_utilization_target = v.into();
                self
            }
        }

        impl wkt::message::Message for AutoScaling {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable.AutoScaling"
            }
        }
    }

    /// Optimized storage type
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Optimized {}

    impl Optimized {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Optimized {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Optimized"
        }
    }

    /// The dedicated serving endpoint for this FeatureOnlineStore. Only need to
    /// set when you choose Optimized storage type. Public endpoint is provisioned
    /// by default.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DedicatedServingEndpoint {
        /// Output only. This field will be populated with the domain name to use for
        /// this FeatureOnlineStore
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub public_endpoint_domain_name: std::string::String,

        /// Optional. Private service connect config. The private service connection
        /// is available only for Optimized storage type, not for embedding
        /// management now. If
        /// [PrivateServiceConnectConfig.enable_private_service_connect][google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]
        /// set to true, customers will use private service connection to send
        /// request. Otherwise, the connection will set to public endpoint.
        ///
        /// [google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]: crate::model::PrivateServiceConnectConfig::enable_private_service_connect
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub private_service_connect_config:
            std::option::Option<crate::model::PrivateServiceConnectConfig>,

        /// Output only. The name of the service attachment resource. Populated if
        /// private service connect is enabled and after FeatureViewSync is created.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_attachment: std::string::String,
    }

    impl DedicatedServingEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [public_endpoint_domain_name][crate::model::feature_online_store::DedicatedServingEndpoint::public_endpoint_domain_name].
        pub fn set_public_endpoint_domain_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.public_endpoint_domain_name = v.into();
            self
        }

        /// Sets the value of [private_service_connect_config][crate::model::feature_online_store::DedicatedServingEndpoint::private_service_connect_config].
        pub fn set_private_service_connect_config<
            T: std::convert::Into<std::option::Option<crate::model::PrivateServiceConnectConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.private_service_connect_config = v.into();
            self
        }

        /// Sets the value of [service_attachment][crate::model::feature_online_store::DedicatedServingEndpoint::service_attachment].
        pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment = v.into();
            self
        }
    }

    impl wkt::message::Message for DedicatedServingEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.DedicatedServingEndpoint"
        }
    }

    /// Possible states a featureOnlineStore can have.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default value. This value is unused.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// State when the featureOnlineStore configuration is not being updated and
        /// the fields reflect the current configuration of the featureOnlineStore.
        /// The featureOnlineStore is usable in this state.
        pub const STABLE: State = State::new("STABLE");

        /// The state of the featureOnlineStore configuration when it is being
        /// updated. During an update, the fields reflect either the original
        /// configuration or the updated configuration of the featureOnlineStore. The
        /// featureOnlineStore is still usable in this state.
        pub const UPDATING: State = State::new("UPDATING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StorageType {
        /// Contains settings for the Cloud Bigtable instance that will be created
        /// to serve featureValues for all FeatureViews under this
        /// FeatureOnlineStore.
        Bigtable(std::boxed::Box<crate::model::feature_online_store::Bigtable>),
        /// Contains settings for the Optimized store that will be created
        /// to serve featureValues for all FeatureViews under this
        /// FeatureOnlineStore. When choose Optimized storage type, need to set
        /// [PrivateServiceConnectConfig.enable_private_service_connect][google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]
        /// to use private endpoint. Otherwise will use public endpoint by default.
        ///
        /// [google.cloud.aiplatform.v1.PrivateServiceConnectConfig.enable_private_service_connect]: crate::model::PrivateServiceConnectConfig::enable_private_service_connect
        Optimized(std::boxed::Box<crate::model::feature_online_store::Optimized>),
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.CreateFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::create_feature_online_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureOnlineStoreRequest {
    /// Required. The resource name of the Location to create FeatureOnlineStores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The FeatureOnlineStore to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_online_store: std::option::Option<crate::model::FeatureOnlineStore>,

    /// Required. The ID to use for this FeatureOnlineStore, which will become the
    /// final component of the FeatureOnlineStore's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_online_store_id: std::string::String,
}

impl CreateFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureOnlineStoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature_online_store][crate::model::CreateFeatureOnlineStoreRequest::feature_online_store].
    pub fn set_feature_online_store<
        T: std::convert::Into<std::option::Option<crate::model::FeatureOnlineStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_online_store = v.into();
        self
    }

    /// Sets the value of [feature_online_store_id][crate::model::CreateFeatureOnlineStoreRequest::feature_online_store_id].
    pub fn set_feature_online_store_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_online_store_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.GetFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::get_feature_online_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureOnlineStoreRequest {
    /// Required. The name of the FeatureOnlineStore resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureOnlineStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]: crate::client::FeatureOnlineStoreAdminService::list_feature_online_stores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureOnlineStoresRequest {
    /// Required. The resource name of the Location to list FeatureOnlineStores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureOnlineStores that match the filter expression. The
    /// following fields are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `labels`: Supports key-value equality and key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
    ///   FeatureOnlineStores created or updated after 2020-01-01.
    /// * `labels.env = "prod"`
    ///   FeatureOnlineStores with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureOnlineStores to return. The service may return
    /// fewer than this value. If unspecified, at most 100 FeatureOnlineStores will
    /// be returned. The maximum value is 100; any value greater than 100 will be
    /// coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]: crate::client::FeatureOnlineStoreAdminService::list_feature_online_stores
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported Fields:
    ///
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListFeatureOnlineStoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureOnlineStoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureOnlineStoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureOnlineStoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureOnlineStoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureOnlineStoresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFeatureOnlineStoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.ListFeatureOnlineStores][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureOnlineStores]: crate::client::FeatureOnlineStoreAdminService::list_feature_online_stores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureOnlineStoresResponse {
    /// The FeatureOnlineStores matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_online_stores: std::vec::Vec<crate::model::FeatureOnlineStore>,

    /// A token, which can be sent as
    /// [ListFeatureOnlineStoresRequest.page_token][google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest.page_token]: crate::model::ListFeatureOnlineStoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFeatureOnlineStoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureOnlineStoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_online_stores][crate::model::ListFeatureOnlineStoresResponse::feature_online_stores].
    pub fn set_feature_online_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureOnlineStore>,
    {
        use std::iter::Iterator;
        self.feature_online_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeatureOnlineStoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureOnlineStoresResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFeatureOnlineStoresResponse {
    type PageItem = crate::model::FeatureOnlineStore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_online_stores
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::update_feature_online_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureOnlineStoreRequest {
    /// Required. The FeatureOnlineStore's `name` field is used to identify the
    /// FeatureOnlineStore to be updated. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_online_store: std::option::Option<crate::model::FeatureOnlineStore>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// FeatureOnlineStore resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `description`
    /// * `bigtable`
    /// * `bigtable.auto_scaling`
    /// * `bigtable.enable_multi_region_replica`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_online_store][crate::model::UpdateFeatureOnlineStoreRequest::feature_online_store].
    pub fn set_feature_online_store<
        T: std::convert::Into<std::option::Option<crate::model::FeatureOnlineStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_online_store = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureOnlineStoreRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore]: crate::client::FeatureOnlineStoreAdminService::delete_feature_online_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureOnlineStoreRequest {
    /// Required. The name of the FeatureOnlineStore to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any FeatureViews and Features for this FeatureOnlineStore
    /// will also be deleted. (Otherwise, the request will only work if the
    /// FeatureOnlineStore has no FeatureViews.)
    pub force: bool,
}

impl DeleteFeatureOnlineStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureOnlineStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFeatureOnlineStoreRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeatureOnlineStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureOnlineStoreRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.CreateFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.CreateFeatureView]: crate::client::FeatureOnlineStoreAdminService::create_feature_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureViewRequest {
    /// Required. The resource name of the FeatureOnlineStore to create
    /// FeatureViews. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The FeatureView to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_view: std::option::Option<crate::model::FeatureView>,

    /// Required. The ID to use for the FeatureView, which will become the final
    /// component of the FeatureView's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within a FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view_id: std::string::String,

    /// Immutable. If set to true, one on demand sync will be run immediately,
    /// regardless whether the
    /// [FeatureView.sync_config][google.cloud.aiplatform.v1.FeatureView.sync_config]
    /// is configured or not.
    ///
    /// [google.cloud.aiplatform.v1.FeatureView.sync_config]: crate::model::FeatureView::sync_config
    pub run_sync_immediately: bool,
}

impl CreateFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature_view][crate::model::CreateFeatureViewRequest::feature_view].
    pub fn set_feature_view<
        T: std::convert::Into<std::option::Option<crate::model::FeatureView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [feature_view_id][crate::model::CreateFeatureViewRequest::feature_view_id].
    pub fn set_feature_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view_id = v.into();
        self
    }

    /// Sets the value of [run_sync_immediately][crate::model::CreateFeatureViewRequest::run_sync_immediately].
    pub fn set_run_sync_immediately<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_sync_immediately = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureViewRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.GetFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureView]: crate::client::FeatureOnlineStoreAdminService::get_feature_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureViewRequest {
    /// Required. The name of the FeatureView resource.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureViewRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]: crate::client::FeatureOnlineStoreAdminService::list_feature_views
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewsRequest {
    /// Required. The resource name of the FeatureOnlineStore to list FeatureViews.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureViews that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `labels`: Supports key-value equality as well as key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
    ///   update_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViews
    ///   created or updated after 2020-01-31T15:30:00.000000Z.
    /// * `labels.active = yes AND labels.env = prod` --> FeatureViews having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any FeatureView which has a label with 'env' as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureViews to return. The service may return fewer
    /// than this value. If unspecified, at most 1000 FeatureViews will be
    /// returned. The maximum value is 1000; any value greater than 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]: crate::client::FeatureOnlineStoreAdminService::list_feature_views
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `feature_view_id`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListFeatureViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureViewsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureViewsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFeatureViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewsRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.ListFeatureViews][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViews]: crate::client::FeatureOnlineStoreAdminService::list_feature_views
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewsResponse {
    /// The FeatureViews matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_views: std::vec::Vec<crate::model::FeatureView>,

    /// A token, which can be sent as
    /// [ListFeatureViewsRequest.page_token][google.cloud.aiplatform.v1.ListFeatureViewsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureViewsRequest.page_token]: crate::model::ListFeatureViewsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFeatureViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_views][crate::model::ListFeatureViewsResponse::feature_views].
    pub fn set_feature_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureView>,
    {
        use std::iter::Iterator;
        self.feature_views = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeatureViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFeatureViewsResponse {
    type PageItem = crate::model::FeatureView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_views
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.UpdateFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.UpdateFeatureView]: crate::client::FeatureOnlineStoreAdminService::update_feature_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureViewRequest {
    /// Required. The FeatureView's `name` field is used to identify the
    /// FeatureView to be updated. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_view: std::option::Option<crate::model::FeatureView>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// FeatureView resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `service_agent_type`
    /// * `big_query_source`
    /// * `big_query_source.uri`
    /// * `big_query_source.entity_id_columns`
    /// * `feature_registry_source`
    /// * `feature_registry_source.feature_groups`
    /// * `sync_config`
    /// * `sync_config.cron`
    /// * `optimized_config.automatic_resources`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::UpdateFeatureViewRequest::feature_view].
    pub fn set_feature_view<
        T: std::convert::Into<std::option::Option<crate::model::FeatureView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureViewRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureViewRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.DeleteFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.DeleteFeatureView]: crate::client::FeatureOnlineStoreAdminService::delete_feature_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureViewRequest {
    /// Required. The name of the FeatureView to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureViewRequest"
    }
}

/// Details of operations that perform create FeatureOnlineStore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureOnlineStoreOperationMetadata {
    /// Operation metadata for FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateFeatureOnlineStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureOnlineStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureOnlineStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOnlineStoreOperationMetadata"
    }
}

/// Details of operations that perform update FeatureOnlineStore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureOnlineStoreOperationMetadata {
    /// Operation metadata for FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateFeatureOnlineStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureOnlineStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureOnlineStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreOperationMetadata"
    }
}

/// Details of operations that perform create FeatureView.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureViewOperationMetadata {
    /// Operation metadata for FeatureView Create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateFeatureViewOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureViewOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureViewOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureViewOperationMetadata"
    }
}

/// Details of operations that perform update FeatureView.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureViewOperationMetadata {
    /// Operation metadata for FeatureView Update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateFeatureViewOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureViewOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureViewOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureViewOperationMetadata"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.SyncFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView]: crate::client::FeatureOnlineStoreAdminService::sync_feature_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncFeatureViewRequest {
    /// Required. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view: std::string::String,
}

impl SyncFeatureViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::SyncFeatureViewRequest::feature_view].
    pub fn set_feature_view<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view = v.into();
        self
    }
}

impl wkt::message::Message for SyncFeatureViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyncFeatureViewRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.SyncFeatureView][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.SyncFeatureView]: crate::client::FeatureOnlineStoreAdminService::sync_feature_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncFeatureViewResponse {
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view_sync: std::string::String,
}

impl SyncFeatureViewResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view_sync][crate::model::SyncFeatureViewResponse::feature_view_sync].
    pub fn set_feature_view_sync<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_view_sync = v.into();
        self
    }
}

impl wkt::message::Message for SyncFeatureViewResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyncFeatureViewResponse"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.GetFeatureViewSync][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureViewSync].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.GetFeatureViewSync]: crate::client::FeatureOnlineStoreAdminService::get_feature_view_sync
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureViewSyncRequest {
    /// Required. The name of the FeatureViewSync resource.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFeatureViewSyncRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureViewSyncRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeatureViewSyncRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureViewSyncRequest"
    }
}

/// Request message for
/// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]: crate::client::FeatureOnlineStoreAdminService::list_feature_view_syncs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewSyncsRequest {
    /// Required. The resource name of the FeatureView to list FeatureViewSyncs.
    /// Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureViewSyncs that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    ///
    /// Examples:
    ///
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViewSyncs
    ///   created after 2020-01-31T15:30:00.000000Z.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureViewSyncs to return. The service may return
    /// fewer than this value. If unspecified, at most 1000 FeatureViewSyncs will
    /// be returned. The maximum value is 1000; any value greater than 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]: crate::client::FeatureOnlineStoreAdminService::list_feature_view_syncs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `create_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListFeatureViewSyncsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureViewSyncsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureViewSyncsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureViewSyncsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureViewSyncsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureViewSyncsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFeatureViewSyncsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreAdminService.ListFeatureViewSyncs][google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreAdminService.ListFeatureViewSyncs]: crate::client::FeatureOnlineStoreAdminService::list_feature_view_syncs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureViewSyncsResponse {
    /// The FeatureViewSyncs matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_view_syncs: std::vec::Vec<crate::model::FeatureViewSync>,

    /// A token, which can be sent as
    /// [ListFeatureViewSyncsRequest.page_token][google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest.page_token]: crate::model::ListFeatureViewSyncsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFeatureViewSyncsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureViewSyncsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_view_syncs][crate::model::ListFeatureViewSyncsResponse::feature_view_syncs].
    pub fn set_feature_view_syncs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureViewSync>,
    {
        use std::iter::Iterator;
        self.feature_view_syncs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeatureViewSyncsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewSyncsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFeatureViewSyncsResponse {
    type PageItem = crate::model::FeatureViewSync;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_view_syncs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Lookup key for a feature view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureViewDataKey {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub key_oneof: std::option::Option<crate::model::feature_view_data_key::KeyOneof>,
}

impl FeatureViewDataKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `key_oneof`.
    pub fn set_key_oneof<
        T: std::convert::Into<std::option::Option<crate::model::feature_view_data_key::KeyOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_oneof = v.into();
        self
    }

    /// The value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// if it holds a `Key`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key_oneof.as_ref().and_then(|v| match v {
            crate::model::feature_view_data_key::KeyOneof::Key(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// if it holds a `CompositeKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_composite_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view_data_key::CompositeKey>>
    {
        #[allow(unreachable_patterns)]
        self.key_oneof.as_ref().and_then(|v| match v {
            crate::model::feature_view_data_key::KeyOneof::CompositeKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// to hold a `Key`.
    ///
    /// Note that all the setters affecting `key_oneof` are
    /// mutually exclusive.
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_oneof =
            std::option::Option::Some(crate::model::feature_view_data_key::KeyOneof::Key(v.into()));
        self
    }

    /// Sets the value of [key_oneof][crate::model::FeatureViewDataKey::key_oneof]
    /// to hold a `CompositeKey`.
    ///
    /// Note that all the setters affecting `key_oneof` are
    /// mutually exclusive.
    pub fn set_composite_key<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view_data_key::CompositeKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_oneof = std::option::Option::Some(
            crate::model::feature_view_data_key::KeyOneof::CompositeKey(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeatureViewDataKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDataKey"
    }
}

/// Defines additional types related to FeatureViewDataKey
pub mod feature_view_data_key {
    #[allow(unused_imports)]
    use super::*;

    /// ID that is comprised from several parts (columns).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CompositeKey {
        /// Parts to construct Entity ID. Should match with the same ID columns as
        /// defined in FeatureView in the same order.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub parts: std::vec::Vec<std::string::String>,
    }

    impl CompositeKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parts][crate::model::feature_view_data_key::CompositeKey::parts].
        pub fn set_parts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.parts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CompositeKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDataKey.CompositeKey"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum KeyOneof {
        /// String key to use for lookup.
        Key(std::string::String),
        /// The actual Entity ID will be composed from this struct. This should match
        /// with the way ID is defined in the FeatureView spec.
        CompositeKey(std::boxed::Box<crate::model::feature_view_data_key::CompositeKey>),
    }
}

/// Request message for
/// [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues].
/// All the features under the requested feature view will be returned.
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]: crate::client::FeatureOnlineStoreService::fetch_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchFeatureValuesRequest {
    /// Required. FeatureView resource format
    /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view: std::string::String,

    /// Optional. The request key to fetch feature values for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_key: std::option::Option<crate::model::FeatureViewDataKey>,

    /// Optional. Response data format. If not set,
    /// [FeatureViewDataFormat.KEY_VALUE][google.cloud.aiplatform.v1.FeatureViewDataFormat.KEY_VALUE]
    /// will be used.
    ///
    /// [google.cloud.aiplatform.v1.FeatureViewDataFormat.KEY_VALUE]: crate::model::feature_view_data_format::KEY_VALUE
    pub data_format: crate::model::FeatureViewDataFormat,
}

impl FetchFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::FetchFeatureValuesRequest::feature_view].
    pub fn set_feature_view<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [data_key][crate::model::FetchFeatureValuesRequest::data_key].
    pub fn set_data_key<
        T: std::convert::Into<std::option::Option<crate::model::FeatureViewDataKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_key = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::FetchFeatureValuesRequest::data_format].
    pub fn set_data_format<T: std::convert::Into<crate::model::FeatureViewDataFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }
}

impl wkt::message::Message for FetchFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesRequest"
    }
}

/// Response message for
/// [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]: crate::client::FeatureOnlineStoreService::fetch_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchFeatureValuesResponse {
    /// The data key associated with this response.
    /// Will only be populated for
    /// [FeatureOnlineStoreService.StreamingFetchFeatureValues][] RPCs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_key: std::option::Option<crate::model::FeatureViewDataKey>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub format: std::option::Option<crate::model::fetch_feature_values_response::Format>,
}

impl FetchFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_key][crate::model::FetchFeatureValuesResponse::data_key].
    pub fn set_data_key<
        T: std::convert::Into<std::option::Option<crate::model::FeatureViewDataKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_key = v.into();
        self
    }

    /// Sets the value of `format`.
    pub fn set_format<
        T: std::convert::Into<
            std::option::Option<crate::model::fetch_feature_values_response::Format>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// The value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// if it holds a `KeyValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_key_values(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::fetch_feature_values_response::FeatureNameValuePairList>,
    > {
        #[allow(unreachable_patterns)]
        self.format.as_ref().and_then(|v| match v {
            crate::model::fetch_feature_values_response::Format::KeyValues(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// if it holds a `ProtoStruct`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_proto_struct(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.format.as_ref().and_then(|v| match v {
            crate::model::fetch_feature_values_response::Format::ProtoStruct(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// to hold a `KeyValues`.
    ///
    /// Note that all the setters affecting `format` are
    /// mutually exclusive.
    pub fn set_key_values<
        T: std::convert::Into<
            std::boxed::Box<crate::model::fetch_feature_values_response::FeatureNameValuePairList>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format = std::option::Option::Some(
            crate::model::fetch_feature_values_response::Format::KeyValues(v.into()),
        );
        self
    }

    /// Sets the value of [format][crate::model::FetchFeatureValuesResponse::format]
    /// to hold a `ProtoStruct`.
    ///
    /// Note that all the setters affecting `format` are
    /// mutually exclusive.
    pub fn set_proto_struct<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = std::option::Option::Some(
            crate::model::fetch_feature_values_response::Format::ProtoStruct(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FetchFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse"
    }
}

/// Defines additional types related to FetchFeatureValuesResponse
pub mod fetch_feature_values_response {
    #[allow(unused_imports)]
    use super::*;

    /// Response structure in the format of key (feature name) and (feature) value
    /// pair.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureNameValuePairList {

        /// List of feature names and values.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub features: std::vec::Vec<crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair>,
    }

    impl FeatureNameValuePairList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [features][crate::model::fetch_feature_values_response::FeatureNameValuePairList::features].
        pub fn set_features<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair>
        {
            use std::iter::Iterator;
            self.features = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FeatureNameValuePairList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList"
        }
    }

    /// Defines additional types related to FeatureNameValuePairList
    pub mod feature_name_value_pair_list {
        #[allow(unused_imports)]
        use super::*;

        /// Feature name & value pair.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FeatureNameValuePair {

            /// Feature short name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub data: std::option::Option<crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data>,
        }

        impl FeatureNameValuePair {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of `data`.
            pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data>>>(mut self, v: T) -> Self
            {
                self.data = v.into();
                self
            }

            /// The value of [data][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::data]
            /// if it holds a `Value`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureValue>> {
                #[allow(unreachable_patterns)]
                self.data.as_ref().and_then(|v| match v {
                    crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data::Value(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [data][crate::model::fetch_feature_values_response::feature_name_value_pair_list::FeatureNameValuePair::data]
            /// to hold a `Value`.
            ///
            /// Note that all the setters affecting `data` are
            /// mutually exclusive.
            pub fn set_value<T: std::convert::Into<std::boxed::Box<crate::model::FeatureValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.data = std::option::Option::Some(
                    crate::model::fetch_feature_values_response::feature_name_value_pair_list::feature_name_value_pair::Data::Value(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for FeatureNameValuePair {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair"
            }
        }

        /// Defines additional types related to FeatureNameValuePair
        pub mod feature_name_value_pair {
            #[allow(unused_imports)]
            use super::*;

            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Data {
                /// Feature value.
                Value(std::boxed::Box<crate::model::FeatureValue>),
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Format {
        /// Feature values in KeyValue format.
        KeyValues(
            std::boxed::Box<crate::model::fetch_feature_values_response::FeatureNameValuePairList>,
        ),
        /// Feature values in proto Struct format.
        ProtoStruct(std::boxed::Box<wkt::Struct>),
    }
}

/// A query to find a number of similar entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NearestNeighborQuery {
    /// Optional. The number of similar entities to be retrieved from feature view
    /// for each query.
    pub neighbor_count: i32,

    /// Optional. The list of string filters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub string_filters: std::vec::Vec<crate::model::nearest_neighbor_query::StringFilter>,

    /// Optional. The list of numeric filters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub numeric_filters: std::vec::Vec<crate::model::nearest_neighbor_query::NumericFilter>,

    /// Optional. Crowding is a constraint on a neighbor list produced by nearest
    /// neighbor search requiring that no more than
    /// sper_crowding_attribute_neighbor_count of the k neighbors returned have the
    /// same value of crowding_attribute. It's used for improving result diversity.
    pub per_crowding_attribute_neighbor_count: i32,

    /// Optional. Parameters that can be set to tune query on the fly.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::nearest_neighbor_query::Parameters>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::nearest_neighbor_query::Instance>,
}

impl NearestNeighborQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbor_count][crate::model::NearestNeighborQuery::neighbor_count].
    pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.neighbor_count = v.into();
        self
    }

    /// Sets the value of [per_crowding_attribute_neighbor_count][crate::model::NearestNeighborQuery::per_crowding_attribute_neighbor_count].
    pub fn set_per_crowding_attribute_neighbor_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_crowding_attribute_neighbor_count = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::NearestNeighborQuery::parameters].
    pub fn set_parameters<
        T: std::convert::Into<std::option::Option<crate::model::nearest_neighbor_query::Parameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [string_filters][crate::model::NearestNeighborQuery::string_filters].
    pub fn set_string_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nearest_neighbor_query::StringFilter>,
    {
        use std::iter::Iterator;
        self.string_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [numeric_filters][crate::model::NearestNeighborQuery::numeric_filters].
    pub fn set_numeric_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nearest_neighbor_query::NumericFilter>,
    {
        use std::iter::Iterator;
        self.numeric_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `instance`.
    pub fn set_instance<
        T: std::convert::Into<std::option::Option<crate::model::nearest_neighbor_query::Instance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// The value of [instance][crate::model::NearestNeighborQuery::instance]
    /// if it holds a `EntityId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_entity_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::nearest_neighbor_query::Instance::EntityId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [instance][crate::model::NearestNeighborQuery::instance]
    /// if it holds a `Embedding`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_embedding(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::nearest_neighbor_query::Embedding>>
    {
        #[allow(unreachable_patterns)]
        self.instance.as_ref().and_then(|v| match v {
            crate::model::nearest_neighbor_query::Instance::Embedding(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance][crate::model::NearestNeighborQuery::instance]
    /// to hold a `EntityId`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::nearest_neighbor_query::Instance::EntityId(v.into()),
        );
        self
    }

    /// Sets the value of [instance][crate::model::NearestNeighborQuery::instance]
    /// to hold a `Embedding`.
    ///
    /// Note that all the setters affecting `instance` are
    /// mutually exclusive.
    pub fn set_embedding<
        T: std::convert::Into<std::boxed::Box<crate::model::nearest_neighbor_query::Embedding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance = std::option::Option::Some(
            crate::model::nearest_neighbor_query::Instance::Embedding(v.into()),
        );
        self
    }
}

impl wkt::message::Message for NearestNeighborQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery"
    }
}

/// Defines additional types related to NearestNeighborQuery
pub mod nearest_neighbor_query {
    #[allow(unused_imports)]
    use super::*;

    /// The embedding vector.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Embedding {
        /// Optional. Individual value in the embedding.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub value: std::vec::Vec<f32>,
    }

    impl Embedding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::Embedding::value].
        pub fn set_value<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.value = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Embedding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.Embedding"
        }
    }

    /// String filter is used to search a subset of the entities by using boolean
    /// rules on string columns.
    /// For example: if a query specifies string filter
    /// with 'name = color, allow_tokens = {red, blue}, deny_tokens = {purple}','
    /// then that query will match entities that are red or blue, but if those
    /// points are also purple, then they will be excluded even if they are
    /// red/blue. Only string filter is supported for now, numeric filter will be
    /// supported in the near future.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StringFilter {
        /// Required. Column names in BigQuery that used as filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. The allowed tokens.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allow_tokens: std::vec::Vec<std::string::String>,

        /// Optional. The denied tokens.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub deny_tokens: std::vec::Vec<std::string::String>,
    }

    impl StringFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::nearest_neighbor_query::StringFilter::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [allow_tokens][crate::model::nearest_neighbor_query::StringFilter::allow_tokens].
        pub fn set_allow_tokens<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allow_tokens = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [deny_tokens][crate::model::nearest_neighbor_query::StringFilter::deny_tokens].
        pub fn set_deny_tokens<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.deny_tokens = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.StringFilter"
        }
    }

    /// Numeric filter is used to search a subset of the entities by using boolean
    /// rules on numeric columns.
    /// For example:
    /// Database Point 0: {name: "a" value_int: 42} {name: "b" value_float: 1.0}
    /// Database Point 1:  {name: "a" value_int: 10} {name: "b" value_float: 2.0}
    /// Database Point 2: {name: "a" value_int: -1} {name: "b" value_float: 3.0}
    /// Query: {name: "a" value_int: 12 operator: LESS}    // Matches Point 1, 2
    /// {name: "b" value_float: 2.0 operator: EQUAL} // Matches Point 1
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericFilter {
        /// Required. Column name in BigQuery that used as filters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. This MUST be specified for queries and must NOT be specified
        /// for database points.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub op: std::option::Option<crate::model::nearest_neighbor_query::numeric_filter::Operator>,

        /// The type of Value must be consistent for all datapoints with a given
        /// name.  This is verified at runtime.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::nearest_neighbor_query::numeric_filter::Value>,
    }

    impl NumericFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::nearest_neighbor_query::NumericFilter::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [op][crate::model::nearest_neighbor_query::NumericFilter::op].
        pub fn set_op<
            T: std::convert::Into<
                std::option::Option<crate::model::nearest_neighbor_query::numeric_filter::Operator>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.op = v.into();
            self
        }

        /// Sets the value of `value`.
        pub fn set_value<
            T: std::convert::Into<
                std::option::Option<crate::model::nearest_neighbor_query::numeric_filter::Value>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// if it holds a `ValueInt`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value_int(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueInt(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// if it holds a `ValueFloat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value_float(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueFloat(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// if it holds a `ValueDouble`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value_double(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueDouble(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// to hold a `ValueInt`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_int<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueInt(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// to hold a `ValueFloat`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueFloat(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::nearest_neighbor_query::NumericFilter::value]
        /// to hold a `ValueDouble`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::nearest_neighbor_query::numeric_filter::Value::ValueDouble(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for NumericFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.NumericFilter"
        }
    }

    /// Defines additional types related to NumericFilter
    pub mod numeric_filter {
        #[allow(unused_imports)]
        use super::*;

        /// Datapoints for which Operator is true relative to the query's Value
        /// field will be allowlisted.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Operator(std::borrow::Cow<'static, str>);

        impl Operator {
            /// Creates a new Operator instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Operator](Operator)
        pub mod operator {
            use super::Operator;

            /// Unspecified operator.
            pub const OPERATOR_UNSPECIFIED: Operator = Operator::new("OPERATOR_UNSPECIFIED");

            /// Entities are eligible if their value is < the query's.
            pub const LESS: Operator = Operator::new("LESS");

            /// Entities are eligible if their value is <= the query's.
            pub const LESS_EQUAL: Operator = Operator::new("LESS_EQUAL");

            /// Entities are eligible if their value is == the query's.
            pub const EQUAL: Operator = Operator::new("EQUAL");

            /// Entities are eligible if their value is >= the query's.
            pub const GREATER_EQUAL: Operator = Operator::new("GREATER_EQUAL");

            /// Entities are eligible if their value is > the query's.
            pub const GREATER: Operator = Operator::new("GREATER");

            /// Entities are eligible if their value is != the query's.
            pub const NOT_EQUAL: Operator = Operator::new("NOT_EQUAL");
        }

        impl std::convert::From<std::string::String> for Operator {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// The type of Value must be consistent for all datapoints with a given
        /// name.  This is verified at runtime.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// int value type.
            ValueInt(i64),
            /// float value type.
            ValueFloat(f32),
            /// double value type.
            ValueDouble(f64),
        }
    }

    /// Parameters that can be overrided in each query to tune query latency and
    /// recall.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Parameters {
        /// Optional. The number of neighbors to find via approximate search before
        /// exact reordering is performed; if set, this value must be >
        /// neighbor_count.
        pub approximate_neighbor_candidates: i32,

        /// Optional. The fraction of the number of leaves to search, set at query
        /// time allows user to tune search performance. This value increase result
        /// in both search accuracy and latency increase. The value should be between
        /// 0.0 and 1.0.
        pub leaf_nodes_search_fraction: f64,
    }

    impl Parameters {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [approximate_neighbor_candidates][crate::model::nearest_neighbor_query::Parameters::approximate_neighbor_candidates].
        pub fn set_approximate_neighbor_candidates<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.approximate_neighbor_candidates = v.into();
            self
        }

        /// Sets the value of [leaf_nodes_search_fraction][crate::model::nearest_neighbor_query::Parameters::leaf_nodes_search_fraction].
        pub fn set_leaf_nodes_search_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.leaf_nodes_search_fraction = v.into();
            self
        }
    }

    impl wkt::message::Message for Parameters {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.Parameters"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Instance {
        /// Optional. The entity id whose similar entities should be searched for.
        /// If embedding is set, search will use embedding instead of
        /// entity_id.
        EntityId(std::string::String),
        /// Optional. The embedding vector that be used for similar search.
        Embedding(std::boxed::Box<crate::model::nearest_neighbor_query::Embedding>),
    }
}

/// The request message for
/// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities].
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]: crate::client::FeatureOnlineStoreService::search_nearest_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchNearestEntitiesRequest {
    /// Required. FeatureView resource format
    /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_view: std::string::String,

    /// Required. The query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::NearestNeighborQuery>,

    /// Optional. If set to true, the full entities (including all vector values
    /// and metadata) of the nearest neighbors are returned; otherwise only entity
    /// id of the nearest neighbors will be returned. Note that returning full
    /// entities will significantly increase the latency and cost of the query.
    pub return_full_entity: bool,
}

impl SearchNearestEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_view][crate::model::SearchNearestEntitiesRequest::feature_view].
    pub fn set_feature_view<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_view = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchNearestEntitiesRequest::query].
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::NearestNeighborQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [return_full_entity][crate::model::SearchNearestEntitiesRequest::return_full_entity].
    pub fn set_return_full_entity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_full_entity = v.into();
        self
    }
}

impl wkt::message::Message for SearchNearestEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchNearestEntitiesRequest"
    }
}

/// Nearest neighbors for one query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NearestNeighbors {
    /// All its neighbors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub neighbors: std::vec::Vec<crate::model::nearest_neighbors::Neighbor>,
}

impl NearestNeighbors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neighbors][crate::model::NearestNeighbors::neighbors].
    pub fn set_neighbors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nearest_neighbors::Neighbor>,
    {
        use std::iter::Iterator;
        self.neighbors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NearestNeighbors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighbors"
    }
}

/// Defines additional types related to NearestNeighbors
pub mod nearest_neighbors {
    #[allow(unused_imports)]
    use super::*;

    /// A neighbor of the query vector.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Neighbor {
        /// The id of the similar entity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_id: std::string::String,

        /// The distance between the neighbor and the query vector.
        pub distance: f64,

        /// The attributes of the neighbor, e.g. filters, crowding and metadata
        /// Note that full entities are returned only when "return_full_entity"
        /// is set to true. Otherwise, only the "entity_id" and "distance" fields
        /// are populated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub entity_key_values: std::option::Option<crate::model::FetchFeatureValuesResponse>,
    }

    impl Neighbor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::nearest_neighbors::Neighbor::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [distance][crate::model::nearest_neighbors::Neighbor::distance].
        pub fn set_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.distance = v.into();
            self
        }

        /// Sets the value of [entity_key_values][crate::model::nearest_neighbors::Neighbor::entity_key_values].
        pub fn set_entity_key_values<
            T: std::convert::Into<std::option::Option<crate::model::FetchFeatureValuesResponse>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entity_key_values = v.into();
            self
        }
    }

    impl wkt::message::Message for Neighbor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighbors.Neighbor"
        }
    }
}

/// Response message for
/// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
///
/// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]: crate::client::FeatureOnlineStoreService::search_nearest_entities
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchNearestEntitiesResponse {
    /// The nearest neighbors of the query entity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nearest_neighbors: std::option::Option<crate::model::NearestNeighbors>,
}

impl SearchNearestEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nearest_neighbors][crate::model::SearchNearestEntitiesResponse::nearest_neighbors].
    pub fn set_nearest_neighbors<
        T: std::convert::Into<std::option::Option<crate::model::NearestNeighbors>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nearest_neighbors = v.into();
        self
    }
}

impl wkt::message::Message for SearchNearestEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchNearestEntitiesResponse"
    }
}

/// Request message for
/// [FeatureRegistryService.CreateFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeatureGroup]: crate::client::FeatureRegistryService::create_feature_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureGroupRequest {
    /// Required. The resource name of the Location to create FeatureGroups.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The FeatureGroup to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_group: std::option::Option<crate::model::FeatureGroup>,

    /// Required. The ID to use for this FeatureGroup, which will become the final
    /// component of the FeatureGroup's resource name.
    ///
    /// This value may be up to 128 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_group_id: std::string::String,
}

impl CreateFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature_group][crate::model::CreateFeatureGroupRequest::feature_group].
    pub fn set_feature_group<
        T: std::convert::Into<std::option::Option<crate::model::FeatureGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_group = v.into();
        self
    }

    /// Sets the value of [feature_group_id][crate::model::CreateFeatureGroupRequest::feature_group_id].
    pub fn set_feature_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_group_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureGroupRequest"
    }
}

/// Request message for
/// [FeatureRegistryService.GetFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.GetFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.GetFeatureGroup]: crate::client::FeatureRegistryService::get_feature_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureGroupRequest {
    /// Required. The name of the FeatureGroup resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureGroupRequest"
    }
}

/// Request message for
/// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]: crate::client::FeatureRegistryService::list_feature_groups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureGroupsRequest {
    /// Required. The resource name of the Location to list FeatureGroups.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the FeatureGroups that match the filter expression. The
    /// following fields are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `labels`: Supports key-value equality and key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
    ///   FeatureGroups created or updated after 2020-01-01.
    /// * `labels.env = "prod"`
    ///   FeatureGroups with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of FeatureGroups to return. The service may return
    /// fewer than this value. If unspecified, at most 100 FeatureGroups will
    /// be returned. The maximum value is 100; any value greater than 100 will be
    /// coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]: crate::client::FeatureRegistryService::list_feature_groups
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported Fields:
    ///
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListFeatureGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeatureGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeatureGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeatureGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeatureGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeatureGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFeatureGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureGroupsRequest"
    }
}

/// Response message for
/// [FeatureRegistryService.ListFeatureGroups][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatureGroups]: crate::client::FeatureRegistryService::list_feature_groups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeatureGroupsResponse {
    /// The FeatureGroups matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_groups: std::vec::Vec<crate::model::FeatureGroup>,

    /// A token, which can be sent as
    /// [ListFeatureGroupsRequest.page_token][google.cloud.aiplatform.v1.ListFeatureGroupsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeatureGroupsRequest.page_token]: crate::model::ListFeatureGroupsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFeatureGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeatureGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [feature_groups][crate::model::ListFeatureGroupsResponse::feature_groups].
    pub fn set_feature_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureGroup>,
    {
        use std::iter::Iterator;
        self.feature_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeatureGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureGroupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFeatureGroupsResponse {
    type PageItem = crate::model::FeatureGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feature_groups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeatureRegistryService.UpdateFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeatureGroup]: crate::client::FeatureRegistryService::update_feature_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureGroupRequest {
    /// Required. The FeatureGroup's `name` field is used to identify the
    /// FeatureGroup to be updated. Format:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_group: std::option::Option<crate::model::FeatureGroup>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// FeatureGroup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `description`
    /// * `big_query`
    /// * `big_query.entity_id_columns`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_group][crate::model::UpdateFeatureGroupRequest::feature_group].
    pub fn set_feature_group<
        T: std::convert::Into<std::option::Option<crate::model::FeatureGroup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_group = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureGroupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureGroupRequest"
    }
}

/// Request message for
/// [FeatureRegistryService.DeleteFeatureGroup][google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeatureGroup].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeatureGroup]: crate::client::FeatureRegistryService::delete_feature_group
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureGroupRequest {
    /// Required. The name of the FeatureGroup to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any Features under this FeatureGroup
    /// will also be deleted. (Otherwise, the request will only work if the
    /// FeatureGroup has no Features.)
    pub force: bool,
}

impl DeleteFeatureGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFeatureGroupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeatureGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureGroupRequest"
    }
}

/// Details of operations that perform create FeatureGroup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureGroupOperationMetadata {
    /// Operation metadata for FeatureGroup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateFeatureGroupOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureGroupOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureGroupOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureGroupOperationMetadata"
    }
}

/// Details of operations that perform update FeatureGroup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureGroupOperationMetadata {
    /// Operation metadata for FeatureGroup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateFeatureGroupOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureGroupOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureGroupOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureGroupOperationMetadata"
    }
}

/// Details of operations that perform create FeatureGroup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRegistryFeatureOperationMetadata {
    /// Operation metadata for Feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateRegistryFeatureOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateRegistryFeatureOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateRegistryFeatureOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRegistryFeatureOperationMetadata"
    }
}

/// Details of operations that perform update Feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureOperationMetadata {
    /// Operation metadata for Feature Update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateFeatureOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeatureOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOperationMetadata"
    }
}

/// Matcher for Features of an EntityType by Feature ID.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IdMatcher {
    /// Required. The following are accepted as `ids`:
    ///
    /// * A single-element list containing only `*`, which selects all Features
    ///   in the target EntityType, or
    /// * A list containing only Feature IDs, which selects only Features with
    ///   those IDs in the target EntityType.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ids: std::vec::Vec<std::string::String>,
}

impl IdMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ids][crate::model::IdMatcher::ids].
    pub fn set_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IdMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IdMatcher"
    }
}

/// Selector for Features of an EntityType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureSelector {
    /// Required. Matches Features based on ID.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub id_matcher: std::option::Option<crate::model::IdMatcher>,
}

impl FeatureSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_matcher][crate::model::FeatureSelector::id_matcher].
    pub fn set_id_matcher<T: std::convert::Into<std::option::Option<crate::model::IdMatcher>>>(
        mut self,
        v: T,
    ) -> Self {
        self.id_matcher = v.into();
        self
    }
}

impl wkt::message::Message for FeatureSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureSelector"
    }
}

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureView {
    /// Identifier. Name of the FeatureView. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this FeatureView was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this FeatureView was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// FeatureViews.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one
    /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
    /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Configures when data is to be synced/updated for this FeatureView. At the
    /// end of the sync the latest featureValues for each entityId of this
    /// FeatureView are made ready for online serving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sync_config: std::option::Option<crate::model::feature_view::SyncConfig>,

    /// Optional. Configuration for index preparation for vector search. It
    /// contains the required configurations to create an index from source data,
    /// so that approximate nearest neighbor (a.k.a ANN) algorithms search can be
    /// performed during online serving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_config: std::option::Option<crate::model::feature_view::IndexConfig>,

    /// Optional. Configuration for FeatureView created under Optimized
    /// FeatureOnlineStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub optimized_config: std::option::Option<crate::model::feature_view::OptimizedConfig>,

    /// Optional. Service agent type used during data sync. By default, the Vertex
    /// AI Service Agent is used. When using an IAM Policy to isolate this
    /// FeatureView within a project, a separate service account should be
    /// provisioned by setting this field to `SERVICE_AGENT_TYPE_FEATURE_VIEW`.
    /// This will generate a separate service account to access the BigQuery source
    /// table.
    pub service_agent_type: crate::model::feature_view::ServiceAgentType,

    /// Output only. A Service Account unique to this FeatureView. The role
    /// bigquery.dataViewer should be granted to this service account to allow
    /// Vertex AI Feature Store to sync data to the online store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::feature_view::Source>,
}

impl FeatureView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureView::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeatureView::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::FeatureView::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [sync_config][crate::model::FeatureView::sync_config].
    pub fn set_sync_config<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::SyncConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_config = v.into();
        self
    }

    /// Sets the value of [index_config][crate::model::FeatureView::index_config].
    pub fn set_index_config<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::IndexConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_config = v.into();
        self
    }

    /// Sets the value of [optimized_config][crate::model::FeatureView::optimized_config].
    pub fn set_optimized_config<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::OptimizedConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.optimized_config = v.into();
        self
    }

    /// Sets the value of [service_agent_type][crate::model::FeatureView::service_agent_type].
    pub fn set_service_agent_type<
        T: std::convert::Into<crate::model::feature_view::ServiceAgentType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_agent_type = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::FeatureView::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::FeatureView::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::FeatureView::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::FeatureView::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::feature_view::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::FeatureView::source]
    /// if it holds a `BigQuerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_big_query_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_view::Source::BigQuerySource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::FeatureView::source]
    /// if it holds a `FeatureRegistrySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_feature_registry_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view::FeatureRegistrySource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_view::Source::FeatureRegistrySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::FeatureView::source]
    /// if it holds a `VertexRagSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_rag_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::feature_view::VertexRagSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::feature_view::Source::VertexRagSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::FeatureView::source]
    /// to hold a `BigQuerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_source<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::feature_view::Source::BigQuerySource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::FeatureView::source]
    /// to hold a `FeatureRegistrySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_feature_registry_source<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view::FeatureRegistrySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::feature_view::Source::FeatureRegistrySource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::FeatureView::source]
    /// to hold a `VertexRagSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_source<
        T: std::convert::Into<std::boxed::Box<crate::model::feature_view::VertexRagSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::feature_view::Source::VertexRagSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeatureView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView"
    }
}

/// Defines additional types related to FeatureView
pub mod feature_view {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQuerySource {
        /// Required. The BigQuery view URI that will be materialized on each sync
        /// trigger based on FeatureView.SyncConfig.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// Required. Columns to construct entity_id / row keys.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub entity_id_columns: std::vec::Vec<std::string::String>,
    }

    impl BigQuerySource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::feature_view::BigQuerySource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [entity_id_columns][crate::model::feature_view::BigQuerySource::entity_id_columns].
        pub fn set_entity_id_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_id_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BigQuerySource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.BigQuerySource"
        }
    }

    /// Configuration for Sync. Only one option is set.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SyncConfig {
        /// Cron schedule (<https://en.wikipedia.org/wiki/Cron>) to launch scheduled
        /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
        /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
        /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
        /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
        /// "TZ=America/New_York 1 * * * *".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cron: std::string::String,

        /// Optional. If true, syncs the FeatureView in a continuous manner to Online
        /// Store.
        pub continuous: bool,
    }

    impl SyncConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cron][crate::model::feature_view::SyncConfig::cron].
        pub fn set_cron<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cron = v.into();
            self
        }

        /// Sets the value of [continuous][crate::model::feature_view::SyncConfig::continuous].
        pub fn set_continuous<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.continuous = v.into();
            self
        }
    }

    impl wkt::message::Message for SyncConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.SyncConfig"
        }
    }

    /// Configuration for vector indexing.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexConfig {
        /// Optional. Column of embedding. This column contains the source data to
        /// create index for vector search. embedding_column must be set when using
        /// vector search.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub embedding_column: std::string::String,

        /// Optional. Columns of features that're used to filter vector search
        /// results.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub filter_columns: std::vec::Vec<std::string::String>,

        /// Optional. Column of crowding. This column contains crowding attribute
        /// which is a constraint on a neighbor list produced by
        /// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
        /// to diversify search results. If
        /// [NearestNeighborQuery.per_crowding_attribute_neighbor_count][google.cloud.aiplatform.v1.NearestNeighborQuery.per_crowding_attribute_neighbor_count]
        /// is set to K in
        /// [SearchNearestEntitiesRequest][google.cloud.aiplatform.v1.SearchNearestEntitiesRequest],
        /// it's guaranteed that no more than K entities of the same crowding
        /// attribute are returned in the response.
        ///
        /// [google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]: crate::client::FeatureOnlineStoreService::search_nearest_entities
        /// [google.cloud.aiplatform.v1.NearestNeighborQuery.per_crowding_attribute_neighbor_count]: crate::model::NearestNeighborQuery::per_crowding_attribute_neighbor_count
        /// [google.cloud.aiplatform.v1.SearchNearestEntitiesRequest]: crate::model::SearchNearestEntitiesRequest
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub crowding_column: std::string::String,

        /// Optional. The number of dimensions of the input embedding.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub embedding_dimension: std::option::Option<i32>,

        /// Optional. The distance measure used in nearest neighbor search.
        pub distance_measure_type: crate::model::feature_view::index_config::DistanceMeasureType,

        /// The configuration with regard to the algorithms used for efficient
        /// search.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub algorithm_config:
            std::option::Option<crate::model::feature_view::index_config::AlgorithmConfig>,
    }

    impl IndexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [embedding_column][crate::model::feature_view::IndexConfig::embedding_column].
        pub fn set_embedding_column<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.embedding_column = v.into();
            self
        }

        /// Sets the value of [crowding_column][crate::model::feature_view::IndexConfig::crowding_column].
        pub fn set_crowding_column<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.crowding_column = v.into();
            self
        }

        /// Sets the value of [embedding_dimension][crate::model::feature_view::IndexConfig::embedding_dimension].
        pub fn set_embedding_dimension<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.embedding_dimension = v.into();
            self
        }

        /// Sets the value of [distance_measure_type][crate::model::feature_view::IndexConfig::distance_measure_type].
        pub fn set_distance_measure_type<
            T: std::convert::Into<crate::model::feature_view::index_config::DistanceMeasureType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.distance_measure_type = v.into();
            self
        }

        /// Sets the value of [filter_columns][crate::model::feature_view::IndexConfig::filter_columns].
        pub fn set_filter_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.filter_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of `algorithm_config`.
        pub fn set_algorithm_config<
            T: std::convert::Into<
                std::option::Option<crate::model::feature_view::index_config::AlgorithmConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.algorithm_config = v.into();
            self
        }

        /// The value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// if it holds a `TreeAhConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_tree_ah_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::feature_view::index_config::TreeAHConfig>,
        > {
            #[allow(unreachable_patterns)]
            self.algorithm_config.as_ref().and_then(|v| match v {
                crate::model::feature_view::index_config::AlgorithmConfig::TreeAhConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// if it holds a `BruteForceConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_brute_force_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::feature_view::index_config::BruteForceConfig>,
        > {
            #[allow(unreachable_patterns)]
            self.algorithm_config.as_ref().and_then(|v| match v {
                crate::model::feature_view::index_config::AlgorithmConfig::BruteForceConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// to hold a `TreeAhConfig`.
        ///
        /// Note that all the setters affecting `algorithm_config` are
        /// mutually exclusive.
        pub fn set_tree_ah_config<
            T: std::convert::Into<
                std::boxed::Box<crate::model::feature_view::index_config::TreeAHConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.algorithm_config = std::option::Option::Some(
                crate::model::feature_view::index_config::AlgorithmConfig::TreeAhConfig(v.into()),
            );
            self
        }

        /// Sets the value of [algorithm_config][crate::model::feature_view::IndexConfig::algorithm_config]
        /// to hold a `BruteForceConfig`.
        ///
        /// Note that all the setters affecting `algorithm_config` are
        /// mutually exclusive.
        pub fn set_brute_force_config<
            T: std::convert::Into<
                std::boxed::Box<crate::model::feature_view::index_config::BruteForceConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.algorithm_config = std::option::Option::Some(
                crate::model::feature_view::index_config::AlgorithmConfig::BruteForceConfig(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for IndexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig"
        }
    }

    /// Defines additional types related to IndexConfig
    pub mod index_config {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration options for using brute force search.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BruteForceConfig {}

        impl BruteForceConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for BruteForceConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig.BruteForceConfig"
            }
        }

        /// Configuration options for the tree-AH algorithm.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TreeAHConfig {
            /// Optional. Number of embeddings on each leaf node. The default value is
            /// 1000 if not set.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub leaf_node_embedding_count: std::option::Option<i64>,
        }

        impl TreeAHConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [leaf_node_embedding_count][crate::model::feature_view::index_config::TreeAHConfig::leaf_node_embedding_count].
            pub fn set_leaf_node_embedding_count<
                T: std::convert::Into<std::option::Option<i64>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.leaf_node_embedding_count = v.into();
                self
            }
        }

        impl wkt::message::Message for TreeAHConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig.TreeAHConfig"
            }
        }

        /// The distance measure used in nearest neighbor search.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct DistanceMeasureType(std::borrow::Cow<'static, str>);

        impl DistanceMeasureType {
            /// Creates a new DistanceMeasureType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [DistanceMeasureType](DistanceMeasureType)
        pub mod distance_measure_type {
            use super::DistanceMeasureType;

            /// Should not be set.
            pub const DISTANCE_MEASURE_TYPE_UNSPECIFIED: DistanceMeasureType =
                DistanceMeasureType::new("DISTANCE_MEASURE_TYPE_UNSPECIFIED");

            /// Euclidean (L_2) Distance.
            pub const SQUARED_L2_DISTANCE: DistanceMeasureType =
                DistanceMeasureType::new("SQUARED_L2_DISTANCE");

            /// Cosine Distance. Defined as 1 - cosine similarity.
            ///
            /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
            /// of COSINE distance. Our algorithms have been more optimized for
            /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
            /// mathematically equivalent to COSINE distance and results in the same
            /// ranking.
            pub const COSINE_DISTANCE: DistanceMeasureType =
                DistanceMeasureType::new("COSINE_DISTANCE");

            /// Dot Product Distance. Defined as a negative of the dot product.
            pub const DOT_PRODUCT_DISTANCE: DistanceMeasureType =
                DistanceMeasureType::new("DOT_PRODUCT_DISTANCE");
        }

        impl std::convert::From<std::string::String> for DistanceMeasureType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// The configuration with regard to the algorithms used for efficient
        /// search.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum AlgorithmConfig {
            /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
            ///
            /// + Asymmetric Hashing). Please refer to this paper for more details:
            ///   <https://arxiv.org/abs/1908.10396>
            TreeAhConfig(std::boxed::Box<crate::model::feature_view::index_config::TreeAHConfig>),
            /// Optional. Configuration options for using brute force search, which
            /// simply implements the standard linear search in the database for each
            /// query. It is primarily meant for benchmarking and to generate the
            /// ground truth for approximate search.
            BruteForceConfig(
                std::boxed::Box<crate::model::feature_view::index_config::BruteForceConfig>,
            ),
        }
    }

    /// A Feature Registry source for features that need to be synced to Online
    /// Store.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureRegistrySource {
        /// Required. List of features that need to be synced to Online Store.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub feature_groups:
            std::vec::Vec<crate::model::feature_view::feature_registry_source::FeatureGroup>,

        /// Optional. The project number of the parent project of the Feature Groups.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub project_number: std::option::Option<i64>,
    }

    impl FeatureRegistrySource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_number][crate::model::feature_view::FeatureRegistrySource::project_number].
        pub fn set_project_number<T: std::convert::Into<std::option::Option<i64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.project_number = v.into();
            self
        }

        /// Sets the value of [feature_groups][crate::model::feature_view::FeatureRegistrySource::feature_groups].
        pub fn set_feature_groups<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::feature_view::feature_registry_source::FeatureGroup,
            >,
        {
            use std::iter::Iterator;
            self.feature_groups = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FeatureRegistrySource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource"
        }
    }

    /// Defines additional types related to FeatureRegistrySource
    pub mod feature_registry_source {
        #[allow(unused_imports)]
        use super::*;

        /// Features belonging to a single feature group that will be
        /// synced to Online Store.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FeatureGroup {
            /// Required. Identifier of the feature group.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub feature_group_id: std::string::String,

            /// Required. Identifiers of features under the feature group.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub feature_ids: std::vec::Vec<std::string::String>,
        }

        impl FeatureGroup {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [feature_group_id][crate::model::feature_view::feature_registry_source::FeatureGroup::feature_group_id].
            pub fn set_feature_group_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.feature_group_id = v.into();
                self
            }

            /// Sets the value of [feature_ids][crate::model::feature_view::feature_registry_source::FeatureGroup::feature_ids].
            pub fn set_feature_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.feature_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for FeatureGroup {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource.FeatureGroup"
            }
        }
    }

    /// A Vertex Rag source for features that need to be synced to Online
    /// Store.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexRagSource {
        /// Required. The BigQuery view/table URI that will be materialized on each
        /// manual sync trigger. The table/view is expected to have the following
        /// columns and types at least:
        ///
        /// - `corpus_id` (STRING, NULLABLE/REQUIRED)
        /// - `file_id` (STRING, NULLABLE/REQUIRED)
        /// - `chunk_id` (STRING, NULLABLE/REQUIRED)
        /// - `chunk_data_type` (STRING, NULLABLE/REQUIRED)
        /// - `chunk_data` (STRING, NULLABLE/REQUIRED)
        /// - `embeddings` (FLOAT, REPEATED)
        /// - `file_original_uri` (STRING, NULLABLE/REQUIRED)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// Optional. The RAG corpus id corresponding to this FeatureView.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub rag_corpus_id: i64,
    }

    impl VertexRagSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::feature_view::VertexRagSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [rag_corpus_id][crate::model::feature_view::VertexRagSource::rag_corpus_id].
        pub fn set_rag_corpus_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.rag_corpus_id = v.into();
            self
        }
    }

    impl wkt::message::Message for VertexRagSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.VertexRagSource"
        }
    }

    /// Configuration for FeatureViews created in Optimized FeatureOnlineStore.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OptimizedConfig {
        /// Optional. A description of resources that the FeatureView uses, which to
        /// large degree are decided by Vertex AI, and optionally allows only a
        /// modest additional configuration. If min_replica_count is not set, the
        /// default value is 2. If max_replica_count is not set, the default value
        /// is 6. The max allowed replica count is 1000.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub automatic_resources: std::option::Option<crate::model::AutomaticResources>,
    }

    impl OptimizedConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [automatic_resources][crate::model::feature_view::OptimizedConfig::automatic_resources].
        pub fn set_automatic_resources<
            T: std::convert::Into<std::option::Option<crate::model::AutomaticResources>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.automatic_resources = v.into();
            self
        }
    }

    impl wkt::message::Message for OptimizedConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.OptimizedConfig"
        }
    }

    /// Service agent type used during data sync.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ServiceAgentType(std::borrow::Cow<'static, str>);

    impl ServiceAgentType {
        /// Creates a new ServiceAgentType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ServiceAgentType](ServiceAgentType)
    pub mod service_agent_type {
        use super::ServiceAgentType;

        /// By default, the project-level Vertex AI Service Agent is enabled.
        pub const SERVICE_AGENT_TYPE_UNSPECIFIED: ServiceAgentType =
            ServiceAgentType::new("SERVICE_AGENT_TYPE_UNSPECIFIED");

        /// Indicates the project-level Vertex AI Service Agent
        /// (<https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents>)
        /// will be used during sync jobs.
        pub const SERVICE_AGENT_TYPE_PROJECT: ServiceAgentType =
            ServiceAgentType::new("SERVICE_AGENT_TYPE_PROJECT");

        /// Enable a FeatureView service account to be created by Vertex AI and
        /// output in the field `service_account_email`. This service account will
        /// be used to read from the source BigQuery table during sync.
        pub const SERVICE_AGENT_TYPE_FEATURE_VIEW: ServiceAgentType =
            ServiceAgentType::new("SERVICE_AGENT_TYPE_FEATURE_VIEW");
    }

    impl std::convert::From<std::string::String> for ServiceAgentType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Configures how data is supposed to be extracted from a BigQuery
        /// source to be loaded onto the FeatureOnlineStore.
        BigQuerySource(std::boxed::Box<crate::model::feature_view::BigQuerySource>),
        /// Optional. Configures the features from a Feature Registry source that
        /// need to be loaded onto the FeatureOnlineStore.
        FeatureRegistrySource(std::boxed::Box<crate::model::feature_view::FeatureRegistrySource>),
        /// Optional. The Vertex RAG Source that the FeatureView is linked to.
        VertexRagSource(std::boxed::Box<crate::model::feature_view::VertexRagSource>),
    }
}

/// FeatureViewSync is a representation of sync operation which copies data from
/// data source to Feature View in Online Store.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureViewSync {
    /// Identifier. Name of the FeatureViewSync. Format:
    /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Time when this FeatureViewSync is created. Creation of a
    /// FeatureViewSync means that the job is pending / waiting for sufficient
    /// resources but may not have started the actual data transfer yet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this FeatureViewSync is finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub run_time: std::option::Option<gtype::model::Interval>,

    /// Output only. Final status of the FeatureViewSync.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_status: std::option::Option<rpc::model::Status>,

    /// Output only. Summary of the sync job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sync_summary: std::option::Option<crate::model::feature_view_sync::SyncSummary>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl FeatureViewSync {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeatureViewSync::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeatureViewSync::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [run_time][crate::model::FeatureViewSync::run_time].
    pub fn set_run_time<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.run_time = v.into();
        self
    }

    /// Sets the value of [final_status][crate::model::FeatureViewSync::final_status].
    pub fn set_final_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.final_status = v.into();
        self
    }

    /// Sets the value of [sync_summary][crate::model::FeatureViewSync::sync_summary].
    pub fn set_sync_summary<
        T: std::convert::Into<std::option::Option<crate::model::feature_view_sync::SyncSummary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_summary = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::FeatureViewSync::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::FeatureViewSync::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for FeatureViewSync {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewSync"
    }
}

/// Defines additional types related to FeatureViewSync
pub mod feature_view_sync {
    #[allow(unused_imports)]
    use super::*;

    /// Summary from the Sync job. For continuous syncs, the summary is updated
    /// periodically. For batch syncs, it gets updated on completion of the sync.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SyncSummary {
        /// Output only. Total number of rows synced.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub row_synced: i64,

        /// Output only. BigQuery slot milliseconds consumed for the sync job.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_slot: i64,

        /// Lower bound of the system time watermark for the sync job. This is only
        /// set for continuously syncing feature views.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub system_watermark_time: std::option::Option<wkt::Timestamp>,
    }

    impl SyncSummary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_synced][crate::model::feature_view_sync::SyncSummary::row_synced].
        pub fn set_row_synced<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.row_synced = v.into();
            self
        }

        /// Sets the value of [total_slot][crate::model::feature_view_sync::SyncSummary::total_slot].
        pub fn set_total_slot<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_slot = v.into();
            self
        }

        /// Sets the value of [system_watermark_time][crate::model::feature_view_sync::SyncSummary::system_watermark_time].
        pub fn set_system_watermark_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.system_watermark_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SyncSummary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewSync.SyncSummary"
        }
    }
}

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features. The Featurestore is a top-level container
/// for your features and their values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Featurestore {
    /// Output only. Name of the Featurestore. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this Featurestore was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Featurestore was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. The labels with user-defined metadata to organize your
    /// Featurestore.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information on and examples of labels.
    /// No more than 64 user labels can be associated with one Featurestore(System
    /// labels are excluded)."
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Config for online storage resources. The field should not
    /// co-exist with the field of `OnlineStoreReplicationConfig`. If both of it
    /// and OnlineStoreReplicationConfig are unset, the feature store will not have
    /// an online store and cannot be used for online serving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub online_serving_config: std::option::Option<crate::model::featurestore::OnlineServingConfig>,

    /// Output only. State of the featurestore.
    pub state: crate::model::featurestore::State,

    /// Optional. TTL in days for feature values that will be stored in online
    /// serving storage. The Feature Store online storage periodically removes
    /// obsolete feature values older than `online_storage_ttl_days` since the
    /// feature generation time. Note that `online_storage_ttl_days` should be less
    /// than or equal to `offline_storage_ttl_days` for each EntityType under a
    /// featurestore. If not set, default to 4000 days
    pub online_storage_ttl_days: i32,

    /// Optional. Customer-managed encryption key spec for data storage. If set,
    /// both of the online and offline data storage will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl Featurestore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Featurestore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Featurestore::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Featurestore::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Featurestore::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [online_serving_config][crate::model::Featurestore::online_serving_config].
    pub fn set_online_serving_config<
        T: std::convert::Into<std::option::Option<crate::model::featurestore::OnlineServingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.online_serving_config = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Featurestore::state].
    pub fn set_state<T: std::convert::Into<crate::model::featurestore::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [online_storage_ttl_days][crate::model::Featurestore::online_storage_ttl_days].
    pub fn set_online_storage_ttl_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.online_storage_ttl_days = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Featurestore::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Featurestore::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Featurestore::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Featurestore::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Featurestore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore"
    }
}

/// Defines additional types related to Featurestore
pub mod featurestore {
    #[allow(unused_imports)]
    use super::*;

    /// OnlineServingConfig specifies the details for provisioning online serving
    /// resources.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OnlineServingConfig {
        /// The number of nodes for the online store. The number of nodes doesn't
        /// scale automatically, but you can manually update the number of
        /// nodes. If set to 0, the featurestore will not have an
        /// online store and cannot be used for online serving.
        pub fixed_node_count: i32,

        /// Online serving scaling configuration.
        /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
        /// reset the other.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub scaling:
            std::option::Option<crate::model::featurestore::online_serving_config::Scaling>,
    }

    impl OnlineServingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [fixed_node_count][crate::model::featurestore::OnlineServingConfig::fixed_node_count].
        pub fn set_fixed_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.fixed_node_count = v.into();
            self
        }

        /// Sets the value of [scaling][crate::model::featurestore::OnlineServingConfig::scaling].
        pub fn set_scaling<
            T: std::convert::Into<
                std::option::Option<crate::model::featurestore::online_serving_config::Scaling>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scaling = v.into();
            self
        }
    }

    impl wkt::message::Message for OnlineServingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig"
        }
    }

    /// Defines additional types related to OnlineServingConfig
    pub mod online_serving_config {
        #[allow(unused_imports)]
        use super::*;

        /// Online serving scaling configuration. If min_node_count and
        /// max_node_count are set to the same value, the cluster will be configured
        /// with the fixed number of node (no auto-scaling).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Scaling {
            /// Required. The minimum number of nodes to scale down to. Must be greater
            /// than or equal to 1.
            pub min_node_count: i32,

            /// The maximum number of nodes to scale up to. Must be greater than
            /// min_node_count, and less than or equal to 10 times of 'min_node_count'.
            pub max_node_count: i32,

            /// Optional. The cpu utilization that the Autoscaler should be trying to
            /// achieve. This number is on a scale from 0 (no utilization) to 100
            /// (total utilization), and is limited between 10 and 80. When a cluster's
            /// CPU utilization exceeds the target that you have set, Bigtable
            /// immediately adds nodes to the cluster. When CPU utilization is
            /// substantially lower than the target, Bigtable removes nodes. If not set
            /// or set to 0, default to 50.
            pub cpu_utilization_target: i32,
        }

        impl Scaling {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_node_count][crate::model::featurestore::online_serving_config::Scaling::min_node_count].
            pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.min_node_count = v.into();
                self
            }

            /// Sets the value of [max_node_count][crate::model::featurestore::online_serving_config::Scaling::max_node_count].
            pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_node_count = v.into();
                self
            }

            /// Sets the value of [cpu_utilization_target][crate::model::featurestore::online_serving_config::Scaling::cpu_utilization_target].
            pub fn set_cpu_utilization_target<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_utilization_target = v.into();
                self
            }
        }

        impl wkt::message::Message for Scaling {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig.Scaling"
            }
        }
    }

    /// Possible states a featurestore can have.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Default value. This value is unused.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// State when the featurestore configuration is not being updated and the
        /// fields reflect the current configuration of the featurestore. The
        /// featurestore is usable in this state.
        pub const STABLE: State = State::new("STABLE");

        /// The state of the featurestore configuration when it is being updated.
        /// During an update, the fields reflect either the original configuration
        /// or the updated configuration of the featurestore. For example,
        /// `online_serving_config.fixed_node_count` can take minutes to update.
        /// While the update is in progress, the featurestore is in the UPDATING
        /// state, and the value of `fixed_node_count` can be the original value or
        /// the updated value, depending on the progress of the operation. Until the
        /// update completes, the actual number of nodes can still be the original
        /// value of `fixed_node_count`. The featurestore is still usable in this
        /// state.
        pub const UPDATING: State = State::new("UPDATING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Configuration of how features in Featurestore are monitored.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeaturestoreMonitoringConfig {
    /// The config for Snapshot Analysis Based Feature Monitoring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_analysis:
        std::option::Option<crate::model::featurestore_monitoring_config::SnapshotAnalysis>,

    /// The config for ImportFeatures Analysis Based Feature Monitoring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_features_analysis:
        std::option::Option<crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis>,

    /// Threshold for numerical features of anomaly detection.
    /// This is shared by all objectives of Featurestore Monitoring for numerical
    /// features (i.e. Features with type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) DOUBLE
    /// or INT64).
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub numerical_threshold_config:
        std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,

    /// Threshold for categorical features of anomaly detection.
    /// This is shared by all types of Featurestore Monitoring for categorical
    /// features (i.e. Features with type
    /// ([Feature.ValueType][google.cloud.aiplatform.v1.Feature.ValueType]) BOOL or
    /// STRING).
    ///
    /// [google.cloud.aiplatform.v1.Feature.ValueType]: crate::model::feature::ValueType
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub categorical_threshold_config:
        std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,
}

impl FeaturestoreMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot_analysis][crate::model::FeaturestoreMonitoringConfig::snapshot_analysis].
    pub fn set_snapshot_analysis<
        T: std::convert::Into<
            std::option::Option<crate::model::featurestore_monitoring_config::SnapshotAnalysis>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_analysis = v.into();
        self
    }

    /// Sets the value of [import_features_analysis][crate::model::FeaturestoreMonitoringConfig::import_features_analysis].
    pub fn set_import_features_analysis<
        T: std::convert::Into<
            std::option::Option<
                crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_features_analysis = v.into();
        self
    }

    /// Sets the value of [numerical_threshold_config][crate::model::FeaturestoreMonitoringConfig::numerical_threshold_config].
    pub fn set_numerical_threshold_config<
        T: std::convert::Into<
            std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.numerical_threshold_config = v.into();
        self
    }

    /// Sets the value of [categorical_threshold_config][crate::model::FeaturestoreMonitoringConfig::categorical_threshold_config].
    pub fn set_categorical_threshold_config<
        T: std::convert::Into<
            std::option::Option<crate::model::featurestore_monitoring_config::ThresholdConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.categorical_threshold_config = v.into();
        self
    }
}

impl wkt::message::Message for FeaturestoreMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig"
    }
}

/// Defines additional types related to FeaturestoreMonitoringConfig
pub mod featurestore_monitoring_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
    /// This type of analysis generates statistics for each Feature based on a
    /// snapshot of the latest feature value of each entities every
    /// monitoring_interval.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SnapshotAnalysis {
        /// The monitoring schedule for snapshot analysis.
        /// For EntityType-level config:
        /// unset / disabled = true indicates disabled by
        /// default for Features under it; otherwise by default enable snapshot
        /// analysis monitoring with monitoring_interval for Features under it.
        /// Feature-level config:
        /// disabled = true indicates disabled regardless of the EntityType-level
        /// config; unset monitoring_interval indicates going with EntityType-level
        /// config; otherwise run snapshot analysis monitoring with
        /// monitoring_interval regardless of the EntityType-level config.
        /// Explicitly Disable the snapshot analysis based monitoring.
        pub disabled: bool,

        /// Configuration of the snapshot analysis based monitoring pipeline
        /// running interval. The value indicates number of days.
        pub monitoring_interval_days: i32,

        /// Customized export features time window for snapshot analysis. Unit is one
        /// day. Default value is 3 weeks. Minimum value is 1 day. Maximum value is
        /// 4000 days.
        pub staleness_days: i32,
    }

    impl SnapshotAnalysis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disabled][crate::model::featurestore_monitoring_config::SnapshotAnalysis::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [monitoring_interval_days][crate::model::featurestore_monitoring_config::SnapshotAnalysis::monitoring_interval_days].
        pub fn set_monitoring_interval_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.monitoring_interval_days = v.into();
            self
        }

        /// Sets the value of [staleness_days][crate::model::featurestore_monitoring_config::SnapshotAnalysis::staleness_days].
        pub fn set_staleness_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.staleness_days = v.into();
            self
        }
    }

    impl wkt::message::Message for SnapshotAnalysis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis"
        }
    }

    /// Configuration of the Featurestore's ImportFeature Analysis Based
    /// Monitoring. This type of analysis generates statistics for values of each
    /// Feature imported by every
    /// [ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]
    /// operation.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImportFeaturesAnalysis {
        /// Whether to enable / disable / inherite default hebavior for import
        /// features analysis.
        pub state: crate::model::featurestore_monitoring_config::import_features_analysis::State,

        /// The baseline used to do anomaly detection for the statistics generated by
        /// import features analysis.
        pub anomaly_detection_baseline:
            crate::model::featurestore_monitoring_config::import_features_analysis::Baseline,
    }

    impl ImportFeaturesAnalysis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis::state].
        pub fn set_state<
            T: std::convert::Into<
                crate::model::featurestore_monitoring_config::import_features_analysis::State,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [anomaly_detection_baseline][crate::model::featurestore_monitoring_config::ImportFeaturesAnalysis::anomaly_detection_baseline].
        pub fn set_anomaly_detection_baseline<
            T: std::convert::Into<
                crate::model::featurestore_monitoring_config::import_features_analysis::Baseline,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.anomaly_detection_baseline = v.into();
            self
        }
    }

    impl wkt::message::Message for ImportFeaturesAnalysis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis"
        }
    }

    /// Defines additional types related to ImportFeaturesAnalysis
    pub mod import_features_analysis {
        #[allow(unused_imports)]
        use super::*;

        /// The state defines whether to enable ImportFeature analysis.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct State(std::borrow::Cow<'static, str>);

        impl State {
            /// Creates a new State instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [State](State)
        pub mod state {
            use super::State;

            /// Should not be used.
            pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

            /// The default behavior of whether to enable the monitoring.
            /// EntityType-level config: disabled.
            /// Feature-level config: inherited from the configuration of EntityType
            /// this Feature belongs to.
            pub const DEFAULT: State = State::new("DEFAULT");

            /// Explicitly enables import features analysis.
            /// EntityType-level config: by default enables import features analysis
            /// for all Features under it. Feature-level config: enables import
            /// features analysis regardless of the EntityType-level config.
            pub const ENABLED: State = State::new("ENABLED");

            /// Explicitly disables import features analysis.
            /// EntityType-level config: by default disables import features analysis
            /// for all Features under it. Feature-level config: disables import
            /// features analysis regardless of the EntityType-level config.
            pub const DISABLED: State = State::new("DISABLED");
        }

        impl std::convert::From<std::string::String> for State {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// Defines the baseline to do anomaly detection for feature values imported
        /// by each
        /// [ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]
        /// operation.
        ///
        /// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Baseline(std::borrow::Cow<'static, str>);

        impl Baseline {
            /// Creates a new Baseline instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Baseline](Baseline)
        pub mod baseline {
            use super::Baseline;

            /// Should not be used.
            pub const BASELINE_UNSPECIFIED: Baseline = Baseline::new("BASELINE_UNSPECIFIED");

            /// Choose the later one statistics generated by either most recent
            /// snapshot analysis or previous import features analysis. If non of them
            /// exists, skip anomaly detection and only generate a statistics.
            pub const LATEST_STATS: Baseline = Baseline::new("LATEST_STATS");

            /// Use the statistics generated by the most recent snapshot analysis if
            /// exists.
            pub const MOST_RECENT_SNAPSHOT_STATS: Baseline =
                Baseline::new("MOST_RECENT_SNAPSHOT_STATS");

            /// Use the statistics generated by the previous import features analysis
            /// if exists.
            pub const PREVIOUS_IMPORT_FEATURES_STATS: Baseline =
                Baseline::new("PREVIOUS_IMPORT_FEATURES_STATS");
        }

        impl std::convert::From<std::string::String> for Baseline {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// The config for Featurestore Monitoring threshold.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ThresholdConfig {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub threshold: std::option::Option<
            crate::model::featurestore_monitoring_config::threshold_config::Threshold,
        >,
    }

    impl ThresholdConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `threshold`.
        pub fn set_threshold<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::featurestore_monitoring_config::threshold_config::Threshold,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.threshold = v.into();
            self
        }

        /// The value of [threshold][crate::model::featurestore_monitoring_config::ThresholdConfig::threshold]
        /// if it holds a `Value`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.threshold.as_ref().and_then(|v| match v {
                crate::model::featurestore_monitoring_config::threshold_config::Threshold::Value(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [threshold][crate::model::featurestore_monitoring_config::ThresholdConfig::threshold]
        /// to hold a `Value`.
        ///
        /// Note that all the setters affecting `threshold` are
        /// mutually exclusive.
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.threshold = std::option::Option::Some(
                crate::model::featurestore_monitoring_config::threshold_config::Threshold::Value(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ThresholdConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ThresholdConfig"
        }
    }

    /// Defines additional types related to ThresholdConfig
    pub mod threshold_config {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Threshold {
            /// Specify a threshold value that can trigger the alert.
            ///
            /// . For categorical feature, the distribution distance is calculated by
            ///   L-inifinity norm.
            /// . For numerical feature, the distribution distance is calculated by
            ///   Jensen–Shannon divergence. Each feature must have a non-zero threshold
            ///   if they need to be monitored. Otherwise no alert will be triggered for
            ///   that feature.
            Value(f64),
        }
    }
}

/// Request message for
/// [FeaturestoreOnlineServingService.WriteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues]: crate::client::FeaturestoreOnlineServingService::write_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteFeatureValuesRequest {
    /// Required. The resource name of the EntityType for the entities being
    /// written. Value format:
    /// `projects/{project}/locations/{location}/featurestores/
    /// {featurestore}/entityTypes/{entityType}`. For example,
    /// for a machine learning model predicting user clicks on a website, an
    /// EntityType ID could be `user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. The entities to be written. Up to 100,000 feature values can be
    /// written across all `payloads`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub payloads: std::vec::Vec<crate::model::WriteFeatureValuesPayload>,
}

impl WriteFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::WriteFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [payloads][crate::model::WriteFeatureValuesRequest::payloads].
    pub fn set_payloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WriteFeatureValuesPayload>,
    {
        use std::iter::Iterator;
        self.payloads = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WriteFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesRequest"
    }
}

/// Contains Feature values to be written for a specific entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteFeatureValuesPayload {
    /// Required. The ID of the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    /// Required. Feature values to be written, mapping from Feature ID to value.
    /// Up to 100,000 `feature_values` entries may be written across all payloads.
    /// The feature generation time, aligned by days, must be no older than five
    /// years (1825 days) and no later than one year (366 days) in the future.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub feature_values: std::collections::HashMap<std::string::String, crate::model::FeatureValue>,
}

impl WriteFeatureValuesPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_id][crate::model::WriteFeatureValuesPayload::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [feature_values][crate::model::WriteFeatureValuesPayload::feature_values].
    pub fn set_feature_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::FeatureValue>,
    {
        use std::iter::Iterator;
        self.feature_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for WriteFeatureValuesPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesPayload"
    }
}

/// Response message for
/// [FeaturestoreOnlineServingService.WriteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.WriteFeatureValues]: crate::client::FeaturestoreOnlineServingService::write_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteFeatureValuesResponse {}

impl WriteFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for WriteFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesResponse"
    }
}

/// Request message for
/// [FeaturestoreOnlineServingService.ReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues]: crate::client::FeaturestoreOnlineServingService::read_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadFeatureValuesRequest {
    /// Required. The resource name of the EntityType for the entity being read.
    /// Value format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
    /// For example, for a machine learning model predicting user clicks on a
    /// website, an EntityType ID could be `user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. ID for a specific entity. For example,
    /// for a machine learning model predicting user clicks on a website, an entity
    /// ID could be `user_123`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    /// Required. Selector choosing Features of the target EntityType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_selector: std::option::Option<crate::model::FeatureSelector>,
}

impl ReadFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::ReadFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::ReadFeatureValuesRequest::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [feature_selector][crate::model::ReadFeatureValuesRequest::feature_selector].
    pub fn set_feature_selector<
        T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_selector = v.into();
        self
    }
}

impl wkt::message::Message for ReadFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesRequest"
    }
}

/// Response message for
/// [FeaturestoreOnlineServingService.ReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.ReadFeatureValues]: crate::client::FeaturestoreOnlineServingService::read_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadFeatureValuesResponse {
    /// Response header.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub header: std::option::Option<crate::model::read_feature_values_response::Header>,

    /// Entity view with Feature values. This may be the entity in the
    /// Featurestore if values for all Features were requested, or a projection
    /// of the entity in the Featurestore if values for only some Features were
    /// requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_view: std::option::Option<crate::model::read_feature_values_response::EntityView>,
}

impl ReadFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [header][crate::model::ReadFeatureValuesResponse::header].
    pub fn set_header<
        T: std::convert::Into<std::option::Option<crate::model::read_feature_values_response::Header>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.header = v.into();
        self
    }

    /// Sets the value of [entity_view][crate::model::ReadFeatureValuesResponse::entity_view].
    pub fn set_entity_view<
        T: std::convert::Into<
            std::option::Option<crate::model::read_feature_values_response::EntityView>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_view = v.into();
        self
    }
}

impl wkt::message::Message for ReadFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse"
    }
}

/// Defines additional types related to ReadFeatureValuesResponse
pub mod read_feature_values_response {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata for requested Features.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureDescriptor {
        /// Feature ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,
    }

    impl FeatureDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::read_feature_values_response::FeatureDescriptor::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for FeatureDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.FeatureDescriptor"
        }
    }

    /// Response header with metadata for the requested
    /// [ReadFeatureValuesRequest.entity_type][google.cloud.aiplatform.v1.ReadFeatureValuesRequest.entity_type]
    /// and Features.
    ///
    /// [google.cloud.aiplatform.v1.ReadFeatureValuesRequest.entity_type]: crate::model::ReadFeatureValuesRequest::entity_type
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Header {
        /// The resource name of the EntityType from the
        /// [ReadFeatureValuesRequest][google.cloud.aiplatform.v1.ReadFeatureValuesRequest].
        /// Value format:
        /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
        ///
        /// [google.cloud.aiplatform.v1.ReadFeatureValuesRequest]: crate::model::ReadFeatureValuesRequest
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_type: std::string::String,

        /// List of Feature metadata corresponding to each piece of
        /// [ReadFeatureValuesResponse.EntityView.data][google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.data].
        ///
        /// [google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.data]: crate::model::read_feature_values_response::EntityView::data
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub feature_descriptors:
            std::vec::Vec<crate::model::read_feature_values_response::FeatureDescriptor>,
    }

    impl Header {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_type][crate::model::read_feature_values_response::Header::entity_type].
        pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_type = v.into();
            self
        }

        /// Sets the value of [feature_descriptors][crate::model::read_feature_values_response::Header::feature_descriptors].
        pub fn set_feature_descriptors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::read_feature_values_response::FeatureDescriptor>,
        {
            use std::iter::Iterator;
            self.feature_descriptors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Header {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.Header"
        }
    }

    /// Entity view with Feature values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EntityView {
        /// ID of the requested entity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_id: std::string::String,

        /// Each piece of data holds the k
        /// requested values for one requested Feature. If no values
        /// for the requested Feature exist, the corresponding cell will be empty.
        /// This has the same size and is in the same order as the features from the
        /// header
        /// [ReadFeatureValuesResponse.header][google.cloud.aiplatform.v1.ReadFeatureValuesResponse.header].
        ///
        /// [google.cloud.aiplatform.v1.ReadFeatureValuesResponse.header]: crate::model::ReadFeatureValuesResponse::header
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub data: std::vec::Vec<crate::model::read_feature_values_response::entity_view::Data>,
    }

    impl EntityView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::read_feature_values_response::EntityView::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [data][crate::model::read_feature_values_response::EntityView::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::read_feature_values_response::entity_view::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EntityView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView"
        }
    }

    /// Defines additional types related to EntityView
    pub mod entity_view {
        #[allow(unused_imports)]
        use super::*;

        /// Container to hold value(s), successive in time, for one Feature from the
        /// request.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Data {
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub data: std::option::Option<
                crate::model::read_feature_values_response::entity_view::data::Data,
            >,
        }

        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of `data`.
            pub fn set_data<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::read_feature_values_response::entity_view::data::Data,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.data = v.into();
                self
            }

            /// The value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// if it holds a `Value`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureValue>> {
                #[allow(unreachable_patterns)]
                self.data.as_ref().and_then(|v| match v {
                    crate::model::read_feature_values_response::entity_view::data::Data::Value(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// if it holds a `Values`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_values(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::FeatureValueList>> {
                #[allow(unreachable_patterns)]
                self.data.as_ref().and_then(|v| match v {
                    crate::model::read_feature_values_response::entity_view::data::Data::Values(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// to hold a `Value`.
            ///
            /// Note that all the setters affecting `data` are
            /// mutually exclusive.
            pub fn set_value<T: std::convert::Into<std::boxed::Box<crate::model::FeatureValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.data = std::option::Option::Some(
                    crate::model::read_feature_values_response::entity_view::data::Data::Value(
                        v.into(),
                    ),
                );
                self
            }

            /// Sets the value of [data][crate::model::read_feature_values_response::entity_view::Data::data]
            /// to hold a `Values`.
            ///
            /// Note that all the setters affecting `data` are
            /// mutually exclusive.
            pub fn set_values<
                T: std::convert::Into<std::boxed::Box<crate::model::FeatureValueList>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.data = std::option::Option::Some(
                    crate::model::read_feature_values_response::entity_view::data::Data::Values(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.Data"
            }
        }

        /// Defines additional types related to Data
        pub mod data {
            #[allow(unused_imports)]
            use super::*;

            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Data {
                /// Feature value if a single value is requested.
                Value(std::boxed::Box<crate::model::FeatureValue>),
                /// Feature values list if values, successive in time, are requested.
                /// If the requested number of values is greater than the number of
                /// existing Feature values, nonexistent values are omitted instead of
                /// being returned as empty.
                Values(std::boxed::Box<crate::model::FeatureValueList>),
            }
        }
    }
}

/// Request message for
/// [FeaturestoreOnlineServingService.StreamingReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreOnlineServingService.StreamingReadFeatureValues].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingReadFeatureValuesRequest {
    /// Required. The resource name of the entities' type.
    /// Value format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
    /// For example,
    /// for a machine learning model predicting user clicks on a website, an
    /// EntityType ID could be `user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. IDs of entities to read Feature values of. The maximum number of
    /// IDs is 100. For example, for a machine learning model predicting user
    /// clicks on a website, an entity ID could be `user_123`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_ids: std::vec::Vec<std::string::String>,

    /// Required. Selector choosing Features of the target EntityType. Feature IDs
    /// will be deduplicated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_selector: std::option::Option<crate::model::FeatureSelector>,
}

impl StreamingReadFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::StreamingReadFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [feature_selector][crate::model::StreamingReadFeatureValuesRequest::feature_selector].
    pub fn set_feature_selector<
        T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_selector = v.into();
        self
    }

    /// Sets the value of [entity_ids][crate::model::StreamingReadFeatureValuesRequest::entity_ids].
    pub fn set_entity_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entity_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingReadFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingReadFeatureValuesRequest"
    }
}

/// Value for a feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureValue {
    /// Metadata of feature value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::feature_value::Metadata>,

    /// Value for the feature.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::feature_value::Value>,
}

impl FeatureValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata][crate::model::FeatureValue::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::feature_value::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::feature_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `BoolArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BoolArray>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::BoolArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `DoubleArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DoubleArray>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::DoubleArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `Int64ArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int64_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Int64Array>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::Int64ArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `StringArrayValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_array_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StringArray>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::StringArrayValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `BytesValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bytes_value(&self) -> std::option::Option<&bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::BytesValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::FeatureValue::value]
    /// if it holds a `StructValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_struct_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StructValue>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::feature_value::Value::StructValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::BoolValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::Int64Value(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::StringValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `BoolArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_array_value<T: std::convert::Into<std::boxed::Box<crate::model::BoolArray>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::BoolArrayValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `DoubleArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_array_value<
        T: std::convert::Into<std::boxed::Box<crate::model::DoubleArray>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::feature_value::Value::DoubleArrayValue(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `Int64ArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_array_value<
        T: std::convert::Into<std::boxed::Box<crate::model::Int64Array>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::feature_value::Value::Int64ArrayValue(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `StringArrayValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_array_value<
        T: std::convert::Into<std::boxed::Box<crate::model::StringArray>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::feature_value::Value::StringArrayValue(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `BytesValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bytes_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::BytesValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::FeatureValue::value]
    /// to hold a `StructValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_struct_value<T: std::convert::Into<std::boxed::Box<crate::model::StructValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::feature_value::Value::StructValue(v.into()));
        self
    }
}

impl wkt::message::Message for FeatureValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValue"
    }
}

/// Defines additional types related to FeatureValue
pub mod feature_value {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of feature value.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metadata {
        /// Feature generation timestamp. Typically, it is provided by user at
        /// feature ingestion time. If not, feature store
        /// will use the system timestamp when the data is ingested into feature
        /// store. For streaming ingestion, the time, aligned by days, must be no
        /// older than five years (1825 days) and no later than one year (366 days)
        /// in the future.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub generate_time: std::option::Option<wkt::Timestamp>,
    }

    impl Metadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [generate_time][crate::model::feature_value::Metadata::generate_time].
        pub fn set_generate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.generate_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Metadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValue.Metadata"
        }
    }

    /// Value for the feature.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// Bool type feature value.
        BoolValue(bool),
        /// Double type feature value.
        DoubleValue(f64),
        /// Int64 feature value.
        Int64Value(i64),
        /// String feature value.
        StringValue(std::string::String),
        /// A list of bool type feature value.
        BoolArrayValue(std::boxed::Box<crate::model::BoolArray>),
        /// A list of double type feature value.
        DoubleArrayValue(std::boxed::Box<crate::model::DoubleArray>),
        /// A list of int64 type feature value.
        Int64ArrayValue(std::boxed::Box<crate::model::Int64Array>),
        /// A list of string type feature value.
        StringArrayValue(std::boxed::Box<crate::model::StringArray>),
        /// Bytes feature value.
        BytesValue(bytes::Bytes),
        /// A struct type feature value.
        StructValue(std::boxed::Box<crate::model::StructValue>),
    }
}

/// Struct (or object) type feature value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StructValue {
    /// A list of field values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::StructFieldValue>,
}

impl StructValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::StructValue::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StructFieldValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StructValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StructValue"
    }
}

/// One field of a Struct (or object) type feature value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StructFieldValue {
    /// Name of the field in the struct feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The value for this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<std::boxed::Box<crate::model::FeatureValue>>,
}

impl StructFieldValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StructFieldValue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::StructFieldValue::value].
    pub fn set_value<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::FeatureValue>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for StructFieldValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StructFieldValue"
    }
}

/// Container for list of values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureValueList {
    /// A list of feature values. All of them should be the same data type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::FeatureValue>,
}

impl FeatureValueList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::FeatureValueList::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeatureValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FeatureValueList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValueList"
    }
}

/// Request message for
/// [FeaturestoreService.CreateFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.CreateFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.CreateFeaturestore]: crate::client::FeaturestoreService::create_featurestore
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeaturestoreRequest {
    /// Required. The resource name of the Location to create Featurestores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Featurestore to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub featurestore: std::option::Option<crate::model::Featurestore>,

    /// Required. The ID to use for this Featurestore, which will become the final
    /// component of the Featurestore's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub featurestore_id: std::string::String,
}

impl CreateFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeaturestoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [featurestore][crate::model::CreateFeaturestoreRequest::featurestore].
    pub fn set_featurestore<
        T: std::convert::Into<std::option::Option<crate::model::Featurestore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.featurestore = v.into();
        self
    }

    /// Sets the value of [featurestore_id][crate::model::CreateFeaturestoreRequest::featurestore_id].
    pub fn set_featurestore_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.featurestore_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.GetFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.GetFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.GetFeaturestore]: crate::client::FeaturestoreService::get_featurestore
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeaturestoreRequest {
    /// Required. The name of the Featurestore resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeaturestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]: crate::client::FeaturestoreService::list_featurestores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturestoresRequest {
    /// Required. The resource name of the Location to list Featurestores.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the featurestores that match the filter expression. The following
    /// fields are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be
    ///   in RFC 3339 format.
    /// * `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
    ///   `<=`, and `>=` comparisons.
    /// * `labels`: Supports key-value equality and key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
    ///   Featurestores created or updated after 2020-01-01.
    /// * `labels.env = "prod"`
    ///   Featurestores with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of Featurestores to return. The service may return fewer
    /// than this value. If unspecified, at most 100 Featurestores will be
    /// returned. The maximum value is 100; any value greater than 100 will be
    /// coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]: crate::client::FeaturestoreService::list_featurestores
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported Fields:
    ///
    /// * `create_time`
    /// * `update_time`
    /// * `online_serving_config.fixed_node_count`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListFeaturestoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeaturestoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeaturestoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeaturestoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeaturestoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeaturestoresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListFeaturestoresRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListFeaturestoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturestoresRequest"
    }
}

/// Response message for
/// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]: crate::client::FeaturestoreService::list_featurestores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturestoresResponse {
    /// The Featurestores matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub featurestores: std::vec::Vec<crate::model::Featurestore>,

    /// A token, which can be sent as
    /// [ListFeaturestoresRequest.page_token][google.cloud.aiplatform.v1.ListFeaturestoresRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeaturestoresRequest.page_token]: crate::model::ListFeaturestoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFeaturestoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeaturestoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [featurestores][crate::model::ListFeaturestoresResponse::featurestores].
    pub fn set_featurestores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Featurestore>,
    {
        use std::iter::Iterator;
        self.featurestores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeaturestoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturestoresResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFeaturestoresResponse {
    type PageItem = crate::model::Featurestore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.featurestores
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeaturestoreService.UpdateFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeaturestore]: crate::client::FeaturestoreService::update_featurestore
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeaturestoreRequest {
    /// Required. The Featurestore's `name` field is used to identify the
    /// Featurestore to be updated. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub featurestore: std::option::Option<crate::model::Featurestore>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// Featurestore resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `labels`
    /// * `online_serving_config.fixed_node_count`
    /// * `online_serving_config.scaling`
    /// * `online_storage_ttl_days`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [featurestore][crate::model::UpdateFeaturestoreRequest::featurestore].
    pub fn set_featurestore<
        T: std::convert::Into<std::option::Option<crate::model::Featurestore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.featurestore = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeaturestoreRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeaturestore].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeaturestore]: crate::client::FeaturestoreService::delete_featurestore
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeaturestoreRequest {
    /// Required. The name of the Featurestore to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any EntityTypes and Features for this Featurestore will
    /// also be deleted. (Otherwise, the request will only work if the Featurestore
    /// has no EntityTypes.)
    pub force: bool,
}

impl DeleteFeaturestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeaturestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFeaturestoreRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeaturestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeaturestoreRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportFeatureValuesRequest {
    /// Required. The resource name of the EntityType grouping the Features for
    /// which values are being imported. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Source column that holds entity IDs. If not provided, entity IDs are
    /// extracted from the column named entity_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id_field: std::string::String,

    /// Required. Specifications defining which Feature values to import from the
    /// entity. The request fails if no feature_specs are provided, and having
    /// multiple feature_specs for one Feature is not allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_specs: std::vec::Vec<crate::model::import_feature_values_request::FeatureSpec>,

    /// If set, data will not be imported for online serving. This
    /// is typically used for backfilling, where Feature generation timestamps are
    /// not in the timestamp range needed for online serving.
    pub disable_online_serving: bool,

    /// Specifies the number of workers that are used to write data to the
    /// Featurestore. Consider the online serving capacity that you require to
    /// achieve the desired import throughput without interfering with online
    /// serving. The value must be positive, and less than or equal to 100.
    /// If not set, defaults to using 1 worker. The low count ensures minimal
    /// impact on online serving performance.
    pub worker_count: i32,

    /// If true, API doesn't start ingestion analysis pipeline.
    pub disable_ingestion_analysis: bool,

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_feature_values_request::Source>,

    /// Source of Feature timestamp for all Feature values of each entity.
    /// Timestamps must be millisecond-aligned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub feature_time_source:
        std::option::Option<crate::model::import_feature_values_request::FeatureTimeSource>,
}

impl ImportFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::ImportFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [entity_id_field][crate::model::ImportFeatureValuesRequest::entity_id_field].
    pub fn set_entity_id_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id_field = v.into();
        self
    }

    /// Sets the value of [disable_online_serving][crate::model::ImportFeatureValuesRequest::disable_online_serving].
    pub fn set_disable_online_serving<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_online_serving = v.into();
        self
    }

    /// Sets the value of [worker_count][crate::model::ImportFeatureValuesRequest::worker_count].
    pub fn set_worker_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.worker_count = v.into();
        self
    }

    /// Sets the value of [disable_ingestion_analysis][crate::model::ImportFeatureValuesRequest::disable_ingestion_analysis].
    pub fn set_disable_ingestion_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_ingestion_analysis = v.into();
        self
    }

    /// Sets the value of [feature_specs][crate::model::ImportFeatureValuesRequest::feature_specs].
    pub fn set_feature_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::import_feature_values_request::FeatureSpec>,
    {
        use std::iter::Iterator;
        self.feature_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<
            std::option::Option<crate::model::import_feature_values_request::Source>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// if it holds a `AvroSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_avro_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AvroSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::Source::AvroSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// if it holds a `BigquerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::Source::BigquerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// if it holds a `CsvSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_csv_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::CsvSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::Source::CsvSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// to hold a `AvroSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_avro_source<T: std::convert::Into<std::boxed::Box<crate::model::AvroSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_feature_values_request::Source::AvroSource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// to hold a `BigquerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_bigquery_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_feature_values_request::Source::BigquerySource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::ImportFeatureValuesRequest::source]
    /// to hold a `CsvSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_csv_source<T: std::convert::Into<std::boxed::Box<crate::model::CsvSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_feature_values_request::Source::CsvSource(v.into()),
        );
        self
    }

    /// Sets the value of `feature_time_source`.
    pub fn set_feature_time_source<
        T: std::convert::Into<
            std::option::Option<crate::model::import_feature_values_request::FeatureTimeSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_time_source = v.into();
        self
    }

    /// The value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// if it holds a `FeatureTimeField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_feature_time_field(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.feature_time_source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTimeField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// if it holds a `FeatureTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_feature_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.feature_time_source.as_ref().and_then(|v| match v {
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// to hold a `FeatureTimeField`.
    ///
    /// Note that all the setters affecting `feature_time_source` are
    /// mutually exclusive.
    pub fn set_feature_time_field<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_time_source = std::option::Option::Some(
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTimeField(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [feature_time_source][crate::model::ImportFeatureValuesRequest::feature_time_source]
    /// to hold a `FeatureTime`.
    ///
    /// Note that all the setters affecting `feature_time_source` are
    /// mutually exclusive.
    pub fn set_feature_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_time_source = std::option::Option::Some(
            crate::model::import_feature_values_request::FeatureTimeSource::FeatureTime(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesRequest"
    }
}

/// Defines additional types related to ImportFeatureValuesRequest
pub mod import_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the Feature value(s) to import.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureSpec {
        /// Required. ID of the Feature to import values of. This Feature must exist
        /// in the target EntityType, or the request will fail.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Source column to get the Feature values from. If not set, uses the column
        /// with the same name as the Feature ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_field: std::string::String,
    }

    impl FeatureSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::import_feature_values_request::FeatureSpec::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [source_field][crate::model::import_feature_values_request::FeatureSpec::source_field].
        pub fn set_source_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_field = v.into();
            self
        }
    }

    impl wkt::message::Message for FeatureSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesRequest.FeatureSpec"
        }
    }

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        AvroSource(std::boxed::Box<crate::model::AvroSource>),
        BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        CsvSource(std::boxed::Box<crate::model::CsvSource>),
    }

    /// Source of Feature timestamp for all Feature values of each entity.
    /// Timestamps must be millisecond-aligned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FeatureTimeSource {
        /// Source column that holds the Feature timestamp for all Feature
        /// values in each entity.
        FeatureTimeField(std::string::String),
        /// Single Feature timestamp for all entities being imported. The
        /// timestamp must not have higher than millisecond precision.
        FeatureTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// Response message for
/// [FeaturestoreService.ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues]: crate::client::FeaturestoreService::import_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportFeatureValuesResponse {
    /// Number of entities that have been imported by the operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_entity_count: i64,

    /// Number of Feature values that have been imported by the operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_feature_value_count: i64,

    /// The number of rows in input source that weren't imported due to either
    ///
    /// * Not having any featureValues.
    /// * Having a null entityId.
    /// * Having a null timestamp.
    /// * Not being parsable (applicable for CSV sources).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub invalid_row_count: i64,

    /// The number rows that weren't ingested due to having feature timestamps
    /// outside the retention boundary.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub timestamp_outside_retention_rows_count: i64,
}

impl ImportFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_entity_count][crate::model::ImportFeatureValuesResponse::imported_entity_count].
    pub fn set_imported_entity_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_entity_count = v.into();
        self
    }

    /// Sets the value of [imported_feature_value_count][crate::model::ImportFeatureValuesResponse::imported_feature_value_count].
    pub fn set_imported_feature_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_feature_value_count = v.into();
        self
    }

    /// Sets the value of [invalid_row_count][crate::model::ImportFeatureValuesResponse::invalid_row_count].
    pub fn set_invalid_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.invalid_row_count = v.into();
        self
    }

    /// Sets the value of [timestamp_outside_retention_rows_count][crate::model::ImportFeatureValuesResponse::timestamp_outside_retention_rows_count].
    pub fn set_timestamp_outside_retention_rows_count<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_outside_retention_rows_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesResponse"
    }
}

/// Request message for
/// [FeaturestoreService.BatchReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues]: crate::client::FeaturestoreService::batch_read_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadFeatureValuesRequest {
    /// Required. The resource name of the Featurestore from which to query Feature
    /// values. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub featurestore: std::string::String,

    /// Required. Specifies output location and format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::FeatureValueDestination>,

    /// When not empty, the specified fields in the *_read_instances source will be
    /// joined as-is in the output, in addition to those fields from the
    /// Featurestore Entity.
    ///
    /// For BigQuery source, the type of the pass-through values will be
    /// automatically inferred. For CSV source, the pass-through values will be
    /// passed as opaque bytes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pass_through_fields:
        std::vec::Vec<crate::model::batch_read_feature_values_request::PassThroughField>,

    /// Required. Specifies EntityType grouping Features to read values of and
    /// settings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_type_specs:
        std::vec::Vec<crate::model::batch_read_feature_values_request::EntityTypeSpec>,

    /// Optional. Excludes Feature values with feature generation timestamp before
    /// this timestamp. If not set, retrieve oldest values kept in Feature Store.
    /// Timestamp, if present, must not have higher than millisecond precision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub read_option:
        std::option::Option<crate::model::batch_read_feature_values_request::ReadOption>,
}

impl BatchReadFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [featurestore][crate::model::BatchReadFeatureValuesRequest::featurestore].
    pub fn set_featurestore<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.featurestore = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::BatchReadFeatureValuesRequest::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::FeatureValueDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BatchReadFeatureValuesRequest::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [pass_through_fields][crate::model::BatchReadFeatureValuesRequest::pass_through_fields].
    pub fn set_pass_through_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch_read_feature_values_request::PassThroughField>,
    {
        use std::iter::Iterator;
        self.pass_through_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_type_specs][crate::model::BatchReadFeatureValuesRequest::entity_type_specs].
    pub fn set_entity_type_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch_read_feature_values_request::EntityTypeSpec>,
    {
        use std::iter::Iterator;
        self.entity_type_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `read_option`.
    pub fn set_read_option<
        T: std::convert::Into<
            std::option::Option<crate::model::batch_read_feature_values_request::ReadOption>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_option = v.into();
        self
    }

    /// The value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// if it holds a `CsvReadInstances`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_csv_read_instances(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsvSource>> {
        #[allow(unreachable_patterns)]
        self.read_option.as_ref().and_then(|v| match v {
            crate::model::batch_read_feature_values_request::ReadOption::CsvReadInstances(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// if it holds a `BigqueryReadInstances`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_read_instances(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.read_option.as_ref().and_then(|v| match v {
            crate::model::batch_read_feature_values_request::ReadOption::BigqueryReadInstances(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// to hold a `CsvReadInstances`.
    ///
    /// Note that all the setters affecting `read_option` are
    /// mutually exclusive.
    pub fn set_csv_read_instances<
        T: std::convert::Into<std::boxed::Box<crate::model::CsvSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_option = std::option::Option::Some(
            crate::model::batch_read_feature_values_request::ReadOption::CsvReadInstances(v.into()),
        );
        self
    }

    /// Sets the value of [read_option][crate::model::BatchReadFeatureValuesRequest::read_option]
    /// to hold a `BigqueryReadInstances`.
    ///
    /// Note that all the setters affecting `read_option` are
    /// mutually exclusive.
    pub fn set_bigquery_read_instances<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_option = std::option::Option::Some(
            crate::model::batch_read_feature_values_request::ReadOption::BigqueryReadInstances(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for BatchReadFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest"
    }
}

/// Defines additional types related to BatchReadFeatureValuesRequest
pub mod batch_read_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Describe pass-through fields in read_instance source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PassThroughField {
        /// Required. The name of the field in the CSV header or the name of the
        /// column in BigQuery table. The naming restriction is the same as
        /// [Feature.name][google.cloud.aiplatform.v1.Feature.name].
        ///
        /// [google.cloud.aiplatform.v1.Feature.name]: crate::model::Feature::name
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field_name: std::string::String,
    }

    impl PassThroughField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_name][crate::model::batch_read_feature_values_request::PassThroughField::field_name].
        pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_name = v.into();
            self
        }
    }

    impl wkt::message::Message for PassThroughField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.PassThroughField"
        }
    }

    /// Selects Features of an EntityType to read values of and specifies read
    /// settings.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EntityTypeSpec {
        /// Required. ID of the EntityType to select Features. The EntityType id is
        /// the
        /// [entity_type_id][google.cloud.aiplatform.v1.CreateEntityTypeRequest.entity_type_id]
        /// specified during EntityType creation.
        ///
        /// [google.cloud.aiplatform.v1.CreateEntityTypeRequest.entity_type_id]: crate::model::CreateEntityTypeRequest::entity_type_id
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_type_id: std::string::String,

        /// Required. Selectors choosing which Feature values to read from the
        /// EntityType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

        /// Per-Feature settings for the batch read.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub settings: std::vec::Vec<crate::model::DestinationFeatureSetting>,
    }

    impl EntityTypeSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_type_id][crate::model::batch_read_feature_values_request::EntityTypeSpec::entity_type_id].
        pub fn set_entity_type_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.entity_type_id = v.into();
            self
        }

        /// Sets the value of [feature_selector][crate::model::batch_read_feature_values_request::EntityTypeSpec::feature_selector].
        pub fn set_feature_selector<
            T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_selector = v.into();
            self
        }

        /// Sets the value of [settings][crate::model::batch_read_feature_values_request::EntityTypeSpec::settings].
        pub fn set_settings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::DestinationFeatureSetting>,
        {
            use std::iter::Iterator;
            self.settings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EntityTypeSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.EntityTypeSpec"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ReadOption {
        /// Each read instance consists of exactly one read timestamp and one or more
        /// entity IDs identifying entities of the corresponding EntityTypes whose
        /// Features are requested.
        ///
        /// Each output instance contains Feature values of requested entities
        /// concatenated together as of the read time.
        ///
        /// An example read instance may be `foo_entity_id, bar_entity_id,
        /// 2020-01-01T10:00:00.123Z`.
        ///
        /// An example output instance may be `foo_entity_id, bar_entity_id,
        /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
        /// bar_entity_feature2_value`.
        ///
        /// Timestamp in each read instance must be millisecond-aligned.
        ///
        /// `csv_read_instances` are read instances stored in a plain-text CSV file.
        /// The header should be:
        /// [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
        ///
        /// The columns can be in any order.
        ///
        /// Values in the timestamp column must use the RFC 3339 format, e.g.
        /// `2012-07-30T10:43:17.123Z`.
        CsvReadInstances(std::boxed::Box<crate::model::CsvSource>),
        /// Similar to csv_read_instances, but from BigQuery source.
        BigqueryReadInstances(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// Request message for
/// [FeaturestoreService.ExportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues]: crate::client::FeaturestoreService::export_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFeatureValuesRequest {
    /// Required. The resource name of the EntityType from which to export Feature
    /// values. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Required. Specifies destination location and format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::FeatureValueDestination>,

    /// Required. Selects Features to export values of.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

    /// Per-Feature export settings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub settings: std::vec::Vec<crate::model::DestinationFeatureSetting>,

    /// Required. The mode in which Feature values are exported.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::export_feature_values_request::Mode>,
}

impl ExportFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::ExportFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportFeatureValuesRequest::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::FeatureValueDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [feature_selector][crate::model::ExportFeatureValuesRequest::feature_selector].
    pub fn set_feature_selector<
        T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feature_selector = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::ExportFeatureValuesRequest::settings].
    pub fn set_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DestinationFeatureSetting>,
    {
        use std::iter::Iterator;
        self.settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `mode`.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::export_feature_values_request::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// if it holds a `SnapshotExport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_snapshot_export(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_feature_values_request::SnapshotExport>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::export_feature_values_request::Mode::SnapshotExport(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// if it holds a `FullExport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_full_export(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_feature_values_request::FullExport>,
    > {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::export_feature_values_request::Mode::FullExport(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// to hold a `SnapshotExport`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_snapshot_export<
        T: std::convert::Into<
            std::boxed::Box<crate::model::export_feature_values_request::SnapshotExport>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::export_feature_values_request::Mode::SnapshotExport(v.into()),
        );
        self
    }

    /// Sets the value of [mode][crate::model::ExportFeatureValuesRequest::mode]
    /// to hold a `FullExport`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_full_export<
        T: std::convert::Into<
            std::boxed::Box<crate::model::export_feature_values_request::FullExport>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::export_feature_values_request::Mode::FullExport(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest"
    }
}

/// Defines additional types related to ExportFeatureValuesRequest
pub mod export_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Describes exporting the latest Feature values of all entities of the
    /// EntityType between [start_time, snapshot_time].
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SnapshotExport {
        /// Exports Feature values as of this timestamp. If not set,
        /// retrieve values as of now. Timestamp, if present, must not have higher
        /// than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snapshot_time: std::option::Option<wkt::Timestamp>,

        /// Excludes Feature values with feature generation timestamp before this
        /// timestamp. If not set, retrieve oldest values kept in Feature Store.
        /// Timestamp, if present, must not have higher than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,
    }

    impl SnapshotExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snapshot_time][crate::model::export_feature_values_request::SnapshotExport::snapshot_time].
        pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.snapshot_time = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::export_feature_values_request::SnapshotExport::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SnapshotExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest.SnapshotExport"
        }
    }

    /// Describes exporting all historical Feature values of all entities of the
    /// EntityType between [start_time, end_time].
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FullExport {
        /// Excludes Feature values with feature generation timestamp before this
        /// timestamp. If not set, retrieve oldest values kept in Feature Store.
        /// Timestamp, if present, must not have higher than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Exports Feature values as of this timestamp. If not set,
        /// retrieve values as of now. Timestamp, if present, must not have higher
        /// than millisecond precision.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,
    }

    impl FullExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::export_feature_values_request::FullExport::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::export_feature_values_request::FullExport::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }
    }

    impl wkt::message::Message for FullExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest.FullExport"
        }
    }

    /// Required. The mode in which Feature values are exported.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Exports the latest Feature values of all entities of the EntityType
        /// within a time range.
        SnapshotExport(
            std::boxed::Box<crate::model::export_feature_values_request::SnapshotExport>,
        ),
        /// Exports all historical values of all entities of the EntityType within a
        /// time range
        FullExport(std::boxed::Box<crate::model::export_feature_values_request::FullExport>),
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestinationFeatureSetting {
    /// Required. The ID of the Feature to apply the setting to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_id: std::string::String,

    /// Specify the field name in the export destination. If not specified,
    /// Feature ID is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_field: std::string::String,
}

impl DestinationFeatureSetting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature_id][crate::model::DestinationFeatureSetting::feature_id].
    pub fn set_feature_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_id = v.into();
        self
    }

    /// Sets the value of [destination_field][crate::model::DestinationFeatureSetting::destination_field].
    pub fn set_destination_field<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_field = v.into();
        self
    }
}

impl wkt::message::Message for DestinationFeatureSetting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DestinationFeatureSetting"
    }
}

/// A destination location for Feature values and format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeatureValueDestination {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::feature_value_destination::Destination>,
}

impl FeatureValueDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<
            std::option::Option<crate::model::feature_value_destination::Destination>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::FeatureValueDestination::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feature_value_destination::Destination::BigqueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination][crate::model::FeatureValueDestination::destination]
    /// if it holds a `TfrecordDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tfrecord_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TFRecordDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feature_value_destination::Destination::TfrecordDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination][crate::model::FeatureValueDestination::destination]
    /// if it holds a `CsvDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_csv_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CsvDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::feature_value_destination::Destination::CsvDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feature_value_destination::Destination::BigqueryDestination(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination]
    /// to hold a `TfrecordDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_tfrecord_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::TFRecordDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feature_value_destination::Destination::TfrecordDestination(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::FeatureValueDestination::destination]
    /// to hold a `CsvDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_csv_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::CsvDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::feature_value_destination::Destination::CsvDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeatureValueDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValueDestination"
    }
}

/// Defines additional types related to FeatureValueDestination
pub mod feature_value_destination {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Output in BigQuery format.
        /// [BigQueryDestination.output_uri][google.cloud.aiplatform.v1.BigQueryDestination.output_uri]
        /// in
        /// [FeatureValueDestination.bigquery_destination][google.cloud.aiplatform.v1.FeatureValueDestination.bigquery_destination]
        /// must refer to a table.
        ///
        /// [google.cloud.aiplatform.v1.BigQueryDestination.output_uri]: crate::model::BigQueryDestination::output_uri
        /// [google.cloud.aiplatform.v1.FeatureValueDestination.bigquery_destination]: crate::model::FeatureValueDestination::destination
        BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
        /// Output in TFRecord format.
        ///
        /// Below are the mapping from Feature value type
        /// in Featurestore to Feature value type in TFRecord:
        ///
        /// ```norust
        /// Value type in Featurestore                 | Value type in TFRecord
        /// DOUBLE, DOUBLE_ARRAY                       | FLOAT_LIST
        /// INT64, INT64_ARRAY                         | INT64_LIST
        /// STRING, STRING_ARRAY, BYTES                | BYTES_LIST
        /// true -> byte_string("true"), false -> byte_string("false")
        /// BOOL, BOOL_ARRAY (true, false)             | BYTES_LIST
        /// ```
        TfrecordDestination(std::boxed::Box<crate::model::TFRecordDestination>),
        /// Output in CSV format. Array Feature value types are not allowed in CSV
        /// format.
        CsvDestination(std::boxed::Box<crate::model::CsvDestination>),
    }
}

/// Response message for
/// [FeaturestoreService.ExportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues]: crate::client::FeaturestoreService::export_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFeatureValuesResponse {}

impl ExportFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesResponse"
    }
}

/// Response message for
/// [FeaturestoreService.BatchReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues]: crate::client::FeaturestoreService::batch_read_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadFeatureValuesResponse {}

impl BatchReadFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BatchReadFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesResponse"
    }
}

/// Request message for
/// [FeaturestoreService.CreateEntityType][google.cloud.aiplatform.v1.FeaturestoreService.CreateEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.CreateEntityType]: crate::client::FeaturestoreService::create_entity_type
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntityTypeRequest {
    /// Required. The resource name of the Featurestore to create EntityTypes.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The EntityType to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// Required. The ID to use for the EntityType, which will become the final
    /// component of the EntityType's resource name.
    ///
    /// This value may be up to 60 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within a featurestore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type_id: std::string::String,
}

impl CreateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntityTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::CreateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::option::Option<crate::model::EntityType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [entity_type_id][crate::model::CreateEntityTypeRequest::entity_type_id].
    pub fn set_entity_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.GetEntityType][google.cloud.aiplatform.v1.FeaturestoreService.GetEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.GetEntityType]: crate::client::FeaturestoreService::get_entity_type
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntityTypeRequest {
    /// Required. The name of the EntityType resource.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]: crate::client::FeaturestoreService::list_entity_types
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntityTypesRequest {
    /// Required. The resource name of the Featurestore to list EntityTypes.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the EntityTypes that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `labels`: Supports key-value equality as well as key presence.
    ///
    /// Examples:
    ///
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
    ///   update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
    ///   or updated after 2020-01-31T15:30:00.000000Z.
    /// * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any EntityType which has a label with 'env' as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of EntityTypes to return. The service may return fewer
    /// than this value. If unspecified, at most 1000 EntityTypes will be returned.
    /// The maximum value is 1000; any value greater than 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]: crate::client::FeaturestoreService::list_entity_types
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `entity_type_id`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntityTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntityTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntityTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntityTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListEntityTypesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEntityTypesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]: crate::client::FeaturestoreService::list_entity_types
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntityTypesResponse {
    /// The EntityTypes matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_types: std::vec::Vec<crate::model::EntityType>,

    /// A token, which can be sent as
    /// [ListEntityTypesRequest.page_token][google.cloud.aiplatform.v1.ListEntityTypesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListEntityTypesRequest.page_token]: crate::model::ListEntityTypesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEntityTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entity_types][crate::model::ListEntityTypesResponse::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEntityTypesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEntityTypesResponse {
    type PageItem = crate::model::EntityType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entity_types
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeaturestoreService.UpdateEntityType][google.cloud.aiplatform.v1.FeaturestoreService.UpdateEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.UpdateEntityType]: crate::client::FeaturestoreService::update_entity_type
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntityTypeRequest {
    /// Required. The EntityType's `name` field is used to identify the EntityType
    /// to be updated. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// EntityType resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `description`
    /// * `labels`
    /// * `monitoring_config.snapshot_analysis.disabled`
    /// * `monitoring_config.snapshot_analysis.monitoring_interval_days`
    /// * `monitoring_config.snapshot_analysis.staleness_days`
    /// * `monitoring_config.import_features_analysis.state`
    /// * `monitoring_config.import_features_analysis.anomaly_detection_baseline`
    /// * `monitoring_config.numerical_threshold_config.value`
    /// * `monitoring_config.categorical_threshold_config.value`
    /// * `offline_storage_ttl_days`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::UpdateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::option::Option<crate::model::EntityType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntityTypeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteEntityType][google.cloud.aiplatform.v1.FeaturestoreService.DeleteEntityType].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteEntityType]: crate::client::FeaturestoreService::delete_entity_type
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntityTypeRequest {
    /// Required. The name of the EntityType to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any Features for this EntityType will also be deleted.
    /// (Otherwise, the request will only work if the EntityType has no Features.)
    pub force: bool,
}

impl DeleteEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntityTypeRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteEntityTypeRequest"
    }
}

/// Request message for
/// [FeaturestoreService.CreateFeature][google.cloud.aiplatform.v1.FeaturestoreService.CreateFeature].
/// Request message for
/// [FeatureRegistryService.CreateFeature][google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeature]: crate::client::FeatureRegistryService::create_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.CreateFeature]: crate::client::FeaturestoreService::create_feature
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureRequest {
    /// Required. The resource name of the EntityType or FeatureGroup to create a
    /// Feature. Format for entity_type as parent:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// Format for feature_group as parent:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Feature to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature: std::option::Option<crate::model::Feature>,

    /// Required. The ID to use for the Feature, which will become the final
    /// component of the Feature's resource name.
    ///
    /// This value may be up to 128 characters, and valid characters are
    /// `[a-z0-9_]`. The first character cannot be a number.
    ///
    /// The value must be unique within an EntityType/FeatureGroup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_id: std::string::String,
}

impl CreateFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeatureRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feature][crate::model::CreateFeatureRequest::feature].
    pub fn set_feature<T: std::convert::Into<std::option::Option<crate::model::Feature>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature = v.into();
        self
    }

    /// Sets the value of [feature_id][crate::model::CreateFeatureRequest::feature_id].
    pub fn set_feature_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureRequest"
    }
}

/// Request message for
/// [FeaturestoreService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures].
/// Request message for
/// [FeatureRegistryService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.BatchCreateFeatures].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.BatchCreateFeatures]: crate::client::FeatureRegistryService::batch_create_features
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures]: crate::client::FeaturestoreService::batch_create_features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateFeaturesRequest {
    /// Required. The resource name of the EntityType/FeatureGroup to create the
    /// batch of Features under. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the Features to create. All
    /// Features must be created under the same parent EntityType / FeatureGroup.
    /// The `parent` field in each child request message can be omitted. If
    /// `parent` is set in a child request, then the value must match the `parent`
    /// value in this request message.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateFeatureRequest>,
}

impl BatchCreateFeaturesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateFeaturesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateFeaturesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateFeatureRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateFeaturesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures]: crate::client::FeaturestoreService::batch_create_features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateFeaturesResponse {
    /// The Features created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,
}

impl BatchCreateFeaturesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [features][crate::model::BatchCreateFeaturesResponse::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateFeaturesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesResponse"
    }
}

/// Request message for
/// [FeaturestoreService.GetFeature][google.cloud.aiplatform.v1.FeaturestoreService.GetFeature].
/// Request message for
/// [FeatureRegistryService.GetFeature][google.cloud.aiplatform.v1.FeatureRegistryService.GetFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.GetFeature]: crate::client::FeatureRegistryService::get_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.GetFeature]: crate::client::FeaturestoreService::get_feature
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeatureRequest {
    /// Required. The name of the Feature resource.
    /// Format for entity_type as parent:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// Format for feature_group as parent:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeatureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureRequest"
    }
}

/// Request message for
/// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures].
/// Request message for
/// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]: crate::client::FeatureRegistryService::list_features
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]: crate::client::FeaturestoreService::list_features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturesRequest {
    /// Required. The resource name of the Location to list Features.
    /// Format for entity_type as parent:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
    /// Format for feature_group as parent:
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the Features that match the filter expression. The following
    /// filters are supported:
    ///
    /// * `value_type`: Supports = and != comparisons.
    /// * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
    ///   be in RFC 3339 format.
    /// * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
    ///   be in RFC 3339 format.
    /// * `labels`: Supports key-value equality as well as key presence.
    ///
    /// Examples:
    ///
    /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
    /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
    ///   update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
    ///   or updated after 2020-01-31T15:30:00.000000Z.
    /// * `labels.active = yes AND labels.env = prod` --> Features having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any Feature which has a label with 'env' as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of Features to return. The service may return fewer
    /// than this value. If unspecified, at most 1000 Features will be returned.
    /// The maximum value is 1000; any value greater than 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]
    /// call or
    /// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]
    /// or
    /// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]: crate::client::FeatureRegistryService::list_features
    /// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]: crate::client::FeaturestoreService::list_features
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `feature_id`
    /// * `value_type` (Not supported for FeatureRegistry Feature)
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Only applicable for Vertex AI Feature Store (Legacy).
    /// If set, return the most recent
    /// [ListFeaturesRequest.latest_stats_count][google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count]
    /// of stats for each Feature in response. Valid value is [0, 10]. If number of
    /// stats exists <
    /// [ListFeaturesRequest.latest_stats_count][google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count],
    /// return all existing stats.
    ///
    /// [google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count]: crate::model::ListFeaturesRequest::latest_stats_count
    pub latest_stats_count: i32,
}

impl ListFeaturesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeaturesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeaturesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeaturesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeaturesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFeaturesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListFeaturesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [latest_stats_count][crate::model::ListFeaturesRequest::latest_stats_count].
    pub fn set_latest_stats_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.latest_stats_count = v.into();
        self
    }
}

impl wkt::message::Message for ListFeaturesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures].
/// Response message for
/// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]: crate::client::FeatureRegistryService::list_features
/// [google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]: crate::client::FeaturestoreService::list_features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeaturesResponse {
    /// The Features matching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// A token, which can be sent as
    /// [ListFeaturesRequest.page_token][google.cloud.aiplatform.v1.ListFeaturesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListFeaturesRequest.page_token]: crate::model::ListFeaturesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListFeaturesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFeaturesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [features][crate::model::ListFeaturesResponse::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFeaturesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListFeaturesResponse {
    type PageItem = crate::model::Feature;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.features
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]: crate::client::FeaturestoreService::search_features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchFeaturesRequest {
    /// Required. The resource name of the Location to search Features.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Query string that is a conjunction of field-restricted queries and/or
    /// field-restricted filters.  Field-restricted queries and filters can be
    /// combined using `AND` to form a conjunction.
    ///
    /// A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
    /// exists as a substring within Feature's FIELD. The QUERY
    /// and the FIELD are converted to a sequence of words (i.e. tokens) for
    /// comparison. This is done by:
    ///
    /// * Removing leading/trailing whitespace and tokenizing the search value.
    ///   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
    ///   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
    ///   as a wildcard that matches characters within a token.
    /// * Ignoring case.
    /// * Prepending an asterisk to the first and appending an asterisk to the
    ///   last token in QUERY.
    ///
    /// A QUERY must be either a singular token or a phrase. A phrase is one or
    /// multiple words enclosed in double quotation marks ("). With phrases, the
    /// order of the words is important. Words in the phrase must be matching in
    /// order and consecutively.
    ///
    /// Supported FIELDs for field-restricted queries:
    ///
    /// * `feature_id`
    /// * `description`
    /// * `entity_type_id`
    ///
    /// Examples:
    ///
    /// * `feature_id: foo` --> Matches a Feature with ID containing the substring
    ///   `foo` (eg. `foo`, `foofeature`, `barfoo`).
    /// * `feature_id: foo*feature` --> Matches a Feature with ID containing the
    ///   substring `foo*feature` (eg. `foobarfeature`).
    /// * `feature_id: foo AND description: bar` --> Matches a Feature with ID
    ///   containing the substring `foo` and description containing the substring
    ///   `bar`.
    ///
    /// Besides field queries, the following exact-match filters are
    /// supported. The exact-match filters do not support wildcards. Unlike
    /// field-restricted queries, exact-match filters are case-sensitive.
    ///
    /// * `feature_id`: Supports = comparisons.
    /// * `description`: Supports = comparisons. Multi-token filters should be
    ///   enclosed in quotes.
    /// * `entity_type_id`: Supports = comparisons.
    /// * `value_type`: Supports = and != comparisons.
    /// * `labels`: Supports key-value equality as well as key presence.
    /// * `featurestore_id`: Supports = comparisons.
    ///
    /// Examples:
    ///
    /// * `description = "foo bar"` --> Any Feature with description exactly equal
    ///   to `foo bar`
    /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
    /// * `labels.active = yes AND labels.env = prod` --> Features having both
    ///   (active: yes) and (env: prod) labels.
    /// * `labels.env: *` --> Any Feature which has a label with `env` as the
    ///   key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// The maximum number of Features to return. The service may return fewer
    /// than this value. If unspecified, at most 100 Features will be returned.
    /// The maximum value is 100; any value greater than 100 will be coerced to
    /// 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
    /// except `page_size`, must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]: crate::client::FeaturestoreService::search_features
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl SearchFeaturesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::SearchFeaturesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchFeaturesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchFeaturesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchFeaturesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchFeaturesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchFeaturesRequest"
    }
}

/// Response message for
/// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]: crate::client::FeaturestoreService::search_features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchFeaturesResponse {
    /// The Features matching the request.
    ///
    /// Fields returned:
    ///
    /// * `name`
    /// * `description`
    /// * `labels`
    /// * `create_time`
    /// * `update_time`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// A token, which can be sent as
    /// [SearchFeaturesRequest.page_token][google.cloud.aiplatform.v1.SearchFeaturesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.SearchFeaturesRequest.page_token]: crate::model::SearchFeaturesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchFeaturesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchFeaturesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [features][crate::model::SearchFeaturesResponse::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchFeaturesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchFeaturesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchFeaturesResponse {
    type PageItem = crate::model::Feature;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.features
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [FeaturestoreService.UpdateFeature][google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeature].
/// Request message for
/// [FeatureRegistryService.UpdateFeature][google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeature]: crate::client::FeatureRegistryService::update_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeature]: crate::client::FeaturestoreService::update_feature
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeatureRequest {
    /// Required. The Feature's `name` field is used to identify the Feature to be
    /// updated.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feature: std::option::Option<crate::model::Feature>,

    /// Field mask is used to specify the fields to be overwritten in the
    /// Features resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then only the non-empty fields present in the
    /// request will be overwritten. Set the update_mask to `*` to override all
    /// fields.
    ///
    /// Updatable fields:
    ///
    /// * `description`
    /// * `labels`
    /// * `disable_monitoring` (Not supported for FeatureRegistryService Feature)
    /// * `point_of_contact` (Not supported for FeaturestoreService FeatureStore)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature][crate::model::UpdateFeatureRequest::feature].
    pub fn set_feature<T: std::convert::Into<std::option::Option<crate::model::Feature>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeatureRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureRequest"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteFeature][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeature].
/// Request message for
/// [FeatureRegistryService.DeleteFeature][google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeature].
///
/// [google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeature]: crate::client::FeatureRegistryService::delete_feature
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeature]: crate::client::FeaturestoreService::delete_feature
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureRequest {
    /// Required. The name of the Features to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
    /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteFeatureRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeatureRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeatureRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureRequest"
    }
}

/// Details of operations that perform create Featurestore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeaturestoreOperationMetadata {
    /// Operation metadata for Featurestore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateFeaturestoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeaturestoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeaturestoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeaturestoreOperationMetadata"
    }
}

/// Details of operations that perform update Featurestore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeaturestoreOperationMetadata {
    /// Operation metadata for Featurestore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateFeaturestoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateFeaturestoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeaturestoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeaturestoreOperationMetadata"
    }
}

/// Details of operations that perform import Feature values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore import Feature values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Number of entities that have been imported by the operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_entity_count: i64,

    /// Number of Feature values that have been imported by the operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_feature_value_count: i64,

    /// The source URI from where Feature values are imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_uris: std::vec::Vec<std::string::String>,

    /// The number of rows in input source that weren't imported due to either
    ///
    /// * Not having any featureValues.
    /// * Having a null entityId.
    /// * Having a null timestamp.
    /// * Not being parsable (applicable for CSV sources).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub invalid_row_count: i64,

    /// The number rows that weren't ingested due to having timestamps outside the
    /// retention boundary.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub timestamp_outside_retention_rows_count: i64,

    /// List of ImportFeatureValues operations running under a single EntityType
    /// that are blocking this operation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub blocking_operation_ids: std::vec::Vec<i64>,
}

impl ImportFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ImportFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [imported_entity_count][crate::model::ImportFeatureValuesOperationMetadata::imported_entity_count].
    pub fn set_imported_entity_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_entity_count = v.into();
        self
    }

    /// Sets the value of [imported_feature_value_count][crate::model::ImportFeatureValuesOperationMetadata::imported_feature_value_count].
    pub fn set_imported_feature_value_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_feature_value_count = v.into();
        self
    }

    /// Sets the value of [invalid_row_count][crate::model::ImportFeatureValuesOperationMetadata::invalid_row_count].
    pub fn set_invalid_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.invalid_row_count = v.into();
        self
    }

    /// Sets the value of [timestamp_outside_retention_rows_count][crate::model::ImportFeatureValuesOperationMetadata::timestamp_outside_retention_rows_count].
    pub fn set_timestamp_outside_retention_rows_count<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp_outside_retention_rows_count = v.into();
        self
    }

    /// Sets the value of [source_uris][crate::model::ImportFeatureValuesOperationMetadata::source_uris].
    pub fn set_source_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [blocking_operation_ids][crate::model::ImportFeatureValuesOperationMetadata::blocking_operation_ids].
    pub fn set_blocking_operation_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.blocking_operation_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesOperationMetadata"
    }
}

/// Details of operations that exports Features values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore export Feature values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl ExportFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ExportFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for ExportFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesOperationMetadata"
    }
}

/// Details of operations that batch reads Feature values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore batch read Features values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl BatchReadFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchReadFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for BatchReadFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesOperationMetadata"
    }
}

/// Details of operations that delete Feature values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureValuesOperationMetadata {
    /// Operation metadata for Featurestore delete Features values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl DeleteFeatureValuesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeleteFeatureValuesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeatureValuesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesOperationMetadata"
    }
}

/// Details of operations that perform create EntityType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntityTypeOperationMetadata {
    /// Operation metadata for EntityType.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateEntityTypeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateEntityTypeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntityTypeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEntityTypeOperationMetadata"
    }
}

/// Details of operations that perform create Feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeatureOperationMetadata {
    /// Operation metadata for Feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateFeatureOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateFeatureOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeatureOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOperationMetadata"
    }
}

/// Details of operations that perform batch create Features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateFeaturesOperationMetadata {
    /// Operation metadata for Feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl BatchCreateFeaturesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchCreateFeaturesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateFeaturesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesOperationMetadata"
    }
}

/// Request message for
/// [FeaturestoreService.DeleteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues]: crate::client::FeaturestoreService::delete_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureValuesRequest {
    /// Required. The resource name of the EntityType grouping the Features for
    /// which values are being deleted from. Format:
    /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_type: std::string::String,

    /// Defines options to select feature values to be deleted.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub delete_option:
        std::option::Option<crate::model::delete_feature_values_request::DeleteOption>,
}

impl DeleteFeatureValuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::DeleteFeatureValuesRequest::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of `delete_option`.
    pub fn set_delete_option<
        T: std::convert::Into<
            std::option::Option<crate::model::delete_feature_values_request::DeleteOption>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_option = v.into();
        self
    }

    /// The value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// if it holds a `SelectEntity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_select_entity(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_request::SelectEntity>,
    > {
        #[allow(unreachable_patterns)]
        self.delete_option.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_request::DeleteOption::SelectEntity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// if it holds a `SelectTimeRangeAndFeature`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_select_time_range_and_feature(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_request::SelectTimeRangeAndFeature>,
    > {
        #[allow(unreachable_patterns)]
        self.delete_option.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_request::DeleteOption::SelectTimeRangeAndFeature(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// to hold a `SelectEntity`.
    ///
    /// Note that all the setters affecting `delete_option` are
    /// mutually exclusive.
    pub fn set_select_entity<
        T: std::convert::Into<
            std::boxed::Box<crate::model::delete_feature_values_request::SelectEntity>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_option = std::option::Option::Some(
            crate::model::delete_feature_values_request::DeleteOption::SelectEntity(v.into()),
        );
        self
    }

    /// Sets the value of [delete_option][crate::model::DeleteFeatureValuesRequest::delete_option]
    /// to hold a `SelectTimeRangeAndFeature`.
    ///
    /// Note that all the setters affecting `delete_option` are
    /// mutually exclusive.
    pub fn set_select_time_range_and_feature<
        T: std::convert::Into<
            std::boxed::Box<crate::model::delete_feature_values_request::SelectTimeRangeAndFeature>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_option = std::option::Option::Some(
            crate::model::delete_feature_values_request::DeleteOption::SelectTimeRangeAndFeature(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DeleteFeatureValuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest"
    }
}

/// Defines additional types related to DeleteFeatureValuesRequest
pub mod delete_feature_values_request {
    #[allow(unused_imports)]
    use super::*;

    /// Message to select entity.
    /// If an entity id is selected, all the feature values corresponding to the
    /// entity id will be deleted, including the entityId.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectEntity {
        /// Required. Selectors choosing feature values of which entity id to be
        /// deleted from the EntityType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub entity_id_selector: std::option::Option<crate::model::EntityIdSelector>,
    }

    impl SelectEntity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id_selector][crate::model::delete_feature_values_request::SelectEntity::entity_id_selector].
        pub fn set_entity_id_selector<
            T: std::convert::Into<std::option::Option<crate::model::EntityIdSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entity_id_selector = v.into();
            self
        }
    }

    impl wkt::message::Message for SelectEntity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectEntity"
        }
    }

    /// Message to select time range and feature.
    /// Values of the selected feature generated within an inclusive time range
    /// will be deleted. Using this option permanently deletes the feature values
    /// from the specified feature IDs within the specified time range.
    /// This might include data from the online storage. If you want to retain
    /// any deleted historical data in the online storage, you must re-ingest it.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectTimeRangeAndFeature {
        /// Required. Select feature generated within a half-inclusive time range.
        /// The time range is lower inclusive and upper exclusive.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_range: std::option::Option<gtype::model::Interval>,

        /// Required. Selectors choosing which feature values to be deleted from the
        /// EntityType.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub feature_selector: std::option::Option<crate::model::FeatureSelector>,

        /// If set, data will not be deleted from online storage.
        /// When time range is older than the data in online storage, setting this to
        /// be true will make the deletion have no impact on online serving.
        pub skip_online_storage_delete: bool,
    }

    impl SelectTimeRangeAndFeature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time_range][crate::model::delete_feature_values_request::SelectTimeRangeAndFeature::time_range].
        pub fn set_time_range<
            T: std::convert::Into<std::option::Option<gtype::model::Interval>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_range = v.into();
            self
        }

        /// Sets the value of [feature_selector][crate::model::delete_feature_values_request::SelectTimeRangeAndFeature::feature_selector].
        pub fn set_feature_selector<
            T: std::convert::Into<std::option::Option<crate::model::FeatureSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.feature_selector = v.into();
            self
        }

        /// Sets the value of [skip_online_storage_delete][crate::model::delete_feature_values_request::SelectTimeRangeAndFeature::skip_online_storage_delete].
        pub fn set_skip_online_storage_delete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.skip_online_storage_delete = v.into();
            self
        }
    }

    impl wkt::message::Message for SelectTimeRangeAndFeature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectTimeRangeAndFeature"
        }
    }

    /// Defines options to select feature values to be deleted.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DeleteOption {
        /// Select feature values to be deleted by specifying entities.
        SelectEntity(std::boxed::Box<crate::model::delete_feature_values_request::SelectEntity>),
        /// Select feature values to be deleted by specifying time range and
        /// features.
        SelectTimeRangeAndFeature(
            std::boxed::Box<crate::model::delete_feature_values_request::SelectTimeRangeAndFeature>,
        ),
    }
}

/// Response message for
/// [FeaturestoreService.DeleteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues].
///
/// [google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues]: crate::client::FeaturestoreService::delete_feature_values
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeatureValuesResponse {
    /// Response based on which delete option is specified in the
    /// request
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::delete_feature_values_response::Response>,
}

impl DeleteFeatureValuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `response`.
    pub fn set_response<
        T: std::convert::Into<
            std::option::Option<crate::model::delete_feature_values_response::Response>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// if it holds a `SelectEntity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_select_entity(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_response::SelectEntity>,
    > {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_response::Response::SelectEntity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// if it holds a `SelectTimeRangeAndFeature`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_select_time_range_and_feature(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::delete_feature_values_response::SelectTimeRangeAndFeature>,
    > {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::delete_feature_values_response::Response::SelectTimeRangeAndFeature(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// to hold a `SelectEntity`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_select_entity<
        T: std::convert::Into<
            std::boxed::Box<crate::model::delete_feature_values_response::SelectEntity>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::delete_feature_values_response::Response::SelectEntity(v.into()),
        );
        self
    }

    /// Sets the value of [response][crate::model::DeleteFeatureValuesResponse::response]
    /// to hold a `SelectTimeRangeAndFeature`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_select_time_range_and_feature<
        T: std::convert::Into<
            std::boxed::Box<
                crate::model::delete_feature_values_response::SelectTimeRangeAndFeature,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::delete_feature_values_response::Response::SelectTimeRangeAndFeature(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DeleteFeatureValuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse"
    }
}

/// Defines additional types related to DeleteFeatureValuesResponse
pub mod delete_feature_values_response {
    #[allow(unused_imports)]
    use super::*;

    /// Response message if the request uses the SelectEntity option.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectEntity {
        /// The count of deleted entity rows in the offline storage.
        /// Each row corresponds to the combination of an entity ID and a timestamp.
        /// One entity ID can have multiple rows in the offline storage.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub offline_storage_deleted_entity_row_count: i64,

        /// The count of deleted entities in the online storage.
        /// Each entity ID corresponds to one entity.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub online_storage_deleted_entity_count: i64,
    }

    impl SelectEntity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offline_storage_deleted_entity_row_count][crate::model::delete_feature_values_response::SelectEntity::offline_storage_deleted_entity_row_count].
        pub fn set_offline_storage_deleted_entity_row_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.offline_storage_deleted_entity_row_count = v.into();
            self
        }

        /// Sets the value of [online_storage_deleted_entity_count][crate::model::delete_feature_values_response::SelectEntity::online_storage_deleted_entity_count].
        pub fn set_online_storage_deleted_entity_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.online_storage_deleted_entity_count = v.into();
            self
        }
    }

    impl wkt::message::Message for SelectEntity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectEntity"
        }
    }

    /// Response message if the request uses the SelectTimeRangeAndFeature option.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectTimeRangeAndFeature {
        /// The count of the features or columns impacted.
        /// This is the same as the feature count in the request.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub impacted_feature_count: i64,

        /// The count of modified entity rows in the offline storage.
        /// Each row corresponds to the combination of an entity ID and a timestamp.
        /// One entity ID can have multiple rows in the offline storage.
        /// Within each row, only the features specified in the request are
        /// deleted.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub offline_storage_modified_entity_row_count: i64,

        /// The count of modified entities in the online storage.
        /// Each entity ID corresponds to one entity.
        /// Within each entity, only the features specified in the request are
        /// deleted.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub online_storage_modified_entity_count: i64,
    }

    impl SelectTimeRangeAndFeature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [impacted_feature_count][crate::model::delete_feature_values_response::SelectTimeRangeAndFeature::impacted_feature_count].
        pub fn set_impacted_feature_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.impacted_feature_count = v.into();
            self
        }

        /// Sets the value of [offline_storage_modified_entity_row_count][crate::model::delete_feature_values_response::SelectTimeRangeAndFeature::offline_storage_modified_entity_row_count].
        pub fn set_offline_storage_modified_entity_row_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.offline_storage_modified_entity_row_count = v.into();
            self
        }

        /// Sets the value of [online_storage_modified_entity_count][crate::model::delete_feature_values_response::SelectTimeRangeAndFeature::online_storage_modified_entity_count].
        pub fn set_online_storage_modified_entity_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.online_storage_modified_entity_count = v.into();
            self
        }
    }

    impl wkt::message::Message for SelectTimeRangeAndFeature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectTimeRangeAndFeature"
        }
    }

    /// Response based on which delete option is specified in the
    /// request
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Response {
        /// Response for request specifying the entities to delete
        SelectEntity(std::boxed::Box<crate::model::delete_feature_values_response::SelectEntity>),
        /// Response for request specifying time range and feature
        SelectTimeRangeAndFeature(
            std::boxed::Box<
                crate::model::delete_feature_values_response::SelectTimeRangeAndFeature,
            >,
        ),
    }
}

/// Selector for entityId. Getting ids from the given source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityIdSelector {
    /// Source column that holds entity IDs. If not provided, entity IDs are
    /// extracted from the column named entity_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id_field: std::string::String,

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub entity_ids_source: std::option::Option<crate::model::entity_id_selector::EntityIdsSource>,
}

impl EntityIdSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_id_field][crate::model::EntityIdSelector::entity_id_field].
    pub fn set_entity_id_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id_field = v.into();
        self
    }

    /// Sets the value of `entity_ids_source`.
    pub fn set_entity_ids_source<
        T: std::convert::Into<std::option::Option<crate::model::entity_id_selector::EntityIdsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_ids_source = v.into();
        self
    }

    /// The value of [entity_ids_source][crate::model::EntityIdSelector::entity_ids_source]
    /// if it holds a `CsvSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_csv_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::CsvSource>> {
        #[allow(unreachable_patterns)]
        self.entity_ids_source.as_ref().and_then(|v| match v {
            crate::model::entity_id_selector::EntityIdsSource::CsvSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_ids_source][crate::model::EntityIdSelector::entity_ids_source]
    /// to hold a `CsvSource`.
    ///
    /// Note that all the setters affecting `entity_ids_source` are
    /// mutually exclusive.
    pub fn set_csv_source<T: std::convert::Into<std::boxed::Box<crate::model::CsvSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_ids_source = std::option::Option::Some(
            crate::model::entity_id_selector::EntityIdsSource::CsvSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EntityIdSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.EntityIdSelector"
    }
}

/// Defines additional types related to EntityIdSelector
pub mod entity_id_selector {
    #[allow(unused_imports)]
    use super::*;

    /// Details about the source data, including the location of the storage and
    /// the format.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EntityIdsSource {
        /// Source of Csv
        CsvSource(std::boxed::Box<crate::model::CsvSource>),
    }
}

/// Request message for
/// [GenAiCacheService.CreateCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.CreateCachedContent].
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.CreateCachedContent]: crate::client::GenAiCacheService::create_cached_content
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCachedContentRequest {
    /// Required. The parent resource where the cached content will be created
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The cached content to create
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cached_content: std::option::Option<crate::model::CachedContent>,
}

impl CreateCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCachedContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cached_content][crate::model::CreateCachedContentRequest::cached_content].
    pub fn set_cached_content<
        T: std::convert::Into<std::option::Option<crate::model::CachedContent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cached_content = v.into();
        self
    }
}

impl wkt::message::Message for CreateCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateCachedContentRequest"
    }
}

/// Request message for
/// [GenAiCacheService.GetCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.GetCachedContent].
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.GetCachedContent]: crate::client::GenAiCacheService::get_cached_content
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCachedContentRequest {
    /// Required. The resource name referring to the cached content
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCachedContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetCachedContentRequest"
    }
}

/// Request message for
/// [GenAiCacheService.UpdateCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.UpdateCachedContent].
/// Only expire_time or ttl can be updated.
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.UpdateCachedContent]: crate::client::GenAiCacheService::update_cached_content
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCachedContentRequest {
    /// Required. The cached content to update
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cached_content: std::option::Option<crate::model::CachedContent>,

    /// Required. The list of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cached_content][crate::model::UpdateCachedContentRequest::cached_content].
    pub fn set_cached_content<
        T: std::convert::Into<std::option::Option<crate::model::CachedContent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cached_content = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCachedContentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateCachedContentRequest"
    }
}

/// Request message for
/// [GenAiCacheService.DeleteCachedContent][google.cloud.aiplatform.v1.GenAiCacheService.DeleteCachedContent].
///
/// [google.cloud.aiplatform.v1.GenAiCacheService.DeleteCachedContent]: crate::client::GenAiCacheService::delete_cached_content
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCachedContentRequest {
    /// Required. The resource name referring to the cached content
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteCachedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCachedContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCachedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteCachedContentRequest"
    }
}

/// Request to list CachedContents.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCachedContentsRequest {
    /// Required. The parent, which owns this collection of cached contents.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of cached contents to return. The service may
    /// return fewer than this value. If unspecified, some default (under maximum)
    /// number of items will be returned. The maximum value is 1000; values above
    /// 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListCachedContents` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCachedContents` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListCachedContentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCachedContentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCachedContentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCachedContentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCachedContentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCachedContentsRequest"
    }
}

/// Response with a list of CachedContents.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCachedContentsResponse {
    /// List of cached contents.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cached_contents: std::vec::Vec<crate::model::CachedContent>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListCachedContentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCachedContentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [cached_contents][crate::model::ListCachedContentsResponse::cached_contents].
    pub fn set_cached_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CachedContent>,
    {
        use std::iter::Iterator;
        self.cached_contents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCachedContentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCachedContentsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCachedContentsResponse {
    type PageItem = crate::model::CachedContent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cached_contents
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [GenAiTuningService.CreateTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.CreateTuningJob].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.CreateTuningJob]: crate::client::GenAiTuningService::create_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTuningJobRequest {
    /// Required. The resource name of the Location to create the TuningJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The TuningJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_job: std::option::Option<crate::model::TuningJob>,
}

impl CreateTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTuningJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tuning_job][crate::model::CreateTuningJobRequest::tuning_job].
    pub fn set_tuning_job<T: std::convert::Into<std::option::Option<crate::model::TuningJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTuningJobRequest"
    }
}

/// Request message for
/// [GenAiTuningService.GetTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.GetTuningJob].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.GetTuningJob]: crate::client::GenAiTuningService::get_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTuningJobRequest {
    /// Required. The name of the TuningJob resource. Format:
    /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTuningJobRequest"
    }
}

/// Request message for
/// [GenAiTuningService.ListTuningJobs][google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs]: crate::client::GenAiTuningService::list_tuning_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTuningJobsRequest {
    /// Required. The resource name of the Location to list the TuningJobs from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListTuningJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListTuningJobsResponse.next_page_token]
    /// of the previous GenAiTuningService.ListTuningJob][] call.
    ///
    /// [google.cloud.aiplatform.v1.ListTuningJobsResponse.next_page_token]: crate::model::ListTuningJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTuningJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTuningJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTuningJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTuningJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTuningJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTuningJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTuningJobsRequest"
    }
}

/// Response message for
/// [GenAiTuningService.ListTuningJobs][google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs]
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.ListTuningJobs]: crate::client::GenAiTuningService::list_tuning_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTuningJobsResponse {
    /// List of TuningJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tuning_jobs: std::vec::Vec<crate::model::TuningJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListTuningJobsRequest.page_token][google.cloud.aiplatform.v1.ListTuningJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListTuningJobsRequest.page_token]: crate::model::ListTuningJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTuningJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTuningJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tuning_jobs][crate::model::ListTuningJobsResponse::tuning_jobs].
    pub fn set_tuning_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TuningJob>,
    {
        use std::iter::Iterator;
        self.tuning_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTuningJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTuningJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTuningJobsResponse {
    type PageItem = crate::model::TuningJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tuning_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [GenAiTuningService.CancelTuningJob][google.cloud.aiplatform.v1.GenAiTuningService.CancelTuningJob].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.CancelTuningJob]: crate::client::GenAiTuningService::cancel_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelTuningJobRequest {
    /// Required. The name of the TuningJob to cancel. Format:
    /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelTuningJobRequest"
    }
}

/// Request message for
/// [GenAiTuningService.RebaseTunedModel][google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel]: crate::client::GenAiTuningService::rebase_tuned_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebaseTunedModelRequest {
    /// Required. The resource name of the Location into which to rebase the Model.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. TunedModel reference to retrieve the legacy model information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuned_model_ref: std::option::Option<crate::model::TunedModelRef>,

    /// Optional. The TuningJob to be updated. Users can use this TuningJob field
    /// to overwrite tuning configs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_job: std::option::Option<crate::model::TuningJob>,

    /// Optional. The Google Cloud Storage location to write the artifacts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact_destination: std::option::Option<crate::model::GcsDestination>,

    /// Optional. By default, bison to gemini migration will always create new
    /// model/endpoint, but for gemini-1.0 to gemini-1.5 migration, we default
    /// deploy to the same endpoint. See details in this Section.
    pub deploy_to_same_endpoint: bool,
}

impl RebaseTunedModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RebaseTunedModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tuned_model_ref][crate::model::RebaseTunedModelRequest::tuned_model_ref].
    pub fn set_tuned_model_ref<
        T: std::convert::Into<std::option::Option<crate::model::TunedModelRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model_ref = v.into();
        self
    }

    /// Sets the value of [tuning_job][crate::model::RebaseTunedModelRequest::tuning_job].
    pub fn set_tuning_job<T: std::convert::Into<std::option::Option<crate::model::TuningJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_job = v.into();
        self
    }

    /// Sets the value of [artifact_destination][crate::model::RebaseTunedModelRequest::artifact_destination].
    pub fn set_artifact_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_destination = v.into();
        self
    }

    /// Sets the value of [deploy_to_same_endpoint][crate::model::RebaseTunedModelRequest::deploy_to_same_endpoint].
    pub fn set_deploy_to_same_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deploy_to_same_endpoint = v.into();
        self
    }
}

impl wkt::message::Message for RebaseTunedModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebaseTunedModelRequest"
    }
}

/// Runtime operation information for
/// [GenAiTuningService.RebaseTunedModel][google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel].
///
/// [google.cloud.aiplatform.v1.GenAiTuningService.RebaseTunedModel]: crate::client::GenAiTuningService::rebase_tuned_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebaseTunedModelOperationMetadata {
    /// The common part of the operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl RebaseTunedModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::RebaseTunedModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for RebaseTunedModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebaseTunedModelOperationMetadata"
    }
}

/// Represents a HyperparameterTuningJob. A HyperparameterTuningJob
/// has a Study specification and multiple CustomJobs with identical
/// CustomJob specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HyperparameterTuningJob {
    /// Output only. Resource name of the HyperparameterTuningJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the HyperparameterTuningJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Study configuration of the HyperparameterTuningJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study_spec: std::option::Option<crate::model::StudySpec>,

    /// Required. The desired total number of Trials.
    pub max_trial_count: i32,

    /// Required. The desired number of Trials to run in parallel.
    pub parallel_trial_count: i32,

    /// The number of failed Trials that need to be seen before failing
    /// the HyperparameterTuningJob.
    ///
    /// If set to 0, Vertex AI decides how many Trials must fail
    /// before the whole job fails.
    pub max_failed_trial_count: i32,

    /// Required. The spec of a trial job. The same spec applies to the CustomJobs
    /// created in all the trials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trial_job_spec: std::option::Option<crate::model::CustomJobSpec>,

    /// Output only. Trials of the HyperparameterTuningJob.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trials: std::vec::Vec<crate::model::Trial>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the HyperparameterTuningJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the HyperparameterTuningJob for the first time
    /// entered the `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the HyperparameterTuningJob entered any of the
    /// following states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`,
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the HyperparameterTuningJob was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is JOB_STATE_FAILED or
    /// JOB_STATE_CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize HyperparameterTuningJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a HyperparameterTuningJob.
    /// If this is set, then all resources created by the HyperparameterTuningJob
    /// will be encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl HyperparameterTuningJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HyperparameterTuningJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::HyperparameterTuningJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [study_spec][crate::model::HyperparameterTuningJob::study_spec].
    pub fn set_study_spec<T: std::convert::Into<std::option::Option<crate::model::StudySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.study_spec = v.into();
        self
    }

    /// Sets the value of [max_trial_count][crate::model::HyperparameterTuningJob::max_trial_count].
    pub fn set_max_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_trial_count = v.into();
        self
    }

    /// Sets the value of [parallel_trial_count][crate::model::HyperparameterTuningJob::parallel_trial_count].
    pub fn set_parallel_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.parallel_trial_count = v.into();
        self
    }

    /// Sets the value of [max_failed_trial_count][crate::model::HyperparameterTuningJob::max_failed_trial_count].
    pub fn set_max_failed_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_failed_trial_count = v.into();
        self
    }

    /// Sets the value of [trial_job_spec][crate::model::HyperparameterTuningJob::trial_job_spec].
    pub fn set_trial_job_spec<
        T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trial_job_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::HyperparameterTuningJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::HyperparameterTuningJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::HyperparameterTuningJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::HyperparameterTuningJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::HyperparameterTuningJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::HyperparameterTuningJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::HyperparameterTuningJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::HyperparameterTuningJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::HyperparameterTuningJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [trials][crate::model::HyperparameterTuningJob::trials].
    pub fn set_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.trials = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::HyperparameterTuningJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HyperparameterTuningJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.HyperparameterTuningJob"
    }
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Index {
    /// Output only. The resource name of the Index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the Index.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// additional information about the Index, that is specific to it. Unset if
    /// the Index does not have any additional information. The schema is defined
    /// as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_uri: std::string::String,

    /// An additional information about the Index; the schema of the metadata can
    /// be found in
    /// [metadata_schema][google.cloud.aiplatform.v1.Index.metadata_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Index.metadata_schema_uri]: crate::model::Index::metadata_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. The pointers to DeployedIndexes created from this Index.
    /// An Index can be only deleted if all its DeployedIndexes had been undeployed
    /// first.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_indexes: std::vec::Vec<crate::model::DeployedIndexRef>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Indexes.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this Index was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Index was most recently updated.
    /// This also includes any update to the contents of the Index.
    /// Note that Operations working on this Index may have their
    /// [Operations.metadata.generic_metadata.update_time]
    /// [google.cloud.aiplatform.v1.GenericOperationMetadata.update_time] a little
    /// after the value of this timestamp, yet that does not mean their results are
    /// not already reflected in the Index. Result of any successfully completed
    /// Operation on the Index is reflected in it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Stats of the index resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_stats: std::option::Option<crate::model::IndexStats>,

    /// Immutable. The update method to use with this Index. If not set,
    /// BATCH_UPDATE will be used by default.
    pub index_update_method: crate::model::index::IndexUpdateMethod,

    /// Immutable. Customer-managed encryption key spec for an Index. If set, this
    /// Index and all sub-resources of this Index will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl Index {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Index::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Index::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Index::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [metadata_schema_uri][crate::model::Index::metadata_schema_uri].
    pub fn set_metadata_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Index::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Index::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Index::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Index::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [index_stats][crate::model::Index::index_stats].
    pub fn set_index_stats<T: std::convert::Into<std::option::Option<crate::model::IndexStats>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_stats = v.into();
        self
    }

    /// Sets the value of [index_update_method][crate::model::Index::index_update_method].
    pub fn set_index_update_method<
        T: std::convert::Into<crate::model::index::IndexUpdateMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_update_method = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Index::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Index::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Index::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [deployed_indexes][crate::model::Index::deployed_indexes].
    pub fn set_deployed_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedIndexRef>,
    {
        use std::iter::Iterator;
        self.deployed_indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Index::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Index {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Index"
    }
}

/// Defines additional types related to Index
pub mod index {
    #[allow(unused_imports)]
    use super::*;

    /// The update method of an Index.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IndexUpdateMethod(std::borrow::Cow<'static, str>);

    impl IndexUpdateMethod {
        /// Creates a new IndexUpdateMethod instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [IndexUpdateMethod](IndexUpdateMethod)
    pub mod index_update_method {
        use super::IndexUpdateMethod;

        /// Should not be used.
        pub const INDEX_UPDATE_METHOD_UNSPECIFIED: IndexUpdateMethod =
            IndexUpdateMethod::new("INDEX_UPDATE_METHOD_UNSPECIFIED");

        /// BatchUpdate: user can call UpdateIndex with files on Cloud Storage of
        /// Datapoints to update.
        pub const BATCH_UPDATE: IndexUpdateMethod = IndexUpdateMethod::new("BATCH_UPDATE");

        /// StreamUpdate: user can call UpsertDatapoints/DeleteDatapoints to update
        /// the Index and the updates will be applied in corresponding
        /// DeployedIndexes in nearly real-time.
        pub const STREAM_UPDATE: IndexUpdateMethod = IndexUpdateMethod::new("STREAM_UPDATE");
    }

    impl std::convert::From<std::string::String> for IndexUpdateMethod {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A datapoint of Index.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexDatapoint {
    /// Required. Unique identifier of the datapoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datapoint_id: std::string::String,

    /// Required. Feature embedding vector for dense index. An array of numbers
    /// with the length of [NearestNeighborSearchConfig.dimensions].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_vector: std::vec::Vec<f32>,

    /// Optional. Feature embedding vector for sparse index.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sparse_embedding: std::option::Option<crate::model::index_datapoint::SparseEmbedding>,

    /// Optional. List of Restrict of the datapoint, used to perform "restricted
    /// searches" where boolean rule are used to filter the subset of the database
    /// eligible for matching. This uses categorical tokens. See:
    /// <https://cloud.google.com/vertex-ai/docs/matching-engine/filtering>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub restricts: std::vec::Vec<crate::model::index_datapoint::Restriction>,

    /// Optional. List of Restrict of the datapoint, used to perform "restricted
    /// searches" where boolean rule are used to filter the subset of the database
    /// eligible for matching. This uses numeric comparisons.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub numeric_restricts: std::vec::Vec<crate::model::index_datapoint::NumericRestriction>,

    /// Optional. CrowdingTag of the datapoint, the number of neighbors to return
    /// in each crowding can be configured during query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crowding_tag: std::option::Option<crate::model::index_datapoint::CrowdingTag>,
}

impl IndexDatapoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datapoint_id][crate::model::IndexDatapoint::datapoint_id].
    pub fn set_datapoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datapoint_id = v.into();
        self
    }

    /// Sets the value of [sparse_embedding][crate::model::IndexDatapoint::sparse_embedding].
    pub fn set_sparse_embedding<
        T: std::convert::Into<std::option::Option<crate::model::index_datapoint::SparseEmbedding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sparse_embedding = v.into();
        self
    }

    /// Sets the value of [crowding_tag][crate::model::IndexDatapoint::crowding_tag].
    pub fn set_crowding_tag<
        T: std::convert::Into<std::option::Option<crate::model::index_datapoint::CrowdingTag>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.crowding_tag = v.into();
        self
    }

    /// Sets the value of [feature_vector][crate::model::IndexDatapoint::feature_vector].
    pub fn set_feature_vector<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.feature_vector = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [restricts][crate::model::IndexDatapoint::restricts].
    pub fn set_restricts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index_datapoint::Restriction>,
    {
        use std::iter::Iterator;
        self.restricts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [numeric_restricts][crate::model::IndexDatapoint::numeric_restricts].
    pub fn set_numeric_restricts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::index_datapoint::NumericRestriction>,
    {
        use std::iter::Iterator;
        self.numeric_restricts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IndexDatapoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint"
    }
}

/// Defines additional types related to IndexDatapoint
pub mod index_datapoint {
    #[allow(unused_imports)]
    use super::*;

    /// Feature embedding vector for sparse index. An array of numbers whose values
    /// are located in the specified dimensions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SparseEmbedding {
        /// Required. The list of embedding values of the sparse vector.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<f32>,

        /// Required. The list of indexes for the embedding values of the sparse
        /// vector.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
        pub dimensions: std::vec::Vec<i64>,
    }

    impl SparseEmbedding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::index_datapoint::SparseEmbedding::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dimensions][crate::model::index_datapoint::SparseEmbedding::dimensions].
        pub fn set_dimensions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.dimensions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SparseEmbedding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.SparseEmbedding"
        }
    }

    /// Restriction of a datapoint which describe its attributes(tokens) from each
    /// of several attribute categories(namespaces).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Restriction {
        /// The namespace of this restriction. e.g.: color.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace: std::string::String,

        /// The attributes to allow in this namespace. e.g.: 'red'
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allow_list: std::vec::Vec<std::string::String>,

        /// The attributes to deny in this namespace. e.g.: 'blue'
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub deny_list: std::vec::Vec<std::string::String>,
    }

    impl Restriction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [namespace][crate::model::index_datapoint::Restriction::namespace].
        pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.namespace = v.into();
            self
        }

        /// Sets the value of [allow_list][crate::model::index_datapoint::Restriction::allow_list].
        pub fn set_allow_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allow_list = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [deny_list][crate::model::index_datapoint::Restriction::deny_list].
        pub fn set_deny_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.deny_list = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Restriction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.Restriction"
        }
    }

    /// This field allows restricts to be based on numeric comparisons rather
    /// than categorical tokens.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NumericRestriction {
        /// The namespace of this restriction. e.g.: cost.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespace: std::string::String,

        /// This MUST be specified for queries and must NOT be specified for
        /// datapoints.
        pub op: crate::model::index_datapoint::numeric_restriction::Operator,

        /// The type of Value must be consistent for all datapoints with a given
        /// namespace name. This is verified at runtime.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::index_datapoint::numeric_restriction::Value>,
    }

    impl NumericRestriction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [namespace][crate::model::index_datapoint::NumericRestriction::namespace].
        pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.namespace = v.into();
            self
        }

        /// Sets the value of [op][crate::model::index_datapoint::NumericRestriction::op].
        pub fn set_op<
            T: std::convert::Into<crate::model::index_datapoint::numeric_restriction::Operator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.op = v.into();
            self
        }

        /// Sets the value of `value`.
        pub fn set_value<
            T: std::convert::Into<
                std::option::Option<crate::model::index_datapoint::numeric_restriction::Value>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// if it holds a `ValueInt`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value_int(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::index_datapoint::numeric_restriction::Value::ValueInt(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// if it holds a `ValueFloat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value_float(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::index_datapoint::numeric_restriction::Value::ValueFloat(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// if it holds a `ValueDouble`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_value_double(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::index_datapoint::numeric_restriction::Value::ValueDouble(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// to hold a `ValueInt`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_int<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::index_datapoint::numeric_restriction::Value::ValueInt(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// to hold a `ValueFloat`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::index_datapoint::numeric_restriction::Value::ValueFloat(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::index_datapoint::NumericRestriction::value]
        /// to hold a `ValueDouble`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_value_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::index_datapoint::numeric_restriction::Value::ValueDouble(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for NumericRestriction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.NumericRestriction"
        }
    }

    /// Defines additional types related to NumericRestriction
    pub mod numeric_restriction {
        #[allow(unused_imports)]
        use super::*;

        /// Which comparison operator to use.  Should be specified for queries only;
        /// specifying this for a datapoint is an error.
        ///
        /// Datapoints for which Operator is true relative to the query's Value
        /// field will be allowlisted.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Operator(std::borrow::Cow<'static, str>);

        impl Operator {
            /// Creates a new Operator instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [Operator](Operator)
        pub mod operator {
            use super::Operator;

            /// Default value of the enum.
            pub const OPERATOR_UNSPECIFIED: Operator = Operator::new("OPERATOR_UNSPECIFIED");

            /// Datapoints are eligible iff their value is < the query's.
            pub const LESS: Operator = Operator::new("LESS");

            /// Datapoints are eligible iff their value is <= the query's.
            pub const LESS_EQUAL: Operator = Operator::new("LESS_EQUAL");

            /// Datapoints are eligible iff their value is == the query's.
            pub const EQUAL: Operator = Operator::new("EQUAL");

            /// Datapoints are eligible iff their value is >= the query's.
            pub const GREATER_EQUAL: Operator = Operator::new("GREATER_EQUAL");

            /// Datapoints are eligible iff their value is > the query's.
            pub const GREATER: Operator = Operator::new("GREATER");

            /// Datapoints are eligible iff their value is != the query's.
            pub const NOT_EQUAL: Operator = Operator::new("NOT_EQUAL");
        }

        impl std::convert::From<std::string::String> for Operator {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        /// The type of Value must be consistent for all datapoints with a given
        /// namespace name. This is verified at runtime.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// Represents 64 bit integer.
            ValueInt(i64),
            /// Represents 32 bit float.
            ValueFloat(f32),
            /// Represents 64 bit float.
            ValueDouble(f64),
        }
    }

    /// Crowding tag is a constraint on a neighbor list produced by nearest
    /// neighbor search requiring that no more than some value k' of the k
    /// neighbors returned have the same value of crowding_attribute.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CrowdingTag {
        /// The attribute value used for crowding.  The maximum number of neighbors
        /// to return per crowding attribute value
        /// (per_crowding_attribute_num_neighbors) is configured per-query. This
        /// field is ignored if per_crowding_attribute_num_neighbors is larger than
        /// the total number of neighbors to return for a given query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub crowding_attribute: std::string::String,
    }

    impl CrowdingTag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [crowding_attribute][crate::model::index_datapoint::CrowdingTag::crowding_attribute].
        pub fn set_crowding_attribute<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.crowding_attribute = v.into();
            self
        }
    }

    impl wkt::message::Message for CrowdingTag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.CrowdingTag"
        }
    }
}

/// Stats of the Index.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexStats {
    /// Output only. The number of dense vectors in the Index.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub vectors_count: i64,

    /// Output only. The number of sparse vectors in the Index.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sparse_vectors_count: i64,

    /// Output only. The number of shards in the Index.
    pub shards_count: i32,
}

impl IndexStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vectors_count][crate::model::IndexStats::vectors_count].
    pub fn set_vectors_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.vectors_count = v.into();
        self
    }

    /// Sets the value of [sparse_vectors_count][crate::model::IndexStats::sparse_vectors_count].
    pub fn set_sparse_vectors_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sparse_vectors_count = v.into();
        self
    }

    /// Sets the value of [shards_count][crate::model::IndexStats::shards_count].
    pub fn set_shards_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shards_count = v.into();
        self
    }
}

impl wkt::message::Message for IndexStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexStats"
    }
}

/// Indexes are deployed into it. An IndexEndpoint can have multiple
/// DeployedIndexes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexEndpoint {
    /// Output only. The resource name of the IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the IndexEndpoint.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The indexes deployed in this endpoint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_indexes: std::vec::Vec<crate::model::DeployedIndex>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your IndexEndpoints.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this IndexEndpoint was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this IndexEndpoint was last updated.
    /// This timestamp is not updated when the endpoint's DeployedIndexes are
    /// updated, e.g. due to updates of the original Indexes they are the
    /// deployments of.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The full name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
    /// to which the IndexEndpoint should be peered.
    ///
    /// Private services access must already be configured for the network. If left
    /// unspecified, the Endpoint is not peered with any network.
    ///
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] and
    /// [private_service_connect_config][google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]
    /// are mutually exclusive.
    ///
    /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
    /// `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in '12345', and {network} is
    /// network name.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    /// [google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]: crate::model::IndexEndpoint::private_service_connect_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Deprecated: If true, expose the IndexEndpoint via private service
    /// connect.
    ///
    /// Only one of the fields,
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] or
    /// [enable_private_service_connect][google.cloud.aiplatform.v1.IndexEndpoint.enable_private_service_connect],
    /// can be set.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.enable_private_service_connect]: crate::model::IndexEndpoint::enable_private_service_connect
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    pub enable_private_service_connect: bool,

    /// Optional. Configuration for private service connect.
    ///
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] and
    /// [private_service_connect_config][google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]
    /// are mutually exclusive.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    /// [google.cloud.aiplatform.v1.IndexEndpoint.private_service_connect_config]: crate::model::IndexEndpoint::private_service_connect_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_service_connect_config:
        std::option::Option<crate::model::PrivateServiceConnectConfig>,

    /// Optional. If true, the deployed index will be accessible through public
    /// endpoint.
    pub public_endpoint_enabled: bool,

    /// Output only. If
    /// [public_endpoint_enabled][google.cloud.aiplatform.v1.IndexEndpoint.public_endpoint_enabled]
    /// is true, this field will be populated with the domain name to use for this
    /// index endpoint.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.public_endpoint_enabled]: crate::model::IndexEndpoint::public_endpoint_enabled
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_endpoint_domain_name: std::string::String,

    /// Immutable. Customer-managed encryption key spec for an IndexEndpoint. If
    /// set, this IndexEndpoint and all sub-resources of this IndexEndpoint will be
    /// secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl IndexEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IndexEndpoint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IndexEndpoint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::IndexEndpoint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::IndexEndpoint::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::IndexEndpoint::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::IndexEndpoint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [network][crate::model::IndexEndpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [enable_private_service_connect][crate::model::IndexEndpoint::enable_private_service_connect].
    pub fn set_enable_private_service_connect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_service_connect = v.into();
        self
    }

    /// Sets the value of [private_service_connect_config][crate::model::IndexEndpoint::private_service_connect_config].
    pub fn set_private_service_connect_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateServiceConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_service_connect_config = v.into();
        self
    }

    /// Sets the value of [public_endpoint_enabled][crate::model::IndexEndpoint::public_endpoint_enabled].
    pub fn set_public_endpoint_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.public_endpoint_enabled = v.into();
        self
    }

    /// Sets the value of [public_endpoint_domain_name][crate::model::IndexEndpoint::public_endpoint_domain_name].
    pub fn set_public_endpoint_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_endpoint_domain_name = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::IndexEndpoint::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::IndexEndpoint::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::IndexEndpoint::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [deployed_indexes][crate::model::IndexEndpoint::deployed_indexes].
    pub fn set_deployed_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedIndex>,
    {
        use std::iter::Iterator;
        self.deployed_indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::IndexEndpoint::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for IndexEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexEndpoint"
    }
}

/// A deployment of an Index. IndexEndpoints contain one or more DeployedIndexes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedIndex {
    /// Required. The user specified ID of the DeployedIndex.
    /// The ID can be up to 128 characters long and must start with a letter and
    /// only contain letters, numbers, and underscores.
    /// The ID must be unique within the project it is created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Required. The name of the Index this is the deployment of.
    /// We may refer to this Index as the DeployedIndex's "original" Index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// The display name of the DeployedIndex. If not provided upon creation,
    /// the Index's display_name is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp when the DeployedIndex was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides paths for users to send requests directly to the
    /// deployed index services running on Cloud via private services access. This
    /// field is populated if
    /// [network][google.cloud.aiplatform.v1.IndexEndpoint.network] is configured.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.network]: crate::model::IndexEndpoint::network
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_endpoints: std::option::Option<crate::model::IndexPrivateEndpoints>,

    /// Output only. The DeployedIndex may depend on various data on its original
    /// Index. Additionally when certain changes to the original Index are being
    /// done (e.g. when what the Index contains is being changed) the DeployedIndex
    /// may be asynchronously updated in the background to reflect these changes.
    /// If this timestamp's value is at least the
    /// [Index.update_time][google.cloud.aiplatform.v1.Index.update_time] of the
    /// original Index, it means that this DeployedIndex and the original Index are
    /// in sync. If this timestamp is older, then to see which updates this
    /// DeployedIndex already contains (and which it does not), one must
    /// [list][google.longrunning.Operations.ListOperations] the operations that
    /// are running on the original Index. Only the successfully completed
    /// Operations with
    /// [update_time][google.cloud.aiplatform.v1.GenericOperationMetadata.update_time]
    /// equal or before this sync time are contained in this DeployedIndex.
    ///
    /// [google.cloud.aiplatform.v1.GenericOperationMetadata.update_time]: crate::model::GenericOperationMetadata::update_time
    /// [google.cloud.aiplatform.v1.Index.update_time]: crate::model::Index::update_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_sync_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A description of resources that the DeployedIndex uses, which to
    /// large degree are decided by Vertex AI, and optionally allows only a modest
    /// additional configuration.
    /// If min_replica_count is not set, the default value is 2 (we don't provide
    /// SLA when min_replica_count=1). If max_replica_count is not set, the
    /// default value is min_replica_count. The max allowed replica count is
    /// 1000.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automatic_resources: std::option::Option<crate::model::AutomaticResources>,

    /// Optional. A description of resources that are dedicated to the
    /// DeployedIndex, and that need a higher degree of manual configuration. The
    /// field min_replica_count must be set to a value strictly greater than 0, or
    /// else validation will fail. We don't provide SLA when min_replica_count=1.
    /// If max_replica_count is not set, the default value is min_replica_count.
    /// The max allowed replica count is 1000.
    ///
    /// Available machine types for SMALL shard:
    /// e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
    ///
    /// Available machine types for MEDIUM shard:
    /// e2-standard-16 and all machine types available for LARGE shard.
    ///
    /// Available machine types for LARGE shard:
    /// e2-highmem-16, n2d-standard-32.
    ///
    /// n1-standard-16 and n1-standard-32 are still available, but we recommend
    /// e2-standard-16 and e2-highmem-16 for cost efficiency.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dedicated_resources: std::option::Option<crate::model::DedicatedResources>,

    /// Optional. If true, private endpoint's access logs are sent to Cloud
    /// Logging.
    ///
    /// These logs are like standard server access logs, containing
    /// information like timestamp and latency for each MatchRequest.
    ///
    /// Note that logs may incur a cost, especially if the deployed
    /// index receives a high queries per second rate (QPS).
    /// Estimate your costs before enabling this option.
    pub enable_access_logging: bool,

    /// Optional. If set, the authentication is enabled for the private endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index_auth_config: std::option::Option<crate::model::DeployedIndexAuthConfig>,

    /// Optional. A list of reserved ip ranges under the VPC network that can be
    /// used for this DeployedIndex.
    ///
    /// If set, we will deploy the index within the provided ip ranges. Otherwise,
    /// the index might be deployed to any ip ranges under the provided VPC
    /// network.
    ///
    /// The value should be the name of the address
    /// (<https://cloud.google.com/compute/docs/reference/rest/v1/addresses>)
    /// Example: ['vertex-ai-ip-range'].
    ///
    /// For more information about subnets and network IP ranges, please see
    /// <https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    /// Optional. The deployment group can be no longer than 64 characters (eg:
    /// 'test', 'prod'). If not set, we will use the 'default' deployment group.
    ///
    /// Creating `deployment_groups` with `reserved_ip_ranges` is a recommended
    /// practice when the peered network has multiple peering ranges. This creates
    /// your deployments from predictable IP spaces for easier traffic
    /// administration. Also, one deployment_group (except 'default') can only be
    /// used with the same reserved_ip_ranges which means if the deployment_group
    /// has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or
    /// [d, e] is disallowed.
    ///
    /// Note: we only support up to 5 deployment groups(not including 'default').
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_group: std::string::String,

    /// Optional. If set for PSC deployed index, PSC connection will be
    /// automatically created after deployment is done and the endpoint information
    /// is populated in private_endpoints.psc_automated_endpoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_automation_configs: std::vec::Vec<crate::model::PSCAutomationConfig>,
}

impl DeployedIndex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::DeployedIndex::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [index][crate::model::DeployedIndex::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeployedIndex::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployedIndex::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [private_endpoints][crate::model::DeployedIndex::private_endpoints].
    pub fn set_private_endpoints<
        T: std::convert::Into<std::option::Option<crate::model::IndexPrivateEndpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoints = v.into();
        self
    }

    /// Sets the value of [index_sync_time][crate::model::DeployedIndex::index_sync_time].
    pub fn set_index_sync_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_sync_time = v.into();
        self
    }

    /// Sets the value of [automatic_resources][crate::model::DeployedIndex::automatic_resources].
    pub fn set_automatic_resources<
        T: std::convert::Into<std::option::Option<crate::model::AutomaticResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automatic_resources = v.into();
        self
    }

    /// Sets the value of [dedicated_resources][crate::model::DeployedIndex::dedicated_resources].
    pub fn set_dedicated_resources<
        T: std::convert::Into<std::option::Option<crate::model::DedicatedResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dedicated_resources = v.into();
        self
    }

    /// Sets the value of [enable_access_logging][crate::model::DeployedIndex::enable_access_logging].
    pub fn set_enable_access_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_access_logging = v.into();
        self
    }

    /// Sets the value of [deployed_index_auth_config][crate::model::DeployedIndex::deployed_index_auth_config].
    pub fn set_deployed_index_auth_config<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndexAuthConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_auth_config = v.into();
        self
    }

    /// Sets the value of [deployment_group][crate::model::DeployedIndex::deployment_group].
    pub fn set_deployment_group<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_group = v.into();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::DeployedIndex::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_automation_configs][crate::model::DeployedIndex::psc_automation_configs].
    pub fn set_psc_automation_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PSCAutomationConfig>,
    {
        use std::iter::Iterator;
        self.psc_automation_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeployedIndex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndex"
    }
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployedIndexAuthConfig {
    /// Defines the authentication provider that the DeployedIndex uses.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auth_provider: std::option::Option<crate::model::deployed_index_auth_config::AuthProvider>,
}

impl DeployedIndexAuthConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auth_provider][crate::model::DeployedIndexAuthConfig::auth_provider].
    pub fn set_auth_provider<
        T: std::convert::Into<
            std::option::Option<crate::model::deployed_index_auth_config::AuthProvider>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auth_provider = v.into();
        self
    }
}

impl wkt::message::Message for DeployedIndexAuthConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexAuthConfig"
    }
}

/// Defines additional types related to DeployedIndexAuthConfig
pub mod deployed_index_auth_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for an authentication provider, including support for
    /// [JSON Web Token
    /// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AuthProvider {
        /// The list of JWT
        /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
        /// that are allowed to access. A JWT containing any of these audiences will
        /// be accepted.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub audiences: std::vec::Vec<std::string::String>,

        /// A list of allowed JWT issuers. Each entry must be a valid Google
        /// service account, in the following format:
        ///
        /// `service-account-name@project-id.iam.gserviceaccount.com`
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allowed_issuers: std::vec::Vec<std::string::String>,
    }

    impl AuthProvider {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [audiences][crate::model::deployed_index_auth_config::AuthProvider::audiences].
        pub fn set_audiences<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.audiences = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allowed_issuers][crate::model::deployed_index_auth_config::AuthProvider::allowed_issuers].
        pub fn set_allowed_issuers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_issuers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AuthProvider {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexAuthConfig.AuthProvider"
        }
    }
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
/// To send request via private service access, use match_grpc_address.
/// To send request via private service connect, use service_attachment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexPrivateEndpoints {
    /// Output only. The ip address used to send match gRPC requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub match_grpc_address: std::string::String,

    /// Output only. The name of the service attachment resource. Populated if
    /// private service connect is enabled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. PscAutomatedEndpoints is populated if private service connect
    /// is enabled if PscAutomatedConfig is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_automated_endpoints: std::vec::Vec<crate::model::PscAutomatedEndpoints>,
}

impl IndexPrivateEndpoints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [match_grpc_address][crate::model::IndexPrivateEndpoints::match_grpc_address].
    pub fn set_match_grpc_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_grpc_address = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::IndexPrivateEndpoints::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_automated_endpoints][crate::model::IndexPrivateEndpoints::psc_automated_endpoints].
    pub fn set_psc_automated_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscAutomatedEndpoints>,
    {
        use std::iter::Iterator;
        self.psc_automated_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IndexPrivateEndpoints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexPrivateEndpoints"
    }
}

/// Request message for
/// [IndexEndpointService.CreateIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint]: crate::client::IndexEndpointService::create_index_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexEndpointRequest {
    /// Required. The resource name of the Location to create the IndexEndpoint in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The IndexEndpoint to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_endpoint: std::option::Option<crate::model::IndexEndpoint>,
}

impl CreateIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexEndpointRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index_endpoint][crate::model::CreateIndexEndpointRequest::index_endpoint].
    pub fn set_index_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::IndexEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_endpoint = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexEndpointRequest"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.CreateIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.CreateIndexEndpoint]: crate::client::IndexEndpointService::create_index_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexEndpointOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateIndexEndpointOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateIndexEndpointOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexEndpointOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexEndpointOperationMetadata"
    }
}

/// Request message for
/// [IndexEndpointService.GetIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.GetIndexEndpoint]
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.GetIndexEndpoint]: crate::client::IndexEndpointService::get_index_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexEndpointRequest {
    /// Required. The name of the IndexEndpoint resource.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetIndexEndpointRequest"
    }
}

/// Request message for
/// [IndexEndpointService.ListIndexEndpoints][google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]: crate::client::IndexEndpointService::list_index_endpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexEndpointsRequest {
    /// Required. The resource name of the Location from which to list the
    /// IndexEndpoints. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `index_endpoint` supports = and !=. `index_endpoint` represents the
    ///   IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
    ///   [resourcename][google.cloud.aiplatform.v1.IndexEndpoint.name].
    /// * `display_name` supports =, != and regex()
    ///   (uses [re2](https://github.com/google/re2/wiki/Syntax) syntax)
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* or labels:key - key existence
    ///   A key including a space must be quoted. `labels."a key"`.
    ///
    /// Some examples:
    ///
    /// * `index_endpoint="1"`
    /// * `display_name="myDisplayName"`
    /// * `regex(display_name, "^A") -> The display name starts with an A.
    /// * `labels.myKey="myValue"`
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpoint.name]: crate::model::IndexEndpoint::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListIndexEndpointsResponse.next_page_token][google.cloud.aiplatform.v1.ListIndexEndpointsResponse.next_page_token]
    /// of the previous
    /// [IndexEndpointService.ListIndexEndpoints][google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]: crate::client::IndexEndpointService::list_index_endpoints
    /// [google.cloud.aiplatform.v1.ListIndexEndpointsResponse.next_page_token]: crate::model::ListIndexEndpointsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListIndexEndpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexEndpointsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexEndpointsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexEndpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexEndpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListIndexEndpointsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexEndpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexEndpointsRequest"
    }
}

/// Response message for
/// [IndexEndpointService.ListIndexEndpoints][google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.ListIndexEndpoints]: crate::client::IndexEndpointService::list_index_endpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexEndpointsResponse {
    /// List of IndexEndpoints in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_endpoints: std::vec::Vec<crate::model::IndexEndpoint>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListIndexEndpointsRequest.page_token][google.cloud.aiplatform.v1.ListIndexEndpointsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListIndexEndpointsRequest.page_token]: crate::model::ListIndexEndpointsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListIndexEndpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexEndpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [index_endpoints][crate::model::ListIndexEndpointsResponse::index_endpoints].
    pub fn set_index_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexEndpoint>,
    {
        use std::iter::Iterator;
        self.index_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIndexEndpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexEndpointsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListIndexEndpointsResponse {
    type PageItem = crate::model::IndexEndpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.index_endpoints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [IndexEndpointService.UpdateIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.UpdateIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UpdateIndexEndpoint]: crate::client::IndexEndpointService::update_index_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIndexEndpointRequest {
    /// Required. The IndexEndpoint which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_endpoint: std::option::Option<crate::model::IndexEndpoint>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::UpdateIndexEndpointRequest::index_endpoint].
    pub fn set_index_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::IndexEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIndexEndpointRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexEndpointRequest"
    }
}

/// Request message for
/// [IndexEndpointService.DeleteIndexEndpoint][google.cloud.aiplatform.v1.IndexEndpointService.DeleteIndexEndpoint].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeleteIndexEndpoint]: crate::client::IndexEndpointService::delete_index_endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexEndpointRequest {
    /// Required. The name of the IndexEndpoint resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteIndexEndpointRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexEndpointRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexEndpointRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteIndexEndpointRequest"
    }
}

/// Request message for
/// [IndexEndpointService.DeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex]: crate::client::IndexEndpointService::deploy_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIndexRequest {
    /// Required. The name of the IndexEndpoint resource into which to deploy an
    /// Index. Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Required. The DeployedIndex to be created within the IndexEndpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,
}

impl DeployIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::DeployIndexRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index][crate::model::DeployIndexRequest::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

impl wkt::message::Message for DeployIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexRequest"
    }
}

/// Response message for
/// [IndexEndpointService.DeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex]: crate::client::IndexEndpointService::deploy_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIndexResponse {
    /// The DeployedIndex that had been deployed in the IndexEndpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,
}

impl DeployIndexResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_index][crate::model::DeployIndexResponse::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

impl wkt::message::Message for DeployIndexResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexResponse"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.DeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.DeployIndex]: crate::client::IndexEndpointService::deploy_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The unique index id specified by user
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,
}

impl DeployIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeployIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::DeployIndexOperationMetadata::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }
}

impl wkt::message::Message for DeployIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexEndpointService.UndeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex]: crate::client::IndexEndpointService::undeploy_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIndexRequest {
    /// Required. The name of the IndexEndpoint resource from which to undeploy an
    /// Index. Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Required. The ID of the DeployedIndex to be undeployed from the
    /// IndexEndpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,
}

impl UndeployIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::UndeployIndexRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::UndeployIndexRequest::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }
}

impl wkt::message::Message for UndeployIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexRequest"
    }
}

/// Response message for
/// [IndexEndpointService.UndeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex]: crate::client::IndexEndpointService::undeploy_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIndexResponse {}

impl UndeployIndexResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UndeployIndexResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexResponse"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.UndeployIndex][google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.UndeployIndex]: crate::client::IndexEndpointService::undeploy_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UndeployIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UndeployIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UndeployIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexEndpointService.MutateDeployedIndex][google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex]: crate::client::IndexEndpointService::mutate_deployed_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedIndexRequest {
    /// Required. The name of the IndexEndpoint resource into which to deploy an
    /// Index. Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// Required. The DeployedIndex to be updated within the IndexEndpoint.
    /// Currently, the updatable fields are
    /// [DeployedIndex.automatic_resources][google.cloud.aiplatform.v1.DeployedIndex.automatic_resources]
    /// and
    /// [DeployedIndex.dedicated_resources][google.cloud.aiplatform.v1.DeployedIndex.dedicated_resources]
    ///
    /// [google.cloud.aiplatform.v1.DeployedIndex.automatic_resources]: crate::model::DeployedIndex::automatic_resources
    /// [google.cloud.aiplatform.v1.DeployedIndex.dedicated_resources]: crate::model::DeployedIndex::dedicated_resources
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,
}

impl MutateDeployedIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::MutateDeployedIndexRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index][crate::model::MutateDeployedIndexRequest::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

impl wkt::message::Message for MutateDeployedIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexRequest"
    }
}

/// Response message for
/// [IndexEndpointService.MutateDeployedIndex][google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex]: crate::client::IndexEndpointService::mutate_deployed_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedIndexResponse {
    /// The DeployedIndex that had been updated in the IndexEndpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployed_index: std::option::Option<crate::model::DeployedIndex>,
}

impl MutateDeployedIndexResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_index][crate::model::MutateDeployedIndexResponse::deployed_index].
    pub fn set_deployed_index<
        T: std::convert::Into<std::option::Option<crate::model::DeployedIndex>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index = v.into();
        self
    }
}

impl wkt::message::Message for MutateDeployedIndexResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexResponse"
    }
}

/// Runtime operation information for
/// [IndexEndpointService.MutateDeployedIndex][google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex].
///
/// [google.cloud.aiplatform.v1.IndexEndpointService.MutateDeployedIndex]: crate::client::IndexEndpointService::mutate_deployed_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MutateDeployedIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The unique index id specified by user
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,
}

impl MutateDeployedIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::MutateDeployedIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::MutateDeployedIndexOperationMetadata::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }
}

impl wkt::message::Message for MutateDeployedIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexService.CreateIndex][google.cloud.aiplatform.v1.IndexService.CreateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.CreateIndex]: crate::client::IndexService::create_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexRequest {
    /// Required. The resource name of the Location to create the Index in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Index to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,
}

impl CreateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIndexRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [index][crate::model::CreateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexRequest"
    }
}

/// Runtime operation information for
/// [IndexService.CreateIndex][google.cloud.aiplatform.v1.IndexService.CreateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.CreateIndex]: crate::client::IndexService::create_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The operation metadata with regard to Matching Engine Index operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nearest_neighbor_search_operation_metadata:
        std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,
}

impl CreateIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [nearest_neighbor_search_operation_metadata][crate::model::CreateIndexOperationMetadata::nearest_neighbor_search_operation_metadata].
    pub fn set_nearest_neighbor_search_operation_metadata<
        T: std::convert::Into<
            std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nearest_neighbor_search_operation_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexService.GetIndex][google.cloud.aiplatform.v1.IndexService.GetIndex]
///
/// [google.cloud.aiplatform.v1.IndexService.GetIndex]: crate::client::IndexService::get_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIndexRequest {
    /// Required. The name of the Index resource.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetIndexRequest"
    }
}

/// Request message for
/// [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes].
///
/// [google.cloud.aiplatform.v1.IndexService.ListIndexes]: crate::client::IndexService::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesRequest {
    /// Required. The resource name of the Location from which to list the Indexes.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListIndexesResponse.next_page_token][google.cloud.aiplatform.v1.ListIndexesResponse.next_page_token]
    /// of the previous
    /// [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.IndexService.ListIndexes]: crate::client::IndexService::list_indexes
    /// [google.cloud.aiplatform.v1.ListIndexesResponse.next_page_token]: crate::model::ListIndexesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListIndexesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIndexesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListIndexesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIndexesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIndexesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListIndexesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListIndexesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexesRequest"
    }
}

/// Response message for
/// [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes].
///
/// [google.cloud.aiplatform.v1.IndexService.ListIndexes]: crate::client::IndexService::list_indexes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIndexesResponse {
    /// List of indexes in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indexes: std::vec::Vec<crate::model::Index>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListIndexesRequest.page_token][google.cloud.aiplatform.v1.ListIndexesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListIndexesRequest.page_token]: crate::model::ListIndexesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListIndexesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIndexesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [indexes][crate::model::ListIndexesResponse::indexes].
    pub fn set_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Index>,
    {
        use std::iter::Iterator;
        self.indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIndexesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListIndexesResponse {
    type PageItem = crate::model::Index;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.indexes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [IndexService.UpdateIndex][google.cloud.aiplatform.v1.IndexService.UpdateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.UpdateIndex]: crate::client::IndexService::update_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIndexRequest {
    /// Required. The Index which updates the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index: std::option::Option<crate::model::Index>,

    /// The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::UpdateIndexRequest::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<crate::model::Index>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIndexRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexRequest"
    }
}

/// Runtime operation information for
/// [IndexService.UpdateIndex][google.cloud.aiplatform.v1.IndexService.UpdateIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.UpdateIndex]: crate::client::IndexService::update_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIndexOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The operation metadata with regard to Matching Engine Index operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nearest_neighbor_search_operation_metadata:
        std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,
}

impl UpdateIndexOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateIndexOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [nearest_neighbor_search_operation_metadata][crate::model::UpdateIndexOperationMetadata::nearest_neighbor_search_operation_metadata].
    pub fn set_nearest_neighbor_search_operation_metadata<
        T: std::convert::Into<
            std::option::Option<crate::model::NearestNeighborSearchOperationMetadata>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nearest_neighbor_search_operation_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateIndexOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexOperationMetadata"
    }
}

/// Request message for
/// [IndexService.DeleteIndex][google.cloud.aiplatform.v1.IndexService.DeleteIndex].
///
/// [google.cloud.aiplatform.v1.IndexService.DeleteIndex]: crate::client::IndexService::delete_index
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIndexRequest {
    /// Required. The name of the Index resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteIndexRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIndexRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIndexRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteIndexRequest"
    }
}

/// Request message for
/// [IndexService.UpsertDatapoints][google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]: crate::client::IndexService::upsert_datapoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpsertDatapointsRequest {
    /// Required. The name of the Index resource to be updated.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// A list of datapoints to be created/updated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datapoints: std::vec::Vec<crate::model::IndexDatapoint>,

    /// Optional. Update mask is used to specify the fields to be overwritten in
    /// the datapoints by the update. The fields specified in the update_mask are
    /// relative to each IndexDatapoint inside datapoints, not the full request.
    ///
    /// Updatable fields:
    ///
    /// * Use `all_restricts` to update both restricts and numeric_restricts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpsertDatapointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::UpsertDatapointsRequest::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpsertDatapointsRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [datapoints][crate::model::UpsertDatapointsRequest::datapoints].
    pub fn set_datapoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexDatapoint>,
    {
        use std::iter::Iterator;
        self.datapoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpsertDatapointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpsertDatapointsRequest"
    }
}

/// Response message for
/// [IndexService.UpsertDatapoints][google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]: crate::client::IndexService::upsert_datapoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpsertDatapointsResponse {}

impl UpsertDatapointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpsertDatapointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpsertDatapointsResponse"
    }
}

/// Request message for
/// [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]: crate::client::IndexService::remove_datapoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveDatapointsRequest {
    /// Required. The name of the Index resource to be updated.
    /// Format:
    /// `projects/{project}/locations/{location}/indexes/{index}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index: std::string::String,

    /// A list of datapoint ids to be deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datapoint_ids: std::vec::Vec<std::string::String>,
}

impl RemoveDatapointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::RemoveDatapointsRequest::index].
    pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [datapoint_ids][crate::model::RemoveDatapointsRequest::datapoint_ids].
    pub fn set_datapoint_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.datapoint_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RemoveDatapointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveDatapointsRequest"
    }
}

/// Response message for
/// [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]
///
/// [google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]: crate::client::IndexService::remove_datapoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveDatapointsResponse {}

impl RemoveDatapointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveDatapointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveDatapointsResponse"
    }
}

/// Runtime operation metadata with regard to Matching Engine Index.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NearestNeighborSearchOperationMetadata {
    /// The validation stats of the content (per file) to be inserted or
    /// updated on the Matching Engine Index resource. Populated if
    /// contentsDeltaUri is provided as part of
    /// [Index.metadata][google.cloud.aiplatform.v1.Index.metadata]. Please note
    /// that, currently for those files that are broken or has unsupported file
    /// format, we will not have the stats for those files.
    ///
    /// [google.cloud.aiplatform.v1.Index.metadata]: crate::model::Index::metadata
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content_validation_stats: std::vec::Vec<
        crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats,
    >,

    /// The ingested data size in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub data_bytes_count: i64,
}

impl NearestNeighborSearchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_bytes_count][crate::model::NearestNeighborSearchOperationMetadata::data_bytes_count].
    pub fn set_data_bytes_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_bytes_count = v.into();
        self
    }

    /// Sets the value of [content_validation_stats][crate::model::NearestNeighborSearchOperationMetadata::content_validation_stats].
    pub fn set_content_validation_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
            crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats,
        >,
    {
        use std::iter::Iterator;
        self.content_validation_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NearestNeighborSearchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata"
    }
}

/// Defines additional types related to NearestNeighborSearchOperationMetadata
pub mod nearest_neighbor_search_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RecordError {
        /// The error type of this record.
        pub error_type:
            crate::model::nearest_neighbor_search_operation_metadata::record_error::RecordErrorType,

        /// A human-readable message that is shown to the user to help them fix the
        /// error. Note that this message may change from time to time, your code
        /// should check against error_type as the source of truth.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        /// Cloud Storage URI pointing to the original file in user's bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_gcs_uri: std::string::String,

        /// Empty if the embedding id is failed to parse.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub embedding_id: std::string::String,

        /// The original content of this record.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub raw_record: std::string::String,
    }

    impl RecordError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_type][crate::model::nearest_neighbor_search_operation_metadata::RecordError::error_type].
        pub fn set_error_type<T: std::convert::Into<crate::model::nearest_neighbor_search_operation_metadata::record_error::RecordErrorType>>(mut self, v: T) -> Self{
            self.error_type = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::nearest_neighbor_search_operation_metadata::RecordError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [source_gcs_uri][crate::model::nearest_neighbor_search_operation_metadata::RecordError::source_gcs_uri].
        pub fn set_source_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_gcs_uri = v.into();
            self
        }

        /// Sets the value of [embedding_id][crate::model::nearest_neighbor_search_operation_metadata::RecordError::embedding_id].
        pub fn set_embedding_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.embedding_id = v.into();
            self
        }

        /// Sets the value of [raw_record][crate::model::nearest_neighbor_search_operation_metadata::RecordError::raw_record].
        pub fn set_raw_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.raw_record = v.into();
            self
        }
    }

    impl wkt::message::Message for RecordError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.RecordError"
        }
    }

    /// Defines additional types related to RecordError
    pub mod record_error {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct RecordErrorType(std::borrow::Cow<'static, str>);

        impl RecordErrorType {
            /// Creates a new RecordErrorType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [RecordErrorType](RecordErrorType)
        pub mod record_error_type {
            use super::RecordErrorType;

            /// Default, shall not be used.
            pub const ERROR_TYPE_UNSPECIFIED: RecordErrorType =
                RecordErrorType::new("ERROR_TYPE_UNSPECIFIED");

            /// The record is empty.
            pub const EMPTY_LINE: RecordErrorType = RecordErrorType::new("EMPTY_LINE");

            /// Invalid json format.
            pub const INVALID_JSON_SYNTAX: RecordErrorType =
                RecordErrorType::new("INVALID_JSON_SYNTAX");

            /// Invalid csv format.
            pub const INVALID_CSV_SYNTAX: RecordErrorType =
                RecordErrorType::new("INVALID_CSV_SYNTAX");

            /// Invalid avro format.
            pub const INVALID_AVRO_SYNTAX: RecordErrorType =
                RecordErrorType::new("INVALID_AVRO_SYNTAX");

            /// The embedding id is not valid.
            pub const INVALID_EMBEDDING_ID: RecordErrorType =
                RecordErrorType::new("INVALID_EMBEDDING_ID");

            /// The size of the dense embedding vectors does not match with the
            /// specified dimension.
            pub const EMBEDDING_SIZE_MISMATCH: RecordErrorType =
                RecordErrorType::new("EMBEDDING_SIZE_MISMATCH");

            /// The `namespace` field is missing.
            pub const NAMESPACE_MISSING: RecordErrorType =
                RecordErrorType::new("NAMESPACE_MISSING");

            /// Generic catch-all error. Only used for validation failure where the
            /// root cause cannot be easily retrieved programmatically.
            pub const PARSING_ERROR: RecordErrorType = RecordErrorType::new("PARSING_ERROR");

            /// There are multiple restricts with the same `namespace` value.
            pub const DUPLICATE_NAMESPACE: RecordErrorType =
                RecordErrorType::new("DUPLICATE_NAMESPACE");

            /// Numeric restrict has operator specified in datapoint.
            pub const OP_IN_DATAPOINT: RecordErrorType = RecordErrorType::new("OP_IN_DATAPOINT");

            /// Numeric restrict has multiple values specified.
            pub const MULTIPLE_VALUES: RecordErrorType = RecordErrorType::new("MULTIPLE_VALUES");

            /// Numeric restrict has invalid numeric value specified.
            pub const INVALID_NUMERIC_VALUE: RecordErrorType =
                RecordErrorType::new("INVALID_NUMERIC_VALUE");

            /// File is not in UTF_8 format.
            pub const INVALID_ENCODING: RecordErrorType = RecordErrorType::new("INVALID_ENCODING");

            /// Error parsing sparse dimensions field.
            pub const INVALID_SPARSE_DIMENSIONS: RecordErrorType =
                RecordErrorType::new("INVALID_SPARSE_DIMENSIONS");

            /// Token restrict value is invalid.
            pub const INVALID_TOKEN_VALUE: RecordErrorType =
                RecordErrorType::new("INVALID_TOKEN_VALUE");

            /// Invalid sparse embedding.
            pub const INVALID_SPARSE_EMBEDDING: RecordErrorType =
                RecordErrorType::new("INVALID_SPARSE_EMBEDDING");

            /// Invalid dense embedding.
            pub const INVALID_EMBEDDING: RecordErrorType =
                RecordErrorType::new("INVALID_EMBEDDING");
        }

        impl std::convert::From<std::string::String> for RecordErrorType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ContentValidationStats {
        /// Cloud Storage URI pointing to the original file in user's bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_gcs_uri: std::string::String,

        /// Number of records in this file that were successfully processed.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub valid_record_count: i64,

        /// Number of records in this file we skipped due to validate errors.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub invalid_record_count: i64,

        /// The detail information of the partial failures encountered for those
        /// invalid records that couldn't be parsed.
        /// Up to 50 partial errors will be reported.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub partial_errors:
            std::vec::Vec<crate::model::nearest_neighbor_search_operation_metadata::RecordError>,

        /// Number of sparse records in this file that were successfully processed.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub valid_sparse_record_count: i64,

        /// Number of sparse records in this file we skipped due to validate errors.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub invalid_sparse_record_count: i64,
    }

    impl ContentValidationStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_gcs_uri][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::source_gcs_uri].
        pub fn set_source_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_gcs_uri = v.into();
            self
        }

        /// Sets the value of [valid_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::valid_record_count].
        pub fn set_valid_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.valid_record_count = v.into();
            self
        }

        /// Sets the value of [invalid_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::invalid_record_count].
        pub fn set_invalid_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.invalid_record_count = v.into();
            self
        }

        /// Sets the value of [valid_sparse_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::valid_sparse_record_count].
        pub fn set_valid_sparse_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.valid_sparse_record_count = v.into();
            self
        }

        /// Sets the value of [invalid_sparse_record_count][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::invalid_sparse_record_count].
        pub fn set_invalid_sparse_record_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.invalid_sparse_record_count = v.into();
            self
        }

        /// Sets the value of [partial_errors][crate::model::nearest_neighbor_search_operation_metadata::ContentValidationStats::partial_errors].
        pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::nearest_neighbor_search_operation_metadata::RecordError,
            >,
        {
            use std::iter::Iterator;
            self.partial_errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ContentValidationStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.ContentValidationStats"
        }
    }
}

/// The storage details for Avro input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvroSource {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_source: std::option::Option<crate::model::GcsSource>,
}

impl AvroSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_source][crate::model::AvroSource::gcs_source].
    pub fn set_gcs_source<T: std::convert::Into<std::option::Option<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_source = v.into();
        self
    }
}

impl wkt::message::Message for AvroSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AvroSource"
    }
}

/// The storage details for CSV input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsvSource {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_source: std::option::Option<crate::model::GcsSource>,
}

impl CsvSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_source][crate::model::CsvSource::gcs_source].
    pub fn set_gcs_source<T: std::convert::Into<std::option::Option<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_source = v.into();
        self
    }
}

impl wkt::message::Message for CsvSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CsvSource"
    }
}

/// The Google Cloud Storage location for the input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsSource {
    /// Required. Google Cloud Storage URI(-s) to the input file(s). May contain
    /// wildcards. For more information on wildcards, see
    /// <https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uris: std::vec::Vec<std::string::String>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uris][crate::model::GcsSource::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GcsSource"
    }
}

/// The Google Cloud Storage location where the output is to be written to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. Google Cloud Storage URI to output directory. If the uri doesn't
    /// end with
    /// '/', a '/' will be automatically appended. The directory is created if it
    /// doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::GcsDestination::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GcsDestination"
    }
}

/// The BigQuery location for the input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQuerySource {
    /// Required. BigQuery URI to a table, up to 2000 characters long.
    /// Accepted forms:
    ///
    /// * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri: std::string::String,
}

impl BigQuerySource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uri][crate::model::BigQuerySource::input_uri].
    pub fn set_input_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_uri = v.into();
        self
    }
}

impl wkt::message::Message for BigQuerySource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BigQuerySource"
    }
}

/// The BigQuery location for the output content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDestination {
    /// Required. BigQuery URI to a project or table, up to 2000 characters long.
    ///
    /// When only the project is specified, the Dataset and Table is created.
    /// When the full table reference is specified, the Dataset must exist and
    /// table must not exist.
    ///
    /// Accepted forms:
    ///
    /// * BigQuery path. For example:
    ///   `bq://projectId` or `bq://projectId.bqDatasetId` or
    ///   `bq://projectId.bqDatasetId.bqTableId`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri: std::string::String,
}

impl BigQueryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::BigQueryDestination::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BigQueryDestination"
    }
}

/// The storage details for CSV output content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsvDestination {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_destination: std::option::Option<crate::model::GcsDestination>,
}

impl CsvDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::CsvDestination::gcs_destination].
    pub fn set_gcs_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_destination = v.into();
        self
    }
}

impl wkt::message::Message for CsvDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CsvDestination"
    }
}

/// The storage details for TFRecord output content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TFRecordDestination {
    /// Required. Google Cloud Storage location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_destination: std::option::Option<crate::model::GcsDestination>,
}

impl TFRecordDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::TFRecordDestination::gcs_destination].
    pub fn set_gcs_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_destination = v.into();
        self
    }
}

impl wkt::message::Message for TFRecordDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TFRecordDestination"
    }
}

/// The Container Registry location for the container image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerRegistryDestination {
    /// Required. Container Registry URI of a container image.
    /// Only Google Container Registry and Artifact Registry are supported now.
    /// Accepted forms:
    ///
    /// * Google Container Registry path. For example:
    ///   `gcr.io/projectId/imageName:tag`.
    ///
    /// * Artifact Registry path. For example:
    ///   `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`.
    ///
    ///
    /// If a tag is not specified, "latest" will be used as the default tag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri: std::string::String,
}

impl ContainerRegistryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::ContainerRegistryDestination::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

impl wkt::message::Message for ContainerRegistryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ContainerRegistryDestination"
    }
}

/// The Google Drive location for the input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleDriveSource {
    /// Required. Google Drive resource IDs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_ids: std::vec::Vec<crate::model::google_drive_source::ResourceId>,
}

impl GoogleDriveSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_ids][crate::model::GoogleDriveSource::resource_ids].
    pub fn set_resource_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::google_drive_source::ResourceId>,
    {
        use std::iter::Iterator;
        self.resource_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GoogleDriveSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleDriveSource"
    }
}

/// Defines additional types related to GoogleDriveSource
pub mod google_drive_source {
    #[allow(unused_imports)]
    use super::*;

    /// The type and ID of the Google Drive resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceId {
        /// Required. The type of the Google Drive resource.
        pub resource_type: crate::model::google_drive_source::resource_id::ResourceType,

        /// Required. The ID of the Google Drive resource.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub resource_id: std::string::String,
    }

    impl ResourceId {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_type][crate::model::google_drive_source::ResourceId::resource_type].
        pub fn set_resource_type<
            T: std::convert::Into<crate::model::google_drive_source::resource_id::ResourceType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// Sets the value of [resource_id][crate::model::google_drive_source::ResourceId::resource_id].
        pub fn set_resource_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource_id = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceId {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GoogleDriveSource.ResourceId"
        }
    }

    /// Defines additional types related to ResourceId
    pub mod resource_id {
        #[allow(unused_imports)]
        use super::*;

        /// The type of the Google Drive resource.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ResourceType(std::borrow::Cow<'static, str>);

        impl ResourceType {
            /// Creates a new ResourceType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ResourceType](ResourceType)
        pub mod resource_type {
            use super::ResourceType;

            /// Unspecified resource type.
            pub const RESOURCE_TYPE_UNSPECIFIED: ResourceType =
                ResourceType::new("RESOURCE_TYPE_UNSPECIFIED");

            /// File resource type.
            pub const RESOURCE_TYPE_FILE: ResourceType = ResourceType::new("RESOURCE_TYPE_FILE");

            /// Folder resource type.
            pub const RESOURCE_TYPE_FOLDER: ResourceType =
                ResourceType::new("RESOURCE_TYPE_FOLDER");
        }

        impl std::convert::From<std::string::String> for ResourceType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }
}

/// The input content is encapsulated and uploaded in the request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectUploadSource {}

impl DirectUploadSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DirectUploadSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectUploadSource"
    }
}

/// The Slack source for the ImportRagFilesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SlackSource {
    /// Required. The Slack channels.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub channels: std::vec::Vec<crate::model::slack_source::SlackChannels>,
}

impl SlackSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channels][crate::model::SlackSource::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::slack_source::SlackChannels>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SlackSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource"
    }
}

/// Defines additional types related to SlackSource
pub mod slack_source {
    #[allow(unused_imports)]
    use super::*;

    /// SlackChannels contains the Slack channels and corresponding access token.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SlackChannels {
        /// Required. The Slack channel IDs.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub channels: std::vec::Vec<crate::model::slack_source::slack_channels::SlackChannel>,

        /// Required. The SecretManager secret version resource name (e.g.
        /// projects/{project}/secrets/{secret}/versions/{version}) storing the
        /// Slack channel access token that has access to the slack channel IDs.
        /// See: <https://api.slack.com/tutorials/tracks/getting-a-token>.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub api_key_config: std::option::Option<crate::model::api_auth::ApiKeyConfig>,
    }

    impl SlackChannels {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [api_key_config][crate::model::slack_source::SlackChannels::api_key_config].
        pub fn set_api_key_config<
            T: std::convert::Into<std::option::Option<crate::model::api_auth::ApiKeyConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.api_key_config = v.into();
            self
        }

        /// Sets the value of [channels][crate::model::slack_source::SlackChannels::channels].
        pub fn set_channels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::slack_source::slack_channels::SlackChannel>,
        {
            use std::iter::Iterator;
            self.channels = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SlackChannels {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource.SlackChannels"
        }
    }

    /// Defines additional types related to SlackChannels
    pub mod slack_channels {
        #[allow(unused_imports)]
        use super::*;

        /// SlackChannel contains the Slack channel ID and the time range to import.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SlackChannel {
            /// Required. The Slack channel ID.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub channel_id: std::string::String,

            /// Optional. The starting timestamp for messages to import.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub start_time: std::option::Option<wkt::Timestamp>,

            /// Optional. The ending timestamp for messages to import.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub end_time: std::option::Option<wkt::Timestamp>,
        }

        impl SlackChannel {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [channel_id][crate::model::slack_source::slack_channels::SlackChannel::channel_id].
            pub fn set_channel_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.channel_id = v.into();
                self
            }

            /// Sets the value of [start_time][crate::model::slack_source::slack_channels::SlackChannel::start_time].
            pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.start_time = v.into();
                self
            }

            /// Sets the value of [end_time][crate::model::slack_source::slack_channels::SlackChannel::end_time].
            pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.end_time = v.into();
                self
            }
        }

        impl wkt::message::Message for SlackChannel {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource.SlackChannels.SlackChannel"
            }
        }
    }
}

/// The Jira source for the ImportRagFilesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JiraSource {
    /// Required. The Jira queries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jira_queries: std::vec::Vec<crate::model::jira_source::JiraQueries>,
}

impl JiraSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jira_queries][crate::model::JiraSource::jira_queries].
    pub fn set_jira_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::jira_source::JiraQueries>,
    {
        use std::iter::Iterator;
        self.jira_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JiraSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.JiraSource"
    }
}

/// Defines additional types related to JiraSource
pub mod jira_source {
    #[allow(unused_imports)]
    use super::*;

    /// JiraQueries contains the Jira queries and corresponding authentication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct JiraQueries {
        /// A list of Jira projects to import in their entirety.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub projects: std::vec::Vec<std::string::String>,

        /// A list of custom Jira queries to import. For information about JQL (Jira
        /// Query Language), see
        /// <https://support.atlassian.com/jira-service-management-cloud/docs/use-advanced-search-with-jira-query-language-jql/>
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub custom_queries: std::vec::Vec<std::string::String>,

        /// Required. The Jira email address.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub email: std::string::String,

        /// Required. The Jira server URI.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub server_uri: std::string::String,

        /// Required. The SecretManager secret version resource name (e.g.
        /// projects/{project}/secrets/{secret}/versions/{version}) storing the
        /// Jira API key. See [Manage API tokens for your Atlassian
        /// account](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub api_key_config: std::option::Option<crate::model::api_auth::ApiKeyConfig>,
    }

    impl JiraQueries {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [email][crate::model::jira_source::JiraQueries::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }

        /// Sets the value of [server_uri][crate::model::jira_source::JiraQueries::server_uri].
        pub fn set_server_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.server_uri = v.into();
            self
        }

        /// Sets the value of [api_key_config][crate::model::jira_source::JiraQueries::api_key_config].
        pub fn set_api_key_config<
            T: std::convert::Into<std::option::Option<crate::model::api_auth::ApiKeyConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.api_key_config = v.into();
            self
        }

        /// Sets the value of [projects][crate::model::jira_source::JiraQueries::projects].
        pub fn set_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.projects = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [custom_queries][crate::model::jira_source::JiraQueries::custom_queries].
        pub fn set_custom_queries<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.custom_queries = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for JiraQueries {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.JiraSource.JiraQueries"
        }
    }
}

/// The SharePointSources to pass to ImportRagFiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SharePointSources {
    /// The SharePoint sources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub share_point_sources: std::vec::Vec<crate::model::share_point_sources::SharePointSource>,
}

impl SharePointSources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [share_point_sources][crate::model::SharePointSources::share_point_sources].
    pub fn set_share_point_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::share_point_sources::SharePointSource>,
    {
        use std::iter::Iterator;
        self.share_point_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SharePointSources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SharePointSources"
    }
}

/// Defines additional types related to SharePointSources
pub mod share_point_sources {
    #[allow(unused_imports)]
    use super::*;

    /// An individual SharePointSource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SharePointSource {
        /// The Application ID for the app registered in Microsoft Azure Portal.
        /// The application must also be configured with MS Graph permissions
        /// "Files.ReadAll", "Sites.ReadAll" and BrowserSiteLists.Read.All.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub client_id: std::string::String,

        /// The application secret for the app registered in Azure.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub client_secret: std::option::Option<crate::model::api_auth::ApiKeyConfig>,

        /// Unique identifier of the Azure Active Directory Instance.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tenant_id: std::string::String,

        /// The name of the SharePoint site to download from. This can be the site
        /// name or the site id.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub sharepoint_site_name: std::string::String,

        /// Output only. The SharePoint file id. Output only.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub file_id: std::string::String,

        /// The SharePoint folder source. If not provided, uses "root".
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub folder_source: std::option::Option<
            crate::model::share_point_sources::share_point_source::FolderSource,
        >,

        /// The SharePoint drive source.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub drive_source:
            std::option::Option<crate::model::share_point_sources::share_point_source::DriveSource>,
    }

    impl SharePointSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [client_id][crate::model::share_point_sources::SharePointSource::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::share_point_sources::SharePointSource::client_secret].
        pub fn set_client_secret<
            T: std::convert::Into<std::option::Option<crate::model::api_auth::ApiKeyConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.client_secret = v.into();
            self
        }

        /// Sets the value of [tenant_id][crate::model::share_point_sources::SharePointSource::tenant_id].
        pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tenant_id = v.into();
            self
        }

        /// Sets the value of [sharepoint_site_name][crate::model::share_point_sources::SharePointSource::sharepoint_site_name].
        pub fn set_sharepoint_site_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sharepoint_site_name = v.into();
            self
        }

        /// Sets the value of [file_id][crate::model::share_point_sources::SharePointSource::file_id].
        pub fn set_file_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.file_id = v.into();
            self
        }

        /// Sets the value of `folder_source`.
        pub fn set_folder_source<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::share_point_sources::share_point_source::FolderSource,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.folder_source = v.into();
            self
        }

        /// The value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// if it holds a `SharepointFolderPath`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_sharepoint_folder_path(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.folder_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderPath(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// if it holds a `SharepointFolderId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_sharepoint_folder_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.folder_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderId(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// to hold a `SharepointFolderPath`.
        ///
        /// Note that all the setters affecting `folder_source` are
        /// mutually exclusive.
        pub fn set_sharepoint_folder_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.folder_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderPath(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [folder_source][crate::model::share_point_sources::SharePointSource::folder_source]
        /// to hold a `SharepointFolderId`.
        ///
        /// Note that all the setters affecting `folder_source` are
        /// mutually exclusive.
        pub fn set_sharepoint_folder_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.folder_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::FolderSource::SharepointFolderId(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of `drive_source`.
        pub fn set_drive_source<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::share_point_sources::share_point_source::DriveSource,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.drive_source = v.into();
            self
        }

        /// The value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// if it holds a `DriveName`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_drive_name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.drive_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::DriveSource::DriveName(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// if it holds a `DriveId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_drive_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.drive_source.as_ref().and_then(|v| match v {
                crate::model::share_point_sources::share_point_source::DriveSource::DriveId(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// to hold a `DriveName`.
        ///
        /// Note that all the setters affecting `drive_source` are
        /// mutually exclusive.
        pub fn set_drive_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.drive_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::DriveSource::DriveName(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [drive_source][crate::model::share_point_sources::SharePointSource::drive_source]
        /// to hold a `DriveId`.
        ///
        /// Note that all the setters affecting `drive_source` are
        /// mutually exclusive.
        pub fn set_drive_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.drive_source = std::option::Option::Some(
                crate::model::share_point_sources::share_point_source::DriveSource::DriveId(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for SharePointSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SharePointSources.SharePointSource"
        }
    }

    /// Defines additional types related to SharePointSource
    pub mod share_point_source {
        #[allow(unused_imports)]
        use super::*;

        /// The SharePoint folder source. If not provided, uses "root".
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum FolderSource {
            /// The path of the SharePoint folder to download from.
            SharepointFolderPath(std::string::String),
            /// The ID of the SharePoint folder to download from.
            SharepointFolderId(std::string::String),
        }

        /// The SharePoint drive source.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DriveSource {
            /// The name of the drive to download from.
            DriveName(std::string::String),
            /// The ID of the drive to download from.
            DriveId(std::string::String),
        }
    }
}

/// Request message for
/// [JobService.CreateCustomJob][google.cloud.aiplatform.v1.JobService.CreateCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateCustomJob]: crate::client::JobService::create_custom_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomJobRequest {
    /// Required. The resource name of the Location to create the CustomJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The CustomJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_job: std::option::Option<crate::model::CustomJob>,
}

impl CreateCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_job][crate::model::CreateCustomJobRequest::custom_job].
    pub fn set_custom_job<T: std::convert::Into<std::option::Option<crate::model::CustomJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateCustomJobRequest"
    }
}

/// Request message for
/// [JobService.GetCustomJob][google.cloud.aiplatform.v1.JobService.GetCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetCustomJob]: crate::client::JobService::get_custom_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomJobRequest {
    /// Required. The name of the CustomJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetCustomJobRequest"
    }
}

/// Request message for
/// [JobService.ListCustomJobs][google.cloud.aiplatform.v1.JobService.ListCustomJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListCustomJobs]: crate::client::JobService::list_custom_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomJobsRequest {
    /// Required. The resource name of the Location to list the CustomJobs from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListCustomJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListCustomJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListCustomJobs][google.cloud.aiplatform.v1.JobService.ListCustomJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListCustomJobs]: crate::client::JobService::list_custom_jobs
    /// [google.cloud.aiplatform.v1.ListCustomJobsResponse.next_page_token]: crate::model::ListCustomJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListCustomJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListCustomJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCustomJobsRequest"
    }
}

/// Response message for
/// [JobService.ListCustomJobs][google.cloud.aiplatform.v1.JobService.ListCustomJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListCustomJobs]: crate::client::JobService::list_custom_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomJobsResponse {
    /// List of CustomJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_jobs: std::vec::Vec<crate::model::CustomJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListCustomJobsRequest.page_token][google.cloud.aiplatform.v1.ListCustomJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListCustomJobsRequest.page_token]: crate::model::ListCustomJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListCustomJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [custom_jobs][crate::model::ListCustomJobsResponse::custom_jobs].
    pub fn set_custom_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomJob>,
    {
        use std::iter::Iterator;
        self.custom_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCustomJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCustomJobsResponse {
    type PageItem = crate::model::CustomJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.DeleteCustomJob][google.cloud.aiplatform.v1.JobService.DeleteCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteCustomJob]: crate::client::JobService::delete_custom_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomJobRequest {
    /// Required. The name of the CustomJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteCustomJobRequest"
    }
}

/// Request message for
/// [JobService.CancelCustomJob][google.cloud.aiplatform.v1.JobService.CancelCustomJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelCustomJob]: crate::client::JobService::cancel_custom_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelCustomJobRequest {
    /// Required. The name of the CustomJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelCustomJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCustomJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCustomJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelCustomJobRequest"
    }
}

/// Request message for
/// [JobService.CreateDataLabelingJob][google.cloud.aiplatform.v1.JobService.CreateDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateDataLabelingJob]: crate::client::JobService::create_data_labeling_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataLabelingJobRequest {
    /// Required. The parent of the DataLabelingJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The DataLabelingJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_labeling_job: std::option::Option<crate::model::DataLabelingJob>,
}

impl CreateDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataLabelingJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_labeling_job][crate::model::CreateDataLabelingJobRequest::data_labeling_job].
    pub fn set_data_labeling_job<
        T: std::convert::Into<std::option::Option<crate::model::DataLabelingJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_labeling_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.GetDataLabelingJob][google.cloud.aiplatform.v1.JobService.GetDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetDataLabelingJob]: crate::client::JobService::get_data_labeling_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataLabelingJobRequest {
    /// Required. The name of the DataLabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataLabelingJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.ListDataLabelingJobs][google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs]: crate::client::JobService::list_data_labeling_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataLabelingJobsRequest {
    /// Required. The parent of the DataLabelingJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read. FieldMask represents a set of
    /// symbolic field paths. For example, the mask can be `paths: "name"`. The
    /// "name" here is a field in DataLabelingJob.
    /// If this field is not set, all fields of the DataLabelingJob are returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order by
    /// default.
    /// Use `desc` after a field name for descending.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDataLabelingJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataLabelingJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataLabelingJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataLabelingJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataLabelingJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListDataLabelingJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataLabelingJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataLabelingJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataLabelingJobsRequest"
    }
}

/// Response message for
/// [JobService.ListDataLabelingJobs][google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListDataLabelingJobs]: crate::client::JobService::list_data_labeling_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataLabelingJobsResponse {
    /// A list of DataLabelingJobs that matches the specified filter in the
    /// request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_labeling_jobs: std::vec::Vec<crate::model::DataLabelingJob>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDataLabelingJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDataLabelingJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [data_labeling_jobs][crate::model::ListDataLabelingJobsResponse::data_labeling_jobs].
    pub fn set_data_labeling_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataLabelingJob>,
    {
        use std::iter::Iterator;
        self.data_labeling_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataLabelingJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataLabelingJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDataLabelingJobsResponse {
    type PageItem = crate::model::DataLabelingJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_labeling_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.DeleteDataLabelingJob][google.cloud.aiplatform.v1.JobService.DeleteDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteDataLabelingJob]: crate::client::JobService::delete_data_labeling_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataLabelingJobRequest {
    /// Required. The name of the DataLabelingJob to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataLabelingJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.CancelDataLabelingJob][google.cloud.aiplatform.v1.JobService.CancelDataLabelingJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelDataLabelingJob]: crate::client::JobService::cancel_data_labeling_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelDataLabelingJobRequest {
    /// Required. The name of the DataLabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelDataLabelingJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDataLabelingJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelDataLabelingJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelDataLabelingJobRequest"
    }
}

/// Request message for
/// [JobService.CreateHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.CreateHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateHyperparameterTuningJob]: crate::client::JobService::create_hyperparameter_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateHyperparameterTuningJobRequest {
    /// Required. The resource name of the Location to create the
    /// HyperparameterTuningJob in. Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The HyperparameterTuningJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hyperparameter_tuning_job: std::option::Option<crate::model::HyperparameterTuningJob>,
}

impl CreateHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateHyperparameterTuningJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [hyperparameter_tuning_job][crate::model::CreateHyperparameterTuningJobRequest::hyperparameter_tuning_job].
    pub fn set_hyperparameter_tuning_job<
        T: std::convert::Into<std::option::Option<crate::model::HyperparameterTuningJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyperparameter_tuning_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.GetHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.GetHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetHyperparameterTuningJob]: crate::client::JobService::get_hyperparameter_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetHyperparameterTuningJobRequest {
    /// Required. The name of the HyperparameterTuningJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetHyperparameterTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.ListHyperparameterTuningJobs][google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]: crate::client::JobService::list_hyperparameter_tuning_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHyperparameterTuningJobsRequest {
    /// Required. The resource name of the Location to list the
    /// HyperparameterTuningJobs from. Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListHyperparameterTuningJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListHyperparameterTuningJobs][google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]: crate::client::JobService::list_hyperparameter_tuning_jobs
    /// [google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse.next_page_token]: crate::model::ListHyperparameterTuningJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListHyperparameterTuningJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHyperparameterTuningJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListHyperparameterTuningJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHyperparameterTuningJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHyperparameterTuningJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListHyperparameterTuningJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListHyperparameterTuningJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest"
    }
}

/// Response message for
/// [JobService.ListHyperparameterTuningJobs][google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListHyperparameterTuningJobs]: crate::client::JobService::list_hyperparameter_tuning_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHyperparameterTuningJobsResponse {
    /// List of HyperparameterTuningJobs in the requested page.
    /// [HyperparameterTuningJob.trials][google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]
    /// of the jobs will be not be returned.
    ///
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob.trials]: crate::model::HyperparameterTuningJob::trials
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hyperparameter_tuning_jobs: std::vec::Vec<crate::model::HyperparameterTuningJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListHyperparameterTuningJobsRequest.page_token][google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest.page_token]: crate::model::ListHyperparameterTuningJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListHyperparameterTuningJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListHyperparameterTuningJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [hyperparameter_tuning_jobs][crate::model::ListHyperparameterTuningJobsResponse::hyperparameter_tuning_jobs].
    pub fn set_hyperparameter_tuning_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HyperparameterTuningJob>,
    {
        use std::iter::Iterator;
        self.hyperparameter_tuning_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListHyperparameterTuningJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListHyperparameterTuningJobsResponse {
    type PageItem = crate::model::HyperparameterTuningJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hyperparameter_tuning_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.DeleteHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.DeleteHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteHyperparameterTuningJob]: crate::client::JobService::delete_hyperparameter_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteHyperparameterTuningJobRequest {
    /// Required. The name of the HyperparameterTuningJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteHyperparameterTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.CancelHyperparameterTuningJob][google.cloud.aiplatform.v1.JobService.CancelHyperparameterTuningJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelHyperparameterTuningJob]: crate::client::JobService::cancel_hyperparameter_tuning_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelHyperparameterTuningJobRequest {
    /// Required. The name of the HyperparameterTuningJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelHyperparameterTuningJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelHyperparameterTuningJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelHyperparameterTuningJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelHyperparameterTuningJobRequest"
    }
}

/// Request message for
/// [JobService.CreateNasJob][google.cloud.aiplatform.v1.JobService.CreateNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateNasJob]: crate::client::JobService::create_nas_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNasJobRequest {
    /// Required. The resource name of the Location to create the NasJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NasJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nas_job: std::option::Option<crate::model::NasJob>,
}

impl CreateNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNasJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [nas_job][crate::model::CreateNasJobRequest::nas_job].
    pub fn set_nas_job<T: std::convert::Into<std::option::Option<crate::model::NasJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.nas_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNasJobRequest"
    }
}

/// Request message for
/// [JobService.GetNasJob][google.cloud.aiplatform.v1.JobService.GetNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetNasJob]: crate::client::JobService::get_nas_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNasJobRequest {
    /// Required. The name of the NasJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNasJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNasJobRequest"
    }
}

/// Request message for
/// [JobService.ListNasJobs][google.cloud.aiplatform.v1.JobService.ListNasJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListNasJobs]: crate::client::JobService::list_nas_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasJobsRequest {
    /// Required. The resource name of the Location to list the NasJobs
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListNasJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListNasJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListNasJobs][google.cloud.aiplatform.v1.JobService.ListNasJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListNasJobs]: crate::client::JobService::list_nas_jobs
    /// [google.cloud.aiplatform.v1.ListNasJobsResponse.next_page_token]: crate::model::ListNasJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListNasJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNasJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNasJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNasJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNasJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListNasJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListNasJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasJobsRequest"
    }
}

/// Response message for
/// [JobService.ListNasJobs][google.cloud.aiplatform.v1.JobService.ListNasJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListNasJobs]: crate::client::JobService::list_nas_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasJobsResponse {
    /// List of NasJobs in the requested page.
    /// [NasJob.nas_job_output][google.cloud.aiplatform.v1.NasJob.nas_job_output]
    /// of the jobs will not be returned.
    ///
    /// [google.cloud.aiplatform.v1.NasJob.nas_job_output]: crate::model::NasJob::nas_job_output
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nas_jobs: std::vec::Vec<crate::model::NasJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListNasJobsRequest.page_token][google.cloud.aiplatform.v1.ListNasJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNasJobsRequest.page_token]: crate::model::ListNasJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNasJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNasJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [nas_jobs][crate::model::ListNasJobsResponse::nas_jobs].
    pub fn set_nas_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NasJob>,
    {
        use std::iter::Iterator;
        self.nas_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNasJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNasJobsResponse {
    type PageItem = crate::model::NasJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nas_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.DeleteNasJob][google.cloud.aiplatform.v1.JobService.DeleteNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteNasJob]: crate::client::JobService::delete_nas_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNasJobRequest {
    /// Required. The name of the NasJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNasJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNasJobRequest"
    }
}

/// Request message for
/// [JobService.CancelNasJob][google.cloud.aiplatform.v1.JobService.CancelNasJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelNasJob]: crate::client::JobService::cancel_nas_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelNasJobRequest {
    /// Required. The name of the NasJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelNasJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelNasJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelNasJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelNasJobRequest"
    }
}

/// Request message for
/// [JobService.GetNasTrialDetail][google.cloud.aiplatform.v1.JobService.GetNasTrialDetail].
///
/// [google.cloud.aiplatform.v1.JobService.GetNasTrialDetail]: crate::client::JobService::get_nas_trial_detail
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNasTrialDetailRequest {
    /// Required. The name of the NasTrialDetail resource.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNasTrialDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNasTrialDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNasTrialDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNasTrialDetailRequest"
    }
}

/// Request message for
/// [JobService.ListNasTrialDetails][google.cloud.aiplatform.v1.JobService.ListNasTrialDetails].
///
/// [google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]: crate::client::JobService::list_nas_trial_details
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasTrialDetailsRequest {
    /// Required. The name of the NasJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListNasTrialDetailsResponse.next_page_token][google.cloud.aiplatform.v1.ListNasTrialDetailsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListNasTrialDetails][google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]: crate::client::JobService::list_nas_trial_details
    /// [google.cloud.aiplatform.v1.ListNasTrialDetailsResponse.next_page_token]: crate::model::ListNasTrialDetailsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListNasTrialDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNasTrialDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNasTrialDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNasTrialDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNasTrialDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasTrialDetailsRequest"
    }
}

/// Response message for
/// [JobService.ListNasTrialDetails][google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]
///
/// [google.cloud.aiplatform.v1.JobService.ListNasTrialDetails]: crate::client::JobService::list_nas_trial_details
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNasTrialDetailsResponse {
    /// List of top NasTrials in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nas_trial_details: std::vec::Vec<crate::model::NasTrialDetail>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListNasTrialDetailsRequest.page_token][google.cloud.aiplatform.v1.ListNasTrialDetailsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNasTrialDetailsRequest.page_token]: crate::model::ListNasTrialDetailsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNasTrialDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNasTrialDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [nas_trial_details][crate::model::ListNasTrialDetailsResponse::nas_trial_details].
    pub fn set_nas_trial_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NasTrialDetail>,
    {
        use std::iter::Iterator;
        self.nas_trial_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNasTrialDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasTrialDetailsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNasTrialDetailsResponse {
    type PageItem = crate::model::NasTrialDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nas_trial_details
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.CreateBatchPredictionJob][google.cloud.aiplatform.v1.JobService.CreateBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateBatchPredictionJob]: crate::client::JobService::create_batch_prediction_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBatchPredictionJobRequest {
    /// Required. The resource name of the Location to create the
    /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The BatchPredictionJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub batch_prediction_job: std::option::Option<crate::model::BatchPredictionJob>,
}

impl CreateBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBatchPredictionJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [batch_prediction_job][crate::model::CreateBatchPredictionJobRequest::batch_prediction_job].
    pub fn set_batch_prediction_job<
        T: std::convert::Into<std::option::Option<crate::model::BatchPredictionJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.batch_prediction_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.GetBatchPredictionJob][google.cloud.aiplatform.v1.JobService.GetBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetBatchPredictionJob]: crate::client::JobService::get_batch_prediction_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBatchPredictionJobRequest {
    /// Required. The name of the BatchPredictionJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBatchPredictionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.ListBatchPredictionJobs][google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]: crate::client::JobService::list_batch_prediction_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBatchPredictionJobsRequest {
    /// Required. The resource name of the Location to list the BatchPredictionJobs
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `model_display_name` supports `=`, `!=` comparisons.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListBatchPredictionJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse.next_page_token]
    /// of the previous
    /// [JobService.ListBatchPredictionJobs][google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]: crate::client::JobService::list_batch_prediction_jobs
    /// [google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse.next_page_token]: crate::model::ListBatchPredictionJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListBatchPredictionJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBatchPredictionJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBatchPredictionJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBatchPredictionJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBatchPredictionJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListBatchPredictionJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListBatchPredictionJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest"
    }
}

/// Response message for
/// [JobService.ListBatchPredictionJobs][google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]
///
/// [google.cloud.aiplatform.v1.JobService.ListBatchPredictionJobs]: crate::client::JobService::list_batch_prediction_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBatchPredictionJobsResponse {
    /// List of BatchPredictionJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub batch_prediction_jobs: std::vec::Vec<crate::model::BatchPredictionJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListBatchPredictionJobsRequest.page_token][google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest.page_token]: crate::model::ListBatchPredictionJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListBatchPredictionJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBatchPredictionJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [batch_prediction_jobs][crate::model::ListBatchPredictionJobsResponse::batch_prediction_jobs].
    pub fn set_batch_prediction_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BatchPredictionJob>,
    {
        use std::iter::Iterator;
        self.batch_prediction_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBatchPredictionJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBatchPredictionJobsResponse {
    type PageItem = crate::model::BatchPredictionJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.batch_prediction_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.DeleteBatchPredictionJob][google.cloud.aiplatform.v1.JobService.DeleteBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteBatchPredictionJob]: crate::client::JobService::delete_batch_prediction_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBatchPredictionJobRequest {
    /// Required. The name of the BatchPredictionJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBatchPredictionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.CancelBatchPredictionJob][google.cloud.aiplatform.v1.JobService.CancelBatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.JobService.CancelBatchPredictionJob]: crate::client::JobService::cancel_batch_prediction_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelBatchPredictionJobRequest {
    /// Required. The name of the BatchPredictionJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelBatchPredictionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelBatchPredictionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelBatchPredictionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelBatchPredictionJobRequest"
    }
}

/// Request message for
/// [JobService.CreateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.CreateModelDeploymentMonitoringJob]: crate::client::JobService::create_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateModelDeploymentMonitoringJobRequest {
    /// Required. The parent of the ModelDeploymentMonitoringJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ModelDeploymentMonitoringJob to create
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_deployment_monitoring_job:
        std::option::Option<crate::model::ModelDeploymentMonitoringJob>,
}

impl CreateModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateModelDeploymentMonitoringJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::CreateModelDeploymentMonitoringJobRequest::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<
        T: std::convert::Into<std::option::Option<crate::model::ModelDeploymentMonitoringJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies].
///
/// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesRequest {

    /// Required. ModelDeploymentMonitoring Job resource name.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_deployment_monitoring_job: std::string::String,

    /// Required. The DeployedModel ID of the
    /// [ModelDeploymentMonitoringObjectiveConfig.deployed_model_id].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// The feature display name. If specified, only return the stats belonging to
    /// this feature. Format:
    /// [ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name][google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name],
    /// example: "user_destination".
    ///
    /// [google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name]: crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::feature_display_name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature_display_name: std::string::String,

    /// Required. Objectives of the stats to retrieve.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub objectives: std::vec::Vec<crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective>,

    /// The standard list page size.
    pub page_size: i32,

    /// A page token received from a previous
    /// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The earliest timestamp of stats being generated.
    /// If not set, indicates fetching stats till the earliest possible one.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp of stats being generated.
    /// If not set, indicates feching stats till the latest possible one.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl SearchModelDeploymentMonitoringStatsAnomaliesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [feature_display_name][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::feature_display_name].
    pub fn set_feature_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feature_display_name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [objectives][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::objectives].
    pub fn set_objectives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective>
    {
        use std::iter::Iterator;
        self.objectives = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchModelDeploymentMonitoringStatsAnomaliesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest"
    }
}

/// Defines additional types related to SearchModelDeploymentMonitoringStatsAnomaliesRequest
pub mod search_model_deployment_monitoring_stats_anomalies_request {
    #[allow(unused_imports)]
    use super::*;

    /// Stats requested for specific objective.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StatsAnomaliesObjective {
        #[serde(rename = "type")]
        pub r#type: crate::model::ModelDeploymentMonitoringObjectiveType,

        /// If set, all attribution scores between
        /// [SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time][google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time]
        /// and
        /// [SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time][google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time]
        /// are fetched, and page token doesn't take effect in this case. Only used
        /// to retrieve attribution score for the top Features which has the highest
        /// attribution score in the latest monitoring run.
        ///
        /// [google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time]: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::end_time
        /// [google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time]: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest::start_time
        pub top_feature_count: i32,
    }

    impl StatsAnomaliesObjective {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::ModelDeploymentMonitoringObjectiveType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [top_feature_count][crate::model::search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective::top_feature_count].
        pub fn set_top_feature_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.top_feature_count = v.into();
            self
        }
    }

    impl wkt::message::Message for StatsAnomaliesObjective {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.StatsAnomaliesObjective"
        }
    }
}

/// Response message for
/// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies].
///
/// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    /// Stats retrieved for requested objectives.
    /// There are at most 1000
    /// [ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats][google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats]
    /// in the response.
    ///
    /// [google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats]: crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::prediction_stats
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub monitoring_stats: std::vec::Vec<crate::model::ModelMonitoringStatsAnomalies>,

    /// The page token that can be used by the next
    /// [JobService.SearchModelDeploymentMonitoringStatsAnomalies][google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.JobService.SearchModelDeploymentMonitoringStatsAnomalies]: crate::client::JobService::search_model_deployment_monitoring_stats_anomalies
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [monitoring_stats][crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse::monitoring_stats].
    pub fn set_monitoring_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelMonitoringStatsAnomalies>,
    {
        use std::iter::Iterator;
        self.monitoring_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    type PageItem = crate::model::ModelMonitoringStatsAnomalies;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.monitoring_stats
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.GetModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.GetModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.GetModelDeploymentMonitoringJob]: crate::client::JobService::get_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the ModelDeploymentMonitoringJob.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.ListModelDeploymentMonitoringJobs][google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs]: crate::client::JobService::list_model_deployment_monitoring_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelDeploymentMonitoringJobsRequest {
    /// Required. The parent of the ModelDeploymentMonitoringJob.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
    /// * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
    /// * `NOT display_name="my_job"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `labels.keyA=valueA`
    /// * `labels.keyB:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListModelDeploymentMonitoringJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelDeploymentMonitoringJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelDeploymentMonitoringJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelDeploymentMonitoringJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelDeploymentMonitoringJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelDeploymentMonitoringJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListModelDeploymentMonitoringJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsRequest"
    }
}

/// Response message for
/// [JobService.ListModelDeploymentMonitoringJobs][google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs].
///
/// [google.cloud.aiplatform.v1.JobService.ListModelDeploymentMonitoringJobs]: crate::client::JobService::list_model_deployment_monitoring_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelDeploymentMonitoringJobsResponse {
    /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
    /// in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_deployment_monitoring_jobs: std::vec::Vec<crate::model::ModelDeploymentMonitoringJob>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelDeploymentMonitoringJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelDeploymentMonitoringJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_jobs][crate::model::ListModelDeploymentMonitoringJobsResponse::model_deployment_monitoring_jobs].
    pub fn set_model_deployment_monitoring_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelDeploymentMonitoringJob>,
    {
        use std::iter::Iterator;
        self.model_deployment_monitoring_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelDeploymentMonitoringJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListModelDeploymentMonitoringJobsResponse {
    type PageItem = crate::model::ModelDeploymentMonitoringJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.model_deployment_monitoring_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [JobService.UpdateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob]: crate::client::JobService::update_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelDeploymentMonitoringJobRequest {
    /// Required. The model monitoring configuration which replaces the resource on
    /// the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_deployment_monitoring_job:
        std::option::Option<crate::model::ModelDeploymentMonitoringJob>,

    /// Required. The update mask is used to specify the fields to be overwritten
    /// in the ModelDeploymentMonitoringJob resource by the update. The fields
    /// specified in the update_mask are relative to the resource, not the full
    /// request. A field will be overwritten if it is in the mask. If the user does
    /// not provide a mask then only the non-empty fields present in the request
    /// will be overwritten. Set the update_mask to `*` to override all fields. For
    /// the objective config, the user can either provide the update mask for
    /// model_deployment_monitoring_objective_configs or any combination of its
    /// nested fields, such as:
    /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
    ///
    /// Updatable fields:
    ///
    /// * `display_name`
    /// * `model_deployment_monitoring_schedule_config`
    /// * `model_monitoring_alert_config`
    /// * `logging_sampling_strategy`
    /// * `labels`
    /// * `log_ttl`
    /// * `enable_monitoring_pipeline_logs`
    ///   .  and
    /// * `model_deployment_monitoring_objective_configs`
    ///   .  or
    /// * `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
    /// * `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
    /// * `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_deployment_monitoring_job][crate::model::UpdateModelDeploymentMonitoringJobRequest::model_deployment_monitoring_job].
    pub fn set_model_deployment_monitoring_job<
        T: std::convert::Into<std::option::Option<crate::model::ModelDeploymentMonitoringJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_job = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateModelDeploymentMonitoringJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.DeleteModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.DeleteModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.DeleteModelDeploymentMonitoringJob]: crate::client::JobService::delete_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the model monitoring job to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.PauseModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.PauseModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.PauseModelDeploymentMonitoringJob]: crate::client::JobService::pause_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the ModelDeploymentMonitoringJob to pause.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl PauseModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PauseModelDeploymentMonitoringJobRequest"
    }
}

/// Request message for
/// [JobService.ResumeModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.ResumeModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.ResumeModelDeploymentMonitoringJob]: crate::client::JobService::resume_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeModelDeploymentMonitoringJobRequest {
    /// Required. The resource name of the ModelDeploymentMonitoringJob to resume.
    /// Format:
    /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ResumeModelDeploymentMonitoringJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeModelDeploymentMonitoringJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeModelDeploymentMonitoringJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResumeModelDeploymentMonitoringJobRequest"
    }
}

/// Runtime operation information for
/// [JobService.UpdateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob].
///
/// [google.cloud.aiplatform.v1.JobService.UpdateModelDeploymentMonitoringJob]: crate::client::JobService::update_model_deployment_monitoring_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelDeploymentMonitoringJobOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateModelDeploymentMonitoringJobOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateModelDeploymentMonitoringJobOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateModelDeploymentMonitoringJobOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobOperationMetadata"
    }
}

/// A subgraph of the overall lineage graph. Event edges connect Artifact and
/// Execution nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LineageSubgraph {
    /// The Artifact nodes in the subgraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub artifacts: std::vec::Vec<crate::model::Artifact>,

    /// The Execution nodes in the subgraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<crate::model::Execution>,

    /// The Event edges between Artifacts and Executions in the subgraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,
}

impl LineageSubgraph {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifacts][crate::model::LineageSubgraph::artifacts].
    pub fn set_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>,
    {
        use std::iter::Iterator;
        self.artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [executions][crate::model::LineageSubgraph::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Execution>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [events][crate::model::LineageSubgraph::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LineageSubgraph {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LineageSubgraph"
    }
}

/// Request message for ComputeTokens RPC call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeTokensRequest {
    /// Required. The name of the Endpoint requested to get lists of tokens and
    /// token ids.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. The instances that are the input to token computing API call.
    /// Schema is identical to the prediction schema of the text model, even for
    /// the non-text models, like chat models, or Codey models.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// Optional. The name of the publisher model requested to serve the
    /// prediction. Format:
    /// projects/{project}/locations/{location}/publishers/*/models/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. Input content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,
}

impl ComputeTokensRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::ComputeTokensRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [model][crate::model::ComputeTokensRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ComputeTokensRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [contents][crate::model::ComputeTokensRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeTokensRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ComputeTokensRequest"
    }
}

/// Tokens info with a list of tokens and the corresponding list of token ids.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TokensInfo {
    /// A list of tokens from the input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub tokens: std::vec::Vec<bytes::Bytes>,

    /// A list of token ids from the input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub token_ids: std::vec::Vec<i64>,

    /// Optional. Optional fields for the role from the corresponding Content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,
}

impl TokensInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::TokensInfo::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [tokens][crate::model::TokensInfo::tokens].
    pub fn set_tokens<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.tokens = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [token_ids][crate::model::TokensInfo::token_ids].
    pub fn set_token_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.token_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TokensInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TokensInfo"
    }
}

/// Response message for ComputeTokens RPC call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeTokensResponse {
    /// Lists of tokens info from the input. A ComputeTokensRequest could have
    /// multiple instances with a prompt in each instance. We also need to return
    /// lists of tokens info for the request with multiple instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tokens_info: std::vec::Vec<crate::model::TokensInfo>,
}

impl ComputeTokensResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tokens_info][crate::model::ComputeTokensResponse::tokens_info].
    pub fn set_tokens_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TokensInfo>,
    {
        use std::iter::Iterator;
        self.tokens_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeTokensResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ComputeTokensResponse"
    }
}

/// Specification of a single machine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MachineSpec {
    /// Immutable. The type of the machine.
    ///
    /// See the [list of machine types supported for
    /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
    ///
    /// See the [list of machine types supported for custom
    /// training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
    ///
    /// For [DeployedModel][google.cloud.aiplatform.v1.DeployedModel] this field is
    /// optional, and the default value is `n1-standard-2`. For
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob] or as
    /// part of [WorkerPoolSpec][google.cloud.aiplatform.v1.WorkerPoolSpec] this
    /// field is required.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
    /// [google.cloud.aiplatform.v1.WorkerPoolSpec]: crate::model::WorkerPoolSpec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Immutable. The type of accelerator(s) that may be attached to the machine
    /// as per
    /// [accelerator_count][google.cloud.aiplatform.v1.MachineSpec.accelerator_count].
    ///
    /// [google.cloud.aiplatform.v1.MachineSpec.accelerator_count]: crate::model::MachineSpec::accelerator_count
    pub accelerator_type: crate::model::AcceleratorType,

    /// The number of accelerators to attach to the machine.
    pub accelerator_count: i32,

    /// Immutable. The topology of the TPUs. Corresponds to the TPU topologies
    /// available from GKE. (Example: tpu_topology: "2x2x1").
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tpu_topology: std::string::String,

    /// Optional. Immutable. Configuration controlling how this resource pool
    /// consumes reservation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,
}

impl MachineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::MachineSpec::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::MachineSpec::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<crate::model::AcceleratorType>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [accelerator_count][crate::model::MachineSpec::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }

    /// Sets the value of [tpu_topology][crate::model::MachineSpec::tpu_topology].
    pub fn set_tpu_topology<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tpu_topology = v.into();
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::MachineSpec::reservation_affinity].
    pub fn set_reservation_affinity<
        T: std::convert::Into<std::option::Option<crate::model::ReservationAffinity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reservation_affinity = v.into();
        self
    }
}

impl wkt::message::Message for MachineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MachineSpec"
    }
}

/// A description of resources that are dedicated to a DeployedModel, and
/// that need a higher degree of manual configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DedicatedResources {
    /// Required. Immutable. The specification of a single machine used by the
    /// prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Required. Immutable. The minimum number of machine replicas this
    /// DeployedModel will be always deployed on. This value must be greater than
    /// or equal to 1.
    ///
    /// If traffic against the DeployedModel increases, it may dynamically be
    /// deployed onto more replicas, and as traffic decreases, some of these extra
    /// replicas may be freed.
    pub min_replica_count: i32,

    /// Immutable. The maximum number of replicas this DeployedModel may be
    /// deployed on when the traffic against it increases. If the requested value
    /// is too large, the deployment will error, but if deployment succeeds then
    /// the ability to scale the model to that many replicas is guaranteed (barring
    /// service outages). If traffic against the DeployedModel increases beyond
    /// what its replicas at maximum may handle, a portion of the traffic will be
    /// dropped. If this value is not provided, will use
    /// [min_replica_count][google.cloud.aiplatform.v1.DedicatedResources.min_replica_count]
    /// as the default value.
    ///
    /// The value of this field impacts the charge against Vertex CPU and GPU
    /// quotas. Specifically, you will be charged for (max_replica_count *
    /// number of cores in the selected machine type) and (max_replica_count *
    /// number of GPUs per replica in the selected machine type).
    ///
    /// [google.cloud.aiplatform.v1.DedicatedResources.min_replica_count]: crate::model::DedicatedResources::min_replica_count
    pub max_replica_count: i32,

    /// Optional. Number of required available replicas for the deployment to
    /// succeed. This field is only needed when partial model deployment/mutation
    /// is desired. If set, the model deploy/mutate operation will succeed once
    /// available_replica_count reaches required_replica_count, and the rest of
    /// the replicas will be retried. If not set, the default
    /// required_replica_count will be min_replica_count.
    pub required_replica_count: i32,

    /// Immutable. The metric specifications that overrides a resource
    /// utilization metric (CPU utilization, accelerator's duty cycle, and so on)
    /// target value (default to 60 if not set). At most one entry is allowed per
    /// metric.
    ///
    /// If
    /// [machine_spec.accelerator_count][google.cloud.aiplatform.v1.MachineSpec.accelerator_count]
    /// is above 0, the autoscaling will be based on both CPU utilization and
    /// accelerator's duty cycle metrics and scale up when either metrics exceeds
    /// its target value while scale down if both metrics are under their target
    /// value. The default target value is 60 for both metrics.
    ///
    /// If
    /// [machine_spec.accelerator_count][google.cloud.aiplatform.v1.MachineSpec.accelerator_count]
    /// is 0, the autoscaling will be based on CPU utilization metric only with
    /// default target value 60 if not explicitly set.
    ///
    /// For example, in the case of Online Prediction, if you want to override
    /// target CPU utilization to 80, you should set
    /// [autoscaling_metric_specs.metric_name][google.cloud.aiplatform.v1.AutoscalingMetricSpec.metric_name]
    /// to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
    /// [autoscaling_metric_specs.target][google.cloud.aiplatform.v1.AutoscalingMetricSpec.target]
    /// to `80`.
    ///
    /// [google.cloud.aiplatform.v1.AutoscalingMetricSpec.metric_name]: crate::model::AutoscalingMetricSpec::metric_name
    /// [google.cloud.aiplatform.v1.AutoscalingMetricSpec.target]: crate::model::AutoscalingMetricSpec::target
    /// [google.cloud.aiplatform.v1.MachineSpec.accelerator_count]: crate::model::MachineSpec::accelerator_count
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autoscaling_metric_specs: std::vec::Vec<crate::model::AutoscalingMetricSpec>,

    /// Optional. If true, schedule the deployment workload on [spot
    /// VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
    pub spot: bool,
}

impl DedicatedResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_spec][crate::model::DedicatedResources::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [min_replica_count][crate::model::DedicatedResources::min_replica_count].
    pub fn set_min_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_replica_count = v.into();
        self
    }

    /// Sets the value of [max_replica_count][crate::model::DedicatedResources::max_replica_count].
    pub fn set_max_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_replica_count = v.into();
        self
    }

    /// Sets the value of [required_replica_count][crate::model::DedicatedResources::required_replica_count].
    pub fn set_required_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.required_replica_count = v.into();
        self
    }

    /// Sets the value of [spot][crate::model::DedicatedResources::spot].
    pub fn set_spot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.spot = v.into();
        self
    }

    /// Sets the value of [autoscaling_metric_specs][crate::model::DedicatedResources::autoscaling_metric_specs].
    pub fn set_autoscaling_metric_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutoscalingMetricSpec>,
    {
        use std::iter::Iterator;
        self.autoscaling_metric_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DedicatedResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DedicatedResources"
    }
}

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
/// Each Model supporting these resources documents its specific guidelines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomaticResources {
    /// Immutable. The minimum number of replicas this DeployedModel will be always
    /// deployed on. If traffic against it increases, it may dynamically be
    /// deployed onto more replicas up to
    /// [max_replica_count][google.cloud.aiplatform.v1.AutomaticResources.max_replica_count],
    /// and as traffic decreases, some of these extra replicas may be freed. If the
    /// requested value is too large, the deployment will error.
    ///
    /// [google.cloud.aiplatform.v1.AutomaticResources.max_replica_count]: crate::model::AutomaticResources::max_replica_count
    pub min_replica_count: i32,

    /// Immutable. The maximum number of replicas this DeployedModel may be
    /// deployed on when the traffic against it increases. If the requested value
    /// is too large, the deployment will error, but if deployment succeeds then
    /// the ability to scale the model to that many replicas is guaranteed (barring
    /// service outages). If traffic against the DeployedModel increases beyond
    /// what its replicas at maximum may handle, a portion of the traffic will be
    /// dropped. If this value is not provided, a no upper bound for scaling under
    /// heavy traffic will be assume, though Vertex AI may be unable to scale
    /// beyond certain replica number.
    pub max_replica_count: i32,
}

impl AutomaticResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_replica_count][crate::model::AutomaticResources::min_replica_count].
    pub fn set_min_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_replica_count = v.into();
        self
    }

    /// Sets the value of [max_replica_count][crate::model::AutomaticResources::max_replica_count].
    pub fn set_max_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_replica_count = v.into();
        self
    }
}

impl wkt::message::Message for AutomaticResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AutomaticResources"
    }
}

/// A description of resources that are used for performing batch operations, are
/// dedicated to a Model, and need manual configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDedicatedResources {
    /// Required. Immutable. The specification of a single machine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Immutable. The number of machine replicas used at the start of the batch
    /// operation. If not set, Vertex AI decides starting number, not greater than
    /// [max_replica_count][google.cloud.aiplatform.v1.BatchDedicatedResources.max_replica_count]
    ///
    /// [google.cloud.aiplatform.v1.BatchDedicatedResources.max_replica_count]: crate::model::BatchDedicatedResources::max_replica_count
    pub starting_replica_count: i32,

    /// Immutable. The maximum number of machine replicas the batch operation may
    /// be scaled to. The default value is 10.
    pub max_replica_count: i32,
}

impl BatchDedicatedResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_spec][crate::model::BatchDedicatedResources::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [starting_replica_count][crate::model::BatchDedicatedResources::starting_replica_count].
    pub fn set_starting_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.starting_replica_count = v.into();
        self
    }

    /// Sets the value of [max_replica_count][crate::model::BatchDedicatedResources::max_replica_count].
    pub fn set_max_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_replica_count = v.into();
        self
    }
}

impl wkt::message::Message for BatchDedicatedResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDedicatedResources"
    }
}

/// Statistics information about resource consumption.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourcesConsumed {
    /// Output only. The number of replica hours used. Note that many replicas may
    /// run in parallel, and additionally any given work may be queued for some
    /// time. Therefore this value is not strictly related to wall time.
    pub replica_hours: f64,
}

impl ResourcesConsumed {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replica_hours][crate::model::ResourcesConsumed::replica_hours].
    pub fn set_replica_hours<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.replica_hours = v.into();
        self
    }
}

impl wkt::message::Message for ResourcesConsumed {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourcesConsumed"
    }
}

/// Represents the spec of disk options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskSpec {
    /// Type of the boot disk (default is "pd-ssd").
    /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive) or
    /// "pd-standard" (Persistent Disk Hard Disk Drive).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub boot_disk_type: std::string::String,

    /// Size in GB of the boot disk (default is 100GB).
    pub boot_disk_size_gb: i32,
}

impl DiskSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [boot_disk_type][crate::model::DiskSpec::boot_disk_type].
    pub fn set_boot_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.boot_disk_type = v.into();
        self
    }

    /// Sets the value of [boot_disk_size_gb][crate::model::DiskSpec::boot_disk_size_gb].
    pub fn set_boot_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.boot_disk_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for DiskSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DiskSpec"
    }
}

/// Represents the spec of [persistent
/// disk][<https://cloud.google.com/compute/docs/disks/persistent-disks>] options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersistentDiskSpec {
    /// Type of the disk (default is "pd-standard").
    /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive)
    /// "pd-standard" (Persistent Disk Hard Disk Drive)
    /// "pd-balanced" (Balanced Persistent Disk)
    /// "pd-extreme" (Extreme Persistent Disk)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_type: std::string::String,

    /// Size in GB of the disk (default is 100GB).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_size_gb: i64,
}

impl PersistentDiskSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_type][crate::model::PersistentDiskSpec::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::PersistentDiskSpec::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for PersistentDiskSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PersistentDiskSpec"
    }
}

/// Represents a mount configuration for Network File System (NFS) to mount.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsMount {
    /// Required. IP address of the NFS server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server: std::string::String,

    /// Required. Source path exported from NFS server.
    /// Has to start with '/', and combined with the ip address, it indicates
    /// the source mount path in the form of `server:path`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Required. Destination mount path. The NFS will be mounted for the user
    /// under /mnt/nfs/<mount_point>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mount_point: std::string::String,
}

impl NfsMount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [server][crate::model::NfsMount::server].
    pub fn set_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server = v.into();
        self
    }

    /// Sets the value of [path][crate::model::NfsMount::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [mount_point][crate::model::NfsMount::mount_point].
    pub fn set_mount_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_point = v.into();
        self
    }
}

impl wkt::message::Message for NfsMount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NfsMount"
    }
}

/// The metric specification that defines the target resource utilization
/// (CPU utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingMetricSpec {
    /// Required. The resource metric name.
    /// Supported metrics:
    ///
    /// * For Online Prediction:
    /// * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
    /// * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric_name: std::string::String,

    /// The target resource utilization in percentage (1% - 100%) for the given
    /// metric; once the real usage deviates from the target by a certain
    /// percentage, the machine replicas change. The default value is 60
    /// (representing 60%) if not provided.
    pub target: i32,
}

impl AutoscalingMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::AutoscalingMetricSpec::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::AutoscalingMetricSpec::target].
    pub fn set_target<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AutoscalingMetricSpec"
    }
}

/// A set of Shielded Instance options.
/// See [Images using supported Shielded VM
/// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShieldedVmConfig {
    /// Defines whether the instance has [Secure
    /// Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot)
    /// enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails.
    pub enable_secure_boot: bool,
}

impl ShieldedVmConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedVmConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_secure_boot = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedVmConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ShieldedVmConfig"
    }
}

/// Manual batch tuning parameters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManualBatchTuningParameters {
    /// Immutable. The number of the records (e.g. instances) of the operation
    /// given in each batch to a machine replica. Machine type, and size of a
    /// single record should be considered when setting this parameter, higher
    /// value speeds up the batch operation's execution, but too high value will
    /// result in a whole batch not fitting in a machine's memory, and the whole
    /// operation will fail.
    /// The default value is 64.
    pub batch_size: i32,
}

impl ManualBatchTuningParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [batch_size][crate::model::ManualBatchTuningParameters::batch_size].
    pub fn set_batch_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.batch_size = v.into();
        self
    }
}

impl wkt::message::Message for ManualBatchTuningParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ManualBatchTuningParameters"
    }
}

/// The request message for
/// [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
///
/// [google.cloud.aiplatform.v1.MatchService.FindNeighbors]: crate::client::MatchService::find_neighbors
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FindNeighborsRequest {
    /// Required. The name of the index endpoint.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// The ID of the DeployedIndex that will serve the request. This request is
    /// sent to a specific IndexEndpoint, as per the IndexEndpoint.network. That
    /// IndexEndpoint also has IndexEndpoint.deployed_indexes, and each such index
    /// has a DeployedIndex.id field.
    /// The value of the field below must equal one of the DeployedIndex.id
    /// fields of the IndexEndpoint that is being called for this request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    /// The list of queries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub queries: std::vec::Vec<crate::model::find_neighbors_request::Query>,

    /// If set to true, the full datapoints (including all vector values and
    /// restricts) of the nearest neighbors are returned.
    /// Note that returning full datapoint will significantly increase the
    /// latency and cost of the query.
    pub return_full_datapoint: bool,
}

impl FindNeighborsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::FindNeighborsRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::FindNeighborsRequest::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }

    /// Sets the value of [return_full_datapoint][crate::model::FindNeighborsRequest::return_full_datapoint].
    pub fn set_return_full_datapoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_full_datapoint = v.into();
        self
    }

    /// Sets the value of [queries][crate::model::FindNeighborsRequest::queries].
    pub fn set_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::find_neighbors_request::Query>,
    {
        use std::iter::Iterator;
        self.queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FindNeighborsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest"
    }
}

/// Defines additional types related to FindNeighborsRequest
pub mod find_neighbors_request {
    #[allow(unused_imports)]
    use super::*;

    /// A query to find a number of the nearest neighbors (most similar vectors)
    /// of a vector.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Query {
        /// Required. The datapoint/vector whose nearest neighbors should be searched
        /// for.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub datapoint: std::option::Option<crate::model::IndexDatapoint>,

        /// The number of nearest neighbors to be retrieved from database for each
        /// query. If not set, will use the default from the service configuration
        /// (<https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config>).
        pub neighbor_count: i32,

        /// Crowding is a constraint on a neighbor list produced by nearest neighbor
        /// search requiring that no more than some value k' of the k neighbors
        /// returned have the same value of crowding_attribute.
        /// It's used for improving result diversity.
        /// This field is the maximum number of matches with the same crowding tag.
        pub per_crowding_attribute_neighbor_count: i32,

        /// The number of neighbors to find via approximate search before
        /// exact reordering is performed. If not set, the default value from scam
        /// config is used; if set, this value must be > 0.
        pub approximate_neighbor_count: i32,

        /// The fraction of the number of leaves to search, set at query time allows
        /// user to tune search performance. This value increase result in both
        /// search accuracy and latency increase. The value should be between 0.0
        /// and 1.0. If not set or set to 0.0, query uses the default value specified
        /// in
        /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
        pub fraction_leaf_nodes_to_search_override: f64,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub ranking: std::option::Option<crate::model::find_neighbors_request::query::Ranking>,
    }

    impl Query {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [datapoint][crate::model::find_neighbors_request::Query::datapoint].
        pub fn set_datapoint<
            T: std::convert::Into<std::option::Option<crate::model::IndexDatapoint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.datapoint = v.into();
            self
        }

        /// Sets the value of [neighbor_count][crate::model::find_neighbors_request::Query::neighbor_count].
        pub fn set_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.neighbor_count = v.into();
            self
        }

        /// Sets the value of [per_crowding_attribute_neighbor_count][crate::model::find_neighbors_request::Query::per_crowding_attribute_neighbor_count].
        pub fn set_per_crowding_attribute_neighbor_count<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.per_crowding_attribute_neighbor_count = v.into();
            self
        }

        /// Sets the value of [approximate_neighbor_count][crate::model::find_neighbors_request::Query::approximate_neighbor_count].
        pub fn set_approximate_neighbor_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.approximate_neighbor_count = v.into();
            self
        }

        /// Sets the value of [fraction_leaf_nodes_to_search_override][crate::model::find_neighbors_request::Query::fraction_leaf_nodes_to_search_override].
        pub fn set_fraction_leaf_nodes_to_search_override<T: std::convert::Into<f64>>(
            mut self,
            v: T,
        ) -> Self {
            self.fraction_leaf_nodes_to_search_override = v.into();
            self
        }

        /// Sets the value of `ranking`.
        pub fn set_ranking<
            T: std::convert::Into<
                std::option::Option<crate::model::find_neighbors_request::query::Ranking>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking = v.into();
            self
        }

        /// The value of [ranking][crate::model::find_neighbors_request::Query::ranking]
        /// if it holds a `Rrf`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_rrf(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::find_neighbors_request::query::Rrf>>
        {
            #[allow(unreachable_patterns)]
            self.ranking.as_ref().and_then(|v| match v {
                crate::model::find_neighbors_request::query::Ranking::Rrf(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [ranking][crate::model::find_neighbors_request::Query::ranking]
        /// to hold a `Rrf`.
        ///
        /// Note that all the setters affecting `ranking` are
        /// mutually exclusive.
        pub fn set_rrf<
            T: std::convert::Into<std::boxed::Box<crate::model::find_neighbors_request::query::Rrf>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ranking = std::option::Option::Some(
                crate::model::find_neighbors_request::query::Ranking::Rrf(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Query {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest.Query"
        }
    }

    /// Defines additional types related to Query
    pub mod query {
        #[allow(unused_imports)]
        use super::*;

        /// Parameters for RRF algorithm that combines search results.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Rrf {
            /// Required. Users can provide an alpha value to give more weight to dense
            /// vs sparse results. For example, if the alpha is 0, we only return
            /// sparse and if the alpha is 1, we only return dense.
            pub alpha: f32,
        }

        impl Rrf {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [alpha][crate::model::find_neighbors_request::query::Rrf::alpha].
            pub fn set_alpha<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.alpha = v.into();
                self
            }
        }

        impl wkt::message::Message for Rrf {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest.Query.RRF"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Ranking {
            /// Optional. Represents RRF algorithm that combines search results.
            Rrf(std::boxed::Box<crate::model::find_neighbors_request::query::Rrf>),
        }
    }
}

/// The response message for
/// [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
///
/// [google.cloud.aiplatform.v1.MatchService.FindNeighbors]: crate::client::MatchService::find_neighbors
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FindNeighborsResponse {
    /// The nearest neighbors of the query datapoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nearest_neighbors: std::vec::Vec<crate::model::find_neighbors_response::NearestNeighbors>,
}

impl FindNeighborsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nearest_neighbors][crate::model::FindNeighborsResponse::nearest_neighbors].
    pub fn set_nearest_neighbors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::find_neighbors_response::NearestNeighbors>,
    {
        use std::iter::Iterator;
        self.nearest_neighbors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FindNeighborsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse"
    }
}

/// Defines additional types related to FindNeighborsResponse
pub mod find_neighbors_response {
    #[allow(unused_imports)]
    use super::*;

    /// A neighbor of the query vector.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Neighbor {
        /// The datapoint of the neighbor.
        /// Note that full datapoints are returned only when "return_full_datapoint"
        /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
        /// fields are populated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub datapoint: std::option::Option<crate::model::IndexDatapoint>,

        /// The distance between the neighbor and the dense embedding query.
        pub distance: f64,

        /// The distance between the neighbor and the query sparse_embedding.
        pub sparse_distance: f64,
    }

    impl Neighbor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [datapoint][crate::model::find_neighbors_response::Neighbor::datapoint].
        pub fn set_datapoint<
            T: std::convert::Into<std::option::Option<crate::model::IndexDatapoint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.datapoint = v.into();
            self
        }

        /// Sets the value of [distance][crate::model::find_neighbors_response::Neighbor::distance].
        pub fn set_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.distance = v.into();
            self
        }

        /// Sets the value of [sparse_distance][crate::model::find_neighbors_response::Neighbor::sparse_distance].
        pub fn set_sparse_distance<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.sparse_distance = v.into();
            self
        }
    }

    impl wkt::message::Message for Neighbor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse.Neighbor"
        }
    }

    /// Nearest neighbors for one query.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NearestNeighbors {
        /// The ID of the query datapoint.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// All its neighbors.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub neighbors: std::vec::Vec<crate::model::find_neighbors_response::Neighbor>,
    }

    impl NearestNeighbors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::find_neighbors_response::NearestNeighbors::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [neighbors][crate::model::find_neighbors_response::NearestNeighbors::neighbors].
        pub fn set_neighbors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::find_neighbors_response::Neighbor>,
        {
            use std::iter::Iterator;
            self.neighbors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NearestNeighbors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse.NearestNeighbors"
        }
    }
}

/// The request message for
/// [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
///
/// [google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints]: crate::client::MatchService::read_index_datapoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadIndexDatapointsRequest {
    /// Required. The name of the index endpoint.
    /// Format:
    /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub index_endpoint: std::string::String,

    /// The ID of the DeployedIndex that will serve the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_index_id: std::string::String,

    /// IDs of the datapoints to be searched for.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ids: std::vec::Vec<std::string::String>,
}

impl ReadIndexDatapointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_endpoint][crate::model::ReadIndexDatapointsRequest::index_endpoint].
    pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.index_endpoint = v.into();
        self
    }

    /// Sets the value of [deployed_index_id][crate::model::ReadIndexDatapointsRequest::deployed_index_id].
    pub fn set_deployed_index_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_index_id = v.into();
        self
    }

    /// Sets the value of [ids][crate::model::ReadIndexDatapointsRequest::ids].
    pub fn set_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReadIndexDatapointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadIndexDatapointsRequest"
    }
}

/// The response message for
/// [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
///
/// [google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints]: crate::client::MatchService::read_index_datapoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadIndexDatapointsResponse {
    /// The result list of datapoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datapoints: std::vec::Vec<crate::model::IndexDatapoint>,
}

impl ReadIndexDatapointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datapoints][crate::model::ReadIndexDatapointsResponse::datapoints].
    pub fn set_datapoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexDatapoint>,
    {
        use std::iter::Iterator;
        self.datapoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReadIndexDatapointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadIndexDatapointsResponse"
    }
}

/// Instance of a general MetadataSchema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataSchema {
    /// Output only. The resource name of the MetadataSchema.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The version of the MetadataSchema. The version's format must match
    /// the following regular expression: `^[0-9]+[.][0-9]+[.][0-9]+$`, which would
    /// allow to order/compare different versions. Example: 1.0.0, 1.0.1, etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_version: std::string::String,

    /// Required. The raw YAML string representation of the MetadataSchema. The
    /// combination of [MetadataSchema.version] and the schema name given by
    /// `title` in [MetadataSchema.schema] must be unique within a MetadataStore.
    ///
    /// The schema is defined as an OpenAPI 3.0.2
    /// [MetadataSchema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// The type of the MetadataSchema. This is a property that identifies which
    /// metadata types will use the MetadataSchema.
    pub schema_type: crate::model::metadata_schema::MetadataSchemaType,

    /// Output only. Timestamp when this MetadataSchema was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Description of the Metadata Schema
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl MetadataSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MetadataSchema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema_version][crate::model::MetadataSchema::schema_version].
    pub fn set_schema_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_version = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::MetadataSchema::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::MetadataSchema::schema_type].
    pub fn set_schema_type<
        T: std::convert::Into<crate::model::metadata_schema::MetadataSchemaType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MetadataSchema::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MetadataSchema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for MetadataSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetadataSchema"
    }
}

/// Defines additional types related to MetadataSchema
pub mod metadata_schema {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the type of the MetadataSchema.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MetadataSchemaType(std::borrow::Cow<'static, str>);

    impl MetadataSchemaType {
        /// Creates a new MetadataSchemaType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [MetadataSchemaType](MetadataSchemaType)
    pub mod metadata_schema_type {
        use super::MetadataSchemaType;

        /// Unspecified type for the MetadataSchema.
        pub const METADATA_SCHEMA_TYPE_UNSPECIFIED: MetadataSchemaType =
            MetadataSchemaType::new("METADATA_SCHEMA_TYPE_UNSPECIFIED");

        /// A type indicating that the MetadataSchema will be used by Artifacts.
        pub const ARTIFACT_TYPE: MetadataSchemaType = MetadataSchemaType::new("ARTIFACT_TYPE");

        /// A typee indicating that the MetadataSchema will be used by Executions.
        pub const EXECUTION_TYPE: MetadataSchemaType = MetadataSchemaType::new("EXECUTION_TYPE");

        /// A state indicating that the MetadataSchema will be used by Contexts.
        pub const CONTEXT_TYPE: MetadataSchemaType = MetadataSchemaType::new("CONTEXT_TYPE");
    }

    impl std::convert::From<std::string::String> for MetadataSchemaType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Request message for
/// [MetadataService.CreateMetadataStore][google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore]: crate::client::MetadataService::create_metadata_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataStoreRequest {
    /// Required. The resource name of the Location where the MetadataStore should
    /// be created.
    /// Format: `projects/{project}/locations/{location}/`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The MetadataStore to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_store: std::option::Option<crate::model::MetadataStore>,

    /// The {metadatastore} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    /// If not provided, the MetadataStore's ID will be a UUID generated by the
    /// service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all MetadataStores in the parent Location.
    /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
    /// if the caller can't view the preexisting MetadataStore.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_store_id: std::string::String,
}

impl CreateMetadataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMetadataStoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metadata_store][crate::model::CreateMetadataStoreRequest::metadata_store].
    pub fn set_metadata_store<
        T: std::convert::Into<std::option::Option<crate::model::MetadataStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store = v.into();
        self
    }

    /// Sets the value of [metadata_store_id][crate::model::CreateMetadataStoreRequest::metadata_store_id].
    pub fn set_metadata_store_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMetadataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataStoreRequest"
    }
}

/// Details of operations that perform
/// [MetadataService.CreateMetadataStore][google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateMetadataStore]: crate::client::MetadataService::create_metadata_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataStoreOperationMetadata {
    /// Operation metadata for creating a MetadataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateMetadataStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateMetadataStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateMetadataStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataStoreOperationMetadata"
    }
}

/// Request message for
/// [MetadataService.GetMetadataStore][google.cloud.aiplatform.v1.MetadataService.GetMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetMetadataStore]: crate::client::MetadataService::get_metadata_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetadataStoreRequest {
    /// Required. The resource name of the MetadataStore to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMetadataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetadataStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetadataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetMetadataStoreRequest"
    }
}

/// Request message for
/// [MetadataService.ListMetadataStores][google.cloud.aiplatform.v1.MetadataService.ListMetadataStores].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]: crate::client::MetadataService::list_metadata_stores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataStoresRequest {
    /// Required. The Location whose MetadataStores should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Metadata Stores to return. The service may return
    /// fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListMetadataStores][google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]: crate::client::MetadataService::list_metadata_stores
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListMetadataStoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMetadataStoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetadataStoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetadataStoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMetadataStoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataStoresRequest"
    }
}

/// Response message for
/// [MetadataService.ListMetadataStores][google.cloud.aiplatform.v1.MetadataService.ListMetadataStores].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataStores]: crate::client::MetadataService::list_metadata_stores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataStoresResponse {
    /// The MetadataStores found for the Location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metadata_stores: std::vec::Vec<crate::model::MetadataStore>,

    /// A token, which can be sent as
    /// [ListMetadataStoresRequest.page_token][google.cloud.aiplatform.v1.ListMetadataStoresRequest.page_token]
    /// to retrieve the next page. If this field is not populated, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListMetadataStoresRequest.page_token]: crate::model::ListMetadataStoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListMetadataStoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMetadataStoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata_stores][crate::model::ListMetadataStoresResponse::metadata_stores].
    pub fn set_metadata_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetadataStore>,
    {
        use std::iter::Iterator;
        self.metadata_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMetadataStoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataStoresResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMetadataStoresResponse {
    type PageItem = crate::model::MetadataStore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metadata_stores
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [MetadataService.DeleteMetadataStore][google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore]: crate::client::MetadataService::delete_metadata_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMetadataStoreRequest {
    /// Required. The resource name of the MetadataStore to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Deprecated: Field is no longer supported.
    pub force: bool,
}

impl DeleteMetadataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMetadataStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteMetadataStoreRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMetadataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteMetadataStoreRequest"
    }
}

/// Details of operations that perform
/// [MetadataService.DeleteMetadataStore][google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteMetadataStore]: crate::client::MetadataService::delete_metadata_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMetadataStoreOperationMetadata {
    /// Operation metadata for deleting a MetadataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl DeleteMetadataStoreOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeleteMetadataStoreOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMetadataStoreOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteMetadataStoreOperationMetadata"
    }
}

/// Request message for
/// [MetadataService.CreateArtifact][google.cloud.aiplatform.v1.MetadataService.CreateArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateArtifact]: crate::client::MetadataService::create_artifact
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateArtifactRequest {
    /// Required. The resource name of the MetadataStore where the Artifact should
    /// be created.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Artifact to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact: std::option::Option<crate::model::Artifact>,

    /// The {artifact} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    /// If not provided, the Artifact's ID will be a UUID generated by the service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all Artifacts in the parent MetadataStore. (Otherwise
    /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
    /// caller can't view the preexisting Artifact.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_id: std::string::String,
}

impl CreateArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateArtifactRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [artifact][crate::model::CreateArtifactRequest::artifact].
    pub fn set_artifact<T: std::convert::Into<std::option::Option<crate::model::Artifact>>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [artifact_id][crate::model::CreateArtifactRequest::artifact_id].
    pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.GetArtifact][google.cloud.aiplatform.v1.MetadataService.GetArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetArtifact]: crate::client::MetadataService::get_artifact
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetArtifactRequest {
    /// Required. The resource name of the Artifact to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetArtifactRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.ListArtifacts][google.cloud.aiplatform.v1.MetadataService.ListArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListArtifacts]: crate::client::MetadataService::list_artifacts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListArtifactsRequest {
    /// Required. The MetadataStore whose Artifacts should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Artifacts to return. The service may return fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListArtifacts][google.cloud.aiplatform.v1.MetadataService.ListArtifacts]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListArtifacts]: crate::client::MetadataService::list_artifacts
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter specifying the boolean condition for the Artifacts to satisfy in
    /// order to be part of the result set.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// The supported set of filters include the following:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`.
    ///   Supported fields include: `name`, `display_name`, `uri`, `state`,
    ///   `schema_title`, `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`.
    ///   For example: `metadata.field_1.number_value = 10.0`
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    /// * **Context based filtering**:
    ///   To filter Artifacts based on the contexts to which they belong, use the
    ///   function operator with the full resource name
    ///   `in_context(<context-name>)`.
    ///   For example:
    ///   `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
    ///
    /// Each of the above supported filter types can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// How the list of messages is ordered. Specify the values to order by and an
    /// ordering operation. The default sorting order is ascending. To specify
    /// descending order for a field, users append a " desc" suffix; for example:
    /// "foo desc, bar".
    /// Subfields are specified with a `.` character, such as foo.bar.
    /// see <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListArtifactsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListArtifactsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListArtifactsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListArtifactsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListArtifactsRequest"
    }
}

/// Response message for
/// [MetadataService.ListArtifacts][google.cloud.aiplatform.v1.MetadataService.ListArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListArtifacts]: crate::client::MetadataService::list_artifacts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListArtifactsResponse {
    /// The Artifacts retrieved from the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub artifacts: std::vec::Vec<crate::model::Artifact>,

    /// A token, which can be sent as
    /// [ListArtifactsRequest.page_token][google.cloud.aiplatform.v1.ListArtifactsRequest.page_token]
    /// to retrieve the next page.
    /// If this field is not populated, there are no subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListArtifactsRequest.page_token]: crate::model::ListArtifactsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListArtifactsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [artifacts][crate::model::ListArtifactsResponse::artifacts].
    pub fn set_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Artifact>,
    {
        use std::iter::Iterator;
        self.artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListArtifactsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListArtifactsResponse {
    type PageItem = crate::model::Artifact;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.artifacts
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [MetadataService.UpdateArtifact][google.cloud.aiplatform.v1.MetadataService.UpdateArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.UpdateArtifact]: crate::client::MetadataService::update_artifact
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateArtifactRequest {
    /// Required. The Artifact containing updates.
    /// The Artifact's [Artifact.name][google.cloud.aiplatform.v1.Artifact.name]
    /// field is used to identify the Artifact to be updated. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    ///
    /// [google.cloud.aiplatform.v1.Artifact.name]: crate::model::Artifact::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact: std::option::Option<crate::model::Artifact>,

    /// Optional. A FieldMask indicating which fields should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Artifact][google.cloud.aiplatform.v1.Artifact] is
    /// not found, a new [Artifact][google.cloud.aiplatform.v1.Artifact] is
    /// created.
    ///
    /// [google.cloud.aiplatform.v1.Artifact]: crate::model::Artifact
    pub allow_missing: bool,
}

impl UpdateArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact][crate::model::UpdateArtifactRequest::artifact].
    pub fn set_artifact<T: std::convert::Into<std::option::Option<crate::model::Artifact>>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateArtifactRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateArtifactRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.DeleteArtifact][google.cloud.aiplatform.v1.MetadataService.DeleteArtifact].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteArtifact]: crate::client::MetadataService::delete_artifact
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteArtifactRequest {
    /// Required. The resource name of the Artifact to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The etag of the Artifact to delete.
    /// If this is provided, it must match the server's etag. Otherwise, the
    /// request will fail with a FAILED_PRECONDITION.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteArtifactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteArtifactRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteArtifactRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteArtifactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteArtifactRequest"
    }
}

/// Request message for
/// [MetadataService.PurgeArtifacts][google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts]: crate::client::MetadataService::purge_artifacts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeArtifactsRequest {
    /// Required. The metadata store to purge Artifacts from.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A required filter matching the Artifacts to be purged.
    /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Flag to indicate to actually perform the purge.
    /// If `force` is set to false, the method will return a sample of
    /// Artifact names that would be deleted.
    pub force: bool,
}

impl PurgeArtifactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeArtifactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeArtifactsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeArtifactsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for PurgeArtifactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsRequest"
    }
}

/// Response message for
/// [MetadataService.PurgeArtifacts][google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts]: crate::client::MetadataService::purge_artifacts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeArtifactsResponse {
    /// The number of Artifacts that this request deleted (or, if `force` is false,
    /// the number of Artifacts that will be deleted). This can be an estimate.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub purge_count: i64,

    /// A sample of the Artifact names that will be deleted.
    /// Only populated if `force` is set to false. The maximum number of samples is
    /// 100 (it is possible to return fewer).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,
}

impl PurgeArtifactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeArtifactsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeArtifactsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeArtifactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsResponse"
    }
}

/// Details of operations that perform
/// [MetadataService.PurgeArtifacts][google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeArtifacts]: crate::client::MetadataService::purge_artifacts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeArtifactsMetadata {
    /// Operation metadata for purging Artifacts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl PurgeArtifactsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::PurgeArtifactsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for PurgeArtifactsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsMetadata"
    }
}

/// Request message for
/// [MetadataService.CreateContext][google.cloud.aiplatform.v1.MetadataService.CreateContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateContext]: crate::client::MetadataService::create_context
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateContextRequest {
    /// Required. The resource name of the MetadataStore where the Context should
    /// be created. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Context to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::Context>,

    /// The {context} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
    /// If not provided, the Context's ID will be a UUID generated by the service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all Contexts in the parent MetadataStore. (Otherwise
    /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
    /// caller can't view the preexisting Context.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context_id: std::string::String,
}

impl CreateContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateContextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CreateContextRequest::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::Context>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [context_id][crate::model::CreateContextRequest::context_id].
    pub fn set_context_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateContextRequest"
    }
}

/// Request message for
/// [MetadataService.GetContext][google.cloud.aiplatform.v1.MetadataService.GetContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetContext]: crate::client::MetadataService::get_context
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetContextRequest {
    /// Required. The resource name of the Context to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetContextRequest"
    }
}

/// Request message for
/// [MetadataService.ListContexts][google.cloud.aiplatform.v1.MetadataService.ListContexts]
///
/// [google.cloud.aiplatform.v1.MetadataService.ListContexts]: crate::client::MetadataService::list_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListContextsRequest {
    /// Required. The MetadataStore whose Contexts should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Contexts to return. The service may return fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListContexts][google.cloud.aiplatform.v1.MetadataService.ListContexts]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListContexts]: crate::client::MetadataService::list_contexts
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter specifying the boolean condition for the Contexts to satisfy in
    /// order to be part of the result set.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// Following are the supported set of filters:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`.
    ///   Supported fields include: `name`, `display_name`, `schema_title`,
    ///   `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`.
    ///
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`.
    ///   For example: `metadata.field_1.number_value = 10.0`.
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    ///
    /// * **Parent Child filtering**:
    ///   To filter Contexts based on parent-child relationship use the HAS
    ///   operator as follows:
    ///
    ///
    /// ```norust
    /// parent_contexts:
    /// "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
    /// child_contexts:
    /// "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
    /// ```
    ///
    /// Each of the above supported filters can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// How the list of messages is ordered. Specify the values to order by and an
    /// ordering operation. The default sorting order is ascending. To specify
    /// descending order for a field, users append a " desc" suffix; for example:
    /// "foo desc, bar".
    /// Subfields are specified with a `.` character, such as foo.bar.
    /// see <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListContextsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListContextsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListContextsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListContextsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListContextsRequest"
    }
}

/// Response message for
/// [MetadataService.ListContexts][google.cloud.aiplatform.v1.MetadataService.ListContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListContexts]: crate::client::MetadataService::list_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListContextsResponse {
    /// The Contexts retrieved from the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contexts: std::vec::Vec<crate::model::Context>,

    /// A token, which can be sent as
    /// [ListContextsRequest.page_token][google.cloud.aiplatform.v1.ListContextsRequest.page_token]
    /// to retrieve the next page.
    /// If this field is not populated, there are no subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListContextsRequest.page_token]: crate::model::ListContextsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListContextsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [contexts][crate::model::ListContextsResponse::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListContextsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListContextsResponse {
    type PageItem = crate::model::Context;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.contexts
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [MetadataService.UpdateContext][google.cloud.aiplatform.v1.MetadataService.UpdateContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.UpdateContext]: crate::client::MetadataService::update_context
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateContextRequest {
    /// Required. The Context containing updates.
    /// The Context's [Context.name][google.cloud.aiplatform.v1.Context.name] field
    /// is used to identify the Context to be updated. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    ///
    /// [google.cloud.aiplatform.v1.Context.name]: crate::model::Context::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::Context>,

    /// Optional. A FieldMask indicating which fields should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Context][google.cloud.aiplatform.v1.Context] is
    /// not found, a new [Context][google.cloud.aiplatform.v1.Context] is created.
    ///
    /// [google.cloud.aiplatform.v1.Context]: crate::model::Context
    pub allow_missing: bool,
}

impl UpdateContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::UpdateContextRequest::context].
    pub fn set_context<T: std::convert::Into<std::option::Option<crate::model::Context>>>(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateContextRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateContextRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateContextRequest"
    }
}

/// Request message for
/// [MetadataService.DeleteContext][google.cloud.aiplatform.v1.MetadataService.DeleteContext].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteContext]: crate::client::MetadataService::delete_context
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteContextRequest {
    /// Required. The resource name of the Context to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The force deletion semantics is still undefined.
    /// Users should not use this field.
    pub force: bool,

    /// Optional. The etag of the Context to delete.
    /// If this is provided, it must match the server's etag. Otherwise, the
    /// request will fail with a FAILED_PRECONDITION.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteContextRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteContextRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteContextRequest"
    }
}

/// Request message for
/// [MetadataService.PurgeContexts][google.cloud.aiplatform.v1.MetadataService.PurgeContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeContexts]: crate::client::MetadataService::purge_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeContextsRequest {
    /// Required. The metadata store to purge Contexts from.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A required filter matching the Contexts to be purged.
    /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Flag to indicate to actually perform the purge.
    /// If `force` is set to false, the method will return a sample of
    /// Context names that would be deleted.
    pub force: bool,
}

impl PurgeContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeContextsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeContextsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for PurgeContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsRequest"
    }
}

/// Response message for
/// [MetadataService.PurgeContexts][google.cloud.aiplatform.v1.MetadataService.PurgeContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeContexts]: crate::client::MetadataService::purge_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeContextsResponse {
    /// The number of Contexts that this request deleted (or, if `force` is false,
    /// the number of Contexts that will be deleted). This can be an estimate.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub purge_count: i64,

    /// A sample of the Context names that will be deleted.
    /// Only populated if `force` is set to false. The maximum number of samples is
    /// 100 (it is possible to return fewer).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,
}

impl PurgeContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeContextsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeContextsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsResponse"
    }
}

/// Details of operations that perform
/// [MetadataService.PurgeContexts][google.cloud.aiplatform.v1.MetadataService.PurgeContexts].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeContexts]: crate::client::MetadataService::purge_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeContextsMetadata {
    /// Operation metadata for purging Contexts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl PurgeContextsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::PurgeContextsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for PurgeContextsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsMetadata"
    }
}

/// Request message for
/// [MetadataService.AddContextArtifactsAndExecutions][google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions]: crate::client::MetadataService::add_context_artifacts_and_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextArtifactsAndExecutionsRequest {
    /// Required. The resource name of the Context that the Artifacts and
    /// Executions belong to. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    /// The resource names of the Artifacts to attribute to the Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub artifacts: std::vec::Vec<std::string::String>,

    /// The resource names of the Executions to associate with the
    /// Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<std::string::String>,
}

impl AddContextArtifactsAndExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::AddContextArtifactsAndExecutionsRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [artifacts][crate::model::AddContextArtifactsAndExecutionsRequest::artifacts].
    pub fn set_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [executions][crate::model::AddContextArtifactsAndExecutionsRequest::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AddContextArtifactsAndExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsRequest"
    }
}

/// Response message for
/// [MetadataService.AddContextArtifactsAndExecutions][google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextArtifactsAndExecutions]: crate::client::MetadataService::add_context_artifacts_and_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextArtifactsAndExecutionsResponse {}

impl AddContextArtifactsAndExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddContextArtifactsAndExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsResponse"
    }
}

/// Request message for
/// [MetadataService.AddContextChildren][google.cloud.aiplatform.v1.MetadataService.AddContextChildren].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextChildren]: crate::client::MetadataService::add_context_children
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextChildrenRequest {
    /// Required. The resource name of the parent Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    /// The resource names of the child Contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_contexts: std::vec::Vec<std::string::String>,
}

impl AddContextChildrenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::AddContextChildrenRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [child_contexts][crate::model::AddContextChildrenRequest::child_contexts].
    pub fn set_child_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AddContextChildrenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextChildrenRequest"
    }
}

/// Response message for
/// [MetadataService.AddContextChildren][google.cloud.aiplatform.v1.MetadataService.AddContextChildren].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddContextChildren]: crate::client::MetadataService::add_context_children
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddContextChildrenResponse {}

impl AddContextChildrenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddContextChildrenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextChildrenResponse"
    }
}

/// Request message for
/// [MetadataService.DeleteContextChildrenRequest][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveContextChildrenRequest {
    /// Required. The resource name of the parent Context.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,

    /// The resource names of the child Contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_contexts: std::vec::Vec<std::string::String>,
}

impl RemoveContextChildrenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::RemoveContextChildrenRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [child_contexts][crate::model::RemoveContextChildrenRequest::child_contexts].
    pub fn set_child_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RemoveContextChildrenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveContextChildrenRequest"
    }
}

/// Response message for
/// [MetadataService.RemoveContextChildren][google.cloud.aiplatform.v1.MetadataService.RemoveContextChildren].
///
/// [google.cloud.aiplatform.v1.MetadataService.RemoveContextChildren]: crate::client::MetadataService::remove_context_children
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveContextChildrenResponse {}

impl RemoveContextChildrenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveContextChildrenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveContextChildrenResponse"
    }
}

/// Request message for
/// [MetadataService.QueryContextLineageSubgraph][google.cloud.aiplatform.v1.MetadataService.QueryContextLineageSubgraph].
///
/// [google.cloud.aiplatform.v1.MetadataService.QueryContextLineageSubgraph]: crate::client::MetadataService::query_context_lineage_subgraph
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryContextLineageSubgraphRequest {
    /// Required. The resource name of the Context whose Artifacts and Executions
    /// should be retrieved as a LineageSubgraph.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
    ///
    /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
    /// the number of Executions, or the number of Events that would be returned
    /// for the Context exceeds 1000.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub context: std::string::String,
}

impl QueryContextLineageSubgraphRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::QueryContextLineageSubgraphRequest::context].
    pub fn set_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.context = v.into();
        self
    }
}

impl wkt::message::Message for QueryContextLineageSubgraphRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryContextLineageSubgraphRequest"
    }
}

/// Request message for
/// [MetadataService.CreateExecution][google.cloud.aiplatform.v1.MetadataService.CreateExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateExecution]: crate::client::MetadataService::create_execution
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateExecutionRequest {
    /// Required. The resource name of the MetadataStore where the Execution should
    /// be created.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Execution to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution: std::option::Option<crate::model::Execution>,

    /// The {execution} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    /// If not provided, the Execution's ID will be a UUID generated by the
    /// service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all Executions in the parent MetadataStore.
    /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
    /// if the caller can't view the preexisting Execution.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution_id: std::string::String,
}

impl CreateExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExecutionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::CreateExecutionRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::option::Option<crate::model::Execution>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [execution_id][crate::model::CreateExecutionRequest::execution_id].
    pub fn set_execution_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.GetExecution][google.cloud.aiplatform.v1.MetadataService.GetExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetExecution]: crate::client::MetadataService::get_execution
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetExecutionRequest {
    /// Required. The resource name of the Execution to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.ListExecutions][google.cloud.aiplatform.v1.MetadataService.ListExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListExecutions]: crate::client::MetadataService::list_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExecutionsRequest {
    /// Required. The MetadataStore whose Executions should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Executions to return. The service may return fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListExecutions][google.cloud.aiplatform.v1.MetadataService.ListExecutions]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with an
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListExecutions]: crate::client::MetadataService::list_executions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter specifying the boolean condition for the Executions to satisfy in
    /// order to be part of the result set.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// Following are the supported set of filters:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`.
    ///   Supported fields include: `name`, `display_name`, `state`,
    ///   `schema_title`, `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`.
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`
    ///   For example: `metadata.field_1.number_value = 10.0`
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    /// * **Context based filtering**:
    ///   To filter Executions based on the contexts to which they belong use
    ///   the function operator with the full resource name:
    ///   `in_context(<context-name>)`.
    ///   For example:
    ///   `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
    ///
    /// Each of the above supported filters can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// How the list of messages is ordered. Specify the values to order by and an
    /// ordering operation. The default sorting order is ascending. To specify
    /// descending order for a field, users append a " desc" suffix; for example:
    /// "foo desc, bar".
    /// Subfields are specified with a `.` character, such as foo.bar.
    /// see <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExecutionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExecutionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExecutionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExecutionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListExecutionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListExecutionsRequest"
    }
}

/// Response message for
/// [MetadataService.ListExecutions][google.cloud.aiplatform.v1.MetadataService.ListExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListExecutions]: crate::client::MetadataService::list_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExecutionsResponse {
    /// The Executions retrieved from the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<crate::model::Execution>,

    /// A token, which can be sent as
    /// [ListExecutionsRequest.page_token][google.cloud.aiplatform.v1.ListExecutionsRequest.page_token]
    /// to retrieve the next page.
    /// If this field is not populated, there are no subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListExecutionsRequest.page_token]: crate::model::ListExecutionsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListExecutionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [executions][crate::model::ListExecutionsResponse::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Execution>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListExecutionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListExecutionsResponse {
    type PageItem = crate::model::Execution;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.executions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [MetadataService.UpdateExecution][google.cloud.aiplatform.v1.MetadataService.UpdateExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.UpdateExecution]: crate::client::MetadataService::update_execution
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExecutionRequest {
    /// Required. The Execution containing updates.
    /// The Execution's [Execution.name][google.cloud.aiplatform.v1.Execution.name]
    /// field is used to identify the Execution to be updated. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    ///
    /// [google.cloud.aiplatform.v1.Execution.name]: crate::model::Execution::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution: std::option::Option<crate::model::Execution>,

    /// Optional. A FieldMask indicating which fields should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Execution][google.cloud.aiplatform.v1.Execution]
    /// is not found, a new [Execution][google.cloud.aiplatform.v1.Execution] is
    /// created.
    ///
    /// [google.cloud.aiplatform.v1.Execution]: crate::model::Execution
    pub allow_missing: bool,
}

impl UpdateExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution][crate::model::UpdateExecutionRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::option::Option<crate::model::Execution>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExecutionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateExecutionRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.DeleteExecution][google.cloud.aiplatform.v1.MetadataService.DeleteExecution].
///
/// [google.cloud.aiplatform.v1.MetadataService.DeleteExecution]: crate::client::MetadataService::delete_execution
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteExecutionRequest {
    /// Required. The resource name of the Execution to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The etag of the Execution to delete.
    /// If this is provided, it must match the server's etag. Otherwise, the
    /// request will fail with a FAILED_PRECONDITION.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteExecutionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteExecutionRequest"
    }
}

/// Request message for
/// [MetadataService.PurgeExecutions][google.cloud.aiplatform.v1.MetadataService.PurgeExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeExecutions]: crate::client::MetadataService::purge_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeExecutionsRequest {
    /// Required. The metadata store to purge Executions from.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A required filter matching the Executions to be purged.
    /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Flag to indicate to actually perform the purge.
    /// If `force` is set to false, the method will return a sample of
    /// Execution names that would be deleted.
    pub force: bool,
}

impl PurgeExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeExecutionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeExecutionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeExecutionsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for PurgeExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsRequest"
    }
}

/// Response message for
/// [MetadataService.PurgeExecutions][google.cloud.aiplatform.v1.MetadataService.PurgeExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeExecutions]: crate::client::MetadataService::purge_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeExecutionsResponse {
    /// The number of Executions that this request deleted (or, if `force` is
    /// false, the number of Executions that will be deleted). This can be an
    /// estimate.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub purge_count: i64,

    /// A sample of the Execution names that will be deleted.
    /// Only populated if `force` is set to false. The maximum number of samples is
    /// 100 (it is possible to return fewer).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,
}

impl PurgeExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeExecutionsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeExecutionsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsResponse"
    }
}

/// Details of operations that perform
/// [MetadataService.PurgeExecutions][google.cloud.aiplatform.v1.MetadataService.PurgeExecutions].
///
/// [google.cloud.aiplatform.v1.MetadataService.PurgeExecutions]: crate::client::MetadataService::purge_executions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeExecutionsMetadata {
    /// Operation metadata for purging Executions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl PurgeExecutionsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::PurgeExecutionsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for PurgeExecutionsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsMetadata"
    }
}

/// Request message for
/// [MetadataService.AddExecutionEvents][google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents]: crate::client::MetadataService::add_execution_events
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddExecutionEventsRequest {
    /// Required. The resource name of the Execution that the Events connect
    /// Artifacts with.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,

    /// The Events to create and add.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,
}

impl AddExecutionEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution][crate::model::AddExecutionEventsRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [events][crate::model::AddExecutionEventsRequest::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AddExecutionEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddExecutionEventsRequest"
    }
}

/// Response message for
/// [MetadataService.AddExecutionEvents][google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents].
///
/// [google.cloud.aiplatform.v1.MetadataService.AddExecutionEvents]: crate::client::MetadataService::add_execution_events
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddExecutionEventsResponse {}

impl AddExecutionEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddExecutionEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddExecutionEventsResponse"
    }
}

/// Request message for
/// [MetadataService.QueryExecutionInputsAndOutputs][google.cloud.aiplatform.v1.MetadataService.QueryExecutionInputsAndOutputs].
///
/// [google.cloud.aiplatform.v1.MetadataService.QueryExecutionInputsAndOutputs]: crate::client::MetadataService::query_execution_inputs_and_outputs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryExecutionInputsAndOutputsRequest {
    /// Required. The resource name of the Execution whose input and output
    /// Artifacts should be retrieved as a LineageSubgraph. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,
}

impl QueryExecutionInputsAndOutputsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution][crate::model::QueryExecutionInputsAndOutputsRequest::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }
}

impl wkt::message::Message for QueryExecutionInputsAndOutputsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryExecutionInputsAndOutputsRequest"
    }
}

/// Request message for
/// [MetadataService.CreateMetadataSchema][google.cloud.aiplatform.v1.MetadataService.CreateMetadataSchema].
///
/// [google.cloud.aiplatform.v1.MetadataService.CreateMetadataSchema]: crate::client::MetadataService::create_metadata_schema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataSchemaRequest {
    /// Required. The resource name of the MetadataStore where the MetadataSchema
    /// should be created. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The MetadataSchema to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_schema: std::option::Option<crate::model::MetadataSchema>,

    /// The {metadata_schema} portion of the resource name with the format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
    /// If not provided, the MetadataStore's ID will be a UUID generated by the
    /// service.
    /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
    /// Must be unique across all MetadataSchemas in the parent Location.
    /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
    /// if the caller can't view the preexisting MetadataSchema.)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_id: std::string::String,
}

impl CreateMetadataSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMetadataSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metadata_schema][crate::model::CreateMetadataSchemaRequest::metadata_schema].
    pub fn set_metadata_schema<
        T: std::convert::Into<std::option::Option<crate::model::MetadataSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema = v.into();
        self
    }

    /// Sets the value of [metadata_schema_id][crate::model::CreateMetadataSchemaRequest::metadata_schema_id].
    pub fn set_metadata_schema_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMetadataSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataSchemaRequest"
    }
}

/// Request message for
/// [MetadataService.GetMetadataSchema][google.cloud.aiplatform.v1.MetadataService.GetMetadataSchema].
///
/// [google.cloud.aiplatform.v1.MetadataService.GetMetadataSchema]: crate::client::MetadataService::get_metadata_schema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetadataSchemaRequest {
    /// Required. The resource name of the MetadataSchema to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMetadataSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetadataSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetadataSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetMetadataSchemaRequest"
    }
}

/// Request message for
/// [MetadataService.ListMetadataSchemas][google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]: crate::client::MetadataService::list_metadata_schemas
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataSchemasRequest {
    /// Required. The MetadataStore whose MetadataSchemas should be listed.
    /// Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of MetadataSchemas to return. The service may return
    /// fewer.
    /// Must be in range 1-1000, inclusive. Defaults to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [MetadataService.ListMetadataSchemas][google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]
    /// call. Provide this to retrieve the next page.
    ///
    /// When paginating, all other provided parameters must match the call that
    /// provided the page token. (Otherwise the request will fail with
    /// INVALID_ARGUMENT error.)
    ///
    /// [google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]: crate::client::MetadataService::list_metadata_schemas
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A query to filter available MetadataSchemas for matching results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListMetadataSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMetadataSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetadataSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetadataSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMetadataSchemasRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListMetadataSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataSchemasRequest"
    }
}

/// Response message for
/// [MetadataService.ListMetadataSchemas][google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas].
///
/// [google.cloud.aiplatform.v1.MetadataService.ListMetadataSchemas]: crate::client::MetadataService::list_metadata_schemas
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataSchemasResponse {
    /// The MetadataSchemas found for the MetadataStore.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metadata_schemas: std::vec::Vec<crate::model::MetadataSchema>,

    /// A token, which can be sent as
    /// [ListMetadataSchemasRequest.page_token][google.cloud.aiplatform.v1.ListMetadataSchemasRequest.page_token]
    /// to retrieve the next page. If this field is not populated, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListMetadataSchemasRequest.page_token]: crate::model::ListMetadataSchemasRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListMetadataSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMetadataSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata_schemas][crate::model::ListMetadataSchemasResponse::metadata_schemas].
    pub fn set_metadata_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetadataSchema>,
    {
        use std::iter::Iterator;
        self.metadata_schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMetadataSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataSchemasResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMetadataSchemasResponse {
    type PageItem = crate::model::MetadataSchema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metadata_schemas
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [MetadataService.QueryArtifactLineageSubgraph][google.cloud.aiplatform.v1.MetadataService.QueryArtifactLineageSubgraph].
///
/// [google.cloud.aiplatform.v1.MetadataService.QueryArtifactLineageSubgraph]: crate::client::MetadataService::query_artifact_lineage_subgraph
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryArtifactLineageSubgraphRequest {
    /// Required. The resource name of the Artifact whose Lineage needs to be
    /// retrieved as a LineageSubgraph. Format:
    /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
    ///
    /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
    /// the number of Executions, or the number of Events that would be returned
    /// for the Context exceeds 1000.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact: std::string::String,

    /// Specifies the size of the lineage graph in terms of number of hops from the
    /// specified artifact.
    /// Negative Value: INVALID_ARGUMENT error is returned
    /// 0: Only input artifact is returned.
    /// No value: Transitive closure is performed to return the complete graph.
    pub max_hops: i32,

    /// Filter specifying the boolean condition for the Artifacts to satisfy in
    /// order to be part of the Lineage Subgraph.
    /// The syntax to define filter query is based on <https://google.aip.dev/160>.
    /// The supported set of filters include the following:
    ///
    /// * **Attribute filtering**:
    ///   For example: `display_name = "test"`
    ///   Supported fields include: `name`, `display_name`, `uri`, `state`,
    ///   `schema_title`, `create_time`, and `update_time`.
    ///   Time fields, such as `create_time` and `update_time`, require values
    ///   specified in RFC-3339 format.
    ///   For example: `create_time = "2020-11-19T11:30:00-04:00"`
    /// * **Metadata field**:
    ///   To filter on metadata fields use traversal operation as follows:
    ///   `metadata.<field_name>.<type_value>`.
    ///   For example: `metadata.field_1.number_value = 10.0`
    ///   In case the field name contains special characters (such as colon), one
    ///   can embed it inside double quote.
    ///   For example: `metadata."field:1".number_value = 10.0`
    ///
    /// Each of the above supported filter types can be combined together using
    /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
    /// is 5.
    ///
    /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl QueryArtifactLineageSubgraphRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact][crate::model::QueryArtifactLineageSubgraphRequest::artifact].
    pub fn set_artifact<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact = v.into();
        self
    }

    /// Sets the value of [max_hops][crate::model::QueryArtifactLineageSubgraphRequest::max_hops].
    pub fn set_max_hops<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_hops = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::QueryArtifactLineageSubgraphRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for QueryArtifactLineageSubgraphRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryArtifactLineageSubgraphRequest"
    }
}

/// Instance of a metadata store. Contains a set of metadata that can be
/// queried.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataStore {
    /// Output only. The resource name of the MetadataStore instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when this MetadataStore was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this MetadataStore was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Customer-managed encryption key spec for a Metadata Store. If set, this
    /// Metadata Store and all sub-resources of this Metadata Store are secured
    /// using this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Description of the MetadataStore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. State information of the MetadataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state: std::option::Option<crate::model::metadata_store::MetadataStoreState>,

    /// Optional. Dataplex integration settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_config: std::option::Option<crate::model::metadata_store::DataplexConfig>,
}

impl MetadataStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MetadataStore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MetadataStore::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MetadataStore::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::MetadataStore::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MetadataStore::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MetadataStore::state].
    pub fn set_state<
        T: std::convert::Into<std::option::Option<crate::model::metadata_store::MetadataStoreState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [dataplex_config][crate::model::MetadataStore::dataplex_config].
    pub fn set_dataplex_config<
        T: std::convert::Into<std::option::Option<crate::model::metadata_store::DataplexConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_config = v.into();
        self
    }
}

impl wkt::message::Message for MetadataStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore"
    }
}

/// Defines additional types related to MetadataStore
pub mod metadata_store {
    #[allow(unused_imports)]
    use super::*;

    /// Represents state information for a MetadataStore.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetadataStoreState {
        /// The disk utilization of the MetadataStore in bytes.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub disk_utilization_bytes: i64,
    }

    impl MetadataStoreState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_utilization_bytes][crate::model::metadata_store::MetadataStoreState::disk_utilization_bytes].
        pub fn set_disk_utilization_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.disk_utilization_bytes = v.into();
            self
        }
    }

    impl wkt::message::Message for MetadataStoreState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore.MetadataStoreState"
        }
    }

    /// Represents Dataplex integration settings.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataplexConfig {
        /// Optional. Whether or not Data Lineage synchronization is enabled for
        /// Vertex Pipelines.
        pub enabled_pipelines_lineage: bool,
    }

    impl DataplexConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled_pipelines_lineage][crate::model::metadata_store::DataplexConfig::enabled_pipelines_lineage].
        pub fn set_enabled_pipelines_lineage<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled_pipelines_lineage = v.into();
            self
        }
    }

    impl wkt::message::Message for DataplexConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore.DataplexConfig"
        }
    }
}

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigratableResource {
    /// Output only. Timestamp when the last migration attempt on this
    /// MigratableResource started. Will not be set if there's no migration attempt
    /// on this MigratableResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_migrate_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this MigratableResource was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::migratable_resource::Resource>,
}

impl MigratableResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_migrate_time][crate::model::MigratableResource::last_migrate_time].
    pub fn set_last_migrate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_migrate_time = v.into();
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigratableResource::last_update_time].
    pub fn set_last_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_update_time = v.into();
        self
    }

    /// Sets the value of `resource`.
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::migratable_resource::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `MlEngineModelVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ml_engine_model_version(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migratable_resource::MlEngineModelVersion>,
    > {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::MlEngineModelVersion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `AutomlModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_automl_model(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::migratable_resource::AutomlModel>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::AutomlModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `AutomlDataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_automl_dataset(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::migratable_resource::AutomlDataset>>
    {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::AutomlDataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [resource][crate::model::MigratableResource::resource]
    /// if it holds a `DataLabelingDataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_data_labeling_dataset(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::migratable_resource::DataLabelingDataset>>
    {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::migratable_resource::Resource::DataLabelingDataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `MlEngineModelVersion`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_ml_engine_model_version<
        T: std::convert::Into<
            std::boxed::Box<crate::model::migratable_resource::MlEngineModelVersion>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::MlEngineModelVersion(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `AutomlModel`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_automl_model<
        T: std::convert::Into<std::boxed::Box<crate::model::migratable_resource::AutomlModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::AutomlModel(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `AutomlDataset`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_automl_dataset<
        T: std::convert::Into<std::boxed::Box<crate::model::migratable_resource::AutomlDataset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::AutomlDataset(v.into()),
        );
        self
    }

    /// Sets the value of [resource][crate::model::MigratableResource::resource]
    /// to hold a `DataLabelingDataset`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_data_labeling_dataset<
        T: std::convert::Into<std::boxed::Box<crate::model::migratable_resource::DataLabelingDataset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(
            crate::model::migratable_resource::Resource::DataLabelingDataset(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigratableResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource"
    }
}

/// Defines additional types related to MigratableResource
pub mod migratable_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Represents one model Version in ml.googleapis.com.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MlEngineModelVersion {
        /// The ml.googleapis.com endpoint that this model Version currently lives
        /// in.
        /// Example values:
        ///
        /// * ml.googleapis.com
        /// * us-centrall-ml.googleapis.com
        /// * europe-west4-ml.googleapis.com
        /// * asia-east1-ml.googleapis.com
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Full resource name of ml engine model Version.
        /// Format: `projects/{project}/models/{model}/versions/{version}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,
    }

    impl MlEngineModelVersion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::migratable_resource::MlEngineModelVersion::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [version][crate::model::migratable_resource::MlEngineModelVersion::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for MlEngineModelVersion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.MlEngineModelVersion"
        }
    }

    /// Represents one Model in automl.googleapis.com.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutomlModel {
        /// Full resource name of automl Model.
        /// Format:
        /// `projects/{project}/locations/{location}/models/{model}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// The Model's display name in automl.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_display_name: std::string::String,
    }

    impl AutomlModel {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::migratable_resource::AutomlModel::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_display_name][crate::model::migratable_resource::AutomlModel::model_display_name].
        pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for AutomlModel {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.AutomlModel"
        }
    }

    /// Represents one Dataset in automl.googleapis.com.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutomlDataset {
        /// Full resource name of automl Dataset.
        /// Format:
        /// `projects/{project}/locations/{location}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// The Dataset's display name in automl.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,
    }

    impl AutomlDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migratable_resource::AutomlDataset::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migratable_resource::AutomlDataset::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for AutomlDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.AutomlDataset"
        }
    }

    /// Represents one Dataset in datalabeling.googleapis.com.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataLabelingDataset {
        /// Full resource name of data labeling Dataset.
        /// Format:
        /// `projects/{project}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// The Dataset's display name in datalabeling.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,

        /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
        /// the data labeling Dataset.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub data_labeling_annotated_datasets: std::vec::Vec<
            crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset,
        >,
    }

    impl DataLabelingDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migratable_resource::DataLabelingDataset::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migratable_resource::DataLabelingDataset::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }

        /// Sets the value of [data_labeling_annotated_datasets][crate::model::migratable_resource::DataLabelingDataset::data_labeling_annotated_datasets].
        pub fn set_data_labeling_annotated_datasets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset>
        {
            use std::iter::Iterator;
            self.data_labeling_annotated_datasets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DataLabelingDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset"
        }
    }

    /// Defines additional types related to DataLabelingDataset
    pub mod data_labeling_dataset {
        #[allow(unused_imports)]
        use super::*;

        /// Represents one AnnotatedDataset in datalabeling.googleapis.com.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DataLabelingAnnotatedDataset {
            /// Full resource name of data labeling AnnotatedDataset.
            /// Format:
            /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub annotated_dataset: std::string::String,

            /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub annotated_dataset_display_name: std::string::String,
        }

        impl DataLabelingAnnotatedDataset {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [annotated_dataset][crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset::annotated_dataset].
            pub fn set_annotated_dataset<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.annotated_dataset = v.into();
                self
            }

            /// Sets the value of [annotated_dataset_display_name][crate::model::migratable_resource::data_labeling_dataset::DataLabelingAnnotatedDataset::annotated_dataset_display_name].
            pub fn set_annotated_dataset_display_name<
                T: std::convert::Into<std::string::String>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.annotated_dataset_display_name = v.into();
                self
            }
        }

        impl wkt::message::Message for DataLabelingAnnotatedDataset {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset.DataLabelingAnnotatedDataset"
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Resource {
        /// Output only. Represents one Version in ml.googleapis.com.
        MlEngineModelVersion(
            std::boxed::Box<crate::model::migratable_resource::MlEngineModelVersion>,
        ),
        /// Output only. Represents one Model in automl.googleapis.com.
        AutomlModel(std::boxed::Box<crate::model::migratable_resource::AutomlModel>),
        /// Output only. Represents one Dataset in automl.googleapis.com.
        AutomlDataset(std::boxed::Box<crate::model::migratable_resource::AutomlDataset>),
        /// Output only. Represents one Dataset in datalabeling.googleapis.com.
        DataLabelingDataset(
            std::boxed::Box<crate::model::migratable_resource::DataLabelingDataset>,
        ),
    }
}

/// Request message for
/// [MigrationService.SearchMigratableResources][google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources]: crate::client::MigrationService::search_migratable_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchMigratableResourcesRequest {
    /// Required. The location that the migratable resources should be searched
    /// from. It's the Vertex AI location that the resources can be migrated to,
    /// not the resources' original location. Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard page size.
    /// The default and maximum value is 100.
    pub page_size: i32,

    /// The standard page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter for your search. You can use the following types of filters:
    ///
    /// * Resource type filters. The following strings filter for a specific type
    ///   of [MigratableResource][google.cloud.aiplatform.v1.MigratableResource]:
    ///   * `ml_engine_model_version:*`
    ///   * `automl_model:*`
    ///   * `automl_dataset:*`
    ///   * `data_labeling_dataset:*`
    /// * "Migrated or not" filters. The following strings filter for resources
    ///   that either have or have not already been migrated:
    ///   * `last_migrate_time:*` filters for migrated resources.
    ///   * `NOT last_migrate_time:*` filters for not yet migrated resources.
    ///
    /// [google.cloud.aiplatform.v1.MigratableResource]: crate::model::MigratableResource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl SearchMigratableResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchMigratableResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchMigratableResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchMigratableResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchMigratableResourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for SearchMigratableResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchMigratableResourcesRequest"
    }
}

/// Response message for
/// [MigrationService.SearchMigratableResources][google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources]: crate::client::MigrationService::search_migratable_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchMigratableResourcesResponse {
    /// All migratable resources that can be migrated to the
    /// location specified in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migratable_resources: std::vec::Vec<crate::model::MigratableResource>,

    /// The standard next-page token.
    /// The migratable_resources may not fill page_size in
    /// SearchMigratableResourcesRequest even when there are subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchMigratableResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchMigratableResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [migratable_resources][crate::model::SearchMigratableResourcesResponse::migratable_resources].
    pub fn set_migratable_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigratableResource>,
    {
        use std::iter::Iterator;
        self.migratable_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchMigratableResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchMigratableResourcesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchMigratableResourcesResponse {
    type PageItem = crate::model::MigratableResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migratable_resources
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources]: crate::client::MigrationService::batch_migrate_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchMigrateResourcesRequest {
    /// Required. The location of the migrated resource will live in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request messages specifying the resources to migrate.
    /// They must be in the same location as the destination.
    /// Up to 50 resources can be migrated in one batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migrate_resource_requests: std::vec::Vec<crate::model::MigrateResourceRequest>,
}

impl BatchMigrateResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchMigrateResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migrate_resource_requests][crate::model::BatchMigrateResourcesRequest::migrate_resource_requests].
    pub fn set_migrate_resource_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrateResourceRequest>,
    {
        use std::iter::Iterator;
        self.migrate_resource_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchMigrateResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesRequest"
    }
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrateResourceRequest {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::migrate_resource_request::Request>,
}

impl MigrateResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `request`.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::migrate_resource_request::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateMlEngineModelVersionConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_migrate_ml_engine_model_version_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateMlEngineModelVersionConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateAutomlModelConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_migrate_automl_model_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlModelConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateAutomlModelConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateAutomlDatasetConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_migrate_automl_dataset_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlDatasetConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateAutomlDatasetConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::MigrateResourceRequest::request]
    /// if it holds a `MigrateDataLabelingDatasetConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_migrate_data_labeling_dataset_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_request::Request::MigrateDataLabelingDatasetConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateMlEngineModelVersionConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_ml_engine_model_version_config<
        T: std::convert::Into<
            std::boxed::Box<
                crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateMlEngineModelVersionConfig(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateAutomlModelConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_automl_model_config<
        T: std::convert::Into<
            std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlModelConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateAutomlModelConfig(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateAutomlDatasetConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_automl_dataset_config<
        T: std::convert::Into<
            std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlDatasetConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateAutomlDatasetConfig(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::MigrateResourceRequest::request]
    /// to hold a `MigrateDataLabelingDatasetConfig`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_migrate_data_labeling_dataset_config<
        T: std::convert::Into<
            std::boxed::Box<
                crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::migrate_resource_request::Request::MigrateDataLabelingDatasetConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for MigrateResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest"
    }
}

/// Defines additional types related to MigrateResourceRequest
pub mod migrate_resource_request {
    #[allow(unused_imports)]
    use super::*;

    /// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateMlEngineModelVersionConfig {
        /// Required. The ml.googleapis.com endpoint that this model version should
        /// be migrated from. Example values:
        ///
        /// * ml.googleapis.com
        ///
        /// * us-centrall-ml.googleapis.com
        ///
        /// * europe-west4-ml.googleapis.com
        ///
        /// * asia-east1-ml.googleapis.com
        ///
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Required. Full resource name of ml engine model version.
        /// Format: `projects/{project}/models/{model}/versions/{version}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_version: std::string::String,

        /// Required. Display name of the model in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_display_name: std::string::String,
    }

    impl MigrateMlEngineModelVersionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [model_version][crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig::model_version].
        pub fn set_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_version = v.into();
            self
        }

        /// Sets the value of [model_display_name][crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig::model_display_name].
        pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for MigrateMlEngineModelVersionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateMlEngineModelVersionConfig"
        }
    }

    /// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateAutomlModelConfig {
        /// Required. Full resource name of automl Model.
        /// Format:
        /// `projects/{project}/locations/{location}/models/{model}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// Optional. Display name of the model in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_display_name: std::string::String,
    }

    impl MigrateAutomlModelConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::migrate_resource_request::MigrateAutomlModelConfig::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_display_name][crate::model::migrate_resource_request::MigrateAutomlModelConfig::model_display_name].
        pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for MigrateAutomlModelConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlModelConfig"
        }
    }

    /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
    /// Dataset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateAutomlDatasetConfig {
        /// Required. Full resource name of automl Dataset.
        /// Format:
        /// `projects/{project}/locations/{location}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// Required. Display name of the Dataset in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,
    }

    impl MigrateAutomlDatasetConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migrate_resource_request::MigrateAutomlDatasetConfig::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migrate_resource_request::MigrateAutomlDatasetConfig::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for MigrateAutomlDatasetConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlDatasetConfig"
        }
    }

    /// Config for migrating Dataset in datalabeling.googleapis.com to Vertex
    /// AI's Dataset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MigrateDataLabelingDatasetConfig {

        /// Required. Full resource name of data labeling Dataset.
        /// Format:
        /// `projects/{project}/datasets/{dataset}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// Optional. Display name of the Dataset in Vertex AI.
        /// System will pick a display name if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_display_name: std::string::String,

        /// Optional. Configs for migrating AnnotatedDataset in
        /// datalabeling.googleapis.com to Vertex AI's SavedQuery. The specified
        /// AnnotatedDatasets have to belong to the datalabeling Dataset.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub migrate_data_labeling_annotated_dataset_configs: std::vec::Vec<crate::model::migrate_resource_request::migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig>,
    }

    impl MigrateDataLabelingDatasetConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [dataset_display_name][crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig::dataset_display_name].
        pub fn set_dataset_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataset_display_name = v.into();
            self
        }

        /// Sets the value of [migrate_data_labeling_annotated_dataset_configs][crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig::migrate_data_labeling_annotated_dataset_configs].
        pub fn set_migrate_data_labeling_annotated_dataset_configs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migrate_resource_request::migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig>
        {
            use std::iter::Iterator;
            self.migrate_data_labeling_annotated_dataset_configs =
                v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MigrateDataLabelingDatasetConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig"
        }
    }

    /// Defines additional types related to MigrateDataLabelingDatasetConfig
    pub mod migrate_data_labeling_dataset_config {
        #[allow(unused_imports)]
        use super::*;

        /// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
        /// Vertex AI's SavedQuery.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MigrateDataLabelingAnnotatedDatasetConfig {
            /// Required. Full resource name of data labeling AnnotatedDataset.
            /// Format:
            /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub annotated_dataset: std::string::String,
        }

        impl MigrateDataLabelingAnnotatedDatasetConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [annotated_dataset][crate::model::migrate_resource_request::migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig::annotated_dataset].
            pub fn set_annotated_dataset<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.annotated_dataset = v.into();
                self
            }
        }

        impl wkt::message::Message for MigrateDataLabelingAnnotatedDatasetConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig"
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
        MigrateMlEngineModelVersionConfig(
            std::boxed::Box<
                crate::model::migrate_resource_request::MigrateMlEngineModelVersionConfig,
            >,
        ),
        /// Config for migrating Model in automl.googleapis.com to Vertex AI's
        /// Model.
        MigrateAutomlModelConfig(
            std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlModelConfig>,
        ),
        /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
        /// Dataset.
        MigrateAutomlDatasetConfig(
            std::boxed::Box<crate::model::migrate_resource_request::MigrateAutomlDatasetConfig>,
        ),
        /// Config for migrating Dataset in datalabeling.googleapis.com to
        /// Vertex AI's Dataset.
        MigrateDataLabelingDatasetConfig(
            std::boxed::Box<
                crate::model::migrate_resource_request::MigrateDataLabelingDatasetConfig,
            >,
        ),
    }
}

/// Response message for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources]: crate::client::MigrationService::batch_migrate_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchMigrateResourcesResponse {
    /// Successfully migrated resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migrate_resource_responses: std::vec::Vec<crate::model::MigrateResourceResponse>,
}

impl BatchMigrateResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrate_resource_responses][crate::model::BatchMigrateResourcesResponse::migrate_resource_responses].
    pub fn set_migrate_resource_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrateResourceResponse>,
    {
        use std::iter::Iterator;
        self.migrate_resource_responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchMigrateResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesResponse"
    }
}

/// Describes a successfully migrated resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrateResourceResponse {
    /// Before migration, the identifier in ml.googleapis.com,
    /// automl.googleapis.com or datalabeling.googleapis.com.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migratable_resource: std::option::Option<crate::model::MigratableResource>,

    /// After migration, the resource name in Vertex AI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub migrated_resource:
        std::option::Option<crate::model::migrate_resource_response::MigratedResource>,
}

impl MigrateResourceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migratable_resource][crate::model::MigrateResourceResponse::migratable_resource].
    pub fn set_migratable_resource<
        T: std::convert::Into<std::option::Option<crate::model::MigratableResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migratable_resource = v.into();
        self
    }

    /// Sets the value of `migrated_resource`.
    pub fn set_migrated_resource<
        T: std::convert::Into<
            std::option::Option<crate::model::migrate_resource_response::MigratedResource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migrated_resource = v.into();
        self
    }

    /// The value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// if it holds a `Dataset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dataset(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.migrated_resource.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_response::MigratedResource::Dataset(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// if it holds a `Model`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.migrated_resource.as_ref().and_then(|v| match v {
            crate::model::migrate_resource_response::MigratedResource::Model(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// to hold a `Dataset`.
    ///
    /// Note that all the setters affecting `migrated_resource` are
    /// mutually exclusive.
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrated_resource = std::option::Option::Some(
            crate::model::migrate_resource_response::MigratedResource::Dataset(v.into()),
        );
        self
    }

    /// Sets the value of [migrated_resource][crate::model::MigrateResourceResponse::migrated_resource]
    /// to hold a `Model`.
    ///
    /// Note that all the setters affecting `migrated_resource` are
    /// mutually exclusive.
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrated_resource = std::option::Option::Some(
            crate::model::migrate_resource_response::MigratedResource::Model(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrateResourceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceResponse"
    }
}

/// Defines additional types related to MigrateResourceResponse
pub mod migrate_resource_response {
    #[allow(unused_imports)]
    use super::*;

    /// After migration, the resource name in Vertex AI.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MigratedResource {
        /// Migrated Dataset's resource name.
        Dataset(std::string::String),
        /// Migrated Model's resource name.
        Model(std::string::String),
    }
}

/// Runtime operation information for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
///
/// [google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources]: crate::client::MigrationService::batch_migrate_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchMigrateResourcesOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Partial results that reflect the latest migration operation progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_results:
        std::vec::Vec<crate::model::batch_migrate_resources_operation_metadata::PartialResult>,
}

impl BatchMigrateResourcesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchMigrateResourcesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [partial_results][crate::model::BatchMigrateResourcesOperationMetadata::partial_results].
    pub fn set_partial_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
            crate::model::batch_migrate_resources_operation_metadata::PartialResult,
        >,
    {
        use std::iter::Iterator;
        self.partial_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchMigrateResourcesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata"
    }
}

/// Defines additional types related to BatchMigrateResourcesOperationMetadata
pub mod batch_migrate_resources_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a partial result in batch migration operation for one
    /// [MigrateResourceRequest][google.cloud.aiplatform.v1.MigrateResourceRequest].
    ///
    /// [google.cloud.aiplatform.v1.MigrateResourceRequest]: crate::model::MigrateResourceRequest
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PartialResult {
        /// It's the same as the value in
        /// [BatchMigrateResourcesRequest.migrate_resource_requests][google.cloud.aiplatform.v1.BatchMigrateResourcesRequest.migrate_resource_requests].
        ///
        /// [google.cloud.aiplatform.v1.BatchMigrateResourcesRequest.migrate_resource_requests]: crate::model::BatchMigrateResourcesRequest::migrate_resource_requests
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub request: std::option::Option<crate::model::MigrateResourceRequest>,

        /// If the resource's migration is ongoing, none of the result will be set.
        /// If the resource's migration is finished, either error or one of the
        /// migrated resource name will be filled.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub result: std::option::Option<
            crate::model::batch_migrate_resources_operation_metadata::partial_result::Result,
        >,
    }

    impl PartialResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [request][crate::model::batch_migrate_resources_operation_metadata::PartialResult::request].
        pub fn set_request<
            T: std::convert::Into<std::option::Option<crate::model::MigrateResourceRequest>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request = v.into();
            self
        }

        /// Sets the value of `result`.
        pub fn set_result<T: std::convert::Into<std::option::Option<crate::model::batch_migrate_resources_operation_metadata::partial_result::Result>>>(mut self, v: T) -> Self
        {
            self.result = v.into();
            self
        }

        /// The value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// if it holds a `Error`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Error(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// if it holds a `Model`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_model(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Model(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// if it holds a `Dataset`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_dataset(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Dataset(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// to hold a `Error`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.result = std::option::Option::Some(
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Error(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// to hold a `Model`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.result = std::option::Option::Some(
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Model(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [result][crate::model::batch_migrate_resources_operation_metadata::PartialResult::result]
        /// to hold a `Dataset`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.result = std::option::Option::Some(
                crate::model::batch_migrate_resources_operation_metadata::partial_result::Result::Dataset(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for PartialResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata.PartialResult"
        }
    }

    /// Defines additional types related to PartialResult
    pub mod partial_result {
        #[allow(unused_imports)]
        use super::*;

        /// If the resource's migration is ongoing, none of the result will be set.
        /// If the resource's migration is finished, either error or one of the
        /// migrated resource name will be filled.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Result {
            /// The error result of the migration request in case of failure.
            Error(std::boxed::Box<rpc::model::Status>),
            /// Migrated model resource name.
            Model(std::string::String),
            /// Migrated dataset resource name.
            Dataset(std::string::String),
        }
    }
}

/// A trained machine learning Model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Model {
    /// The resource name of the Model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The version ID of the model.
    /// A new version is committed when a new model version is uploaded or
    /// trained under an existing model id. It is an auto-incrementing decimal
    /// number in string representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_id: std::string::String,

    /// User provided version aliases so that a model version can be referenced via
    /// alias (i.e.
    /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
    /// instead of auto-generated version id (i.e.
    /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
    /// The format is [a-z][a-zA-Z0-9-]{0,126}[a-z0-9] to distinguish from
    /// version_id. A default version alias will be created for the first version
    /// of the model, and there must be exactly one default version alias for a
    /// model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version_aliases: std::vec::Vec<std::string::String>,

    /// Output only. Timestamp when this version was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this version was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The display name of the Model.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the Model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The description of this version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_description: std::string::String,

    /// The default checkpoint id of a model version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_checkpoint_id: std::string::String,

    /// The schemata that describe formats of the Model's predictions and
    /// explanations as given and returned via
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// and
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
    ///
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_schemata: std::option::Option<crate::model::PredictSchemata>,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// additional information about the Model, that is specific to it. Unset if
    /// the Model does not have any additional information. The schema is defined
    /// as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI, if no
    /// additional metadata is needed, this field is set to an empty string.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_schema_uri: std::string::String,

    /// Immutable. An additional information about the Model; the schema of the
    /// metadata can be found in
    /// [metadata_schema][google.cloud.aiplatform.v1.Model.metadata_schema_uri].
    /// Unset if the Model does not have any additional information.
    ///
    /// [google.cloud.aiplatform.v1.Model.metadata_schema_uri]: crate::model::Model::metadata_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. The formats in which this Model may be exported. If empty,
    /// this Model is not available for export.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_export_formats: std::vec::Vec<crate::model::model::ExportFormat>,

    /// Output only. The resource name of the TrainingPipeline that uploaded this
    /// Model, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_pipeline: std::string::String,

    /// Optional. This field is populated if the model is produced by a pipeline
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pipeline_job: std::string::String,

    /// Input only. The specification of the container that is to be used when
    /// deploying this Model. The specification is ingested upon
    /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel],
    /// and all binaries it contains are copied and stored internally by Vertex AI.
    /// Not required for AutoML Models.
    ///
    /// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_spec: std::option::Option<crate::model::ModelContainerSpec>,

    /// Immutable. The path to the directory containing the Model artifact and any
    /// of its supporting files. Not required for AutoML Models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_uri: std::string::String,

    /// Output only. When this Model is deployed, its prediction resources are
    /// described by the `prediction_resources` field of the
    /// [Endpoint.deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
    /// object. Because not all Models support all resource configuration types,
    /// the configuration types this Model supports are listed here. If no
    /// configuration types are listed, the Model cannot be deployed to an
    /// [Endpoint][google.cloud.aiplatform.v1.Endpoint] and does not support
    /// online predictions
    /// ([PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// or
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain]).
    /// Such a Model can serve predictions by using a
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob], if it
    /// has at least one entry each in
    /// [supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats]
    /// and
    /// [supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.Endpoint]: crate::model::Endpoint
    /// [google.cloud.aiplatform.v1.Endpoint.deployed_models]: crate::model::Endpoint::deployed_models
    /// [google.cloud.aiplatform.v1.Model.supported_input_storage_formats]: crate::model::Model::supported_input_storage_formats
    /// [google.cloud.aiplatform.v1.Model.supported_output_storage_formats]: crate::model::Model::supported_output_storage_formats
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_deployment_resources_types:
        std::vec::Vec<crate::model::model::DeploymentResourcesType>,

    /// Output only. The formats this Model supports in
    /// [BatchPredictionJob.input_config][google.cloud.aiplatform.v1.BatchPredictionJob.input_config].
    /// If
    /// [PredictSchemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// exists, the instances should be given as per that schema.
    ///
    /// The possible formats are:
    ///
    /// * `jsonl`
    ///   The JSON Lines format, where each instance is a single line. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `csv`
    ///   The CSV format, where each instance is a single comma-separated line.
    ///   The first line in the file is the header, containing comma-separated field
    ///   names. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `tf-record`
    ///   The TFRecord format, where each instance is a single record in tfrecord
    ///   syntax. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `tf-record-gzip`
    ///   Similar to `tf-record`, but the file is gzipped. Uses
    ///   [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
    ///
    /// * `bigquery`
    ///   Each instance is a single row in BigQuery. Uses
    ///   [BigQuerySource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.bigquery_source].
    ///
    /// * `file-list`
    ///   Each line of the file is the location of an instance to process, uses
    ///   `gcs_source` field of the
    ///   [InputConfig][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig]
    ///   object.
    ///
    ///
    /// If this Model doesn't support any of these formats it means it cannot be
    /// used with a
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    /// However, if it has
    /// [supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types],
    /// it could serve online predictions by using
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// or
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig]: crate::model::batch_prediction_job::InputConfig
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.bigquery_source]: crate::model::batch_prediction_job::InputConfig::source
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source]: crate::model::batch_prediction_job::InputConfig::source
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.input_config]: crate::model::BatchPredictionJob::input_config
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_input_storage_formats: std::vec::Vec<std::string::String>,

    /// Output only. The formats this Model supports in
    /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
    /// If both
    /// [PredictSchemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// and
    /// [PredictSchemata.prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]
    /// exist, the predictions are returned together with their instances. In other
    /// words, the prediction has the original instance data first, followed by the
    /// actual prediction content (as per the schema).
    ///
    /// The possible formats are:
    ///
    /// * `jsonl`
    ///   The JSON Lines format, where each prediction is a single line. Uses
    ///   [GcsDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination].
    ///
    /// * `csv`
    ///   The CSV format, where each prediction is a single comma-separated line.
    ///   The first line in the file is the header, containing comma-separated field
    ///   names. Uses
    ///   [GcsDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination].
    ///
    /// * `bigquery`
    ///   Each prediction is a single row in a BigQuery table, uses
    ///   [BigQueryDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.bigquery_destination]
    ///   .
    ///
    ///
    /// If this Model doesn't support any of these formats it means it cannot be
    /// used with a
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    /// However, if it has
    /// [supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types],
    /// it could serve online predictions by using
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// or
    /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.bigquery_destination]: crate::model::batch_prediction_job::OutputConfig::destination
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination]: crate::model::batch_prediction_job::OutputConfig::destination
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    /// [google.cloud.aiplatform.v1.Model.supported_deployment_resources_types]: crate::model::Model::supported_deployment_resources_types
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]: crate::model::PredictSchemata::prediction_schema_uri
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_output_storage_formats: std::vec::Vec<std::string::String>,

    /// Output only. Timestamp when this Model was uploaded into Vertex AI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Model was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The pointers to DeployedModels created from this Model. Note
    /// that Model could have been deployed to Endpoints in different Locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployed_models: std::vec::Vec<crate::model::DeployedModelRef>,

    /// The default explanation specification for this Model.
    ///
    /// The Model can be used for
    /// [requesting
    /// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] after
    /// being [deployed][google.cloud.aiplatform.v1.EndpointService.DeployModel] if
    /// it is populated. The Model can be used for [batch
    /// explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
    /// if it is populated.
    ///
    /// All fields of the explanation_spec can be overridden by
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// of
    /// [DeployModelRequest.deployed_model][google.cloud.aiplatform.v1.DeployModelRequest.deployed_model],
    /// or
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// of [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    ///
    /// If the default explanation specification is not set for this Model, this
    /// Model can still be used for
    /// [requesting
    /// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] by
    /// setting
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// of
    /// [DeployModelRequest.deployed_model][google.cloud.aiplatform.v1.DeployModelRequest.deployed_model]
    /// and for [batch
    /// explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
    /// by setting
    /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
    /// of [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]: crate::model::BatchPredictionJob::explanation_spec
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]: crate::model::BatchPredictionJob::generate_explanation
    /// [google.cloud.aiplatform.v1.DeployModelRequest.deployed_model]: crate::model::DeployModelRequest::deployed_model
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize your Models.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Stats of data used for training or evaluating the Model.
    ///
    /// Only populated when the Model is trained by a TrainingPipeline with
    /// [data_input_config][google.cloud.aiplatform.v1.TrainingPipeline.input_data_config].
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.input_data_config]: crate::model::TrainingPipeline::input_data_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_stats: std::option::Option<crate::model::model::DataStats>,

    /// Customer-managed encryption key spec for a Model. If set, this
    /// Model and all sub-resources of this Model will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Source of a model. It can either be automl training pipeline,
    /// custom training pipeline, BigQuery ML, or saved and tuned from Genie or
    /// Model Garden.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_source_info: std::option::Option<crate::model::ModelSourceInfo>,

    /// Output only. If this Model is a copy of another Model, this contains info
    /// about the original.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_model_info: std::option::Option<crate::model::model::OriginalModelInfo>,

    /// Output only. The resource name of the Artifact that was created in
    /// MetadataStore when creating the Model. The Artifact resource name pattern
    /// is
    /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_artifact: std::string::String,

    /// Optional. User input field to specify the base model source. Currently it
    /// only supports specifing the Model Garden models and Genie models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_model_source: std::option::Option<crate::model::model::BaseModelSource>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Model::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::Model::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [version_create_time][crate::model::Model::version_create_time].
    pub fn set_version_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_create_time = v.into();
        self
    }

    /// Sets the value of [version_update_time][crate::model::Model::version_update_time].
    pub fn set_version_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Model::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Model::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version_description][crate::model::Model::version_description].
    pub fn set_version_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_description = v.into();
        self
    }

    /// Sets the value of [default_checkpoint_id][crate::model::Model::default_checkpoint_id].
    pub fn set_default_checkpoint_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_checkpoint_id = v.into();
        self
    }

    /// Sets the value of [predict_schemata][crate::model::Model::predict_schemata].
    pub fn set_predict_schemata<
        T: std::convert::Into<std::option::Option<crate::model::PredictSchemata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_schemata = v.into();
        self
    }

    /// Sets the value of [metadata_schema_uri][crate::model::Model::metadata_schema_uri].
    pub fn set_metadata_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Model::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [training_pipeline][crate::model::Model::training_pipeline].
    pub fn set_training_pipeline<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_pipeline = v.into();
        self
    }

    /// Sets the value of [pipeline_job][crate::model::Model::pipeline_job].
    pub fn set_pipeline_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_job = v.into();
        self
    }

    /// Sets the value of [container_spec][crate::model::Model::container_spec].
    pub fn set_container_spec<
        T: std::convert::Into<std::option::Option<crate::model::ModelContainerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container_spec = v.into();
        self
    }

    /// Sets the value of [artifact_uri][crate::model::Model::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Model::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Model::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [explanation_spec][crate::model::Model::explanation_spec].
    pub fn set_explanation_spec<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Model::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [data_stats][crate::model::Model::data_stats].
    pub fn set_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::model::DataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_stats = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Model::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [model_source_info][crate::model::Model::model_source_info].
    pub fn set_model_source_info<
        T: std::convert::Into<std::option::Option<crate::model::ModelSourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_source_info = v.into();
        self
    }

    /// Sets the value of [original_model_info][crate::model::Model::original_model_info].
    pub fn set_original_model_info<
        T: std::convert::Into<std::option::Option<crate::model::model::OriginalModelInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_model_info = v.into();
        self
    }

    /// Sets the value of [metadata_artifact][crate::model::Model::metadata_artifact].
    pub fn set_metadata_artifact<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_artifact = v.into();
        self
    }

    /// Sets the value of [base_model_source][crate::model::Model::base_model_source].
    pub fn set_base_model_source<
        T: std::convert::Into<std::option::Option<crate::model::model::BaseModelSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_model_source = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Model::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Model::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::Model::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_export_formats][crate::model::Model::supported_export_formats].
    pub fn set_supported_export_formats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::ExportFormat>,
    {
        use std::iter::Iterator;
        self.supported_export_formats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_deployment_resources_types][crate::model::Model::supported_deployment_resources_types].
    pub fn set_supported_deployment_resources_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::DeploymentResourcesType>,
    {
        use std::iter::Iterator;
        self.supported_deployment_resources_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_input_storage_formats][crate::model::Model::supported_input_storage_formats].
    pub fn set_supported_input_storage_formats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_input_storage_formats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_output_storage_formats][crate::model::Model::supported_output_storage_formats].
    pub fn set_supported_output_storage_formats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_output_storage_formats = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployed_models][crate::model::Model::deployed_models].
    pub fn set_deployed_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployedModelRef>,
    {
        use std::iter::Iterator;
        self.deployed_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Model::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Model"
    }
}

/// Defines additional types related to Model
pub mod model {
    #[allow(unused_imports)]
    use super::*;

    /// Represents export format supported by the Model.
    /// All formats export to Google Cloud Storage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExportFormat {
        /// Output only. The ID of the export format.
        /// The possible format IDs are:
        ///
        /// * `tflite`
        ///   Used for Android mobile devices.
        ///
        /// * `edgetpu-tflite`
        ///   Used for [Edge TPU](https://cloud.google.com/edge-tpu/) devices.
        ///
        /// * `tf-saved-model`
        ///   A tensorflow model in SavedModel format.
        ///
        /// * `tf-js`
        ///   A [TensorFlow.js](https://www.tensorflow.org/js) model that can be used
        ///   in the browser and in Node.js using JavaScript.
        ///
        /// * `core-ml`
        ///   Used for iOS mobile devices.
        ///
        /// * `custom-trained`
        ///   A Model that was uploaded or trained by custom code.
        ///
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Output only. The content of this Model that may be exported.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub exportable_contents:
            std::vec::Vec<crate::model::model::export_format::ExportableContent>,
    }

    impl ExportFormat {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::model::ExportFormat::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [exportable_contents][crate::model::model::ExportFormat::exportable_contents].
        pub fn set_exportable_contents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::export_format::ExportableContent>,
        {
            use std::iter::Iterator;
            self.exportable_contents = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ExportFormat {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.ExportFormat"
        }
    }

    /// Defines additional types related to ExportFormat
    pub mod export_format {
        #[allow(unused_imports)]
        use super::*;

        /// The Model content that can be exported.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ExportableContent(std::borrow::Cow<'static, str>);

        impl ExportableContent {
            /// Creates a new ExportableContent instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ExportableContent](ExportableContent)
        pub mod exportable_content {
            use super::ExportableContent;

            /// Should not be used.
            pub const EXPORTABLE_CONTENT_UNSPECIFIED: ExportableContent =
                ExportableContent::new("EXPORTABLE_CONTENT_UNSPECIFIED");

            /// Model artifact and any of its supported files. Will be exported to the
            /// location specified by the `artifactDestination` field of the
            /// [ExportModelRequest.output_config][google.cloud.aiplatform.v1.ExportModelRequest.output_config]
            /// object.
            ///
            /// [google.cloud.aiplatform.v1.ExportModelRequest.output_config]: crate::model::ExportModelRequest::output_config
            pub const ARTIFACT: ExportableContent = ExportableContent::new("ARTIFACT");

            /// The container image that is to be used when deploying this Model. Will
            /// be exported to the location specified by the `imageDestination` field
            /// of the
            /// [ExportModelRequest.output_config][google.cloud.aiplatform.v1.ExportModelRequest.output_config]
            /// object.
            ///
            /// [google.cloud.aiplatform.v1.ExportModelRequest.output_config]: crate::model::ExportModelRequest::output_config
            pub const IMAGE: ExportableContent = ExportableContent::new("IMAGE");
        }

        impl std::convert::From<std::string::String> for ExportableContent {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Stats of data used for train or evaluate the Model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataStats {
        /// Number of DataItems that were used for training this Model.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub training_data_items_count: i64,

        /// Number of DataItems that were used for validating this Model during
        /// training.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub validation_data_items_count: i64,

        /// Number of DataItems that were used for evaluating this Model. If the
        /// Model is evaluated multiple times, this will be the number of test
        /// DataItems used by the first evaluation. If the Model is not evaluated,
        /// the number is 0.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub test_data_items_count: i64,

        /// Number of Annotations that are used for training this Model.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub training_annotations_count: i64,

        /// Number of Annotations that are used for validating this Model during
        /// training.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub validation_annotations_count: i64,

        /// Number of Annotations that are used for evaluating this Model. If the
        /// Model is evaluated multiple times, this will be the number of test
        /// Annotations used by the first evaluation. If the Model is not evaluated,
        /// the number is 0.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub test_annotations_count: i64,
    }

    impl DataStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_data_items_count][crate::model::model::DataStats::training_data_items_count].
        pub fn set_training_data_items_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.training_data_items_count = v.into();
            self
        }

        /// Sets the value of [validation_data_items_count][crate::model::model::DataStats::validation_data_items_count].
        pub fn set_validation_data_items_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.validation_data_items_count = v.into();
            self
        }

        /// Sets the value of [test_data_items_count][crate::model::model::DataStats::test_data_items_count].
        pub fn set_test_data_items_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.test_data_items_count = v.into();
            self
        }

        /// Sets the value of [training_annotations_count][crate::model::model::DataStats::training_annotations_count].
        pub fn set_training_annotations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.training_annotations_count = v.into();
            self
        }

        /// Sets the value of [validation_annotations_count][crate::model::model::DataStats::validation_annotations_count].
        pub fn set_validation_annotations_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.validation_annotations_count = v.into();
            self
        }

        /// Sets the value of [test_annotations_count][crate::model::model::DataStats::test_annotations_count].
        pub fn set_test_annotations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.test_annotations_count = v.into();
            self
        }
    }

    impl wkt::message::Message for DataStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.DataStats"
        }
    }

    /// Contains information about the original Model if this Model is a copy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OriginalModelInfo {
        /// Output only. The resource name of the Model this Model is a copy of,
        /// including the revision. Format:
        /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,
    }

    impl OriginalModelInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::model::OriginalModelInfo::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }
    }

    impl wkt::message::Message for OriginalModelInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.OriginalModelInfo"
        }
    }

    /// User input field to specify the base model source. Currently it only
    /// supports specifing the Model Garden models and Genie models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BaseModelSource {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::model::base_model_source::Source>,
    }

    impl BaseModelSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `source`.
        pub fn set_source<
            T: std::convert::Into<std::option::Option<crate::model::model::base_model_source::Source>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::model::BaseModelSource::source]
        /// if it holds a `ModelGardenSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_model_garden_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::ModelGardenSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::model::base_model_source::Source::ModelGardenSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [source][crate::model::model::BaseModelSource::source]
        /// if it holds a `GenieSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_genie_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GenieSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::model::base_model_source::Source::GenieSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::model::BaseModelSource::source]
        /// to hold a `ModelGardenSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_model_garden_source<
            T: std::convert::Into<std::boxed::Box<crate::model::ModelGardenSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::model::base_model_source::Source::ModelGardenSource(v.into()),
            );
            self
        }

        /// Sets the value of [source][crate::model::model::BaseModelSource::source]
        /// to hold a `GenieSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_genie_source<
            T: std::convert::Into<std::boxed::Box<crate::model::GenieSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::model::base_model_source::Source::GenieSource(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for BaseModelSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.BaseModelSource"
        }
    }

    /// Defines additional types related to BaseModelSource
    pub mod base_model_source {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// Source information of Model Garden models.
            ModelGardenSource(std::boxed::Box<crate::model::ModelGardenSource>),
            /// Information about the base model of Genie models.
            GenieSource(std::boxed::Box<crate::model::GenieSource>),
        }
    }

    /// Identifies a type of Model's prediction resources.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DeploymentResourcesType(std::borrow::Cow<'static, str>);

    impl DeploymentResourcesType {
        /// Creates a new DeploymentResourcesType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DeploymentResourcesType](DeploymentResourcesType)
    pub mod deployment_resources_type {
        use super::DeploymentResourcesType;

        /// Should not be used.
        pub const DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED: DeploymentResourcesType =
            DeploymentResourcesType::new("DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED");

        /// Resources that are dedicated to the
        /// [DeployedModel][google.cloud.aiplatform.v1.DeployedModel], and that need
        /// a higher degree of manual configuration.
        ///
        /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
        pub const DEDICATED_RESOURCES: DeploymentResourcesType =
            DeploymentResourcesType::new("DEDICATED_RESOURCES");

        /// Resources that to large degree are decided by Vertex AI, and require
        /// only a modest additional configuration.
        pub const AUTOMATIC_RESOURCES: DeploymentResourcesType =
            DeploymentResourcesType::new("AUTOMATIC_RESOURCES");

        /// Resources that can be shared by multiple
        /// [DeployedModels][google.cloud.aiplatform.v1.DeployedModel]. A
        /// pre-configured
        /// [DeploymentResourcePool][google.cloud.aiplatform.v1.DeploymentResourcePool]
        /// is required.
        ///
        /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
        /// [google.cloud.aiplatform.v1.DeploymentResourcePool]: crate::model::DeploymentResourcePool
        pub const SHARED_RESOURCES: DeploymentResourcesType =
            DeploymentResourcesType::new("SHARED_RESOURCES");
    }

    impl std::convert::From<std::string::String> for DeploymentResourcesType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Contains information about the Large Model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LargeModelReference {
    /// Required. The unique name of the large Foundation or pre-built model. Like
    /// "chat-bison", "text-bison". Or model name with version ID, like
    /// "chat-bison@001", "text-bison@005", etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl LargeModelReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LargeModelReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for LargeModelReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LargeModelReference"
    }
}

/// Contains information about the source of the models generated from Model
/// Garden.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelGardenSource {
    /// Required. The model garden source model resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_model_name: std::string::String,
}

impl ModelGardenSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_model_name][crate::model::ModelGardenSource::public_model_name].
    pub fn set_public_model_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_model_name = v.into();
        self
    }
}

impl wkt::message::Message for ModelGardenSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelGardenSource"
    }
}

/// Contains information about the source of the models generated from Generative
/// AI Studio.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenieSource {
    /// Required. The public base model URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_model_uri: std::string::String,
}

impl GenieSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_model_uri][crate::model::GenieSource::base_model_uri].
    pub fn set_base_model_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_model_uri = v.into();
        self
    }
}

impl wkt::message::Message for GenieSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenieSource"
    }
}

/// Contains the schemata used in Model's predictions and explanations via
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict],
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain]
/// and [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
///
/// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
/// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictSchemata {
    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// the format of a single instance, which are used in
    /// [PredictRequest.instances][google.cloud.aiplatform.v1.PredictRequest.instances],
    /// [ExplainRequest.instances][google.cloud.aiplatform.v1.ExplainRequest.instances]
    /// and
    /// [BatchPredictionJob.input_config][google.cloud.aiplatform.v1.BatchPredictionJob.input_config].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.input_config]: crate::model::BatchPredictionJob::input_config
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.PredictRequest.instances]: crate::model::PredictRequest::instances
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_schema_uri: std::string::String,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// the parameters of prediction and explanation via
    /// [PredictRequest.parameters][google.cloud.aiplatform.v1.PredictRequest.parameters],
    /// [ExplainRequest.parameters][google.cloud.aiplatform.v1.ExplainRequest.parameters]
    /// and
    /// [BatchPredictionJob.model_parameters][google.cloud.aiplatform.v1.BatchPredictionJob.model_parameters].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI, if no
    /// parameters are supported, then it is set to an empty string.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.model_parameters]: crate::model::BatchPredictionJob::model_parameters
    /// [google.cloud.aiplatform.v1.ExplainRequest.parameters]: crate::model::ExplainRequest::parameters
    /// [google.cloud.aiplatform.v1.PredictRequest.parameters]: crate::model::PredictRequest::parameters
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parameters_schema_uri: std::string::String,

    /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
    /// the format of a single prediction produced by this Model, which are
    /// returned via
    /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions],
    /// [ExplainResponse.explanations][google.cloud.aiplatform.v1.ExplainResponse.explanations],
    /// and
    /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML Models always have this field populated by Vertex AI.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    ///
    /// [google.cloud.aiplatform.v1.BatchPredictionJob.output_config]: crate::model::BatchPredictionJob::output_config
    /// [google.cloud.aiplatform.v1.ExplainResponse.explanations]: crate::model::ExplainResponse::explanations
    /// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub prediction_schema_uri: std::string::String,
}

impl PredictSchemata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_schema_uri][crate::model::PredictSchemata::instance_schema_uri].
    pub fn set_instance_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_schema_uri = v.into();
        self
    }

    /// Sets the value of [parameters_schema_uri][crate::model::PredictSchemata::parameters_schema_uri].
    pub fn set_parameters_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters_schema_uri = v.into();
        self
    }

    /// Sets the value of [prediction_schema_uri][crate::model::PredictSchemata::prediction_schema_uri].
    pub fn set_prediction_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_schema_uri = v.into();
        self
    }
}

impl wkt::message::Message for PredictSchemata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictSchemata"
    }
}

/// Specification of a container for serving predictions. Some fields in this
/// message correspond to fields in the [Kubernetes Container v1 core
/// specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelContainerSpec {
    /// Required. Immutable. URI of the Docker image to be used as the custom
    /// container for serving predictions. This URI must identify an image in
    /// Artifact Registry or Container Registry. Learn more about the [container
    /// publishing
    /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
    /// including permissions requirements for the Vertex AI Service Agent.
    ///
    /// The container image is ingested upon
    /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel],
    /// stored internally, and this original path is afterwards not used.
    ///
    /// To learn about the requirements for the Docker image itself, see
    /// [Custom container
    /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
    ///
    /// You can use the URI to one of Vertex AI's [pre-built container images for
    /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
    /// in this field.
    ///
    /// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Immutable. Specifies the command that runs when the container starts. This
    /// overrides the container's
    /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
    /// Specify this field as an array of executable and arguments, similar to a
    /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form.
    ///
    /// If you do not specify this field, then the container's `ENTRYPOINT` runs,
    /// in conjunction with the
    /// [args][google.cloud.aiplatform.v1.ModelContainerSpec.args] field or the
    /// container's [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
    /// if either exists. If this field is not specified and the container does not
    /// have an `ENTRYPOINT`, then refer to the Docker documentation about [how
    /// `CMD` and `ENTRYPOINT`
    /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
    ///
    /// If you specify this field, then you can also specify the `args` field to
    /// provide additional arguments for this command. However, if you specify this
    /// field, then the container's `CMD` is ignored. See the
    /// [Kubernetes documentation about how the
    /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
    /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
    ///
    /// In this field, you can reference [environment variables set by Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
    /// and environment variables set in the
    /// [env][google.cloud.aiplatform.v1.ModelContainerSpec.env] field. You cannot
    /// reference environment variables set in the Docker image. In order for
    /// environment variables to be expanded, reference them by using the following
    /// syntax: \<code\>$(\<var\>VARIABLE_NAME\</var\>)\</code\> Note that this differs
    /// from Bash variable expansion, which does not use parentheses. If a variable
    /// cannot be resolved, the reference in the input string is used unchanged. To
    /// avoid variable expansion, you can escape this syntax with `$$`; for
    /// example: \<code\>$$(\<var\>VARIABLE_NAME\</var\>)\</code\> This field corresponds
    /// to the `command` field of the Kubernetes Containers [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    ///
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.args]: crate::model::ModelContainerSpec::args
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.env]: crate::model::ModelContainerSpec::env
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub command: std::vec::Vec<std::string::String>,

    /// Immutable. Specifies arguments for the command that runs when the container
    /// starts. This overrides the container's
    /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
    /// this field as an array of executable and arguments, similar to a Docker
    /// `CMD`'s "default parameters" form.
    ///
    /// If you don't specify this field but do specify the
    /// [command][google.cloud.aiplatform.v1.ModelContainerSpec.command] field,
    /// then the command from the `command` field runs without any additional
    /// arguments. See the [Kubernetes documentation about how the `command` and
    /// `args` fields interact with a container's `ENTRYPOINT` and
    /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
    ///
    /// If you don't specify this field and don't specify the `command` field,
    /// then the container's
    /// [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
    /// `CMD` determine what runs based on their default behavior. See the Docker
    /// documentation about [how `CMD` and `ENTRYPOINT`
    /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
    ///
    /// In this field, you can reference [environment variables
    /// set by Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
    /// and environment variables set in the
    /// [env][google.cloud.aiplatform.v1.ModelContainerSpec.env] field. You cannot
    /// reference environment variables set in the Docker image. In order for
    /// environment variables to be expanded, reference them by using the following
    /// syntax: \<code\>$(\<var\>VARIABLE_NAME\</var\>)\</code\> Note that this differs
    /// from Bash variable expansion, which does not use parentheses. If a variable
    /// cannot be resolved, the reference in the input string is used unchanged. To
    /// avoid variable expansion, you can escape this syntax with `$$`; for
    /// example: \<code\>$$(\<var\>VARIABLE_NAME\</var\>)\</code\> This field corresponds
    /// to the `args` field of the Kubernetes Containers [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    ///
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.command]: crate::model::ModelContainerSpec::command
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.env]: crate::model::ModelContainerSpec::env
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Immutable. List of environment variables to set in the container. After the
    /// container starts running, code running in the container can read these
    /// environment variables.
    ///
    /// Additionally, the
    /// [command][google.cloud.aiplatform.v1.ModelContainerSpec.command] and
    /// [args][google.cloud.aiplatform.v1.ModelContainerSpec.args] fields can
    /// reference these variables. Later entries in this list can also reference
    /// earlier entries. For example, the following example sets the variable
    /// `VAR_2` to have the value `foo bar`:
    ///
    /// ```norust
    /// [
    ///   {
    ///     "name": "VAR_1",
    ///     "value": "foo"
    ///   },
    ///   {
    ///     "name": "VAR_2",
    ///     "value": "$(VAR_1) bar"
    ///   }
    /// ]
    /// ```
    ///
    /// If you switch the order of the variables in the example, then the expansion
    /// does not occur.
    ///
    /// This field corresponds to the `env` field of the Kubernetes Containers
    /// [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    ///
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.args]: crate::model::ModelContainerSpec::args
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.command]: crate::model::ModelContainerSpec::command
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    /// Immutable. List of ports to expose from the container. Vertex AI sends any
    /// prediction requests that it receives to the first port on this list. Vertex
    /// AI also sends
    /// [liveness and health
    /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
    /// to this port.
    ///
    /// If you do not specify this field, it defaults to following value:
    ///
    /// ```norust
    /// [
    ///   {
    ///     "containerPort": 8080
    ///   }
    /// ]
    /// ```
    ///
    /// Vertex AI does not use ports other than the first one listed. This field
    /// corresponds to the `ports` field of the Kubernetes Containers
    /// [v1 core
    /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ports: std::vec::Vec<crate::model::Port>,

    /// Immutable. HTTP path on the container to send prediction requests to.
    /// Vertex AI forwards requests sent using
    /// [projects.locations.endpoints.predict][google.cloud.aiplatform.v1.PredictionService.Predict]
    /// to this path on the container's IP address and port. Vertex AI then returns
    /// the container's response in the API response.
    ///
    /// For example, if you set this field to `/foo`, then when Vertex AI
    /// receives a prediction request, it forwards the request body in a POST
    /// request to the `/foo` path on the port of your container specified by the
    /// first value of this `ModelContainerSpec`'s
    /// [ports][google.cloud.aiplatform.v1.ModelContainerSpec.ports] field.
    ///
    /// If you don't specify this field, it defaults to the following value when
    /// you [deploy this Model to an
    /// Endpoint][google.cloud.aiplatform.v1.EndpointService.DeployModel]:
    /// \<code\>/v1/endpoints/\<var\>ENDPOINT\</var\>/deployedModels/\<var\>DEPLOYED_MODEL\</var\>:predict\</code\>
    /// The placeholders in this value are replaced as follows:
    ///
    /// * \<var\>ENDPOINT\</var\>: The last segment (following `endpoints/`)of the
    ///   Endpoint.name][] field of the Endpoint where this Model has been
    ///   deployed. (Vertex AI makes this value available to your container code
    ///   as the [`AIP_ENDPOINT_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    /// * \<var\>DEPLOYED_MODEL\</var\>:
    ///   [DeployedModel.id][google.cloud.aiplatform.v1.DeployedModel.id] of the
    ///   `DeployedModel`.
    ///   (Vertex AI makes this value available to your container code
    ///   as the [`AIP_DEPLOYED_MODEL_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.id]: crate::model::DeployedModel::id
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.ports]: crate::model::ModelContainerSpec::ports
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predict_route: std::string::String,

    /// Immutable. HTTP path on the container to send health checks to. Vertex AI
    /// intermittently sends GET requests to this path on the container's IP
    /// address and port to check that the container is healthy. Read more about
    /// [health
    /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
    ///
    /// For example, if you set this field to `/bar`, then Vertex AI
    /// intermittently sends a GET request to the `/bar` path on the port of your
    /// container specified by the first value of this `ModelContainerSpec`'s
    /// [ports][google.cloud.aiplatform.v1.ModelContainerSpec.ports] field.
    ///
    /// If you don't specify this field, it defaults to the following value when
    /// you [deploy this Model to an
    /// Endpoint][google.cloud.aiplatform.v1.EndpointService.DeployModel]:
    /// \<code\>/v1/endpoints/\<var\>ENDPOINT\</var\>/deployedModels/\<var\>DEPLOYED_MODEL\</var\>:predict\</code\>
    /// The placeholders in this value are replaced as follows:
    ///
    /// * \<var\>ENDPOINT\</var\>: The last segment (following `endpoints/`)of the
    ///   Endpoint.name][] field of the Endpoint where this Model has been
    ///   deployed. (Vertex AI makes this value available to your container code
    ///   as the [`AIP_ENDPOINT_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    /// * \<var\>DEPLOYED_MODEL\</var\>:
    ///   [DeployedModel.id][google.cloud.aiplatform.v1.DeployedModel.id] of the
    ///   `DeployedModel`.
    ///   (Vertex AI makes this value available to your container code as the
    ///   [`AIP_DEPLOYED_MODEL_ID` environment
    ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
    ///
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.id]: crate::model::DeployedModel::id
    /// [google.cloud.aiplatform.v1.EndpointService.DeployModel]: crate::client::EndpointService::deploy_model
    /// [google.cloud.aiplatform.v1.ModelContainerSpec.ports]: crate::model::ModelContainerSpec::ports
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_route: std::string::String,

    /// Immutable. List of ports to expose from the container. Vertex AI sends gRPC
    /// prediction requests that it receives to the first port on this list. Vertex
    /// AI also sends liveness and health checks to this port.
    ///
    /// If you do not specify this field, gRPC requests to the container will be
    /// disabled.
    ///
    /// Vertex AI does not use ports other than the first one listed. This field
    /// corresponds to the `ports` field of the Kubernetes Containers v1 core API.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grpc_ports: std::vec::Vec<crate::model::Port>,

    /// Immutable. Deployment timeout.
    /// Limit for deployment timeout is 2 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_timeout: std::option::Option<wkt::Duration>,

    /// Immutable. The amount of the VM memory to reserve as the shared memory for
    /// the model in megabytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub shared_memory_size_mb: i64,

    /// Immutable. Specification for Kubernetes startup probe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub startup_probe: std::option::Option<crate::model::Probe>,

    /// Immutable. Specification for Kubernetes readiness probe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub health_probe: std::option::Option<crate::model::Probe>,

    /// Immutable. Specification for Kubernetes liveness probe.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub liveness_probe: std::option::Option<crate::model::Probe>,
}

impl ModelContainerSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_uri][crate::model::ModelContainerSpec::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [predict_route][crate::model::ModelContainerSpec::predict_route].
    pub fn set_predict_route<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predict_route = v.into();
        self
    }

    /// Sets the value of [health_route][crate::model::ModelContainerSpec::health_route].
    pub fn set_health_route<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.health_route = v.into();
        self
    }

    /// Sets the value of [deployment_timeout][crate::model::ModelContainerSpec::deployment_timeout].
    pub fn set_deployment_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_timeout = v.into();
        self
    }

    /// Sets the value of [shared_memory_size_mb][crate::model::ModelContainerSpec::shared_memory_size_mb].
    pub fn set_shared_memory_size_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shared_memory_size_mb = v.into();
        self
    }

    /// Sets the value of [startup_probe][crate::model::ModelContainerSpec::startup_probe].
    pub fn set_startup_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.startup_probe = v.into();
        self
    }

    /// Sets the value of [health_probe][crate::model::ModelContainerSpec::health_probe].
    pub fn set_health_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_probe = v.into();
        self
    }

    /// Sets the value of [liveness_probe][crate::model::ModelContainerSpec::liveness_probe].
    pub fn set_liveness_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.liveness_probe = v.into();
        self
    }

    /// Sets the value of [command][crate::model::ModelContainerSpec::command].
    pub fn set_command<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.command = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::ModelContainerSpec::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::ModelContainerSpec::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ports][crate::model::ModelContainerSpec::ports].
    pub fn set_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Port>,
    {
        use std::iter::Iterator;
        self.ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grpc_ports][crate::model::ModelContainerSpec::grpc_ports].
    pub fn set_grpc_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Port>,
    {
        use std::iter::Iterator;
        self.grpc_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModelContainerSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelContainerSpec"
    }
}

/// Represents a network port in a container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Port {
    /// The number of the port to expose on the pod's IP address.
    /// Must be a valid port number, between 1 and 65535 inclusive.
    pub container_port: i32,
}

impl Port {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_port][crate::model::Port::container_port].
    pub fn set_container_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.container_port = v.into();
        self
    }
}

impl wkt::message::Message for Port {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Port"
    }
}

/// Detail description of the source information of the model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelSourceInfo {
    /// Type of the model source.
    pub source_type: crate::model::model_source_info::ModelSourceType,

    /// If this Model is copy of another Model. If true then
    /// [source_type][google.cloud.aiplatform.v1.ModelSourceInfo.source_type]
    /// pertains to the original.
    ///
    /// [google.cloud.aiplatform.v1.ModelSourceInfo.source_type]: crate::model::ModelSourceInfo::source_type
    pub copy: bool,
}

impl ModelSourceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::ModelSourceInfo::source_type].
    pub fn set_source_type<
        T: std::convert::Into<crate::model::model_source_info::ModelSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::ModelSourceInfo::copy].
    pub fn set_copy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.copy = v.into();
        self
    }
}

impl wkt::message::Message for ModelSourceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelSourceInfo"
    }
}

/// Defines additional types related to ModelSourceInfo
pub mod model_source_info {
    #[allow(unused_imports)]
    use super::*;

    /// Source of the model.
    /// Different from `objective` field, this `ModelSourceType` enum
    /// indicates the source from which the model was accessed or obtained,
    /// whereas the `objective` indicates the overall aim or function of this
    /// model.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ModelSourceType(std::borrow::Cow<'static, str>);

    impl ModelSourceType {
        /// Creates a new ModelSourceType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ModelSourceType](ModelSourceType)
    pub mod model_source_type {
        use super::ModelSourceType;

        /// Should not be used.
        pub const MODEL_SOURCE_TYPE_UNSPECIFIED: ModelSourceType =
            ModelSourceType::new("MODEL_SOURCE_TYPE_UNSPECIFIED");

        /// The Model is uploaded by automl training pipeline.
        pub const AUTOML: ModelSourceType = ModelSourceType::new("AUTOML");

        /// The Model is uploaded by user or custom training pipeline.
        pub const CUSTOM: ModelSourceType = ModelSourceType::new("CUSTOM");

        /// The Model is registered and sync'ed from BigQuery ML.
        pub const BQML: ModelSourceType = ModelSourceType::new("BQML");

        /// The Model is saved or tuned from Model Garden.
        pub const MODEL_GARDEN: ModelSourceType = ModelSourceType::new("MODEL_GARDEN");

        /// The Model is saved or tuned from Genie.
        pub const GENIE: ModelSourceType = ModelSourceType::new("GENIE");

        /// The Model is uploaded by text embedding finetuning pipeline.
        pub const CUSTOM_TEXT_EMBEDDING: ModelSourceType =
            ModelSourceType::new("CUSTOM_TEXT_EMBEDDING");

        /// The Model is saved or tuned from Marketplace.
        pub const MARKETPLACE: ModelSourceType = ModelSourceType::new("MARKETPLACE");
    }

    impl std::convert::From<std::string::String> for ModelSourceType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Probe {
    /// How often (in seconds) to perform the probe. Default to 10 seconds.
    /// Minimum value is 1. Must be less than timeout_seconds.
    ///
    /// Maps to Kubernetes probe argument 'periodSeconds'.
    pub period_seconds: i32,

    /// Number of seconds after which the probe times out. Defaults to 1 second.
    /// Minimum value is 1. Must be greater or equal to period_seconds.
    ///
    /// Maps to Kubernetes probe argument 'timeoutSeconds'.
    pub timeout_seconds: i32,

    /// Number of consecutive failures before the probe is considered failed.
    /// Defaults to 3. Minimum value is 1.
    ///
    /// Maps to Kubernetes probe argument 'failureThreshold'.
    pub failure_threshold: i32,

    /// Number of consecutive successes before the probe is considered successful.
    /// Defaults to 1. Minimum value is 1.
    ///
    /// Maps to Kubernetes probe argument 'successThreshold'.
    pub success_threshold: i32,

    /// Number of seconds to wait before starting the probe. Defaults to 0.
    /// Minimum value is 0.
    ///
    /// Maps to Kubernetes probe argument 'initialDelaySeconds'.
    pub initial_delay_seconds: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub probe_type: std::option::Option<crate::model::probe::ProbeType>,
}

impl Probe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [period_seconds][crate::model::Probe::period_seconds].
    pub fn set_period_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.period_seconds = v.into();
        self
    }

    /// Sets the value of [timeout_seconds][crate::model::Probe::timeout_seconds].
    pub fn set_timeout_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_seconds = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::Probe::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [success_threshold][crate::model::Probe::success_threshold].
    pub fn set_success_threshold<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.success_threshold = v.into();
        self
    }

    /// Sets the value of [initial_delay_seconds][crate::model::Probe::initial_delay_seconds].
    pub fn set_initial_delay_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_delay_seconds = v.into();
        self
    }

    /// Sets the value of `probe_type`.
    pub fn set_probe_type<
        T: std::convert::Into<std::option::Option<crate::model::probe::ProbeType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = v.into();
        self
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `Exec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::probe::ExecAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::Exec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `HttpGet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_http_get(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::probe::HttpGetAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::HttpGet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `Grpc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_grpc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::probe::GrpcAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::Grpc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `TcpSocket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tcp_socket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::probe::TcpSocketAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::TcpSocket(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `Exec`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_exec<T: std::convert::Into<std::boxed::Box<crate::model::probe::ExecAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = std::option::Option::Some(crate::model::probe::ProbeType::Exec(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `HttpGet`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_http_get<
        T: std::convert::Into<std::boxed::Box<crate::model::probe::HttpGetAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::HttpGet(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `Grpc`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_grpc<T: std::convert::Into<std::boxed::Box<crate::model::probe::GrpcAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = std::option::Option::Some(crate::model::probe::ProbeType::Grpc(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `TcpSocket`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_tcp_socket<
        T: std::convert::Into<std::boxed::Box<crate::model::probe::TcpSocketAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::TcpSocket(v.into()));
        self
    }
}

impl wkt::message::Message for Probe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Probe"
    }
}

/// Defines additional types related to Probe
pub mod probe {
    #[allow(unused_imports)]
    use super::*;

    /// ExecAction specifies a command to execute.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExecAction {
        /// Command is the command line to execute inside the container, the working
        /// directory for the command is root ('/') in the container's filesystem.
        /// The command is simply exec'd, it is not run inside a shell, so
        /// traditional shell instructions ('|', etc) won't work. To use a shell, you
        /// need to explicitly call out to that shell. Exit status of 0 is treated as
        /// live/healthy and non-zero is unhealthy.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub command: std::vec::Vec<std::string::String>,
    }

    impl ExecAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [command][crate::model::probe::ExecAction::command].
        pub fn set_command<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.command = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ExecAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.ExecAction"
        }
    }

    /// HttpGetAction describes an action based on HTTP Get requests.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpGetAction {
        /// Path to access on the HTTP server.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        /// Number of the port to access on the container.
        /// Number must be in the range 1 to 65535.
        pub port: i32,

        /// Host name to connect to, defaults to the model serving container's IP.
        /// You probably want to set "Host" in httpHeaders instead.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub host: std::string::String,

        /// Scheme to use for connecting to the host.
        /// Defaults to HTTP. Acceptable values are "HTTP" or "HTTPS".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub scheme: std::string::String,

        /// Custom headers to set in the request. HTTP allows repeated headers.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub http_headers: std::vec::Vec<crate::model::probe::HttpHeader>,
    }

    impl HttpGetAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::probe::HttpGetAction::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [port][crate::model::probe::HttpGetAction::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [host][crate::model::probe::HttpGetAction::host].
        pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.host = v.into();
            self
        }

        /// Sets the value of [scheme][crate::model::probe::HttpGetAction::scheme].
        pub fn set_scheme<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scheme = v.into();
            self
        }

        /// Sets the value of [http_headers][crate::model::probe::HttpGetAction::http_headers].
        pub fn set_http_headers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::probe::HttpHeader>,
        {
            use std::iter::Iterator;
            self.http_headers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for HttpGetAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.HttpGetAction"
        }
    }

    /// GrpcAction checks the health of a container using a gRPC service.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GrpcAction {
        /// Port number of the gRPC service. Number must be in the range 1 to 65535.
        pub port: i32,

        /// Service is the name of the service to place in the gRPC
        /// HealthCheckRequest (see
        /// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>).
        ///
        /// If this is not specified, the default behavior is defined by gRPC.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service: std::string::String,
    }

    impl GrpcAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [port][crate::model::probe::GrpcAction::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [service][crate::model::probe::GrpcAction::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }
    }

    impl wkt::message::Message for GrpcAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.GrpcAction"
        }
    }

    /// TcpSocketAction probes the health of a container by opening a TCP socket
    /// connection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TcpSocketAction {
        /// Number of the port to access on the container.
        /// Number must be in the range 1 to 65535.
        pub port: i32,

        /// Optional: Host name to connect to, defaults to the model serving
        /// container's IP.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub host: std::string::String,
    }

    impl TcpSocketAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [port][crate::model::probe::TcpSocketAction::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [host][crate::model::probe::TcpSocketAction::host].
        pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.host = v.into();
            self
        }
    }

    impl wkt::message::Message for TcpSocketAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.TcpSocketAction"
        }
    }

    /// HttpHeader describes a custom header to be used in HTTP probes
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HttpHeader {
        /// The header field name.
        /// This will be canonicalized upon output, so case-variant names will be
        /// understood as the same header.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The header field value
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,
    }

    impl HttpHeader {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::probe::HttpHeader::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::probe::HttpHeader::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for HttpHeader {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.HttpHeader"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ProbeType {
        /// ExecAction probes the health of a container by executing a command.
        Exec(std::boxed::Box<crate::model::probe::ExecAction>),
        /// HttpGetAction probes the health of a container by sending an HTTP GET
        /// request.
        HttpGet(std::boxed::Box<crate::model::probe::HttpGetAction>),
        /// GrpcAction probes the health of a container by sending a gRPC request.
        Grpc(std::boxed::Box<crate::model::probe::GrpcAction>),
        /// TcpSocketAction probes the health of a container by opening a TCP socket
        /// connection.
        TcpSocket(std::boxed::Box<crate::model::probe::TcpSocketAction>),
    }
}

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint. It will analyze the logged training & prediction data to detect any
/// abnormal behaviors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringJob {
    /// Output only. Resource name of a ModelDeploymentMonitoringJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the ModelDeploymentMonitoringJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    /// Display name of a ModelDeploymentMonitoringJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Endpoint resource name.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Output only. The detailed state of the monitoring job.
    /// When the job is still creating, the state will be 'PENDING'.
    /// Once the job is successfully created, the state will be 'RUNNING'.
    /// Pause the job, the state will be 'PAUSED'.
    /// Resume the job, the state will return to 'RUNNING'.
    pub state: crate::model::JobState,

    /// Output only. Schedule state when the monitoring job is in Running state.
    pub schedule_state: crate::model::model_deployment_monitoring_job::MonitoringScheduleState,

    /// Output only. Latest triggered monitoring pipeline metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_monitoring_pipeline_metadata: std::option::Option<
        crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata,
    >,

    /// Required. The config for monitoring objectives. This is a per DeployedModel
    /// config. Each DeployedModel needs to be configured separately.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_deployment_monitoring_objective_configs:
        std::vec::Vec<crate::model::ModelDeploymentMonitoringObjectiveConfig>,

    /// Required. Schedule config for running the monitoring job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_deployment_monitoring_schedule_config:
        std::option::Option<crate::model::ModelDeploymentMonitoringScheduleConfig>,

    /// Required. Sample Strategy for logging.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_sampling_strategy: std::option::Option<crate::model::SamplingStrategy>,

    /// Alert config for model monitoring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_monitoring_alert_config:
        std::option::Option<crate::model::ModelMonitoringAlertConfig>,

    /// YAML schema file uri describing the format of a single instance,
    /// which are given to format this Endpoint's prediction (and explanation).
    /// If not set, we will generate predict schema from collected predict
    /// requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predict_instance_schema_uri: std::string::String,

    /// Sample Predict instance, same format as
    /// [PredictRequest.instances][google.cloud.aiplatform.v1.PredictRequest.instances],
    /// this can be set as a replacement of
    /// [ModelDeploymentMonitoringJob.predict_instance_schema_uri][google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri].
    /// If not set, we will generate predict schema from collected predict
    /// requests.
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri]: crate::model::ModelDeploymentMonitoringJob::predict_instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictRequest.instances]: crate::model::PredictRequest::instances
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_predict_instance: std::option::Option<wkt::Value>,

    /// YAML schema file uri describing the format of a single instance that you
    /// want Tensorflow Data Validation (TFDV) to analyze.
    ///
    /// If this field is empty, all the feature data types are inferred from
    /// [predict_instance_schema_uri][google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri],
    /// meaning that TFDV will use the data in the exact format(data type) as
    /// prediction request/response.
    /// If there are any data type differences between predict instance and TFDV
    /// instance, this field can be used to override the schema.
    /// For models trained with Vertex AI, this field must be set as all the
    /// fields in predict instance formatted as string.
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.predict_instance_schema_uri]: crate::model::ModelDeploymentMonitoringJob::predict_instance_schema_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub analysis_instance_schema_uri: std::string::String,

    /// Output only. The created bigquery tables for the job under customer
    /// project. Customer could do their own query & analysis. There could be 4 log
    /// tables in maximum:
    ///
    /// . Training data logging predict request/response
    /// . Serving data logging predict request/response
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bigquery_tables: std::vec::Vec<crate::model::ModelDeploymentMonitoringBigQueryTable>,

    /// The TTL of BigQuery tables in user projects which stores logs.
    /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
    /// day). e.g. { second: 3600} indicates ttl = 1 day.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub log_ttl: std::option::Option<wkt::Duration>,

    /// The labels with user-defined metadata to organize your
    /// ModelDeploymentMonitoringJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this ModelDeploymentMonitoringJob was updated
    /// most recently.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this monitoring pipeline will be scheduled to
    /// run for the next round.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_schedule_time: std::option::Option<wkt::Timestamp>,

    /// Stats anomalies base folder path.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stats_anomalies_base_directory: std::option::Option<crate::model::GcsDestination>,

    /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If
    /// set, this ModelDeploymentMonitoringJob and all sub-resources of this
    /// ModelDeploymentMonitoringJob will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// If true, the scheduled monitoring pipeline logs are sent to
    /// Google Cloud Logging, including pipeline status and anomalies detected.
    /// Please note the logs incur cost, which are subject to [Cloud Logging
    /// pricing](https://cloud.google.com/logging#pricing).
    pub enable_monitoring_pipeline_logs: bool,

    /// Output only. Only populated when the job's state is `JOB_STATE_FAILED` or
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl ModelDeploymentMonitoringJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModelDeploymentMonitoringJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ModelDeploymentMonitoringJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::ModelDeploymentMonitoringJob::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ModelDeploymentMonitoringJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schedule_state][crate::model::ModelDeploymentMonitoringJob::schedule_state].
    pub fn set_schedule_state<
        T: std::convert::Into<crate::model::model_deployment_monitoring_job::MonitoringScheduleState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_state = v.into();
        self
    }

    /// Sets the value of [latest_monitoring_pipeline_metadata][crate::model::ModelDeploymentMonitoringJob::latest_monitoring_pipeline_metadata].
    pub fn set_latest_monitoring_pipeline_metadata<
        T: std::convert::Into<
            std::option::Option<
                crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_monitoring_pipeline_metadata = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_schedule_config][crate::model::ModelDeploymentMonitoringJob::model_deployment_monitoring_schedule_config].
    pub fn set_model_deployment_monitoring_schedule_config<
        T: std::convert::Into<
            std::option::Option<crate::model::ModelDeploymentMonitoringScheduleConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_deployment_monitoring_schedule_config = v.into();
        self
    }

    /// Sets the value of [logging_sampling_strategy][crate::model::ModelDeploymentMonitoringJob::logging_sampling_strategy].
    pub fn set_logging_sampling_strategy<
        T: std::convert::Into<std::option::Option<crate::model::SamplingStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_sampling_strategy = v.into();
        self
    }

    /// Sets the value of [model_monitoring_alert_config][crate::model::ModelDeploymentMonitoringJob::model_monitoring_alert_config].
    pub fn set_model_monitoring_alert_config<
        T: std::convert::Into<std::option::Option<crate::model::ModelMonitoringAlertConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_monitoring_alert_config = v.into();
        self
    }

    /// Sets the value of [predict_instance_schema_uri][crate::model::ModelDeploymentMonitoringJob::predict_instance_schema_uri].
    pub fn set_predict_instance_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predict_instance_schema_uri = v.into();
        self
    }

    /// Sets the value of [sample_predict_instance][crate::model::ModelDeploymentMonitoringJob::sample_predict_instance].
    pub fn set_sample_predict_instance<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sample_predict_instance = v.into();
        self
    }

    /// Sets the value of [analysis_instance_schema_uri][crate::model::ModelDeploymentMonitoringJob::analysis_instance_schema_uri].
    pub fn set_analysis_instance_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_instance_schema_uri = v.into();
        self
    }

    /// Sets the value of [log_ttl][crate::model::ModelDeploymentMonitoringJob::log_ttl].
    pub fn set_log_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.log_ttl = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ModelDeploymentMonitoringJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ModelDeploymentMonitoringJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [next_schedule_time][crate::model::ModelDeploymentMonitoringJob::next_schedule_time].
    pub fn set_next_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_schedule_time = v.into();
        self
    }

    /// Sets the value of [stats_anomalies_base_directory][crate::model::ModelDeploymentMonitoringJob::stats_anomalies_base_directory].
    pub fn set_stats_anomalies_base_directory<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stats_anomalies_base_directory = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::ModelDeploymentMonitoringJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [enable_monitoring_pipeline_logs][crate::model::ModelDeploymentMonitoringJob::enable_monitoring_pipeline_logs].
    pub fn set_enable_monitoring_pipeline_logs<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_monitoring_pipeline_logs = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ModelDeploymentMonitoringJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ModelDeploymentMonitoringJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ModelDeploymentMonitoringJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [model_deployment_monitoring_objective_configs][crate::model::ModelDeploymentMonitoringJob::model_deployment_monitoring_objective_configs].
    pub fn set_model_deployment_monitoring_objective_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelDeploymentMonitoringObjectiveConfig>,
    {
        use std::iter::Iterator;
        self.model_deployment_monitoring_objective_configs =
            v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bigquery_tables][crate::model::ModelDeploymentMonitoringJob::bigquery_tables].
    pub fn set_bigquery_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelDeploymentMonitoringBigQueryTable>,
    {
        use std::iter::Iterator;
        self.bigquery_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::ModelDeploymentMonitoringJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ModelDeploymentMonitoringJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob"
    }
}

/// Defines additional types related to ModelDeploymentMonitoringJob
pub mod model_deployment_monitoring_job {
    #[allow(unused_imports)]
    use super::*;

    /// All metadata of most recent monitoring pipelines.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LatestMonitoringPipelineMetadata {
        /// The time that most recent monitoring pipelines that is related to this
        /// run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub run_time: std::option::Option<wkt::Timestamp>,

        /// The status of the most recent monitoring pipeline.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,
    }

    impl LatestMonitoringPipelineMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [run_time][crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata::run_time].
        pub fn set_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.run_time = v.into();
            self
        }

        /// Sets the value of [status][crate::model::model_deployment_monitoring_job::LatestMonitoringPipelineMetadata::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for LatestMonitoringPipelineMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.LatestMonitoringPipelineMetadata"
        }
    }

    /// The state to Specify the monitoring pipeline.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MonitoringScheduleState(std::borrow::Cow<'static, str>);

    impl MonitoringScheduleState {
        /// Creates a new MonitoringScheduleState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [MonitoringScheduleState](MonitoringScheduleState)
    pub mod monitoring_schedule_state {
        use super::MonitoringScheduleState;

        /// Unspecified state.
        pub const MONITORING_SCHEDULE_STATE_UNSPECIFIED: MonitoringScheduleState =
            MonitoringScheduleState::new("MONITORING_SCHEDULE_STATE_UNSPECIFIED");

        /// The pipeline is picked up and wait to run.
        pub const PENDING: MonitoringScheduleState = MonitoringScheduleState::new("PENDING");

        /// The pipeline is offline and will be scheduled for next run.
        pub const OFFLINE: MonitoringScheduleState = MonitoringScheduleState::new("OFFLINE");

        /// The pipeline is running.
        pub const RUNNING: MonitoringScheduleState = MonitoringScheduleState::new("RUNNING");
    }

    impl std::convert::From<std::string::String> for MonitoringScheduleState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name
/// as well as some information of the logs stored in this table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringBigQueryTable {
    /// The source of log.
    pub log_source: crate::model::model_deployment_monitoring_big_query_table::LogSource,

    /// The type of log.
    pub log_type: crate::model::model_deployment_monitoring_big_query_table::LogType,

    /// The created BigQuery table to store logs. Customer could do their own query
    /// & analysis. Format:
    /// `bq://<project_id>.model_deployment_monitoring_<endpoint_id>.<tolower(log_source)>_<tolower(log_type)>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bigquery_table_path: std::string::String,

    /// Output only. The schema version of the request/response logging BigQuery
    /// table. Default to v1 if unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_response_logging_schema_version: std::string::String,
}

impl ModelDeploymentMonitoringBigQueryTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_source][crate::model::ModelDeploymentMonitoringBigQueryTable::log_source].
    pub fn set_log_source<
        T: std::convert::Into<crate::model::model_deployment_monitoring_big_query_table::LogSource>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_source = v.into();
        self
    }

    /// Sets the value of [log_type][crate::model::ModelDeploymentMonitoringBigQueryTable::log_type].
    pub fn set_log_type<
        T: std::convert::Into<crate::model::model_deployment_monitoring_big_query_table::LogType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_type = v.into();
        self
    }

    /// Sets the value of [bigquery_table_path][crate::model::ModelDeploymentMonitoringBigQueryTable::bigquery_table_path].
    pub fn set_bigquery_table_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_table_path = v.into();
        self
    }

    /// Sets the value of [request_response_logging_schema_version][crate::model::ModelDeploymentMonitoringBigQueryTable::request_response_logging_schema_version].
    pub fn set_request_response_logging_schema_version<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_response_logging_schema_version = v.into();
        self
    }
}

impl wkt::message::Message for ModelDeploymentMonitoringBigQueryTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringBigQueryTable"
    }
}

/// Defines additional types related to ModelDeploymentMonitoringBigQueryTable
pub mod model_deployment_monitoring_big_query_table {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates where does the log come from.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LogSource(std::borrow::Cow<'static, str>);

    impl LogSource {
        /// Creates a new LogSource instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [LogSource](LogSource)
    pub mod log_source {
        use super::LogSource;

        /// Unspecified source.
        pub const LOG_SOURCE_UNSPECIFIED: LogSource = LogSource::new("LOG_SOURCE_UNSPECIFIED");

        /// Logs coming from Training dataset.
        pub const TRAINING: LogSource = LogSource::new("TRAINING");

        /// Logs coming from Serving traffic.
        pub const SERVING: LogSource = LogSource::new("SERVING");
    }

    impl std::convert::From<std::string::String> for LogSource {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Indicates what type of traffic does the log belong to.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LogType(std::borrow::Cow<'static, str>);

    impl LogType {
        /// Creates a new LogType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [LogType](LogType)
    pub mod log_type {
        use super::LogType;

        /// Unspecified type.
        pub const LOG_TYPE_UNSPECIFIED: LogType = LogType::new("LOG_TYPE_UNSPECIFIED");

        /// Predict logs.
        pub const PREDICT: LogType = LogType::new("PREDICT");

        /// Explain logs.
        pub const EXPLAIN: LogType = LogType::new("EXPLAIN");
    }

    impl std::convert::From<std::string::String> for LogType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringObjectiveConfig {
    /// The DeployedModel ID of the objective config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// The objective config of for the modelmonitoring job of this deployed model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub objective_config: std::option::Option<crate::model::ModelMonitoringObjectiveConfig>,
}

impl ModelDeploymentMonitoringObjectiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model_id][crate::model::ModelDeploymentMonitoringObjectiveConfig::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [objective_config][crate::model::ModelDeploymentMonitoringObjectiveConfig::objective_config].
    pub fn set_objective_config<
        T: std::convert::Into<std::option::Option<crate::model::ModelMonitoringObjectiveConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.objective_config = v.into();
        self
    }
}

impl wkt::message::Message for ModelDeploymentMonitoringObjectiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveConfig"
    }
}

/// The config for scheduling monitoring job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelDeploymentMonitoringScheduleConfig {
    /// Required. The model monitoring job scheduling interval. It will be rounded
    /// up to next full hour. This defines how often the monitoring jobs are
    /// triggered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitor_interval: std::option::Option<wkt::Duration>,

    /// The time window of the prediction data being included in each prediction
    /// dataset. This window specifies how long the data should be collected from
    /// historical model results for each run. If not set,
    /// [ModelDeploymentMonitoringScheduleConfig.monitor_interval][google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig.monitor_interval]
    /// will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and
    /// the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
    /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
    /// monitoring statistics.
    ///
    /// [google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig.monitor_interval]: crate::model::ModelDeploymentMonitoringScheduleConfig::monitor_interval
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitor_window: std::option::Option<wkt::Duration>,
}

impl ModelDeploymentMonitoringScheduleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monitor_interval][crate::model::ModelDeploymentMonitoringScheduleConfig::monitor_interval].
    pub fn set_monitor_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitor_interval = v.into();
        self
    }

    /// Sets the value of [monitor_window][crate::model::ModelDeploymentMonitoringScheduleConfig::monitor_window].
    pub fn set_monitor_window<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitor_window = v.into();
        self
    }
}

impl wkt::message::Message for ModelDeploymentMonitoringScheduleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig"
    }
}

/// Statistics and anomalies generated by Model Monitoring.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMonitoringStatsAnomalies {
    /// Model Monitoring Objective those stats and anomalies belonging to.
    pub objective: crate::model::ModelDeploymentMonitoringObjectiveType,

    /// Deployed Model ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// Number of anomalies within all stats.
    pub anomaly_count: i32,

    /// A list of historical Stats and Anomalies generated for all Features.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_stats: std::vec::Vec<
        crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies,
    >,
}

impl ModelMonitoringStatsAnomalies {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objective][crate::model::ModelMonitoringStatsAnomalies::objective].
    pub fn set_objective<
        T: std::convert::Into<crate::model::ModelDeploymentMonitoringObjectiveType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.objective = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::ModelMonitoringStatsAnomalies::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [anomaly_count][crate::model::ModelMonitoringStatsAnomalies::anomaly_count].
    pub fn set_anomaly_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.anomaly_count = v.into();
        self
    }

    /// Sets the value of [feature_stats][crate::model::ModelMonitoringStatsAnomalies::feature_stats].
    pub fn set_feature_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
            crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies,
        >,
    {
        use std::iter::Iterator;
        self.feature_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModelMonitoringStatsAnomalies {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies"
    }
}

/// Defines additional types related to ModelMonitoringStatsAnomalies
pub mod model_monitoring_stats_anomalies {
    #[allow(unused_imports)]
    use super::*;

    /// Historical Stats (and Anomalies) for a specific Feature.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FeatureHistoricStatsAnomalies {
        /// Display Name of the Feature.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub feature_display_name: std::string::String,

        /// Threshold for anomaly detection.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threshold: std::option::Option<crate::model::ThresholdConfig>,

        /// Stats calculated for the Training Dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub training_stats: std::option::Option<crate::model::FeatureStatsAnomaly>,

        /// A list of historical stats generated by different time window's
        /// Prediction Dataset.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub prediction_stats: std::vec::Vec<crate::model::FeatureStatsAnomaly>,
    }

    impl FeatureHistoricStatsAnomalies {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [feature_display_name][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::feature_display_name].
        pub fn set_feature_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.feature_display_name = v.into();
            self
        }

        /// Sets the value of [threshold][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::threshold].
        pub fn set_threshold<
            T: std::convert::Into<std::option::Option<crate::model::ThresholdConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.threshold = v.into();
            self
        }

        /// Sets the value of [training_stats][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::training_stats].
        pub fn set_training_stats<
            T: std::convert::Into<std::option::Option<crate::model::FeatureStatsAnomaly>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.training_stats = v.into();
            self
        }

        /// Sets the value of [prediction_stats][crate::model::model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies::prediction_stats].
        pub fn set_prediction_stats<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::FeatureStatsAnomaly>,
        {
            use std::iter::Iterator;
            self.prediction_stats = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FeatureHistoricStatsAnomalies {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies"
        }
    }
}

/// A collection of metrics calculated by comparing Model's predictions on all of
/// the test data against annotations from the test data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelEvaluation {
    /// Output only. The resource name of the ModelEvaluation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the ModelEvaluation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Points to a YAML file stored on Google Cloud Storage describing the
    /// [metrics][google.cloud.aiplatform.v1.ModelEvaluation.metrics] of this
    /// ModelEvaluation. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluation.metrics]: crate::model::ModelEvaluation::metrics
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metrics_schema_uri: std::string::String,

    /// Evaluation metrics of the Model. The schema of the metrics is stored in
    /// [metrics_schema_uri][google.cloud.aiplatform.v1.ModelEvaluation.metrics_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluation.metrics_schema_uri]: crate::model::ModelEvaluation::metrics_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metrics: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this ModelEvaluation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// All possible
    /// [dimensions][google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.dimension]
    /// of ModelEvaluationSlices. The dimensions can be used as the filter of the
    /// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]
    /// request, in the form of `slice.dimension = <dimension>`.
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.dimension]: crate::model::model_evaluation_slice::Slice::dimension
    /// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub slice_dimensions: std::vec::Vec<std::string::String>,

    /// Points to a YAML file stored on Google Cloud Storage describing
    /// [EvaluatedDataItemView.data_item_payload][] and
    /// [EvaluatedAnnotation.data_item_payload][google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// This field is not populated if there are neither EvaluatedDataItemViews nor
    /// EvaluatedAnnotations under this ModelEvaluation.
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.data_item_payload]: crate::model::EvaluatedAnnotation::data_item_payload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_item_schema_uri: std::string::String,

    /// Points to a YAML file stored on Google Cloud Storage describing
    /// [EvaluatedDataItemView.predictions][],
    /// [EvaluatedDataItemView.ground_truths][],
    /// [EvaluatedAnnotation.predictions][google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions],
    /// and
    /// [EvaluatedAnnotation.ground_truths][google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// This field is not populated if there are neither EvaluatedDataItemViews nor
    /// EvaluatedAnnotations under this ModelEvaluation.
    ///
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.ground_truths]: crate::model::EvaluatedAnnotation::ground_truths
    /// [google.cloud.aiplatform.v1.EvaluatedAnnotation.predictions]: crate::model::EvaluatedAnnotation::predictions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_schema_uri: std::string::String,

    /// Aggregated explanation metrics for the Model's prediction output over the
    /// data this ModelEvaluation uses. This field is populated only if the Model
    /// is evaluated with explanations, and only for AutoML tabular Models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_explanation: std::option::Option<crate::model::ModelExplanation>,

    /// Describes the values of
    /// [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] that are used
    /// for explaining the predicted values on the evaluated data.
    ///
    /// [google.cloud.aiplatform.v1.ExplanationSpec]: crate::model::ExplanationSpec
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explanation_specs:
        std::vec::Vec<crate::model::model_evaluation::ModelEvaluationExplanationSpec>,

    /// The metadata of the ModelEvaluation.
    /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains a
    /// structured value with keys of "pipeline_job_id", "evaluation_dataset_type",
    /// "evaluation_dataset_path", "row_based_metrics_path".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,
}

impl ModelEvaluation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModelEvaluation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ModelEvaluation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [metrics_schema_uri][crate::model::ModelEvaluation::metrics_schema_uri].
    pub fn set_metrics_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics_schema_uri = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::ModelEvaluation::metrics].
    pub fn set_metrics<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ModelEvaluation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [data_item_schema_uri][crate::model::ModelEvaluation::data_item_schema_uri].
    pub fn set_data_item_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_item_schema_uri = v.into();
        self
    }

    /// Sets the value of [annotation_schema_uri][crate::model::ModelEvaluation::annotation_schema_uri].
    pub fn set_annotation_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_schema_uri = v.into();
        self
    }

    /// Sets the value of [model_explanation][crate::model::ModelEvaluation::model_explanation].
    pub fn set_model_explanation<
        T: std::convert::Into<std::option::Option<crate::model::ModelExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_explanation = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ModelEvaluation::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [slice_dimensions][crate::model::ModelEvaluation::slice_dimensions].
    pub fn set_slice_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.slice_dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [explanation_specs][crate::model::ModelEvaluation::explanation_specs].
    pub fn set_explanation_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model_evaluation::ModelEvaluationExplanationSpec>,
    {
        use std::iter::Iterator;
        self.explanation_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModelEvaluation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluation"
    }
}

/// Defines additional types related to ModelEvaluation
pub mod model_evaluation {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ModelEvaluationExplanationSpec {
        /// Explanation type.
        ///
        /// For AutoML Image Classification models, possible values are:
        ///
        /// * `image-integrated-gradients`
        /// * `image-xrai`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub explanation_type: std::string::String,

        /// Explanation spec details.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub explanation_spec: std::option::Option<crate::model::ExplanationSpec>,
    }

    impl ModelEvaluationExplanationSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [explanation_type][crate::model::model_evaluation::ModelEvaluationExplanationSpec::explanation_type].
        pub fn set_explanation_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.explanation_type = v.into();
            self
        }

        /// Sets the value of [explanation_spec][crate::model::model_evaluation::ModelEvaluationExplanationSpec::explanation_spec].
        pub fn set_explanation_spec<
            T: std::convert::Into<std::option::Option<crate::model::ExplanationSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.explanation_spec = v.into();
            self
        }
    }

    impl wkt::message::Message for ModelEvaluationExplanationSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluation.ModelEvaluationExplanationSpec"
        }
    }
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelEvaluationSlice {
    /// Output only. The resource name of the ModelEvaluationSlice.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The slice of the test data that is used to evaluate the Model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub slice: std::option::Option<crate::model::model_evaluation_slice::Slice>,

    /// Output only. Points to a YAML file stored on Google Cloud Storage
    /// describing the
    /// [metrics][google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics] of this
    /// ModelEvaluationSlice. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics]: crate::model::ModelEvaluationSlice::metrics
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metrics_schema_uri: std::string::String,

    /// Output only. Sliced evaluation metrics of the Model. The schema of the
    /// metrics is stored in
    /// [metrics_schema_uri][google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics_schema_uri]
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.metrics_schema_uri]: crate::model::ModelEvaluationSlice::metrics_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metrics: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this ModelEvaluationSlice was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Aggregated explanation metrics for the Model's prediction
    /// output over the data this ModelEvaluation uses. This field is populated
    /// only if the Model is evaluated with explanations, and only for tabular
    /// Models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_explanation: std::option::Option<crate::model::ModelExplanation>,
}

impl ModelEvaluationSlice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModelEvaluationSlice::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slice][crate::model::ModelEvaluationSlice::slice].
    pub fn set_slice<
        T: std::convert::Into<std::option::Option<crate::model::model_evaluation_slice::Slice>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.slice = v.into();
        self
    }

    /// Sets the value of [metrics_schema_uri][crate::model::ModelEvaluationSlice::metrics_schema_uri].
    pub fn set_metrics_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics_schema_uri = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::ModelEvaluationSlice::metrics].
    pub fn set_metrics<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ModelEvaluationSlice::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [model_explanation][crate::model::ModelEvaluationSlice::model_explanation].
    pub fn set_model_explanation<
        T: std::convert::Into<std::option::Option<crate::model::ModelExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_explanation = v.into();
        self
    }
}

impl wkt::message::Message for ModelEvaluationSlice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice"
    }
}

/// Defines additional types related to ModelEvaluationSlice
pub mod model_evaluation_slice {
    #[allow(unused_imports)]
    use super::*;

    /// Definition of a slice.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Slice {
        /// Output only. The dimension of the slice.
        /// Well-known dimensions are:
        ///
        /// * `annotationSpec`: This slice is on the test data that has either
        ///   ground truth or prediction with
        ///   [AnnotationSpec.display_name][google.cloud.aiplatform.v1.AnnotationSpec.display_name]
        ///   equals to
        ///   [value][google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.value].
        /// * `slice`: This slice is a user customized slice defined by its
        ///   SliceSpec.
        ///
        /// [google.cloud.aiplatform.v1.AnnotationSpec.display_name]: crate::model::AnnotationSpec::display_name
        /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.value]: crate::model::model_evaluation_slice::Slice::value
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dimension: std::string::String,

        /// Output only. The value of the dimension in this slice.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        /// Output only. Specification for how the data was sliced.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub slice_spec: std::option::Option<crate::model::model_evaluation_slice::slice::SliceSpec>,
    }

    impl Slice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dimension][crate::model::model_evaluation_slice::Slice::dimension].
        pub fn set_dimension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dimension = v.into();
            self
        }

        /// Sets the value of [value][crate::model::model_evaluation_slice::Slice::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [slice_spec][crate::model::model_evaluation_slice::Slice::slice_spec].
        pub fn set_slice_spec<
            T: std::convert::Into<
                std::option::Option<crate::model::model_evaluation_slice::slice::SliceSpec>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.slice_spec = v.into();
            self
        }
    }

    impl wkt::message::Message for Slice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice"
        }
    }

    /// Defines additional types related to Slice
    pub mod slice {
        #[allow(unused_imports)]
        use super::*;

        /// Specification for how the data should be sliced.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SliceSpec {
            /// Mapping configuration for this SliceSpec.
            /// The key is the name of the feature.
            /// By default, the key will be prefixed by "instance" as a dictionary
            /// prefix for Vertex Batch Predictions output format.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub configs: std::collections::HashMap<
                std::string::String,
                crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig,
            >,
        }

        impl SliceSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [configs][crate::model::model_evaluation_slice::slice::SliceSpec::configs].
            pub fn set_configs<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<
                    crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig,
                >,
            {
                use std::iter::Iterator;
                self.configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for SliceSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec"
            }
        }

        /// Defines additional types related to SliceSpec
        pub mod slice_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Specification message containing the config for this SliceSpec.
            /// When `kind` is selected as `value` and/or `range`, only a single slice
            /// will be computed.
            /// When `all_values` is present, a separate slice will be computed for
            /// each possible label/value for the corresponding key in `config`.
            /// Examples, with feature zip_code with values 12345, 23334, 88888 and
            /// feature country with values "US", "Canada", "Mexico" in the dataset:
            ///
            /// Example 1:
            ///
            /// ```norust
            /// {
            ///   "zip_code": { "value": { "float_value": 12345.0 } }
            /// }
            /// ```
            ///
            /// A single slice for any data with zip_code 12345 in the dataset.
            ///
            /// Example 2:
            ///
            /// ```norust
            /// {
            ///   "zip_code": { "range": { "low": 12345, "high": 20000 } }
            /// }
            /// ```
            ///
            /// A single slice containing data where the zip_codes between 12345 and
            /// 20000 For this example, data with the zip_code of 12345 will be in this
            /// slice.
            ///
            /// Example 3:
            ///
            /// ```norust
            /// {
            ///   "zip_code": { "range": { "low": 10000, "high": 20000 } },
            ///   "country": { "value": { "string_value": "US" } }
            /// }
            /// ```
            ///
            /// A single slice containing data where the zip_codes between 10000 and
            /// 20000 has the country "US". For this example, data with the zip_code of
            /// 12345 and country "US" will be in this slice.
            ///
            /// Example 4:
            ///
            /// ```norust
            /// { "country": {"all_values": { "value": true } } }
            /// ```
            ///
            /// Three slices are computed, one for each unique country in the dataset.
            ///
            /// Example 5:
            ///
            /// ```norust
            /// {
            ///   "country": { "all_values": { "value": true } },
            ///   "zip_code": { "value": { "float_value": 12345.0 } }
            /// }
            /// ```
            ///
            /// Three slices are computed, one for each unique country in the dataset
            /// where the zip_code is also 12345. For this example, data with zip_code
            /// 12345 and country "US" will be in one slice, zip_code 12345 and country
            /// "Canada" in another slice, and zip_code 12345 and country "Mexico" in
            /// another slice, totaling 3 slices.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct SliceConfig {
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub kind: std::option::Option<
                    crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind,
                >,
            }

            impl SliceConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of `kind`.
                pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind>>>(mut self, v: T) -> Self
                {
                    self.kind = v.into();
                    self
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// if it holds a `Value`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_value(
                    &self,
                ) -> std::option::Option<
                    &std::boxed::Box<
                        crate::model::model_evaluation_slice::slice::slice_spec::Value,
                    >,
                > {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Value(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// if it holds a `Range`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_range(
                    &self,
                ) -> std::option::Option<
                    &std::boxed::Box<
                        crate::model::model_evaluation_slice::slice::slice_spec::Range,
                    >,
                > {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Range(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// if it holds a `AllValues`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_all_values(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<wkt::BoolValue>> {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::AllValues(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// to hold a `Value`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_value<
                    T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::model_evaluation_slice::slice::slice_spec::Value,
                        >,
                    >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Value(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// to hold a `Range`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_range<
                    T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::model_evaluation_slice::slice::slice_spec::Range,
                        >,
                    >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::Range(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::SliceConfig::kind]
                /// to hold a `AllValues`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_all_values<T: std::convert::Into<std::boxed::Box<wkt::BoolValue>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::slice_config::Kind::AllValues(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for SliceConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.SliceConfig"
                }
            }

            /// Defines additional types related to SliceConfig
            pub mod slice_config {
                #[allow(unused_imports)]
                use super::*;

                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Kind {
                    /// A unique specific value for a given feature.
                    /// Example: `{ "value": { "string_value": "12345" } }`
                    Value(
                        std::boxed::Box<
                            crate::model::model_evaluation_slice::slice::slice_spec::Value,
                        >,
                    ),
                    /// A range of values for a numerical feature.
                    /// Example: `{"range":{"low":10000.0,"high":50000.0}}`
                    /// will capture 12345 and 23334 in the slice.
                    Range(
                        std::boxed::Box<
                            crate::model::model_evaluation_slice::slice::slice_spec::Range,
                        >,
                    ),
                    /// If all_values is set to true, then all possible labels of the keyed
                    /// feature will have another slice computed.
                    /// Example: `{"all_values":{"value":true}}`
                    AllValues(std::boxed::Box<wkt::BoolValue>),
                }
            }

            /// A range of values for slice(s).
            /// `low` is inclusive, `high` is exclusive.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Range {
                /// Inclusive low value for the range.
                pub low: f32,

                /// Exclusive high value for the range.
                pub high: f32,
            }

            impl Range {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [low][crate::model::model_evaluation_slice::slice::slice_spec::Range::low].
                pub fn set_low<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.low = v.into();
                    self
                }

                /// Sets the value of [high][crate::model::model_evaluation_slice::slice::slice_spec::Range::high].
                pub fn set_high<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.high = v.into();
                    self
                }
            }

            impl wkt::message::Message for Range {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Range"
                }
            }

            /// Single value that supports strings and floats.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Value {
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub kind: std::option::Option<
                    crate::model::model_evaluation_slice::slice::slice_spec::value::Kind,
                >,
            }

            impl Value {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of `kind`.
                pub fn set_kind<
                    T: std::convert::Into<
                        std::option::Option<
                            crate::model::model_evaluation_slice::slice::slice_spec::value::Kind,
                        >,
                    >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = v.into();
                    self
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// if it holds a `StringValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::StringValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// if it holds a `FloatValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_float_value(&self) -> std::option::Option<&f32> {
                    #[allow(unreachable_patterns)]
                    self.kind.as_ref().and_then(|v| match v {
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::FloatValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// to hold a `StringValue`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_string_value<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::StringValue(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [kind][crate::model::model_evaluation_slice::slice::slice_spec::Value::kind]
                /// to hold a `FloatValue`.
                ///
                /// Note that all the setters affecting `kind` are
                /// mutually exclusive.
                pub fn set_float_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.kind = std::option::Option::Some(
                        crate::model::model_evaluation_slice::slice::slice_spec::value::Kind::FloatValue(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for Value {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Value"
                }
            }

            /// Defines additional types related to Value
            pub mod value {
                #[allow(unused_imports)]
                use super::*;

                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Kind {
                    /// String type.
                    StringValue(std::string::String),
                    /// Float type.
                    FloatValue(f32),
                }
            }
        }
    }
}

/// Request message for
/// [ModelGardenService.GetPublisherModel][google.cloud.aiplatform.v1.ModelGardenService.GetPublisherModel]
///
/// [google.cloud.aiplatform.v1.ModelGardenService.GetPublisherModel]: crate::client::ModelGardenService::get_publisher_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPublisherModelRequest {
    /// Required. The name of the PublisherModel resource.
    /// Format:
    /// `publishers/{publisher}/models/{publisher_model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The IETF BCP-47 language code representing the language in which
    /// the publisher model's text information should be written in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Optional. PublisherModel view specifying which fields to read.
    pub view: crate::model::PublisherModelView,

    /// Optional. Boolean indicates whether the requested model is a Hugging Face
    /// model.
    pub is_hugging_face_model: bool,

    /// Optional. Token used to access Hugging Face gated models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hugging_face_token: std::string::String,
}

impl GetPublisherModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPublisherModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetPublisherModelRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetPublisherModelRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::PublisherModelView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [is_hugging_face_model][crate::model::GetPublisherModelRequest::is_hugging_face_model].
    pub fn set_is_hugging_face_model<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_hugging_face_model = v.into();
        self
    }

    /// Sets the value of [hugging_face_token][crate::model::GetPublisherModelRequest::hugging_face_token].
    pub fn set_hugging_face_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.hugging_face_token = v.into();
        self
    }
}

impl wkt::message::Message for GetPublisherModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPublisherModelRequest"
    }
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMonitoringObjectiveConfig {
    /// Training dataset for models. This field has to be set only if
    /// TrainingPredictionSkewDetectionConfig is specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_dataset:
        std::option::Option<crate::model::model_monitoring_objective_config::TrainingDataset>,

    /// The config for skew between training data and prediction data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_prediction_skew_detection_config: std::option::Option<
        crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig,
    >,

    /// The config for drift of prediction data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction_drift_detection_config: std::option::Option<
        crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig,
    >,

    /// The config for integrating with Vertex Explainable AI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_config:
        std::option::Option<crate::model::model_monitoring_objective_config::ExplanationConfig>,
}

impl ModelMonitoringObjectiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_dataset][crate::model::ModelMonitoringObjectiveConfig::training_dataset].
    pub fn set_training_dataset<
        T: std::convert::Into<
            std::option::Option<crate::model::model_monitoring_objective_config::TrainingDataset>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_dataset = v.into();
        self
    }

    /// Sets the value of [training_prediction_skew_detection_config][crate::model::ModelMonitoringObjectiveConfig::training_prediction_skew_detection_config].
    pub fn set_training_prediction_skew_detection_config<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig>>>(mut self, v: T) -> Self{
        self.training_prediction_skew_detection_config = v.into();
        self
    }

    /// Sets the value of [prediction_drift_detection_config][crate::model::ModelMonitoringObjectiveConfig::prediction_drift_detection_config].
    pub fn set_prediction_drift_detection_config<
        T: std::convert::Into<
            std::option::Option<
                crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_drift_detection_config = v.into();
        self
    }

    /// Sets the value of [explanation_config][crate::model::ModelMonitoringObjectiveConfig::explanation_config].
    pub fn set_explanation_config<
        T: std::convert::Into<
            std::option::Option<crate::model::model_monitoring_objective_config::ExplanationConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_config = v.into();
        self
    }
}

impl wkt::message::Message for ModelMonitoringObjectiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig"
    }
}

/// Defines additional types related to ModelMonitoringObjectiveConfig
pub mod model_monitoring_objective_config {
    #[allow(unused_imports)]
    use super::*;

    /// Training Dataset information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrainingDataset {
        /// Data format of the dataset, only applicable if the input is from
        /// Google Cloud Storage.
        /// The possible formats are:
        ///
        /// "tf-record"
        /// The source file is a TFRecord file.
        ///
        /// "csv"
        /// The source file is a CSV file.
        /// "jsonl"
        /// The source file is a JSONL file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_format: std::string::String,

        /// The target field name the model is to predict.
        /// This field will be excluded when doing Predict and (or) Explain for the
        /// training data.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target_field: std::string::String,

        /// Strategy to sample data from Training Dataset.
        /// If not set, we process the whole dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub logging_sampling_strategy: std::option::Option<crate::model::SamplingStrategy>,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub data_source: std::option::Option<
            crate::model::model_monitoring_objective_config::training_dataset::DataSource,
        >,
    }

    impl TrainingDataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_format][crate::model::model_monitoring_objective_config::TrainingDataset::data_format].
        pub fn set_data_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_format = v.into();
            self
        }

        /// Sets the value of [target_field][crate::model::model_monitoring_objective_config::TrainingDataset::target_field].
        pub fn set_target_field<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_field = v.into();
            self
        }

        /// Sets the value of [logging_sampling_strategy][crate::model::model_monitoring_objective_config::TrainingDataset::logging_sampling_strategy].
        pub fn set_logging_sampling_strategy<
            T: std::convert::Into<std::option::Option<crate::model::SamplingStrategy>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.logging_sampling_strategy = v.into();
            self
        }

        /// Sets the value of `data_source`.
        pub fn set_data_source<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::model_monitoring_objective_config::training_dataset::DataSource,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_source = v.into();
            self
        }

        /// The value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// if it holds a `Dataset`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_dataset(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.data_source.as_ref().and_then(|v| match v {
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::Dataset(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// if it holds a `GcsSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gcs_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
            #[allow(unreachable_patterns)]
            self.data_source.as_ref().and_then(|v| match v {
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::GcsSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// if it holds a `BigquerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_bigquery_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
            #[allow(unreachable_patterns)]
            self.data_source.as_ref().and_then(|v| match v {
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::BigquerySource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// to hold a `Dataset`.
        ///
        /// Note that all the setters affecting `data_source` are
        /// mutually exclusive.
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_source = std::option::Option::Some(
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::Dataset(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// to hold a `GcsSource`.
        ///
        /// Note that all the setters affecting `data_source` are
        /// mutually exclusive.
        pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_source = std::option::Option::Some(
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::GcsSource(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [data_source][crate::model::model_monitoring_objective_config::TrainingDataset::data_source]
        /// to hold a `BigquerySource`.
        ///
        /// Note that all the setters affecting `data_source` are
        /// mutually exclusive.
        pub fn set_bigquery_source<
            T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_source = std::option::Option::Some(
                crate::model::model_monitoring_objective_config::training_dataset::DataSource::BigquerySource(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for TrainingDataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingDataset"
        }
    }

    /// Defines additional types related to TrainingDataset
    pub mod training_dataset {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DataSource {
            /// The resource name of the Dataset used to train this Model.
            Dataset(std::string::String),
            /// The Google Cloud Storage uri of the unmanaged Dataset used to train
            /// this Model.
            GcsSource(std::boxed::Box<crate::model::GcsSource>),
            /// The BigQuery table of the unmanaged Dataset used to train this
            /// Model.
            BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        }
    }

    /// The config for Training & Prediction data skew detection. It specifies the
    /// training dataset sources and the skew detection parameters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrainingPredictionSkewDetectionConfig {
        /// Key is the feature name and value is the threshold. If a feature needs to
        /// be monitored for skew, a value threshold must be configured for that
        /// feature. The threshold here is against feature distribution distance
        /// between the training and prediction feature.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub skew_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Key is the feature name and value is the threshold. The threshold here is
        /// against attribution score distance between the training and prediction
        /// feature.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub attribution_score_skew_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Skew anomaly detection threshold used by all features.
        /// When the per-feature thresholds are not set, this field can be used to
        /// specify a threshold for all features.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub default_skew_threshold: std::option::Option<crate::model::ThresholdConfig>,
    }

    impl TrainingPredictionSkewDetectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_skew_threshold][crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig::default_skew_threshold].
        pub fn set_default_skew_threshold<
            T: std::convert::Into<std::option::Option<crate::model::ThresholdConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.default_skew_threshold = v.into();
            self
        }

        /// Sets the value of [skew_thresholds][crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig::skew_thresholds].
        pub fn set_skew_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.skew_thresholds = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [attribution_score_skew_thresholds][crate::model::model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig::attribution_score_skew_thresholds].
        pub fn set_attribution_score_skew_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.attribution_score_skew_thresholds =
                v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for TrainingPredictionSkewDetectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig"
        }
    }

    /// The config for Prediction data drift detection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PredictionDriftDetectionConfig {
        /// Key is the feature name and value is the threshold. If a feature needs to
        /// be monitored for drift, a value threshold must be configured for that
        /// feature. The threshold here is against feature distribution distance
        /// between different time windws.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub drift_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Key is the feature name and value is the threshold. The threshold here is
        /// against attribution score distance between different time windows.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub attribution_score_drift_thresholds:
            std::collections::HashMap<std::string::String, crate::model::ThresholdConfig>,

        /// Drift anomaly detection threshold used by all features.
        /// When the per-feature thresholds are not set, this field can be used to
        /// specify a threshold for all features.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub default_drift_threshold: std::option::Option<crate::model::ThresholdConfig>,
    }

    impl PredictionDriftDetectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_drift_threshold][crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig::default_drift_threshold].
        pub fn set_default_drift_threshold<
            T: std::convert::Into<std::option::Option<crate::model::ThresholdConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.default_drift_threshold = v.into();
            self
        }

        /// Sets the value of [drift_thresholds][crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig::drift_thresholds].
        pub fn set_drift_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.drift_thresholds = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [attribution_score_drift_thresholds][crate::model::model_monitoring_objective_config::PredictionDriftDetectionConfig::attribution_score_drift_thresholds].
        pub fn set_attribution_score_drift_thresholds<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::ThresholdConfig>,
        {
            use std::iter::Iterator;
            self.attribution_score_drift_thresholds =
                v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for PredictionDriftDetectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig"
        }
    }

    /// The config for integrating with Vertex Explainable AI. Only applicable if
    /// the Model has explanation_spec populated.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExplanationConfig {

        /// If want to analyze the Vertex Explainable AI feature attribute scores or
        /// not. If set to true, Vertex AI will log the feature attributions from
        /// explain response and do the skew/drift detection for them.
        pub enable_feature_attributes: bool,

        /// Predictions generated by the BatchPredictionJob using baseline dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub explanation_baseline: std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline>,
    }

    impl ExplanationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_feature_attributes][crate::model::model_monitoring_objective_config::ExplanationConfig::enable_feature_attributes].
        pub fn set_enable_feature_attributes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_feature_attributes = v.into();
            self
        }

        /// Sets the value of [explanation_baseline][crate::model::model_monitoring_objective_config::ExplanationConfig::explanation_baseline].
        pub fn set_explanation_baseline<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline>>>(mut self, v: T) -> Self{
            self.explanation_baseline = v.into();
            self
        }
    }

    impl wkt::message::Message for ExplanationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig"
        }
    }

    /// Defines additional types related to ExplanationConfig
    pub mod explanation_config {
        #[allow(unused_imports)]
        use super::*;

        /// Output from
        /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob] for
        /// Model Monitoring baseline dataset, which can be used to generate baseline
        /// attribution scores.
        ///
        /// [google.cloud.aiplatform.v1.BatchPredictionJob]: crate::model::BatchPredictionJob
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ExplanationBaseline {

            /// The storage format of the predictions generated BatchPrediction job.
            pub prediction_format: crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::PredictionFormat,

            /// The configuration specifying of BatchExplain job output. This can be
            /// used to generate the baseline of feature attribution scores.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub destination: std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination>,
        }

        impl ExplanationBaseline {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [prediction_format][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::prediction_format].
            pub fn set_prediction_format<T: std::convert::Into<crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::PredictionFormat>>(mut self, v: T) -> Self{
                self.prediction_format = v.into();
                self
            }

            /// Sets the value of `destination`.
            pub fn set_destination<T: std::convert::Into<std::option::Option<crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination>>>(mut self, v: T) -> Self
            {
                self.destination = v.into();
                self
            }

            /// The value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// if it holds a `Gcs`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_gcs(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
                #[allow(unreachable_patterns)]
                self.destination.as_ref().and_then(|v| match v {
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Gcs(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// if it holds a `Bigquery`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_bigquery(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>>
            {
                #[allow(unreachable_patterns)]
                self.destination.as_ref().and_then(|v| match v {
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Bigquery(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// to hold a `Gcs`.
            ///
            /// Note that all the setters affecting `destination` are
            /// mutually exclusive.
            pub fn set_gcs<T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>>(
                mut self,
                v: T,
            ) -> Self {
                self.destination = std::option::Option::Some(
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Gcs(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [destination][crate::model::model_monitoring_objective_config::explanation_config::ExplanationBaseline::destination]
            /// to hold a `Bigquery`.
            ///
            /// Note that all the setters affecting `destination` are
            /// mutually exclusive.
            pub fn set_bigquery<
                T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.destination = std::option::Option::Some(
                    crate::model::model_monitoring_objective_config::explanation_config::explanation_baseline::Destination::Bigquery(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for ExplanationBaseline {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline"
            }
        }

        /// Defines additional types related to ExplanationBaseline
        pub mod explanation_baseline {
            #[allow(unused_imports)]
            use super::*;

            /// The storage format of the predictions generated BatchPrediction job.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct PredictionFormat(std::borrow::Cow<'static, str>);

            impl PredictionFormat {
                /// Creates a new PredictionFormat instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [PredictionFormat](PredictionFormat)
            pub mod prediction_format {
                use super::PredictionFormat;

                /// Should not be set.
                pub const PREDICTION_FORMAT_UNSPECIFIED: PredictionFormat =
                    PredictionFormat::new("PREDICTION_FORMAT_UNSPECIFIED");

                /// Predictions are in JSONL files.
                pub const JSONL: PredictionFormat = PredictionFormat::new("JSONL");

                /// Predictions are in BigQuery.
                pub const BIGQUERY: PredictionFormat = PredictionFormat::new("BIGQUERY");
            }

            impl std::convert::From<std::string::String> for PredictionFormat {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }

            /// The configuration specifying of BatchExplain job output. This can be
            /// used to generate the baseline of feature attribution scores.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Destination {
                /// Cloud Storage location for BatchExplain output.
                Gcs(std::boxed::Box<crate::model::GcsDestination>),
                /// BigQuery location for BatchExplain output.
                Bigquery(std::boxed::Box<crate::model::BigQueryDestination>),
            }
        }
    }
}

/// The alert config for model monitoring.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMonitoringAlertConfig {
    /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
    /// payload encoded from proto
    /// [ModelMonitoringStatsAnomalies][google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies].
    /// This can be further synced to Pub/Sub or any other services supported by
    /// Cloud Logging.
    ///
    /// [google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies]: crate::model::ModelMonitoringStatsAnomalies
    pub enable_logging: bool,

    /// Resource names of the NotificationChannels to send alert.
    /// Must be of the format
    /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notification_channels: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub alert: std::option::Option<crate::model::model_monitoring_alert_config::Alert>,
}

impl ModelMonitoringAlertConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_logging][crate::model::ModelMonitoringAlertConfig::enable_logging].
    pub fn set_enable_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_logging = v.into();
        self
    }

    /// Sets the value of [notification_channels][crate::model::ModelMonitoringAlertConfig::notification_channels].
    pub fn set_notification_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.notification_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `alert`.
    pub fn set_alert<
        T: std::convert::Into<std::option::Option<crate::model::model_monitoring_alert_config::Alert>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert = v.into();
        self
    }

    /// The value of [alert][crate::model::ModelMonitoringAlertConfig::alert]
    /// if it holds a `EmailAlertConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_email_alert_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::model_monitoring_alert_config::EmailAlertConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.alert.as_ref().and_then(|v| match v {
            crate::model::model_monitoring_alert_config::Alert::EmailAlertConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [alert][crate::model::ModelMonitoringAlertConfig::alert]
    /// to hold a `EmailAlertConfig`.
    ///
    /// Note that all the setters affecting `alert` are
    /// mutually exclusive.
    pub fn set_email_alert_config<
        T: std::convert::Into<
            std::boxed::Box<crate::model::model_monitoring_alert_config::EmailAlertConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.alert = std::option::Option::Some(
            crate::model::model_monitoring_alert_config::Alert::EmailAlertConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ModelMonitoringAlertConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringAlertConfig"
    }
}

/// Defines additional types related to ModelMonitoringAlertConfig
pub mod model_monitoring_alert_config {
    #[allow(unused_imports)]
    use super::*;

    /// The config for email alert.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EmailAlertConfig {
        /// The email addresses to send the alert.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub user_emails: std::vec::Vec<std::string::String>,
    }

    impl EmailAlertConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user_emails][crate::model::model_monitoring_alert_config::EmailAlertConfig::user_emails].
        pub fn set_user_emails<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.user_emails = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EmailAlertConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringAlertConfig.EmailAlertConfig"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Alert {
        /// Email alert config.
        EmailAlertConfig(
            std::boxed::Box<crate::model::model_monitoring_alert_config::EmailAlertConfig>,
        ),
    }
}

/// The config for feature monitoring threshold.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ThresholdConfig {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub threshold: std::option::Option<crate::model::threshold_config::Threshold>,
}

impl ThresholdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `threshold`.
    pub fn set_threshold<
        T: std::convert::Into<std::option::Option<crate::model::threshold_config::Threshold>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.threshold = v.into();
        self
    }

    /// The value of [threshold][crate::model::ThresholdConfig::threshold]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.threshold.as_ref().and_then(|v| match v {
            crate::model::threshold_config::Threshold::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [threshold][crate::model::ThresholdConfig::threshold]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `threshold` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.threshold =
            std::option::Option::Some(crate::model::threshold_config::Threshold::Value(v.into()));
        self
    }
}

impl wkt::message::Message for ThresholdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ThresholdConfig"
    }
}

/// Defines additional types related to ThresholdConfig
pub mod threshold_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Threshold {
        /// Specify a threshold value that can trigger the alert.
        /// If this threshold config is for feature distribution distance:
        ///
        /// . For categorical feature, the distribution distance is calculated by
        ///   L-inifinity norm.
        /// . For numerical feature, the distribution distance is calculated by
        ///   Jensen–Shannon divergence.
        ///   Each feature must have a non-zero threshold if they need to be monitored.
        ///   Otherwise no alert will be triggered for that feature.
        Value(f64),
    }
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SamplingStrategy {
    /// Random sample config. Will support more sampling strategies later.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub random_sample_config:
        std::option::Option<crate::model::sampling_strategy::RandomSampleConfig>,
}

impl SamplingStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [random_sample_config][crate::model::SamplingStrategy::random_sample_config].
    pub fn set_random_sample_config<
        T: std::convert::Into<
            std::option::Option<crate::model::sampling_strategy::RandomSampleConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.random_sample_config = v.into();
        self
    }
}

impl wkt::message::Message for SamplingStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SamplingStrategy"
    }
}

/// Defines additional types related to SamplingStrategy
pub mod sampling_strategy {
    #[allow(unused_imports)]
    use super::*;

    /// Requests are randomly selected.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RandomSampleConfig {
        /// Sample rate (0, 1]
        pub sample_rate: f64,
    }

    impl RandomSampleConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sample_rate][crate::model::sampling_strategy::RandomSampleConfig::sample_rate].
        pub fn set_sample_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.sample_rate = v.into();
            self
        }
    }

    impl wkt::message::Message for RandomSampleConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SamplingStrategy.RandomSampleConfig"
        }
    }
}

/// Request message for
/// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel].
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadModelRequest {
    /// Required. The resource name of the Location into which to upload the Model.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The resource name of the model into which to upload the version.
    /// Only specify this field when uploading a new version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_model: std::string::String,

    /// Optional. The ID to use for the uploaded Model, which will become the final
    /// component of the model resource name.
    ///
    /// This value may be up to 63 characters, and valid characters are
    /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Required. The Model to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,

    /// Optional. The user-provided custom service account to use to do the model
    /// upload. If empty, [Vertex AI Service
    /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
    /// will be used to access resources needed to upload the model. This account
    /// must belong to the target project where the model is uploaded to, i.e., the
    /// project specified in the `parent` field of this request and have necessary
    /// read permissions (to Google Cloud Storage, Artifact Registry, etc.).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,
}

impl UploadModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UploadModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [parent_model][crate::model::UploadModelRequest::parent_model].
    pub fn set_parent_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::UploadModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::UploadModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::UploadModelRequest::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for UploadModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelRequest"
    }
}

/// Details of
/// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadModelOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UploadModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UploadModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UploadModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelOperationMetadata"
    }
}

/// Response message of
/// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadModelResponse {
    /// The name of the uploaded Model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the model that is uploaded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,
}

impl UploadModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UploadModelResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::UploadModelResponse::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }
}

impl wkt::message::Message for UploadModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelResponse"
    }
}

/// Request message for
/// [ModelService.GetModel][google.cloud.aiplatform.v1.ModelService.GetModel].
///
/// [google.cloud.aiplatform.v1.ModelService.GetModel]: crate::client::ModelService::get_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. The name of the Model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    ///
    /// In order to retrieve a specific version of the model, also provide
    /// the version ID or version alias.
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// If no version ID or alias is specified, the "default" version will be
    /// returned. The "default" version alias is created for the first version of
    /// the model, and can be moved to other versions later on. There will be
    /// exactly one default version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelRequest"
    }
}

/// Request message for
/// [ModelService.ListModels][google.cloud.aiplatform.v1.ModelService.ListModels].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModels]: crate::client::ModelService::list_models
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. The resource name of the Location to list the Models from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// An expression for filtering the results of the request. For field names
    /// both snake_case and camelCase are supported.
    ///
    /// * `model` supports = and !=. `model` represents the Model ID,
    ///   i.e. the last segment of the Model's [resource
    ///   name][google.cloud.aiplatform.v1.Model.name].
    /// * `display_name` supports = and !=
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    /// * `base_model_name` only supports =
    ///
    /// Some examples:
    ///
    /// * `model=1234`
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    /// * `baseModelName="text-bison"`
    ///
    /// [google.cloud.aiplatform.v1.Model.name]: crate::model::Model::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListModelsResponse.next_page_token][google.cloud.aiplatform.v1.ListModelsResponse.next_page_token]
    /// of the previous
    /// [ModelService.ListModels][google.cloud.aiplatform.v1.ModelService.ListModels]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelsResponse.next_page_token]: crate::model::ListModelsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModels]: crate::client::ModelService::list_models
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListModelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelsRequest"
    }
}

/// Response message for
/// [ModelService.ListModels][google.cloud.aiplatform.v1.ModelService.ListModels]
///
/// [google.cloud.aiplatform.v1.ModelService.ListModels]: crate::client::ModelService::list_models
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// List of Models in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListModelsRequest.page_token][google.cloud.aiplatform.v1.ListModelsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelsRequest.page_token]: crate::model::ListModelsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListModelsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ModelService.ListModelVersions][google.cloud.aiplatform.v1.ModelService.ListModelVersions].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersions]: crate::client::ModelService::list_model_versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionsRequest {
    /// Required. The name of the model to list versions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [next_page_token][google.cloud.aiplatform.v1.ListModelVersionsResponse.next_page_token]
    /// of the previous
    /// [ListModelVersions][google.cloud.aiplatform.v1.ModelService.ListModelVersions]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionsResponse.next_page_token]: crate::model::ListModelVersionsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelVersions]: crate::client::ModelService::list_model_versions
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// An expression for filtering the results of the request. For field names
    /// both snake_case and camelCase are supported.
    ///
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    ///
    /// Some examples:
    ///
    /// * `labels.myKey="myValue"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `update_time asc, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListModelVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListModelVersionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelVersionsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListModelVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListModelVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionsRequest"
    }
}

/// Response message for
/// [ModelService.ListModelVersions][google.cloud.aiplatform.v1.ModelService.ListModelVersions]
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersions]: crate::client::ModelService::list_model_versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionsResponse {
    /// List of Model versions in the requested page.
    /// In the returned Model name field, version ID instead of regvision tag will
    /// be included.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListModelVersionsRequest.page_token][google.cloud.aiplatform.v1.ListModelVersionsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionsRequest.page_token]: crate::model::ListModelVersionsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelVersionsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListModelVersionsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ModelService.ListModelVersionCheckpoints][google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]: crate::client::ModelService::list_model_version_checkpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionCheckpointsRequest {
    /// Required. The name of the model version to list checkpoints for.
    /// `projects/{project}/locations/{location}/models/{model}@{version}`
    /// Example: `projects/{project}/locations/{location}/models/{model}@2`
    /// or
    /// `projects/{project}/locations/{location}/models/{model}@golden`
    /// If no version ID or alias is specified, the latest version will be
    /// used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [next_page_token][google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse.next_page_token]
    /// of the previous
    /// [ListModelVersionCheckpoints][google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse.next_page_token]: crate::model::ListModelVersionCheckpointsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]: crate::client::ModelService::list_model_version_checkpoints
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListModelVersionCheckpointsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListModelVersionCheckpointsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelVersionCheckpointsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelVersionCheckpointsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelVersionCheckpointsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest"
    }
}

/// A proto representation of a Spanner-stored ModelVersionCheckpoint.
/// The meaning of the fields is equivalent to their in-Spanner counterparts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelVersionCheckpoint {
    /// The ID of the checkpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub checkpoint_id: std::string::String,

    /// The epoch of the checkpoint.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub epoch: i64,

    /// The step of the checkpoint.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub step: i64,
}

impl ModelVersionCheckpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checkpoint_id][crate::model::ModelVersionCheckpoint::checkpoint_id].
    pub fn set_checkpoint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.checkpoint_id = v.into();
        self
    }

    /// Sets the value of [epoch][crate::model::ModelVersionCheckpoint::epoch].
    pub fn set_epoch<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.epoch = v.into();
        self
    }

    /// Sets the value of [step][crate::model::ModelVersionCheckpoint::step].
    pub fn set_step<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }
}

impl wkt::message::Message for ModelVersionCheckpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelVersionCheckpoint"
    }
}

/// Response message for
/// [ModelService.ListModelVersionCheckpoints][google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelVersionCheckpoints]: crate::client::ModelService::list_model_version_checkpoints
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelVersionCheckpointsResponse {
    /// List of Model Version checkpoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub checkpoints: std::vec::Vec<crate::model::ModelVersionCheckpoint>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListModelVersionCheckpointsRequest.page_token][google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest.page_token]: crate::model::ListModelVersionCheckpointsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelVersionCheckpointsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelVersionCheckpointsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [checkpoints][crate::model::ListModelVersionCheckpointsResponse::checkpoints].
    pub fn set_checkpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelVersionCheckpoint>,
    {
        use std::iter::Iterator;
        self.checkpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelVersionCheckpointsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListModelVersionCheckpointsResponse {
    type PageItem = crate::model::ModelVersionCheckpoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.checkpoints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ModelService.UpdateModel][google.cloud.aiplatform.v1.ModelService.UpdateModel].
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateModel]: crate::client::ModelService::update_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelRequest {
    /// Required. The Model which replaces the resource on the server.
    /// When Model Versioning is enabled, the model.name will be used to determine
    /// whether to update the model or model version.
    ///
    /// . model.name with the @ value, e.g. models/123@1, refers to a version
    ///   specific update.
    /// . model.name without the @ value, e.g. models/123, refers to a model
    ///   update.
    /// . model.name with @-, e.g. models/123@-, refers to a model update.
    /// . Supported model fields: display_name, description; supported
    ///   version-specific fields: version_description. Labels are supported in both
    ///   scenarios. Both the model labels and the version labels are merged when a
    ///   model is returned. When updating labels, if the request is for
    ///   model-specific update, model label gets updated. Otherwise, version labels
    ///   get updated.
    /// . A model name or model version name fields update mismatch will cause a
    ///   precondition error.
    /// . One request cannot update both the model and the version fields. You
    ///   must update them separately.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UpdateModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateModelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelRequest"
    }
}

/// Request message for
/// [ModelService.UpdateExplanationDataset][google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset].
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]: crate::client::ModelService::update_explanation_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExplanationDatasetRequest {
    /// Required. The resource name of the Model to update.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// The example config containing the location of the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub examples: std::option::Option<crate::model::Examples>,
}

impl UpdateExplanationDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UpdateExplanationDatasetRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [examples][crate::model::UpdateExplanationDatasetRequest::examples].
    pub fn set_examples<T: std::convert::Into<std::option::Option<crate::model::Examples>>>(
        mut self,
        v: T,
    ) -> Self {
        self.examples = v.into();
        self
    }
}

impl wkt::message::Message for UpdateExplanationDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetRequest"
    }
}

/// Runtime operation information for
/// [ModelService.UpdateExplanationDataset][google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset].
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]: crate::client::ModelService::update_explanation_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExplanationDatasetOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateExplanationDatasetOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateExplanationDatasetOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateExplanationDatasetOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetOperationMetadata"
    }
}

/// Request message for
/// [ModelService.DeleteModel][google.cloud.aiplatform.v1.ModelService.DeleteModel].
///
/// [google.cloud.aiplatform.v1.ModelService.DeleteModel]: crate::client::ModelService::delete_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. The name of the Model resource to be deleted.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelRequest"
    }
}

/// Request message for
/// [ModelService.DeleteModelVersion][google.cloud.aiplatform.v1.ModelService.DeleteModelVersion].
///
/// [google.cloud.aiplatform.v1.ModelService.DeleteModelVersion]: crate::client::ModelService::delete_model_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelVersionRequest {
    /// Required. The name of the model version to be deleted, with a version ID
    /// explicitly included.
    ///
    /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteModelVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelVersionRequest"
    }
}

/// Request message for
/// [ModelService.MergeVersionAliases][google.cloud.aiplatform.v1.ModelService.MergeVersionAliases].
///
/// [google.cloud.aiplatform.v1.ModelService.MergeVersionAliases]: crate::client::ModelService::merge_version_aliases
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MergeVersionAliasesRequest {
    /// Required. The name of the model version to merge aliases, with a version ID
    /// explicitly included.
    ///
    /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The set of version aliases to merge.
    /// The alias should be at most 128 characters, and match
    /// `[a-z][a-zA-Z0-9-]{0,126}[a-z-0-9]`.
    /// Add the `-` prefix to an alias means removing that alias from the version.
    /// `-` is NOT counted in the 128 characters. Example: `-golden` means removing
    /// the `golden` alias from the version.
    ///
    /// There is NO ordering in aliases, which means
    ///
    /// ) The aliases returned from GetModel API might not have the exactly same
    ///   order from this MergeVersionAliases API. 2) Adding and deleting the same
    ///   alias in the request is not recommended, and the 2 operations will be
    ///   cancelled out.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub version_aliases: std::vec::Vec<std::string::String>,
}

impl MergeVersionAliasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MergeVersionAliasesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::MergeVersionAliasesRequest::version_aliases].
    pub fn set_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MergeVersionAliasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.MergeVersionAliasesRequest"
    }
}

/// Request message for
/// [ModelService.ExportModel][google.cloud.aiplatform.v1.ModelService.ExportModel].
///
/// [google.cloud.aiplatform.v1.ModelService.ExportModel]: crate::client::ModelService::export_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelRequest {
    /// Required. The resource name of the Model to export.
    /// The resource name may contain version id or version alias to specify the
    /// version, if no version is specified, the default version will be exported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The desired output location and configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::export_model_request::OutputConfig>,
}

impl ExportModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::ExportModelRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::export_model_request::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }
}

impl wkt::message::Message for ExportModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelRequest"
    }
}

/// Defines additional types related to ExportModelRequest
pub mod export_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Output configuration for the Model export.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputConfig {
        /// The ID of the format in which the Model must be exported. Each Model
        /// lists the [export formats it
        /// supports][google.cloud.aiplatform.v1.Model.supported_export_formats]. If
        /// no value is provided here, then the first from the list of the Model's
        /// supported formats is used by default.
        ///
        /// [google.cloud.aiplatform.v1.Model.supported_export_formats]: crate::model::Model::supported_export_formats
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub export_format_id: std::string::String,

        /// The Cloud Storage location where the Model artifact is to be
        /// written to. Under the directory given as the destination a new one with
        /// name "`model-export-<model-display-name>-<timestamp-of-export-call>`",
        /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format,
        /// will be created. Inside, the Model and any of its supporting files
        /// will be written.
        /// This field should only be set when the `exportableContent` field of the
        /// [Model.supported_export_formats] object contains `ARTIFACT`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub artifact_destination: std::option::Option<crate::model::GcsDestination>,

        /// The Google Container Registry or Artifact Registry uri where the
        /// Model container image will be copied to.
        /// This field should only be set when the `exportableContent` field of the
        /// [Model.supported_export_formats] object contains `IMAGE`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub image_destination: std::option::Option<crate::model::ContainerRegistryDestination>,
    }

    impl OutputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [export_format_id][crate::model::export_model_request::OutputConfig::export_format_id].
        pub fn set_export_format_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.export_format_id = v.into();
            self
        }

        /// Sets the value of [artifact_destination][crate::model::export_model_request::OutputConfig::artifact_destination].
        pub fn set_artifact_destination<
            T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.artifact_destination = v.into();
            self
        }

        /// Sets the value of [image_destination][crate::model::export_model_request::OutputConfig::image_destination].
        pub fn set_image_destination<
            T: std::convert::Into<std::option::Option<crate::model::ContainerRegistryDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.image_destination = v.into();
            self
        }
    }

    impl wkt::message::Message for OutputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig"
        }
    }
}

/// Details of
/// [ModelService.ExportModel][google.cloud.aiplatform.v1.ModelService.ExportModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.ExportModel]: crate::client::ModelService::export_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Output only. Information further describing the output of this Model
    /// export.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_info: std::option::Option<crate::model::export_model_operation_metadata::OutputInfo>,
}

impl ExportModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ExportModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [output_info][crate::model::ExportModelOperationMetadata::output_info].
    pub fn set_output_info<
        T: std::convert::Into<
            std::option::Option<crate::model::export_model_operation_metadata::OutputInfo>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_info = v.into();
        self
    }
}

impl wkt::message::Message for ExportModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelOperationMetadata"
    }
}

/// Defines additional types related to ExportModelOperationMetadata
pub mod export_model_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Further describes the output of the ExportModel. Supplements
    /// [ExportModelRequest.OutputConfig][google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig].
    ///
    /// [google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig]: crate::model::export_model_request::OutputConfig
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OutputInfo {
        /// Output only. If the Model artifact is being exported to Google Cloud
        /// Storage this is the full path of the directory created, into which the
        /// Model files are being written to.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub artifact_output_uri: std::string::String,

        /// Output only. If the Model image is being exported to Google Container
        /// Registry or Artifact Registry this is the full path of the image created.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub image_output_uri: std::string::String,
    }

    impl OutputInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [artifact_output_uri][crate::model::export_model_operation_metadata::OutputInfo::artifact_output_uri].
        pub fn set_artifact_output_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.artifact_output_uri = v.into();
            self
        }

        /// Sets the value of [image_output_uri][crate::model::export_model_operation_metadata::OutputInfo::image_output_uri].
        pub fn set_image_output_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.image_output_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for OutputInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelOperationMetadata.OutputInfo"
        }
    }
}

/// Response message of
/// [ModelService.UpdateExplanationDataset][google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.UpdateExplanationDataset]: crate::client::ModelService::update_explanation_dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExplanationDatasetResponse {}

impl UpdateExplanationDatasetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpdateExplanationDatasetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetResponse"
    }
}

/// Response message of
/// [ModelService.ExportModel][google.cloud.aiplatform.v1.ModelService.ExportModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.ExportModel]: crate::client::ModelService::export_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelResponse {}

impl ExportModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelResponse"
    }
}

/// Request message for
/// [ModelService.CopyModel][google.cloud.aiplatform.v1.ModelService.CopyModel].
///
/// [google.cloud.aiplatform.v1.ModelService.CopyModel]: crate::client::ModelService::copy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyModelRequest {
    /// Required. The resource name of the Location into which to copy the Model.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource name of the Model to copy. That Model must be in the
    /// same Project. Format:
    /// `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_model: std::string::String,

    /// Customer-managed encryption key options. If this is set,
    /// then the Model copy will be encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// If both fields are unset, a new Model will be created with a generated ID.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination_model: std::option::Option<crate::model::copy_model_request::DestinationModel>,
}

impl CopyModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CopyModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_model][crate::model::CopyModelRequest::source_model].
    pub fn set_source_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_model = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::CopyModelRequest::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of `destination_model`.
    pub fn set_destination_model<
        T: std::convert::Into<std::option::Option<crate::model::copy_model_request::DestinationModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_model = v.into();
        self
    }

    /// The value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// if it holds a `ModelId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_model_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination_model.as_ref().and_then(|v| match v {
            crate::model::copy_model_request::DestinationModel::ModelId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// if it holds a `ParentModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_parent_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination_model.as_ref().and_then(|v| match v {
            crate::model::copy_model_request::DestinationModel::ParentModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// to hold a `ModelId`.
    ///
    /// Note that all the setters affecting `destination_model` are
    /// mutually exclusive.
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_model = std::option::Option::Some(
            crate::model::copy_model_request::DestinationModel::ModelId(v.into()),
        );
        self
    }

    /// Sets the value of [destination_model][crate::model::CopyModelRequest::destination_model]
    /// to hold a `ParentModel`.
    ///
    /// Note that all the setters affecting `destination_model` are
    /// mutually exclusive.
    pub fn set_parent_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_model = std::option::Option::Some(
            crate::model::copy_model_request::DestinationModel::ParentModel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CopyModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelRequest"
    }
}

/// Defines additional types related to CopyModelRequest
pub mod copy_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// If both fields are unset, a new Model will be created with a generated ID.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DestinationModel {
        /// Optional. Copy source_model into a new Model with this ID. The ID will
        /// become the final component of the model resource name.
        ///
        /// This value may be up to 63 characters, and valid characters are
        /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
        ModelId(std::string::String),
        /// Optional. Specify this field to copy source_model into this existing
        /// Model as a new version. Format:
        /// `projects/{project}/locations/{location}/models/{model}`
        ParentModel(std::string::String),
    }
}

/// Details of
/// [ModelService.CopyModel][google.cloud.aiplatform.v1.ModelService.CopyModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.CopyModel]: crate::client::ModelService::copy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyModelOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CopyModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CopyModelOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CopyModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelOperationMetadata"
    }
}

/// Response message of
/// [ModelService.CopyModel][google.cloud.aiplatform.v1.ModelService.CopyModel]
/// operation.
///
/// [google.cloud.aiplatform.v1.ModelService.CopyModel]: crate::client::ModelService::copy_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyModelResponse {
    /// The name of the copied Model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the model that is copied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,
}

impl CopyModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::CopyModelResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::CopyModelResponse::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }
}

impl wkt::message::Message for CopyModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelResponse"
    }
}

/// Request message for
/// [ModelService.ImportModelEvaluation][google.cloud.aiplatform.v1.ModelService.ImportModelEvaluation]
///
/// [google.cloud.aiplatform.v1.ModelService.ImportModelEvaluation]: crate::client::ModelService::import_model_evaluation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportModelEvaluationRequest {
    /// Required. The name of the parent model resource.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Model evaluation resource to be imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_evaluation: std::option::Option<crate::model::ModelEvaluation>,
}

impl ImportModelEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportModelEvaluationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_evaluation][crate::model::ImportModelEvaluationRequest::model_evaluation].
    pub fn set_model_evaluation<
        T: std::convert::Into<std::option::Option<crate::model::ModelEvaluation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_evaluation = v.into();
        self
    }
}

impl wkt::message::Message for ImportModelEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportModelEvaluationRequest"
    }
}

/// Request message for
/// [ModelService.BatchImportModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]: crate::client::ModelService::batch_import_model_evaluation_slices
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportModelEvaluationSlicesRequest {
    /// Required. The name of the parent ModelEvaluation resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Model evaluation slice resource to be imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_evaluation_slices: std::vec::Vec<crate::model::ModelEvaluationSlice>,
}

impl BatchImportModelEvaluationSlicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchImportModelEvaluationSlicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_evaluation_slices][crate::model::BatchImportModelEvaluationSlicesRequest::model_evaluation_slices].
    pub fn set_model_evaluation_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelEvaluationSlice>,
    {
        use std::iter::Iterator;
        self.model_evaluation_slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchImportModelEvaluationSlicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesRequest"
    }
}

/// Response message for
/// [ModelService.BatchImportModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportModelEvaluationSlices]: crate::client::ModelService::batch_import_model_evaluation_slices
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportModelEvaluationSlicesResponse {
    /// Output only. List of imported
    /// [ModelEvaluationSlice.name][google.cloud.aiplatform.v1.ModelEvaluationSlice.name].
    ///
    /// [google.cloud.aiplatform.v1.ModelEvaluationSlice.name]: crate::model::ModelEvaluationSlice::name
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub imported_model_evaluation_slices: std::vec::Vec<std::string::String>,
}

impl BatchImportModelEvaluationSlicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_model_evaluation_slices][crate::model::BatchImportModelEvaluationSlicesResponse::imported_model_evaluation_slices].
    pub fn set_imported_model_evaluation_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.imported_model_evaluation_slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchImportModelEvaluationSlicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesResponse"
    }
}

/// Request message for
/// [ModelService.BatchImportEvaluatedAnnotations][google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]: crate::client::ModelService::batch_import_evaluated_annotations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportEvaluatedAnnotationsRequest {
    /// Required. The name of the parent ModelEvaluationSlice resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Evaluated annotations resource to be imported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub evaluated_annotations: std::vec::Vec<crate::model::EvaluatedAnnotation>,
}

impl BatchImportEvaluatedAnnotationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchImportEvaluatedAnnotationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [evaluated_annotations][crate::model::BatchImportEvaluatedAnnotationsRequest::evaluated_annotations].
    pub fn set_evaluated_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EvaluatedAnnotation>,
    {
        use std::iter::Iterator;
        self.evaluated_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchImportEvaluatedAnnotationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsRequest"
    }
}

/// Response message for
/// [ModelService.BatchImportEvaluatedAnnotations][google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]
///
/// [google.cloud.aiplatform.v1.ModelService.BatchImportEvaluatedAnnotations]: crate::client::ModelService::batch_import_evaluated_annotations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchImportEvaluatedAnnotationsResponse {
    /// Output only. Number of EvaluatedAnnotations imported.
    pub imported_evaluated_annotations_count: i32,
}

impl BatchImportEvaluatedAnnotationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_evaluated_annotations_count][crate::model::BatchImportEvaluatedAnnotationsResponse::imported_evaluated_annotations_count].
    pub fn set_imported_evaluated_annotations_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.imported_evaluated_annotations_count = v.into();
        self
    }
}

impl wkt::message::Message for BatchImportEvaluatedAnnotationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsResponse"
    }
}

/// Request message for
/// [ModelService.GetModelEvaluation][google.cloud.aiplatform.v1.ModelService.GetModelEvaluation].
///
/// [google.cloud.aiplatform.v1.ModelService.GetModelEvaluation]: crate::client::ModelService::get_model_evaluation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelEvaluationRequest {
    /// Required. The name of the ModelEvaluation resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetModelEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelEvaluationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelEvaluationRequest"
    }
}

/// Request message for
/// [ModelService.ListModelEvaluations][google.cloud.aiplatform.v1.ModelService.ListModelEvaluations].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]: crate::client::ModelService::list_model_evaluations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationsRequest {
    /// Required. The resource name of the Model to list the ModelEvaluations from.
    /// Format: `projects/{project}/locations/{location}/models/{model}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListModelEvaluationsResponse.next_page_token][google.cloud.aiplatform.v1.ListModelEvaluationsResponse.next_page_token]
    /// of the previous
    /// [ModelService.ListModelEvaluations][google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationsResponse.next_page_token]: crate::model::ListModelEvaluationsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]: crate::client::ModelService::list_model_evaluations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListModelEvaluationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelEvaluationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelEvaluationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelEvaluationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelEvaluationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelEvaluationsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListModelEvaluationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationsRequest"
    }
}

/// Response message for
/// [ModelService.ListModelEvaluations][google.cloud.aiplatform.v1.ModelService.ListModelEvaluations].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluations]: crate::client::ModelService::list_model_evaluations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationsResponse {
    /// List of ModelEvaluations in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_evaluations: std::vec::Vec<crate::model::ModelEvaluation>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListModelEvaluationsRequest.page_token][google.cloud.aiplatform.v1.ListModelEvaluationsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationsRequest.page_token]: crate::model::ListModelEvaluationsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelEvaluationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelEvaluationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [model_evaluations][crate::model::ListModelEvaluationsResponse::model_evaluations].
    pub fn set_model_evaluations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelEvaluation>,
    {
        use std::iter::Iterator;
        self.model_evaluations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelEvaluationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListModelEvaluationsResponse {
    type PageItem = crate::model::ModelEvaluation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.model_evaluations
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ModelService.GetModelEvaluationSlice][google.cloud.aiplatform.v1.ModelService.GetModelEvaluationSlice].
///
/// [google.cloud.aiplatform.v1.ModelService.GetModelEvaluationSlice]: crate::client::ModelService::get_model_evaluation_slice
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelEvaluationSliceRequest {
    /// Required. The name of the ModelEvaluationSlice resource.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetModelEvaluationSliceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelEvaluationSliceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelEvaluationSliceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelEvaluationSliceRequest"
    }
}

/// Request message for
/// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationSlicesRequest {
    /// Required. The resource name of the ModelEvaluation to list the
    /// ModelEvaluationSlices from. Format:
    /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// * `slice.dimension` - for =.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListModelEvaluationSlicesResponse.next_page_token][google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse.next_page_token]
    /// of the previous
    /// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse.next_page_token]: crate::model::ListModelEvaluationSlicesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListModelEvaluationSlicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelEvaluationSlicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelEvaluationSlicesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelEvaluationSlicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelEvaluationSlicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListModelEvaluationSlicesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListModelEvaluationSlicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest"
    }
}

/// Response message for
/// [ModelService.ListModelEvaluationSlices][google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices].
///
/// [google.cloud.aiplatform.v1.ModelService.ListModelEvaluationSlices]: crate::client::ModelService::list_model_evaluation_slices
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelEvaluationSlicesResponse {
    /// List of ModelEvaluations in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_evaluation_slices: std::vec::Vec<crate::model::ModelEvaluationSlice>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListModelEvaluationSlicesRequest.page_token][google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest.page_token]: crate::model::ListModelEvaluationSlicesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelEvaluationSlicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelEvaluationSlicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [model_evaluation_slices][crate::model::ListModelEvaluationSlicesResponse::model_evaluation_slices].
    pub fn set_model_evaluation_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelEvaluationSlice>,
    {
        use std::iter::Iterator;
        self.model_evaluation_slices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelEvaluationSlicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListModelEvaluationSlicesResponse {
    type PageItem = crate::model::ModelEvaluationSlice;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.model_evaluation_slices
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Represents a Neural Architecture Search (NAS) job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasJob {
    /// Output only. Resource name of the NasJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the NasJob.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The specification of a NasJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nas_job_spec: std::option::Option<crate::model::NasJobSpec>,

    /// Output only. Output of the NasJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nas_job_output: std::option::Option<crate::model::NasJobOutput>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the NasJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasJob for the first time entered the
    /// `JOB_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasJob entered any of the following states:
    /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is JOB_STATE_FAILED or
    /// JOB_STATE_CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize NasJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key options for a NasJob.
    /// If this is set, then all resources created by the NasJob
    /// will be encrypted with the provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. Enable a separation of Custom model training
    /// and restricted image training for tenant project.
    pub enable_restricted_image_training: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl NasJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NasJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NasJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [nas_job_spec][crate::model::NasJob::nas_job_spec].
    pub fn set_nas_job_spec<
        T: std::convert::Into<std::option::Option<crate::model::NasJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_job_spec = v.into();
        self
    }

    /// Sets the value of [nas_job_output][crate::model::NasJob::nas_job_output].
    pub fn set_nas_job_output<
        T: std::convert::Into<std::option::Option<crate::model::NasJobOutput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_job_output = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NasJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NasJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::NasJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::NasJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NasJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::NasJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NasJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [enable_restricted_image_training][crate::model::NasJob::enable_restricted_image_training].
    pub fn set_enable_restricted_image_training<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_restricted_image_training = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::NasJob::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::NasJob::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NasJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NasJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJob"
    }
}

/// Represents a NasTrial details along with its parameters. If there is a
/// corresponding train NasTrial, the train NasTrial is also returned.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasTrialDetail {
    /// Output only. Resource name of the NasTrialDetail.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The parameters for the NasJob NasTrial.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parameters: std::string::String,

    /// The requested search NasTrial.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_trial: std::option::Option<crate::model::NasTrial>,

    /// The train NasTrial corresponding to
    /// [search_trial][google.cloud.aiplatform.v1.NasTrialDetail.search_trial].
    /// Only populated if
    /// [search_trial][google.cloud.aiplatform.v1.NasTrialDetail.search_trial] is
    /// used for training.
    ///
    /// [google.cloud.aiplatform.v1.NasTrialDetail.search_trial]: crate::model::NasTrialDetail::search_trial
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub train_trial: std::option::Option<crate::model::NasTrial>,
}

impl NasTrialDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NasTrialDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::NasTrialDetail::parameters].
    pub fn set_parameters<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [search_trial][crate::model::NasTrialDetail::search_trial].
    pub fn set_search_trial<T: std::convert::Into<std::option::Option<crate::model::NasTrial>>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_trial = v.into();
        self
    }

    /// Sets the value of [train_trial][crate::model::NasTrialDetail::train_trial].
    pub fn set_train_trial<T: std::convert::Into<std::option::Option<crate::model::NasTrial>>>(
        mut self,
        v: T,
    ) -> Self {
        self.train_trial = v.into();
        self
    }
}

impl wkt::message::Message for NasTrialDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasTrialDetail"
    }
}

/// Represents the spec of a NasJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasJobSpec {
    /// The ID of the existing NasJob in the same Project and Location
    /// which will be used to resume search. search_space_spec and
    /// nas_algorithm_spec are obtained from previous NasJob hence should not
    /// provide them again for this NasJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resume_nas_job_id: std::string::String,

    /// It defines the search space for Neural Architecture Search (NAS).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub search_space_spec: std::string::String,

    /// The Neural Architecture Search (NAS) algorithm specification.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub nas_algorithm_spec: std::option::Option<crate::model::nas_job_spec::NasAlgorithmSpec>,
}

impl NasJobSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resume_nas_job_id][crate::model::NasJobSpec::resume_nas_job_id].
    pub fn set_resume_nas_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resume_nas_job_id = v.into();
        self
    }

    /// Sets the value of [search_space_spec][crate::model::NasJobSpec::search_space_spec].
    pub fn set_search_space_spec<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_space_spec = v.into();
        self
    }

    /// Sets the value of `nas_algorithm_spec`.
    pub fn set_nas_algorithm_spec<
        T: std::convert::Into<std::option::Option<crate::model::nas_job_spec::NasAlgorithmSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_algorithm_spec = v.into();
        self
    }

    /// The value of [nas_algorithm_spec][crate::model::NasJobSpec::nas_algorithm_spec]
    /// if it holds a `MultiTrialAlgorithmSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_multi_trial_algorithm_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::nas_job_spec::MultiTrialAlgorithmSpec>>
    {
        #[allow(unreachable_patterns)]
        self.nas_algorithm_spec.as_ref().and_then(|v| match v {
            crate::model::nas_job_spec::NasAlgorithmSpec::MultiTrialAlgorithmSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [nas_algorithm_spec][crate::model::NasJobSpec::nas_algorithm_spec]
    /// to hold a `MultiTrialAlgorithmSpec`.
    ///
    /// Note that all the setters affecting `nas_algorithm_spec` are
    /// mutually exclusive.
    pub fn set_multi_trial_algorithm_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::nas_job_spec::MultiTrialAlgorithmSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nas_algorithm_spec = std::option::Option::Some(
            crate::model::nas_job_spec::NasAlgorithmSpec::MultiTrialAlgorithmSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for NasJobSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec"
    }
}

/// Defines additional types related to NasJobSpec
pub mod nas_job_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The spec of multi-trial Neural Architecture Search (NAS).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiTrialAlgorithmSpec {
        /// The multi-trial Neural Architecture Search (NAS) algorithm
        /// type. Defaults to `REINFORCEMENT_LEARNING`.
        pub multi_trial_algorithm:
            crate::model::nas_job_spec::multi_trial_algorithm_spec::MultiTrialAlgorithm,

        /// Metric specs for the NAS job.
        /// Validation for this field is done at `multi_trial_algorithm_spec` field.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub metric:
            std::option::Option<crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec>,

        /// Required. Spec for search trials.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub search_trial_spec: std::option::Option<
            crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec,
        >,

        /// Spec for train trials. Top N [TrainTrialSpec.max_parallel_trial_count]
        /// search trials will be trained for every M
        /// [TrainTrialSpec.frequency] trials searched.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub train_trial_spec: std::option::Option<
            crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec,
        >,
    }

    impl MultiTrialAlgorithmSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [multi_trial_algorithm][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::multi_trial_algorithm].
        pub fn set_multi_trial_algorithm<
            T: std::convert::Into<
                crate::model::nas_job_spec::multi_trial_algorithm_spec::MultiTrialAlgorithm,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.multi_trial_algorithm = v.into();
            self
        }

        /// Sets the value of [metric][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::metric].
        pub fn set_metric<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metric = v.into();
            self
        }

        /// Sets the value of [search_trial_spec][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::search_trial_spec].
        pub fn set_search_trial_spec<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_trial_spec = v.into();
            self
        }

        /// Sets the value of [train_trial_spec][crate::model::nas_job_spec::MultiTrialAlgorithmSpec::train_trial_spec].
        pub fn set_train_trial_spec<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.train_trial_spec = v.into();
            self
        }
    }

    impl wkt::message::Message for MultiTrialAlgorithmSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec"
        }
    }

    /// Defines additional types related to MultiTrialAlgorithmSpec
    pub mod multi_trial_algorithm_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a metric to optimize.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MetricSpec {
            /// Required. The ID of the metric. Must not contain whitespaces.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub metric_id: std::string::String,

            /// Required. The optimization goal of the metric.
            pub goal: crate::model::nas_job_spec::multi_trial_algorithm_spec::metric_spec::GoalType,
        }

        impl MetricSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [metric_id][crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec::metric_id].
            pub fn set_metric_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.metric_id = v.into();
                self
            }

            /// Sets the value of [goal][crate::model::nas_job_spec::multi_trial_algorithm_spec::MetricSpec::goal].
            pub fn set_goal<
                T: std::convert::Into<
                    crate::model::nas_job_spec::multi_trial_algorithm_spec::metric_spec::GoalType,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.goal = v.into();
                self
            }
        }

        impl wkt::message::Message for MetricSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec"
            }
        }

        /// Defines additional types related to MetricSpec
        pub mod metric_spec {
            #[allow(unused_imports)]
            use super::*;

            /// The available types of optimization goals.
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct GoalType(std::borrow::Cow<'static, str>);

            impl GoalType {
                /// Creates a new GoalType instance.
                pub const fn new(v: &'static str) -> Self {
                    Self(std::borrow::Cow::Borrowed(v))
                }

                /// Gets the enum value.
                pub fn value(&self) -> &str {
                    &self.0
                }
            }

            /// Useful constants to work with [GoalType](GoalType)
            pub mod goal_type {
                use super::GoalType;

                /// Goal Type will default to maximize.
                pub const GOAL_TYPE_UNSPECIFIED: GoalType = GoalType::new("GOAL_TYPE_UNSPECIFIED");

                /// Maximize the goal metric.
                pub const MAXIMIZE: GoalType = GoalType::new("MAXIMIZE");

                /// Minimize the goal metric.
                pub const MINIMIZE: GoalType = GoalType::new("MINIMIZE");
            }

            impl std::convert::From<std::string::String> for GoalType {
                fn from(value: std::string::String) -> Self {
                    Self(std::borrow::Cow::Owned(value))
                }
            }
        }

        /// Represent spec for search trials.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SearchTrialSpec {
            /// Required. The spec of a search trial job. The same spec applies to
            /// all search trials.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub search_trial_job_spec: std::option::Option<crate::model::CustomJobSpec>,

            /// Required. The maximum number of Neural Architecture Search (NAS) trials
            /// to run.
            pub max_trial_count: i32,

            /// Required. The maximum number of trials to run in parallel.
            pub max_parallel_trial_count: i32,

            /// The number of failed trials that need to be seen before failing
            /// the NasJob.
            ///
            /// If set to 0, Vertex AI decides how many trials must fail
            /// before the whole job fails.
            pub max_failed_trial_count: i32,
        }

        impl SearchTrialSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [search_trial_job_spec][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::search_trial_job_spec].
            pub fn set_search_trial_job_spec<
                T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.search_trial_job_spec = v.into();
                self
            }

            /// Sets the value of [max_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::max_trial_count].
            pub fn set_max_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_trial_count = v.into();
                self
            }

            /// Sets the value of [max_parallel_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::max_parallel_trial_count].
            pub fn set_max_parallel_trial_count<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.max_parallel_trial_count = v.into();
                self
            }

            /// Sets the value of [max_failed_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::SearchTrialSpec::max_failed_trial_count].
            pub fn set_max_failed_trial_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_failed_trial_count = v.into();
                self
            }
        }

        impl wkt::message::Message for SearchTrialSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec"
            }
        }

        /// Represent spec for train trials.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TrainTrialSpec {
            /// Required. The spec of a train trial job. The same spec applies to
            /// all train trials.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub train_trial_job_spec: std::option::Option<crate::model::CustomJobSpec>,

            /// Required. The maximum number of trials to run in parallel.
            pub max_parallel_trial_count: i32,

            /// Required. Frequency of search trials to start train stage. Top N
            /// [TrainTrialSpec.max_parallel_trial_count]
            /// search trials will be trained for every M
            /// [TrainTrialSpec.frequency] trials searched.
            pub frequency: i32,
        }

        impl TrainTrialSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [train_trial_job_spec][crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec::train_trial_job_spec].
            pub fn set_train_trial_job_spec<
                T: std::convert::Into<std::option::Option<crate::model::CustomJobSpec>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.train_trial_job_spec = v.into();
                self
            }

            /// Sets the value of [max_parallel_trial_count][crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec::max_parallel_trial_count].
            pub fn set_max_parallel_trial_count<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.max_parallel_trial_count = v.into();
                self
            }

            /// Sets the value of [frequency][crate::model::nas_job_spec::multi_trial_algorithm_spec::TrainTrialSpec::frequency].
            pub fn set_frequency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.frequency = v.into();
                self
            }
        }

        impl wkt::message::Message for TrainTrialSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec"
            }
        }

        /// The available types of multi-trial algorithms.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct MultiTrialAlgorithm(std::borrow::Cow<'static, str>);

        impl MultiTrialAlgorithm {
            /// Creates a new MultiTrialAlgorithm instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [MultiTrialAlgorithm](MultiTrialAlgorithm)
        pub mod multi_trial_algorithm {
            use super::MultiTrialAlgorithm;

            /// Defaults to `REINFORCEMENT_LEARNING`.
            pub const MULTI_TRIAL_ALGORITHM_UNSPECIFIED: MultiTrialAlgorithm =
                MultiTrialAlgorithm::new("MULTI_TRIAL_ALGORITHM_UNSPECIFIED");

            /// The Reinforcement Learning Algorithm for Multi-trial Neural
            /// Architecture Search (NAS).
            pub const REINFORCEMENT_LEARNING: MultiTrialAlgorithm =
                MultiTrialAlgorithm::new("REINFORCEMENT_LEARNING");

            /// The Grid Search Algorithm for Multi-trial Neural
            /// Architecture Search (NAS).
            pub const GRID_SEARCH: MultiTrialAlgorithm = MultiTrialAlgorithm::new("GRID_SEARCH");
        }

        impl std::convert::From<std::string::String> for MultiTrialAlgorithm {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// The Neural Architecture Search (NAS) algorithm specification.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum NasAlgorithmSpec {
        /// The spec of multi-trial algorithms.
        MultiTrialAlgorithmSpec(
            std::boxed::Box<crate::model::nas_job_spec::MultiTrialAlgorithmSpec>,
        ),
    }
}

/// Represents a uCAIP NasJob output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasJobOutput {
    /// The output of this Neural Architecture Search (NAS) job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output: std::option::Option<crate::model::nas_job_output::Output>,
}

impl NasJobOutput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `output`.
    pub fn set_output<
        T: std::convert::Into<std::option::Option<crate::model::nas_job_output::Output>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = v.into();
        self
    }

    /// The value of [output][crate::model::NasJobOutput::output]
    /// if it holds a `MultiTrialJobOutput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_multi_trial_job_output(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::nas_job_output::MultiTrialJobOutput>>
    {
        #[allow(unreachable_patterns)]
        self.output.as_ref().and_then(|v| match v {
            crate::model::nas_job_output::Output::MultiTrialJobOutput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output][crate::model::NasJobOutput::output]
    /// to hold a `MultiTrialJobOutput`.
    ///
    /// Note that all the setters affecting `output` are
    /// mutually exclusive.
    pub fn set_multi_trial_job_output<
        T: std::convert::Into<std::boxed::Box<crate::model::nas_job_output::MultiTrialJobOutput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = std::option::Option::Some(
            crate::model::nas_job_output::Output::MultiTrialJobOutput(v.into()),
        );
        self
    }
}

impl wkt::message::Message for NasJobOutput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJobOutput"
    }
}

/// Defines additional types related to NasJobOutput
pub mod nas_job_output {
    #[allow(unused_imports)]
    use super::*;

    /// The output of a multi-trial Neural Architecture Search (NAS) jobs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiTrialJobOutput {
        /// Output only. List of NasTrials that were started as part of search stage.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub search_trials: std::vec::Vec<crate::model::NasTrial>,

        /// Output only. List of NasTrials that were started as part of train stage.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub train_trials: std::vec::Vec<crate::model::NasTrial>,
    }

    impl MultiTrialJobOutput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search_trials][crate::model::nas_job_output::MultiTrialJobOutput::search_trials].
        pub fn set_search_trials<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::NasTrial>,
        {
            use std::iter::Iterator;
            self.search_trials = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [train_trials][crate::model::nas_job_output::MultiTrialJobOutput::train_trials].
        pub fn set_train_trials<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::NasTrial>,
        {
            use std::iter::Iterator;
            self.train_trials = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MultiTrialJobOutput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NasJobOutput.MultiTrialJobOutput"
        }
    }

    /// The output of this Neural Architecture Search (NAS) job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Output {
        /// Output only. The output of this multi-trial Neural Architecture Search
        /// (NAS) job.
        MultiTrialJobOutput(std::boxed::Box<crate::model::nas_job_output::MultiTrialJobOutput>),
    }
}

/// Represents a uCAIP NasJob trial.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NasTrial {
    /// Output only. The identifier of the NasTrial assigned by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The detailed state of the NasTrial.
    pub state: crate::model::nas_trial::State,

    /// Output only. The final measurement containing the objective value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_measurement: std::option::Option<crate::model::Measurement>,

    /// Output only. Time when the NasTrial was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the NasTrial's status changed to `SUCCEEDED` or
    /// `INFEASIBLE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl NasTrial {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::NasTrial::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NasTrial::state].
    pub fn set_state<T: std::convert::Into<crate::model::nas_trial::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [final_measurement][crate::model::NasTrial::final_measurement].
    pub fn set_final_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.final_measurement = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::NasTrial::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::NasTrial::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for NasTrial {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasTrial"
    }
}

/// Defines additional types related to NasTrial
pub mod nas_trial {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a NasTrial state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The NasTrial state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Indicates that a specific NasTrial has been requested, but it has not yet
        /// been suggested by the service.
        pub const REQUESTED: State = State::new("REQUESTED");

        /// Indicates that the NasTrial has been suggested.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// Indicates that the NasTrial should stop according to the service.
        pub const STOPPING: State = State::new("STOPPING");

        /// Indicates that the NasTrial is completed successfully.
        pub const SUCCEEDED: State = State::new("SUCCEEDED");

        /// Indicates that the NasTrial should not be attempted again.
        /// The service will set a NasTrial to INFEASIBLE when it's done but missing
        /// the final_measurement.
        pub const INFEASIBLE: State = State::new("INFEASIBLE");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Network spec.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkSpec {
    /// Whether to enable public internet access. Default false.
    pub enable_internet_access: bool,

    /// The full name of the Google Compute Engine
    /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// The name of the subnet that this instance is in.
    /// Format:
    /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,
}

impl NetworkSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_internet_access][crate::model::NetworkSpec::enable_internet_access].
    pub fn set_enable_internet_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_internet_access = v.into();
        self
    }

    /// Sets the value of [network][crate::model::NetworkSpec::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkSpec::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }
}

impl wkt::message::Message for NetworkSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NetworkSpec"
    }
}

/// The euc configuration of NotebookRuntimeTemplate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookEucConfig {
    /// Input only. Whether EUC is disabled in this NotebookRuntimeTemplate.
    /// In proto3, the default value of a boolean is false. In this way, by default
    /// EUC will be enabled for NotebookRuntimeTemplate.
    pub euc_disabled: bool,

    /// Output only. Whether ActAs check is bypassed for service account attached
    /// to the VM. If false, we need ActAs check for the default Compute Engine
    /// Service account. When a Runtime is created, a VM is allocated using Default
    /// Compute Engine Service Account. Any user requesting to use this Runtime
    /// requires Service Account User (ActAs) permission over this SA. If true,
    /// Runtime owner is using EUC and does not require the above permission as VM
    /// no longer use default Compute Engine SA, but a P4SA.
    pub bypass_actas_check: bool,
}

impl NotebookEucConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [euc_disabled][crate::model::NotebookEucConfig::euc_disabled].
    pub fn set_euc_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.euc_disabled = v.into();
        self
    }

    /// Sets the value of [bypass_actas_check][crate::model::NotebookEucConfig::bypass_actas_check].
    pub fn set_bypass_actas_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.bypass_actas_check = v.into();
        self
    }
}

impl wkt::message::Message for NotebookEucConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookEucConfig"
    }
}

/// NotebookExecutionJob represents an instance of a notebook execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookExecutionJob {
    /// Output only. The resource name of this NotebookExecutionJob. Format:
    /// `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the NotebookExecutionJob. The name can be up to 128
    /// characters long and can consist of any UTF-8 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Max running time of the execution job in seconds (default 86400s / 24 hrs).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_timeout: std::option::Option<wkt::Duration>,

    /// Output only. The Schedule resource name if this job is triggered by one.
    /// Format:
    /// `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schedule_resource_name: std::string::String,

    /// Output only. The state of the NotebookExecutionJob.
    pub job_state: crate::model::JobState,

    /// Output only. Populated when the NotebookExecutionJob is completed. When
    /// there is an error during notebook execution, the error details are
    /// populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Output only. Timestamp when this NotebookExecutionJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this NotebookExecutionJob was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize NotebookExecutionJobs.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the kernel to use during notebook execution. If unset, the
    /// default kernel is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kernel_name: std::string::String,

    /// Customer-managed encryption key spec for the notebook execution job.
    /// This field is auto-populated if the
    /// [NotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookRuntimeTemplate]
    /// has an encryption spec.
    ///
    /// [google.cloud.aiplatform.v1.NotebookRuntimeTemplate]: crate::model::NotebookRuntimeTemplate
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The input notebook.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_source: std::option::Option<crate::model::notebook_execution_job::NotebookSource>,

    /// The compute config to use for an execution job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub environment_spec:
        std::option::Option<crate::model::notebook_execution_job::EnvironmentSpec>,

    /// The location to store the notebook execution result.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub execution_sink: std::option::Option<crate::model::notebook_execution_job::ExecutionSink>,

    /// The identity to run the execution as.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub execution_identity:
        std::option::Option<crate::model::notebook_execution_job::ExecutionIdentity>,

    /// Runtime environment for the notebook execution job. If unspecified, the
    /// default runtime of Colab is used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_environment:
        std::option::Option<crate::model::notebook_execution_job::RuntimeEnvironment>,
}

impl NotebookExecutionJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotebookExecutionJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotebookExecutionJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::NotebookExecutionJob::execution_timeout].
    pub fn set_execution_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_timeout = v.into();
        self
    }

    /// Sets the value of [schedule_resource_name][crate::model::NotebookExecutionJob::schedule_resource_name].
    pub fn set_schedule_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_resource_name = v.into();
        self
    }

    /// Sets the value of [job_state][crate::model::NotebookExecutionJob::job_state].
    pub fn set_job_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.job_state = v.into();
        self
    }

    /// Sets the value of [status][crate::model::NotebookExecutionJob::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NotebookExecutionJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotebookExecutionJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [kernel_name][crate::model::NotebookExecutionJob::kernel_name].
    pub fn set_kernel_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kernel_name = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NotebookExecutionJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NotebookExecutionJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `notebook_source`.
    pub fn set_notebook_source<
        T: std::convert::Into<
            std::option::Option<crate::model::notebook_execution_job::NotebookSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = v.into();
        self
    }

    /// The value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// if it holds a `DataformRepositorySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_dataform_repository_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::DataformRepositorySource>,
    > {
        #[allow(unreachable_patterns)]
        self.notebook_source.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::NotebookSource::DataformRepositorySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// if it holds a `GcsNotebookSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_notebook_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::GcsNotebookSource>,
    > {
        #[allow(unreachable_patterns)]
        self.notebook_source.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::NotebookSource::GcsNotebookSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// if it holds a `DirectNotebookSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_direct_notebook_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::DirectNotebookSource>,
    > {
        #[allow(unreachable_patterns)]
        self.notebook_source.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::NotebookSource::DirectNotebookSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// to hold a `DataformRepositorySource`.
    ///
    /// Note that all the setters affecting `notebook_source` are
    /// mutually exclusive.
    pub fn set_dataform_repository_source<
        T: std::convert::Into<
            std::boxed::Box<crate::model::notebook_execution_job::DataformRepositorySource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = std::option::Option::Some(
            crate::model::notebook_execution_job::NotebookSource::DataformRepositorySource(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// to hold a `GcsNotebookSource`.
    ///
    /// Note that all the setters affecting `notebook_source` are
    /// mutually exclusive.
    pub fn set_gcs_notebook_source<
        T: std::convert::Into<
            std::boxed::Box<crate::model::notebook_execution_job::GcsNotebookSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = std::option::Option::Some(
            crate::model::notebook_execution_job::NotebookSource::GcsNotebookSource(v.into()),
        );
        self
    }

    /// Sets the value of [notebook_source][crate::model::NotebookExecutionJob::notebook_source]
    /// to hold a `DirectNotebookSource`.
    ///
    /// Note that all the setters affecting `notebook_source` are
    /// mutually exclusive.
    pub fn set_direct_notebook_source<
        T: std::convert::Into<
            std::boxed::Box<crate::model::notebook_execution_job::DirectNotebookSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_source = std::option::Option::Some(
            crate::model::notebook_execution_job::NotebookSource::DirectNotebookSource(v.into()),
        );
        self
    }

    /// Sets the value of `environment_spec`.
    pub fn set_environment_spec<
        T: std::convert::Into<
            std::option::Option<crate::model::notebook_execution_job::EnvironmentSpec>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_spec = v.into();
        self
    }

    /// The value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// if it holds a `NotebookRuntimeTemplateResourceName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_notebook_runtime_template_resource_name(
        &self,
    ) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.environment_spec.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::EnvironmentSpec::NotebookRuntimeTemplateResourceName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// if it holds a `CustomEnvironmentSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_custom_environment_spec(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::notebook_execution_job::CustomEnvironmentSpec>,
    > {
        #[allow(unreachable_patterns)]
        self.environment_spec.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::EnvironmentSpec::CustomEnvironmentSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// to hold a `NotebookRuntimeTemplateResourceName`.
    ///
    /// Note that all the setters affecting `environment_spec` are
    /// mutually exclusive.
    pub fn set_notebook_runtime_template_resource_name<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_spec = std::option::Option::Some(
            crate::model::notebook_execution_job::EnvironmentSpec::NotebookRuntimeTemplateResourceName(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [environment_spec][crate::model::NotebookExecutionJob::environment_spec]
    /// to hold a `CustomEnvironmentSpec`.
    ///
    /// Note that all the setters affecting `environment_spec` are
    /// mutually exclusive.
    pub fn set_custom_environment_spec<
        T: std::convert::Into<
            std::boxed::Box<crate::model::notebook_execution_job::CustomEnvironmentSpec>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_spec = std::option::Option::Some(
            crate::model::notebook_execution_job::EnvironmentSpec::CustomEnvironmentSpec(v.into()),
        );
        self
    }

    /// Sets the value of `execution_sink`.
    pub fn set_execution_sink<
        T: std::convert::Into<
            std::option::Option<crate::model::notebook_execution_job::ExecutionSink>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_sink = v.into();
        self
    }

    /// The value of [execution_sink][crate::model::NotebookExecutionJob::execution_sink]
    /// if it holds a `GcsOutputUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_output_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_sink.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::ExecutionSink::GcsOutputUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_sink][crate::model::NotebookExecutionJob::execution_sink]
    /// to hold a `GcsOutputUri`.
    ///
    /// Note that all the setters affecting `execution_sink` are
    /// mutually exclusive.
    pub fn set_gcs_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_sink = std::option::Option::Some(
            crate::model::notebook_execution_job::ExecutionSink::GcsOutputUri(v.into()),
        );
        self
    }

    /// Sets the value of `execution_identity`.
    pub fn set_execution_identity<
        T: std::convert::Into<
            std::option::Option<crate::model::notebook_execution_job::ExecutionIdentity>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_identity = v.into();
        self
    }

    /// The value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// if it holds a `ExecutionUser`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_execution_user(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_identity.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::ExecutionIdentity::ExecutionUser(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// if it holds a `ServiceAccount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_service_account(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_identity.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::ExecutionIdentity::ServiceAccount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// to hold a `ExecutionUser`.
    ///
    /// Note that all the setters affecting `execution_identity` are
    /// mutually exclusive.
    pub fn set_execution_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_identity = std::option::Option::Some(
            crate::model::notebook_execution_job::ExecutionIdentity::ExecutionUser(v.into()),
        );
        self
    }

    /// Sets the value of [execution_identity][crate::model::NotebookExecutionJob::execution_identity]
    /// to hold a `ServiceAccount`.
    ///
    /// Note that all the setters affecting `execution_identity` are
    /// mutually exclusive.
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution_identity = std::option::Option::Some(
            crate::model::notebook_execution_job::ExecutionIdentity::ServiceAccount(v.into()),
        );
        self
    }

    /// Sets the value of `runtime_environment`.
    pub fn set_runtime_environment<
        T: std::convert::Into<
            std::option::Option<crate::model::notebook_execution_job::RuntimeEnvironment>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_environment = v.into();
        self
    }

    /// The value of [runtime_environment][crate::model::NotebookExecutionJob::runtime_environment]
    /// if it holds a `WorkbenchRuntime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_workbench_runtime(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::notebook_execution_job::WorkbenchRuntime>>
    {
        #[allow(unreachable_patterns)]
        self.runtime_environment.as_ref().and_then(|v| match v {
            crate::model::notebook_execution_job::RuntimeEnvironment::WorkbenchRuntime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_environment][crate::model::NotebookExecutionJob::runtime_environment]
    /// to hold a `WorkbenchRuntime`.
    ///
    /// Note that all the setters affecting `runtime_environment` are
    /// mutually exclusive.
    pub fn set_workbench_runtime<
        T: std::convert::Into<std::boxed::Box<crate::model::notebook_execution_job::WorkbenchRuntime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_environment = std::option::Option::Some(
            crate::model::notebook_execution_job::RuntimeEnvironment::WorkbenchRuntime(v.into()),
        );
        self
    }
}

impl wkt::message::Message for NotebookExecutionJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob"
    }
}

/// Defines additional types related to NotebookExecutionJob
pub mod notebook_execution_job {
    #[allow(unused_imports)]
    use super::*;

    /// The Dataform Repository containing the input notebook.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataformRepositorySource {
        /// The resource name of the Dataform Repository. Format:
        /// `projects/{project_id}/locations/{location}/repositories/{repository_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataform_repository_resource_name: std::string::String,

        /// The commit SHA to read repository with. If unset, the file will be read
        /// at HEAD.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub commit_sha: std::string::String,
    }

    impl DataformRepositorySource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataform_repository_resource_name][crate::model::notebook_execution_job::DataformRepositorySource::dataform_repository_resource_name].
        pub fn set_dataform_repository_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dataform_repository_resource_name = v.into();
            self
        }

        /// Sets the value of [commit_sha][crate::model::notebook_execution_job::DataformRepositorySource::commit_sha].
        pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.commit_sha = v.into();
            self
        }
    }

    impl wkt::message::Message for DataformRepositorySource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.DataformRepositorySource"
        }
    }

    /// The Cloud Storage uri for the input notebook.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsNotebookSource {
        /// The Cloud Storage uri pointing to the ipynb file. Format:
        /// `gs://bucket/notebook_file.ipynb`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// The version of the Cloud Storage object to read. If unset, the current
        /// version of the object is read. See
        /// <https://cloud.google.com/storage/docs/metadata#generation-number>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub generation: std::string::String,
    }

    impl GcsNotebookSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::notebook_execution_job::GcsNotebookSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [generation][crate::model::notebook_execution_job::GcsNotebookSource::generation].
        pub fn set_generation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.generation = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsNotebookSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.GcsNotebookSource"
        }
    }

    /// The content of the input notebook in ipynb format.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DirectNotebookSource {
        /// The base64-encoded contents of the input notebook file.
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub content: bytes::Bytes,
    }

    impl DirectNotebookSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [content][crate::model::notebook_execution_job::DirectNotebookSource::content].
        pub fn set_content<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    impl wkt::message::Message for DirectNotebookSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.DirectNotebookSource"
        }
    }

    /// Compute configuration to use for an execution job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomEnvironmentSpec {
        /// The specification of a single machine for the execution job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_spec: std::option::Option<crate::model::MachineSpec>,

        /// The specification of a persistent disk to attach for the execution job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub persistent_disk_spec: std::option::Option<crate::model::PersistentDiskSpec>,

        /// The network configuration to use for the execution job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub network_spec: std::option::Option<crate::model::NetworkSpec>,
    }

    impl CustomEnvironmentSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_spec][crate::model::notebook_execution_job::CustomEnvironmentSpec::machine_spec].
        pub fn set_machine_spec<
            T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.machine_spec = v.into();
            self
        }

        /// Sets the value of [persistent_disk_spec][crate::model::notebook_execution_job::CustomEnvironmentSpec::persistent_disk_spec].
        pub fn set_persistent_disk_spec<
            T: std::convert::Into<std::option::Option<crate::model::PersistentDiskSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.persistent_disk_spec = v.into();
            self
        }

        /// Sets the value of [network_spec][crate::model::notebook_execution_job::CustomEnvironmentSpec::network_spec].
        pub fn set_network_spec<
            T: std::convert::Into<std::option::Option<crate::model::NetworkSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network_spec = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomEnvironmentSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.CustomEnvironmentSpec"
        }
    }

    /// Configuration for a Workbench Instances-based environment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WorkbenchRuntime {}

    impl WorkbenchRuntime {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for WorkbenchRuntime {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.WorkbenchRuntime"
        }
    }

    /// The input notebook.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum NotebookSource {
        /// The Dataform Repository pointing to a single file notebook repository.
        DataformRepositorySource(
            std::boxed::Box<crate::model::notebook_execution_job::DataformRepositorySource>,
        ),
        /// The Cloud Storage url pointing to the ipynb file. Format:
        /// `gs://bucket/notebook_file.ipynb`
        GcsNotebookSource(std::boxed::Box<crate::model::notebook_execution_job::GcsNotebookSource>),
        /// The contents of an input notebook file.
        DirectNotebookSource(
            std::boxed::Box<crate::model::notebook_execution_job::DirectNotebookSource>,
        ),
    }

    /// The compute config to use for an execution job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EnvironmentSpec {
        /// The NotebookRuntimeTemplate to source compute configuration from.
        NotebookRuntimeTemplateResourceName(std::string::String),
        /// The custom compute configuration for an execution job.
        CustomEnvironmentSpec(
            std::boxed::Box<crate::model::notebook_execution_job::CustomEnvironmentSpec>,
        ),
    }

    /// The location to store the notebook execution result.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ExecutionSink {
        /// The Cloud Storage location to upload the result to. Format:
        /// `gs://bucket-name`
        GcsOutputUri(std::string::String),
    }

    /// The identity to run the execution as.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ExecutionIdentity {
        /// The user email to run the execution as. Only supported by Colab runtimes.
        ExecutionUser(std::string::String),
        /// The service account to run the execution as.
        ServiceAccount(std::string::String),
    }

    /// Runtime environment for the notebook execution job. If unspecified, the
    /// default runtime of Colab is used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RuntimeEnvironment {
        /// The Workbench runtime configuration to use for the notebook execution.
        WorkbenchRuntime(std::boxed::Box<crate::model::notebook_execution_job::WorkbenchRuntime>),
    }
}

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookIdleShutdownConfig {
    /// Required. Duration is accurate to the second. In Notebook, Idle Timeout is
    /// accurate to minute so the range of idle_timeout (second) is: 10 * 60 ~ 1440
    ///
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
    pub idle_shutdown_disabled: bool,
}

impl NotebookIdleShutdownConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_timeout][crate::model::NotebookIdleShutdownConfig::idle_timeout].
    pub fn set_idle_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_timeout = v.into();
        self
    }

    /// Sets the value of [idle_shutdown_disabled][crate::model::NotebookIdleShutdownConfig::idle_shutdown_disabled].
    pub fn set_idle_shutdown_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.idle_shutdown_disabled = v.into();
        self
    }
}

impl wkt::message::Message for NotebookIdleShutdownConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookIdleShutdownConfig"
    }
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
/// Multiple runtimes can be created from a runtime template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookRuntimeTemplate {
    /// The resource name of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the NotebookRuntimeTemplate.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Deprecated: This field has no behavior. Use
    /// notebook_runtime_type = 'ONE_CLICK' instead.
    ///
    /// The default template to use if not specified.
    pub is_default: bool,

    /// Optional. Immutable. The specification of a single machine for the
    /// template.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Optional. The specification of [persistent
    /// disk][<https://cloud.google.com/compute/docs/disks/persistent-disks>]
    /// attached to the runtime as data disk storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_persistent_disk_spec: std::option::Option<crate::model::PersistentDiskSpec>,

    /// Optional. Network spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_spec: std::option::Option<crate::model::NetworkSpec>,

    /// Deprecated: This field is ignored and the "Vertex AI Notebook Service
    /// Account"
    /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
    /// used for the runtime workload identity.
    /// See
    /// <https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account>
    /// for more details.
    /// For NotebookExecutionJob, use NotebookExecutionJob.service_account instead.
    ///
    /// The service account that the runtime workload runs as.
    /// You can use any service account within the same project, but you
    /// must have the service account user permission to use the instance.
    ///
    /// If not specified, the [Compute Engine default service
    /// account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
    /// is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The labels with user-defined metadata to organize the
    /// NotebookRuntimeTemplates.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The idle shutdown configuration of NotebookRuntimeTemplate. This config
    /// will only be set when idle shutdown is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_shutdown_config: std::option::Option<crate::model::NotebookIdleShutdownConfig>,

    /// EUC configuration of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub euc_config: std::option::Option<crate::model::NotebookEucConfig>,

    /// Output only. Timestamp when this NotebookRuntimeTemplate was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this NotebookRuntimeTemplate was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Immutable. The type of the notebook runtime template.
    pub notebook_runtime_type: crate::model::NotebookRuntimeType,

    /// Optional. Immutable. Runtime Shielded VM spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_vm_config: std::option::Option<crate::model::ShieldedVmConfig>,

    /// Optional. The Compute Engine tags to add to runtime (see [Tagging
    /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Customer-managed encryption key spec for the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. The notebook software configuration of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub software_config: std::option::Option<crate::model::NotebookSoftwareConfig>,
}

impl NotebookRuntimeTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotebookRuntimeTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotebookRuntimeTemplate::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotebookRuntimeTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [is_default][crate::model::NotebookRuntimeTemplate::is_default].
    pub fn set_is_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_default = v.into();
        self
    }

    /// Sets the value of [machine_spec][crate::model::NotebookRuntimeTemplate::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [data_persistent_disk_spec][crate::model::NotebookRuntimeTemplate::data_persistent_disk_spec].
    pub fn set_data_persistent_disk_spec<
        T: std::convert::Into<std::option::Option<crate::model::PersistentDiskSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_persistent_disk_spec = v.into();
        self
    }

    /// Sets the value of [network_spec][crate::model::NotebookRuntimeTemplate::network_spec].
    pub fn set_network_spec<
        T: std::convert::Into<std::option::Option<crate::model::NetworkSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::NotebookRuntimeTemplate::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::NotebookRuntimeTemplate::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [idle_shutdown_config][crate::model::NotebookRuntimeTemplate::idle_shutdown_config].
    pub fn set_idle_shutdown_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookIdleShutdownConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.idle_shutdown_config = v.into();
        self
    }

    /// Sets the value of [euc_config][crate::model::NotebookRuntimeTemplate::euc_config].
    pub fn set_euc_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookEucConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.euc_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NotebookRuntimeTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotebookRuntimeTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_type][crate::model::NotebookRuntimeTemplate::notebook_runtime_type].
    pub fn set_notebook_runtime_type<T: std::convert::Into<crate::model::NotebookRuntimeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_type = v.into();
        self
    }

    /// Sets the value of [shielded_vm_config][crate::model::NotebookRuntimeTemplate::shielded_vm_config].
    pub fn set_shielded_vm_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedVmConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_vm_config = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NotebookRuntimeTemplate::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::NotebookRuntimeTemplate::software_config].
    pub fn set_software_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookSoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.software_config = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::NotebookRuntimeTemplate::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NotebookRuntimeTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NotebookRuntimeTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntimeTemplate"
    }
}

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime limited to 24
/// hours.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookRuntime {
    /// Output only. The resource name of the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user email of the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_user: std::string::String,

    /// Output only. The pointer to NotebookRuntimeTemplate this NotebookRuntime is
    /// created from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime_template_ref:
        std::option::Option<crate::model::NotebookRuntimeTemplateRef>,

    /// Output only. The proxy endpoint used to access the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub proxy_uri: std::string::String,

    /// Output only. Timestamp when this NotebookRuntime was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this NotebookRuntime was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The health state of the NotebookRuntime.
    pub health_state: crate::model::notebook_runtime::HealthState,

    /// Required. The display name of the NotebookRuntime.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Deprecated: This field is no longer used and the "Vertex AI
    /// Notebook Service Account"
    /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
    /// used for the runtime workload identity.
    /// See
    /// <https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account>
    /// for more details.
    ///
    /// The service account that the NotebookRuntime workload runs as.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Output only. The runtime (instance) state of the NotebookRuntime.
    pub runtime_state: crate::model::notebook_runtime::RuntimeState,

    /// Output only. Whether NotebookRuntime is upgradable.
    pub is_upgradable: bool,

    /// The labels with user-defined metadata to organize your
    /// NotebookRuntime.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one NotebookRuntime
    /// (System labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable. Following system labels exist for NotebookRuntime:
    ///
    /// * "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output
    ///   only, its value is the Compute Engine instance id.
    /// * "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
    ///   either "bigquery" or "vertex"; if absent, it should be "vertex". This is to
    ///   describe the entry service, either BigQuery or Vertex.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Timestamp when this NotebookRuntime will be expired:
    ///
    /// . System Predefined NotebookRuntime: 24 hours after creation. After
    ///   expiration, system predifined runtime will be deleted.
    /// . User created NotebookRuntime: 6 months after last upgrade. After
    ///   expiration, user created runtime will be stopped and allowed for upgrade.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The VM os image version of NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The type of the notebook runtime.
    pub notebook_runtime_type: crate::model::NotebookRuntimeType,

    /// Output only. The specification of a single machine used by the notebook
    /// runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Output only. The specification of [persistent
    /// disk][<https://cloud.google.com/compute/docs/disks/persistent-disks>]
    /// attached to the notebook runtime as data disk storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_persistent_disk_spec: std::option::Option<crate::model::PersistentDiskSpec>,

    /// Output only. Network spec of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_spec: std::option::Option<crate::model::NetworkSpec>,

    /// Output only. The idle shutdown configuration of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_shutdown_config: std::option::Option<crate::model::NotebookIdleShutdownConfig>,

    /// Output only. EUC configuration of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub euc_config: std::option::Option<crate::model::NotebookEucConfig>,

    /// Output only. Runtime Shielded VM spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_vm_config: std::option::Option<crate::model::ShieldedVmConfig>,

    /// Optional. The Compute Engine tags to add to runtime (see [Tagging
    /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Output only. Software config of the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub software_config: std::option::Option<crate::model::NotebookSoftwareConfig>,

    /// Output only. Customer-managed encryption key spec for the notebook runtime.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl NotebookRuntime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotebookRuntime::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [runtime_user][crate::model::NotebookRuntime::runtime_user].
    pub fn set_runtime_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_user = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template_ref][crate::model::NotebookRuntime::notebook_runtime_template_ref].
    pub fn set_notebook_runtime_template_ref<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntimeTemplateRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template_ref = v.into();
        self
    }

    /// Sets the value of [proxy_uri][crate::model::NotebookRuntime::proxy_uri].
    pub fn set_proxy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.proxy_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NotebookRuntime::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotebookRuntime::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [health_state][crate::model::NotebookRuntime::health_state].
    pub fn set_health_state<T: std::convert::Into<crate::model::notebook_runtime::HealthState>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::NotebookRuntime::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotebookRuntime::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::NotebookRuntime::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [runtime_state][crate::model::NotebookRuntime::runtime_state].
    pub fn set_runtime_state<
        T: std::convert::Into<crate::model::notebook_runtime::RuntimeState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_state = v.into();
        self
    }

    /// Sets the value of [is_upgradable][crate::model::NotebookRuntime::is_upgradable].
    pub fn set_is_upgradable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_upgradable = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::NotebookRuntime::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [version][crate::model::NotebookRuntime::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_type][crate::model::NotebookRuntime::notebook_runtime_type].
    pub fn set_notebook_runtime_type<T: std::convert::Into<crate::model::NotebookRuntimeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_type = v.into();
        self
    }

    /// Sets the value of [machine_spec][crate::model::NotebookRuntime::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [data_persistent_disk_spec][crate::model::NotebookRuntime::data_persistent_disk_spec].
    pub fn set_data_persistent_disk_spec<
        T: std::convert::Into<std::option::Option<crate::model::PersistentDiskSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_persistent_disk_spec = v.into();
        self
    }

    /// Sets the value of [network_spec][crate::model::NotebookRuntime::network_spec].
    pub fn set_network_spec<
        T: std::convert::Into<std::option::Option<crate::model::NetworkSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_spec = v.into();
        self
    }

    /// Sets the value of [idle_shutdown_config][crate::model::NotebookRuntime::idle_shutdown_config].
    pub fn set_idle_shutdown_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookIdleShutdownConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.idle_shutdown_config = v.into();
        self
    }

    /// Sets the value of [euc_config][crate::model::NotebookRuntime::euc_config].
    pub fn set_euc_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookEucConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.euc_config = v.into();
        self
    }

    /// Sets the value of [shielded_vm_config][crate::model::NotebookRuntime::shielded_vm_config].
    pub fn set_shielded_vm_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedVmConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_vm_config = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::NotebookRuntime::software_config].
    pub fn set_software_config<
        T: std::convert::Into<std::option::Option<crate::model::NotebookSoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.software_config = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::NotebookRuntime::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::NotebookRuntime::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::NotebookRuntime::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::NotebookRuntime::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NotebookRuntime::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NotebookRuntime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntime"
    }
}

/// Defines additional types related to NotebookRuntime
pub mod notebook_runtime {
    #[allow(unused_imports)]
    use super::*;

    /// The substate of the NotebookRuntime to display health information.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HealthState(std::borrow::Cow<'static, str>);

    impl HealthState {
        /// Creates a new HealthState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [HealthState](HealthState)
    pub mod health_state {
        use super::HealthState;

        /// Unspecified health state.
        pub const HEALTH_STATE_UNSPECIFIED: HealthState =
            HealthState::new("HEALTH_STATE_UNSPECIFIED");

        /// NotebookRuntime is in healthy state. Applies to ACTIVE state.
        pub const HEALTHY: HealthState = HealthState::new("HEALTHY");

        /// NotebookRuntime is in unhealthy state. Applies to ACTIVE state.
        pub const UNHEALTHY: HealthState = HealthState::new("UNHEALTHY");
    }

    impl std::convert::From<std::string::String> for HealthState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The substate of the NotebookRuntime to display state of runtime.
    /// The resource of NotebookRuntime is in ACTIVE state for these sub state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RuntimeState(std::borrow::Cow<'static, str>);

    impl RuntimeState {
        /// Creates a new RuntimeState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [RuntimeState](RuntimeState)
    pub mod runtime_state {
        use super::RuntimeState;

        /// Unspecified runtime state.
        pub const RUNTIME_STATE_UNSPECIFIED: RuntimeState =
            RuntimeState::new("RUNTIME_STATE_UNSPECIFIED");

        /// NotebookRuntime is in running state.
        pub const RUNNING: RuntimeState = RuntimeState::new("RUNNING");

        /// NotebookRuntime is in starting state.
        pub const BEING_STARTED: RuntimeState = RuntimeState::new("BEING_STARTED");

        /// NotebookRuntime is in stopping state.
        pub const BEING_STOPPED: RuntimeState = RuntimeState::new("BEING_STOPPED");

        /// NotebookRuntime is in stopped state.
        pub const STOPPED: RuntimeState = RuntimeState::new("STOPPED");

        /// NotebookRuntime is in upgrading state. It is in the middle of upgrading
        /// process.
        pub const BEING_UPGRADED: RuntimeState = RuntimeState::new("BEING_UPGRADED");

        /// NotebookRuntime was unable to start/stop properly.
        pub const ERROR: RuntimeState = RuntimeState::new("ERROR");

        /// NotebookRuntime is in invalid state. Cannot be recovered.
        pub const INVALID: RuntimeState = RuntimeState::new("INVALID");
    }

    impl std::convert::From<std::string::String> for RuntimeState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Points to a NotebookRuntimeTemplateRef.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookRuntimeTemplateRef {
    /// Immutable. A resource name of the NotebookRuntimeTemplate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_template: std::string::String,
}

impl NotebookRuntimeTemplateRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notebook_runtime_template][crate::model::NotebookRuntimeTemplateRef::notebook_runtime_template].
    pub fn set_notebook_runtime_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }
}

impl wkt::message::Message for NotebookRuntimeTemplateRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntimeTemplateRef"
    }
}

/// Request message for
/// [NotebookService.CreateNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate]: crate::client::NotebookService::create_notebook_runtime_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookRuntimeTemplateRequest {
    /// Required. The resource name of the Location to create the
    /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NotebookRuntimeTemplate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime_template: std::option::Option<crate::model::NotebookRuntimeTemplate>,

    /// Optional. User specified ID for the notebook runtime template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_template_id: std::string::String,
}

impl CreateNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNotebookRuntimeTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template][crate::model::CreateNotebookRuntimeTemplateRequest::notebook_runtime_template].
    pub fn set_notebook_runtime_template<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntimeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template_id][crate::model::CreateNotebookRuntimeTemplateRequest::notebook_runtime_template_id].
    pub fn set_notebook_runtime_template_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateRequest"
    }
}

/// Metadata information for
/// [NotebookService.CreateNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookRuntimeTemplate]: crate::client::NotebookService::create_notebook_runtime_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookRuntimeTemplateOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateNotebookRuntimeTemplateOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateNotebookRuntimeTemplateOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateNotebookRuntimeTemplateOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateOperationMetadata"
    }
}

/// Request message for
/// [NotebookService.GetNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntimeTemplate]
///
/// [google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntimeTemplate]: crate::client::NotebookService::get_notebook_runtime_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotebookRuntimeTemplateRequest {
    /// Required. The name of the NotebookRuntimeTemplate resource.
    /// Format:
    /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotebookRuntimeTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookRuntimeTemplateRequest"
    }
}

/// Request message for
/// [NotebookService.ListNotebookRuntimeTemplates][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]: crate::client::NotebookService::list_notebook_runtime_templates
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimeTemplatesRequest {
    /// Required. The resource name of the Location from which to list the
    /// NotebookRuntimeTemplates.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
    ///   represents the NotebookRuntimeTemplate ID,
    ///   i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
    ///   [google.cloud.aiplatform.v1.NotebookRuntimeTemplate.name].
    /// * `display_name` supports = and !=
    /// * `labels` supports general map functions that is:
    ///   * `labels.key=value` - key:value equality
    ///   * `labels.key:* or labels:key - key existence
    ///   * A key including a space must be quoted. `labels."a key"`.
    /// * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
    ///   [USER_DEFINED, ONE_CLICK].
    /// * `machineType` supports = and !=.
    /// * `acceleratorType` supports = and !=.
    ///
    /// Some examples:
    ///
    /// * `notebookRuntimeTemplate=notebookRuntimeTemplate123`
    /// * `displayName="myDisplayName"`
    /// * `labels.myKey="myValue"`
    /// * `notebookRuntimeType=USER_DEFINED`
    /// * `machineType=e2-standard-4`
    /// * `acceleratorType=NVIDIA_TESLA_T4`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListNotebookRuntimeTemplatesResponse.next_page_token][google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse.next_page_token]
    /// of the previous
    /// [NotebookService.ListNotebookRuntimeTemplates][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse.next_page_token]: crate::model::ListNotebookRuntimeTemplatesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]: crate::client::NotebookService::list_notebook_runtime_templates
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending. Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListNotebookRuntimeTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotebookRuntimeTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotebookRuntimeTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotebookRuntimeTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotebookRuntimeTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListNotebookRuntimeTemplatesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotebookRuntimeTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNotebookRuntimeTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest"
    }
}

/// Response message for
/// [NotebookService.ListNotebookRuntimeTemplates][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimeTemplates]: crate::client::NotebookService::list_notebook_runtime_templates
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimeTemplatesResponse {
    /// List of NotebookRuntimeTemplates in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notebook_runtime_templates: std::vec::Vec<crate::model::NotebookRuntimeTemplate>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListNotebookRuntimeTemplatesRequest.page_token][google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest.page_token]: crate::model::ListNotebookRuntimeTemplatesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNotebookRuntimeTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNotebookRuntimeTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_templates][crate::model::ListNotebookRuntimeTemplatesResponse::notebook_runtime_templates].
    pub fn set_notebook_runtime_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotebookRuntimeTemplate>,
    {
        use std::iter::Iterator;
        self.notebook_runtime_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNotebookRuntimeTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNotebookRuntimeTemplatesResponse {
    type PageItem = crate::model::NotebookRuntimeTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notebook_runtime_templates
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [NotebookService.DeleteNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntimeTemplate]: crate::client::NotebookService::delete_notebook_runtime_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotebookRuntimeTemplateRequest {
    /// Required. The name of the NotebookRuntimeTemplate resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotebookRuntimeTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookRuntimeTemplateRequest"
    }
}

/// Request message for
/// [NotebookService.UpdateNotebookRuntimeTemplate][google.cloud.aiplatform.v1.NotebookService.UpdateNotebookRuntimeTemplate].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpdateNotebookRuntimeTemplate]: crate::client::NotebookService::update_notebook_runtime_template
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNotebookRuntimeTemplateRequest {
    /// Required. The NotebookRuntimeTemplate to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime_template: std::option::Option<crate::model::NotebookRuntimeTemplate>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. Input format:
    /// `{paths: "${updated_filed}"}` Updatable fields:
    ///
    /// * `encryption_spec.kms_key_name`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateNotebookRuntimeTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notebook_runtime_template][crate::model::UpdateNotebookRuntimeTemplateRequest::notebook_runtime_template].
    pub fn set_notebook_runtime_template<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntimeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNotebookRuntimeTemplateRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNotebookRuntimeTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateNotebookRuntimeTemplateRequest"
    }
}

/// Request message for
/// [NotebookService.AssignNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime]: crate::client::NotebookService::assign_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignNotebookRuntimeRequest {
    /// Required. The resource name of the Location to get the NotebookRuntime
    /// assignment. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource name of the NotebookRuntimeTemplate based on which a
    /// NotebookRuntime will be assigned (reuse or create a new one).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_template: std::string::String,

    /// Required. Provide runtime specific information (e.g. runtime owner,
    /// notebook id) used for NotebookRuntime assignment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_runtime: std::option::Option<crate::model::NotebookRuntime>,

    /// Optional. User specified ID for the notebook runtime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_runtime_id: std::string::String,
}

impl AssignNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AssignNotebookRuntimeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_template][crate::model::AssignNotebookRuntimeRequest::notebook_runtime_template].
    pub fn set_notebook_runtime_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [notebook_runtime][crate::model::AssignNotebookRuntimeRequest::notebook_runtime].
    pub fn set_notebook_runtime<
        T: std::convert::Into<std::option::Option<crate::model::NotebookRuntime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime = v.into();
        self
    }

    /// Sets the value of [notebook_runtime_id][crate::model::AssignNotebookRuntimeRequest::notebook_runtime_id].
    pub fn set_notebook_runtime_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_runtime_id = v.into();
        self
    }
}

impl wkt::message::Message for AssignNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AssignNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.AssignNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.AssignNotebookRuntime]: crate::client::NotebookService::assign_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl AssignNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::AssignNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::AssignNotebookRuntimeOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for AssignNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AssignNotebookRuntimeOperationMetadata"
    }
}

/// Request message for
/// [NotebookService.GetNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntime]
///
/// [google.cloud.aiplatform.v1.NotebookService.GetNotebookRuntime]: crate::client::NotebookService::get_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookRuntimeRequest"
    }
}

/// Request message for
/// [NotebookService.ListNotebookRuntimes][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]: crate::client::NotebookService::list_notebook_runtimes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimesRequest {
    /// Required. The resource name of the Location from which to list the
    /// NotebookRuntimes.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `notebookRuntime` supports = and !=. `notebookRuntime` represents the
    ///   NotebookRuntime ID,
    ///   i.e. the last segment of the NotebookRuntime's [resource name]
    ///   [google.cloud.aiplatform.v1.NotebookRuntime.name].
    /// * `displayName` supports = and != and regex.
    /// * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
    ///   represents the NotebookRuntimeTemplate ID,
    ///   i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
    ///   [google.cloud.aiplatform.v1.NotebookRuntimeTemplate.name].
    /// * `healthState` supports = and !=. healthState enum: [HEALTHY, UNHEALTHY,
    ///   HEALTH_STATE_UNSPECIFIED].
    /// * `runtimeState` supports = and !=. runtimeState enum:
    ///   [RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
    ///   STOPPED, BEING_UPGRADED, ERROR, INVALID].
    /// * `runtimeUser` supports = and !=.
    /// * API version is UI only: `uiState` supports = and !=. uiState enum:
    ///   [UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
    ///   UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
    ///   UI_RESOURCE_STATE_CREATION_FAILED].
    /// * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
    ///   [USER_DEFINED, ONE_CLICK].
    /// * `machineType` supports = and !=.
    /// * `acceleratorType` supports = and !=.
    ///
    /// Some examples:
    ///
    /// * `notebookRuntime="notebookRuntime123"`
    /// * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
    /// * `notebookRuntimeTemplate="notebookRuntimeTemplate321"`
    /// * `healthState=HEALTHY`
    /// * `runtimeState=RUNNING`
    /// * `runtimeUser="test@google.com"`
    /// * `uiState=UI_RESOURCE_STATE_BEING_DELETED`
    /// * `notebookRuntimeType=USER_DEFINED`
    /// * `machineType=e2-standard-4`
    /// * `acceleratorType=NVIDIA_TESLA_T4`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListNotebookRuntimesResponse.next_page_token][google.cloud.aiplatform.v1.ListNotebookRuntimesResponse.next_page_token]
    /// of the previous
    /// [NotebookService.ListNotebookRuntimes][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimesResponse.next_page_token]: crate::model::ListNotebookRuntimesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]: crate::client::NotebookService::list_notebook_runtimes
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending. Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListNotebookRuntimesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotebookRuntimesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotebookRuntimesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotebookRuntimesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotebookRuntimesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListNotebookRuntimesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotebookRuntimesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNotebookRuntimesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimesRequest"
    }
}

/// Response message for
/// [NotebookService.ListNotebookRuntimes][google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes].
///
/// [google.cloud.aiplatform.v1.NotebookService.ListNotebookRuntimes]: crate::client::NotebookService::list_notebook_runtimes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookRuntimesResponse {
    /// List of NotebookRuntimes in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notebook_runtimes: std::vec::Vec<crate::model::NotebookRuntime>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListNotebookRuntimesRequest.page_token][google.cloud.aiplatform.v1.ListNotebookRuntimesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookRuntimesRequest.page_token]: crate::model::ListNotebookRuntimesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNotebookRuntimesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNotebookRuntimesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [notebook_runtimes][crate::model::ListNotebookRuntimesResponse::notebook_runtimes].
    pub fn set_notebook_runtimes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotebookRuntime>,
    {
        use std::iter::Iterator;
        self.notebook_runtimes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNotebookRuntimesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNotebookRuntimesResponse {
    type PageItem = crate::model::NotebookRuntime;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notebook_runtimes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [NotebookService.DeleteNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.DeleteNotebookRuntime]: crate::client::NotebookService::delete_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be deleted.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookRuntimeRequest"
    }
}

/// Request message for
/// [NotebookService.UpgradeNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime]: crate::client::NotebookService::upgrade_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be upgrade.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl UpgradeNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.UpgradeNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime]: crate::client::NotebookService::upgrade_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl UpgradeNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpgradeNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::UpgradeNotebookRuntimeOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeOperationMetadata"
    }
}

/// Response message for
/// [NotebookService.UpgradeNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.UpgradeNotebookRuntime]: crate::client::NotebookService::upgrade_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeNotebookRuntimeResponse {}

impl UpgradeNotebookRuntimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpgradeNotebookRuntimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeResponse"
    }
}

/// Request message for
/// [NotebookService.StartNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime]: crate::client::NotebookService::start_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be started.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StartNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.StartNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime]: crate::client::NotebookService::start_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl StartNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::StartNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::StartNotebookRuntimeOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for StartNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeOperationMetadata"
    }
}

/// Response message for
/// [NotebookService.StartNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StartNotebookRuntime]: crate::client::NotebookService::start_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartNotebookRuntimeResponse {}

impl StartNotebookRuntimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartNotebookRuntimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeResponse"
    }
}

/// Request message for
/// [NotebookService.StopNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime]: crate::client::NotebookService::stop_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopNotebookRuntimeRequest {
    /// Required. The name of the NotebookRuntime resource to be stopped.
    /// Instead of checking whether the name is in valid NotebookRuntime resource
    /// name format, directly throw NotFound exception if there is no such
    /// NotebookRuntime in spanner.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StopNotebookRuntimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopNotebookRuntimeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopNotebookRuntimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeRequest"
    }
}

/// Metadata information for
/// [NotebookService.StopNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime]: crate::client::NotebookService::stop_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopNotebookRuntimeOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl StopNotebookRuntimeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::StopNotebookRuntimeOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for StopNotebookRuntimeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeOperationMetadata"
    }
}

/// Response message for
/// [NotebookService.StopNotebookRuntime][google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime].
///
/// [google.cloud.aiplatform.v1.NotebookService.StopNotebookRuntime]: crate::client::NotebookService::stop_notebook_runtime
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopNotebookRuntimeResponse {}

impl StopNotebookRuntimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StopNotebookRuntimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeResponse"
    }
}

/// Request message for [NotebookService.CreateNotebookExecutionJob]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookExecutionJobRequest {
    /// Required. The resource name of the Location to create the
    /// NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NotebookExecutionJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notebook_execution_job: std::option::Option<crate::model::NotebookExecutionJob>,

    /// Optional. User specified ID for the NotebookExecutionJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_execution_job_id: std::string::String,
}

impl CreateNotebookExecutionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNotebookExecutionJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [notebook_execution_job][crate::model::CreateNotebookExecutionJobRequest::notebook_execution_job].
    pub fn set_notebook_execution_job<
        T: std::convert::Into<std::option::Option<crate::model::NotebookExecutionJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_execution_job = v.into();
        self
    }

    /// Sets the value of [notebook_execution_job_id][crate::model::CreateNotebookExecutionJobRequest::notebook_execution_job_id].
    pub fn set_notebook_execution_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_execution_job_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNotebookExecutionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookExecutionJobRequest"
    }
}

/// Metadata information for
/// [NotebookService.CreateNotebookExecutionJob][google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob].
///
/// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob]: crate::client::NotebookService::create_notebook_execution_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNotebookExecutionJobOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// A human-readable message that shows the intermediate progress details of
    /// NotebookRuntime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl CreateNotebookExecutionJobOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateNotebookExecutionJobOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::CreateNotebookExecutionJobOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for CreateNotebookExecutionJobOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookExecutionJobOperationMetadata"
    }
}

/// Request message for [NotebookService.GetNotebookExecutionJob]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNotebookExecutionJobRequest {
    /// Required. The name of the NotebookExecutionJob resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
    pub view: crate::model::NotebookExecutionJobView,
}

impl GetNotebookExecutionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotebookExecutionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetNotebookExecutionJobRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::NotebookExecutionJobView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetNotebookExecutionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookExecutionJobRequest"
    }
}

/// Request message for [NotebookService.ListNotebookExecutionJobs]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookExecutionJobsRequest {
    /// Required. The resource name of the Location from which to list the
    /// NotebookExecutionJobs.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the results of the request. For field
    /// names both snake_case and camelCase are supported.
    ///
    /// * `notebookExecutionJob` supports = and !=. `notebookExecutionJob`
    ///   represents the NotebookExecutionJob ID.
    /// * `displayName` supports = and != and regex.
    /// * `schedule` supports = and != and regex.
    ///
    /// Some examples:
    ///
    /// * `notebookExecutionJob="123"`
    /// * `notebookExecutionJob="my-execution-job"`
    /// * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListNotebookExecutionJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse.next_page_token]
    /// of the previous
    /// [NotebookService.ListNotebookExecutionJobs][google.cloud.aiplatform.v1.NotebookService.ListNotebookExecutionJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse.next_page_token]: crate::model::ListNotebookExecutionJobsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.NotebookService.ListNotebookExecutionJobs]: crate::client::NotebookService::list_notebook_execution_jobs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending. Supported fields:
    ///
    /// * `display_name`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `display_name, create_time desc`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
    pub view: crate::model::NotebookExecutionJobView,
}

impl ListNotebookExecutionJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotebookExecutionJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNotebookExecutionJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotebookExecutionJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotebookExecutionJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNotebookExecutionJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListNotebookExecutionJobsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::NotebookExecutionJobView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListNotebookExecutionJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest"
    }
}

/// Response message for [NotebookService.CreateNotebookExecutionJob]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNotebookExecutionJobsResponse {
    /// List of NotebookExecutionJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub notebook_execution_jobs: std::vec::Vec<crate::model::NotebookExecutionJob>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListNotebookExecutionJobsRequest.page_token][google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest.page_token]: crate::model::ListNotebookExecutionJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListNotebookExecutionJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNotebookExecutionJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [notebook_execution_jobs][crate::model::ListNotebookExecutionJobsResponse::notebook_execution_jobs].
    pub fn set_notebook_execution_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotebookExecutionJob>,
    {
        use std::iter::Iterator;
        self.notebook_execution_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNotebookExecutionJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNotebookExecutionJobsResponse {
    type PageItem = crate::model::NotebookExecutionJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notebook_execution_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for [NotebookService.DeleteNotebookExecutionJob]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNotebookExecutionJobRequest {
    /// Required. The name of the NotebookExecutionJob resource to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteNotebookExecutionJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotebookExecutionJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNotebookExecutionJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookExecutionJobRequest"
    }
}

/// Post startup script config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostStartupScriptConfig {
    /// Optional. Post startup script to run after runtime is started.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub post_startup_script: std::string::String,

    /// Optional. Post startup script url to download. Example:
    /// https://bucket/script.sh
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub post_startup_script_url: std::string::String,

    /// Optional. Post startup script behavior that defines download and execution
    /// behavior.
    pub post_startup_script_behavior:
        crate::model::post_startup_script_config::PostStartupScriptBehavior,
}

impl PostStartupScriptConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [post_startup_script][crate::model::PostStartupScriptConfig::post_startup_script].
    pub fn set_post_startup_script<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script = v.into();
        self
    }

    /// Sets the value of [post_startup_script_url][crate::model::PostStartupScriptConfig::post_startup_script_url].
    pub fn set_post_startup_script_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script_url = v.into();
        self
    }

    /// Sets the value of [post_startup_script_behavior][crate::model::PostStartupScriptConfig::post_startup_script_behavior].
    pub fn set_post_startup_script_behavior<
        T: std::convert::Into<crate::model::post_startup_script_config::PostStartupScriptBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script_behavior = v.into();
        self
    }
}

impl wkt::message::Message for PostStartupScriptConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PostStartupScriptConfig"
    }
}

/// Defines additional types related to PostStartupScriptConfig
pub mod post_startup_script_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a notebook runtime post startup script behavior.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PostStartupScriptBehavior(std::borrow::Cow<'static, str>);

    impl PostStartupScriptBehavior {
        /// Creates a new PostStartupScriptBehavior instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [PostStartupScriptBehavior](PostStartupScriptBehavior)
    pub mod post_startup_script_behavior {
        use super::PostStartupScriptBehavior;

        /// Unspecified post startup script behavior.
        pub const POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED: PostStartupScriptBehavior =
            PostStartupScriptBehavior::new("POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED");

        /// Run post startup script after runtime is started.
        pub const RUN_ONCE: PostStartupScriptBehavior = PostStartupScriptBehavior::new("RUN_ONCE");

        /// Run post startup script after runtime is stopped.
        pub const RUN_EVERY_START: PostStartupScriptBehavior =
            PostStartupScriptBehavior::new("RUN_EVERY_START");

        /// Download and run post startup script every time runtime is started.
        pub const DOWNLOAD_AND_RUN_EVERY_START: PostStartupScriptBehavior =
            PostStartupScriptBehavior::new("DOWNLOAD_AND_RUN_EVERY_START");
    }

    impl std::convert::From<std::string::String> for PostStartupScriptBehavior {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Notebook Software Config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotebookSoftwareConfig {
    /// Optional. Environment variables to be passed to the container.
    /// Maximum limit is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    /// Optional. Post startup script config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_startup_script_config: std::option::Option<crate::model::PostStartupScriptConfig>,
}

impl NotebookSoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [post_startup_script_config][crate::model::NotebookSoftwareConfig::post_startup_script_config].
    pub fn set_post_startup_script_config<
        T: std::convert::Into<std::option::Option<crate::model::PostStartupScriptConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_startup_script_config = v.into();
        self
    }

    /// Sets the value of [env][crate::model::NotebookSoftwareConfig::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NotebookSoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookSoftwareConfig"
    }
}

/// Schema is used to define the format of input/output data. Represents a select
/// subset of an [OpenAPI 3.0 schema
/// object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
/// be added in the future as needed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schema {
    /// Optional. The type of the data.
    #[serde(rename = "type")]
    pub r#type: crate::model::Type,

    /// Optional. The format of the data.
    /// Supported formats:
    /// for NUMBER type: "float", "double"
    /// for INTEGER type: "int32", "int64"
    /// for STRING type: "email", "byte", etc
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub format: std::string::String,

    /// Optional. The title of the Schema.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Optional. The description of the data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Indicates if the value may be null.
    pub nullable: bool,

    /// Optional. Default value of the data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default: std::option::Option<wkt::Value>,

    /// Optional. SCHEMA FIELDS FOR TYPE ARRAY
    /// Schema of the elements of Type.ARRAY.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub items: std::option::Option<std::boxed::Box<crate::model::Schema>>,

    /// Optional. Minimum number of the elements for Type.ARRAY.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_items: i64,

    /// Optional. Maximum number of the elements for Type.ARRAY.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_items: i64,

    /// Optional. Possible values of the element of primitive type with enum
    /// format. Examples:
    ///
    /// . We can define direction as :
    ///   {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
    /// . We can define apartment number as :
    ///   {type:INTEGER, format:enum, enum:["101", "201", "301"]}
    #[serde(rename = "enum")]
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub r#enum: std::vec::Vec<std::string::String>,

    /// Optional. SCHEMA FIELDS FOR TYPE OBJECT
    /// Properties of Type.OBJECT.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, crate::model::Schema>,

    /// Optional. The order of the properties.
    /// Not a standard field in open api spec. Only used to support the order of
    /// the properties.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub property_ordering: std::vec::Vec<std::string::String>,

    /// Optional. Required properties of Type.OBJECT.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub required: std::vec::Vec<std::string::String>,

    /// Optional. Minimum number of the properties for Type.OBJECT.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_properties: i64,

    /// Optional. Maximum number of the properties for Type.OBJECT.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_properties: i64,

    /// Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER
    /// Minimum value of the Type.INTEGER and Type.NUMBER
    pub minimum: f64,

    /// Optional. Maximum value of the Type.INTEGER and Type.NUMBER
    pub maximum: f64,

    /// Optional. SCHEMA FIELDS FOR TYPE STRING
    /// Minimum length of the Type.STRING
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_length: i64,

    /// Optional. Maximum length of the Type.STRING
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_length: i64,

    /// Optional. Pattern of the Type.STRING to restrict a string to a regular
    /// expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pattern: std::string::String,

    /// Optional. Example of the object. Will only populated when the object is the
    /// root.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub example: std::option::Option<wkt::Value>,

    /// Optional. The value should be validated against any (one or more) of the
    /// subschemas in the list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub any_of: std::vec::Vec<crate::model::Schema>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Schema::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Schema::format].
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Schema::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Schema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::Schema::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [default][crate::model::Schema::default].
    pub fn set_default<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.default = v.into();
        self
    }

    /// Sets the value of [items][crate::model::Schema::items].
    pub fn set_items<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Schema>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.items = v.into();
        self
    }

    /// Sets the value of [min_items][crate::model::Schema::min_items].
    pub fn set_min_items<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min_items = v.into();
        self
    }

    /// Sets the value of [max_items][crate::model::Schema::max_items].
    pub fn set_max_items<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_items = v.into();
        self
    }

    /// Sets the value of [min_properties][crate::model::Schema::min_properties].
    pub fn set_min_properties<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min_properties = v.into();
        self
    }

    /// Sets the value of [max_properties][crate::model::Schema::max_properties].
    pub fn set_max_properties<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_properties = v.into();
        self
    }

    /// Sets the value of [minimum][crate::model::Schema::minimum].
    pub fn set_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.minimum = v.into();
        self
    }

    /// Sets the value of [maximum][crate::model::Schema::maximum].
    pub fn set_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.maximum = v.into();
        self
    }

    /// Sets the value of [min_length][crate::model::Schema::min_length].
    pub fn set_min_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min_length = v.into();
        self
    }

    /// Sets the value of [max_length][crate::model::Schema::max_length].
    pub fn set_max_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_length = v.into();
        self
    }

    /// Sets the value of [pattern][crate::model::Schema::pattern].
    pub fn set_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pattern = v.into();
        self
    }

    /// Sets the value of [example][crate::model::Schema::example].
    pub fn set_example<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.example = v.into();
        self
    }

    /// Sets the value of [r#enum][crate::model::Schema::enum].
    pub fn set_enum<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.r#enum = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [property_ordering][crate::model::Schema::property_ordering].
    pub fn set_property_ordering<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.property_ordering = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [required][crate::model::Schema::required].
    pub fn set_required<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.required = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [any_of][crate::model::Schema::any_of].
    pub fn set_any_of<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.any_of = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::Schema::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Schema"
    }
}

/// Generic Metadata shared by all operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenericOperationMetadata {
    /// Output only. Partial failures encountered.
    /// E.g. single files that couldn't be read.
    /// This field should never exceed 20 entries.
    /// Status details field will contain standard Google Cloud error details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_failures: std::vec::Vec<rpc::model::Status>,

    /// Output only. Time when the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the operation was updated for the last time.
    /// If the operation has finished (successfully or not), this is the finish
    /// time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl GenericOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::GenericOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::GenericOperationMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [partial_failures][crate::model::GenericOperationMetadata::partial_failures].
    pub fn set_partial_failures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_failures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenericOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenericOperationMetadata"
    }
}

/// Details of operations that perform deletes of any entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl DeleteOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::DeleteOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteOperationMetadata"
    }
}

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
/// A PersistentResource can have multiple node pools and each node
/// pool can have its own machine spec.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersistentResource {
    /// Immutable. Resource name of a PersistentResource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The display name of the PersistentResource.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The spec of the pools of different resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_pools: std::vec::Vec<crate::model::ResourcePool>,

    /// Output only. The detailed state of a Study.
    pub state: crate::model::persistent_resource::State,

    /// Output only. Only populated when persistent resource's state is `STOPPING`
    /// or `ERROR`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Time when the PersistentResource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the PersistentResource for the first time entered
    /// the `RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the PersistentResource was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels with user-defined metadata to organize
    /// PersistentResource.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The full name of the Compute Engine
    /// [network](/compute/docs/networks-and-firewalls#networks) to peered with
    /// Vertex AI to host the persistent resources.
    /// For example, `projects/12345/global/networks/myVPC`.
    /// [Format](/compute/docs/reference/rest/v1/networks/insert)
    /// is of the form `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in `12345`, and {network} is a
    /// network name.
    ///
    /// To specify this field, you must have already [configured VPC Network
    /// Peering for Vertex
    /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
    ///
    /// If this field is left unspecified, the resources aren't peered with any
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Customer-managed encryption key spec for a PersistentResource.
    /// If set, this PersistentResource and all sub-resources of this
    /// PersistentResource will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Optional. Persistent Resource runtime spec.
    /// For example, used for Ray cluster configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_runtime_spec: std::option::Option<crate::model::ResourceRuntimeSpec>,

    /// Output only. Runtime information of the Persistent Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_runtime: std::option::Option<crate::model::ResourceRuntime>,

    /// Optional. A list of names for the reserved IP ranges under the VPC network
    /// that can be used for this persistent resource.
    ///
    /// If set, we will deploy the persistent resource within the provided IP
    /// ranges. Otherwise, the persistent resource is deployed to any IP
    /// ranges under the provided VPC network.
    ///
    /// Example: ['vertex-ai-ip-range'].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,
}

impl PersistentResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PersistentResource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PersistentResource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PersistentResource::state].
    pub fn set_state<T: std::convert::Into<crate::model::persistent_resource::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PersistentResource::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PersistentResource::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::PersistentResource::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PersistentResource::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PersistentResource::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::PersistentResource::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [resource_runtime_spec][crate::model::PersistentResource::resource_runtime_spec].
    pub fn set_resource_runtime_spec<
        T: std::convert::Into<std::option::Option<crate::model::ResourceRuntimeSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_runtime_spec = v.into();
        self
    }

    /// Sets the value of [resource_runtime][crate::model::PersistentResource::resource_runtime].
    pub fn set_resource_runtime<
        T: std::convert::Into<std::option::Option<crate::model::ResourceRuntime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_runtime = v.into();
        self
    }

    /// Sets the value of [resource_pools][crate::model::PersistentResource::resource_pools].
    pub fn set_resource_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourcePool>,
    {
        use std::iter::Iterator;
        self.resource_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::PersistentResource::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::PersistentResource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PersistentResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PersistentResource"
    }
}

/// Defines additional types related to PersistentResource
pub mod persistent_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the PersistentResource state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The PROVISIONING state indicates the persistent resources is being
        /// created.
        pub const PROVISIONING: State = State::new("PROVISIONING");

        /// The RUNNING state indicates the persistent resource is healthy and fully
        /// usable.
        pub const RUNNING: State = State::new("RUNNING");

        /// The STOPPING state indicates the persistent resource is being deleted.
        pub const STOPPING: State = State::new("STOPPING");

        /// The ERROR state indicates the persistent resource may be unusable.
        /// Details can be found in the `error` field.
        pub const ERROR: State = State::new("ERROR");

        /// The REBOOTING state indicates the persistent resource is being rebooted
        /// (PR is not available right now but is expected to be ready again later).
        pub const REBOOTING: State = State::new("REBOOTING");

        /// The UPDATING state indicates the persistent resource is being updated.
        pub const UPDATING: State = State::new("UPDATING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Represents the spec of a group of resources of the same type,
/// for example machine type, disk, and accelerators, in a PersistentResource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourcePool {
    /// Immutable. The unique ID in a PersistentResource for referring to this
    /// resource pool. User can specify it if necessary. Otherwise, it's generated
    /// automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Required. Immutable. The specification of a single machine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_spec: std::option::Option<crate::model::MachineSpec>,

    /// Optional. The total number of machines to use for this resource pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub replica_count: std::option::Option<i64>,

    /// Optional. Disk spec for the machine in this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_spec: std::option::Option<crate::model::DiskSpec>,

    /// Output only. The number of machines currently in use by training jobs for
    /// this resource pool. Will replace idle_replica_count.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub used_replica_count: i64,

    /// Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_spec: std::option::Option<crate::model::resource_pool::AutoscalingSpec>,
}

impl ResourcePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ResourcePool::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [machine_spec][crate::model::ResourcePool::machine_spec].
    pub fn set_machine_spec<
        T: std::convert::Into<std::option::Option<crate::model::MachineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_spec = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::ResourcePool::replica_count].
    pub fn set_replica_count<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [disk_spec][crate::model::ResourcePool::disk_spec].
    pub fn set_disk_spec<T: std::convert::Into<std::option::Option<crate::model::DiskSpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_spec = v.into();
        self
    }

    /// Sets the value of [used_replica_count][crate::model::ResourcePool::used_replica_count].
    pub fn set_used_replica_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.used_replica_count = v.into();
        self
    }

    /// Sets the value of [autoscaling_spec][crate::model::ResourcePool::autoscaling_spec].
    pub fn set_autoscaling_spec<
        T: std::convert::Into<std::option::Option<crate::model::resource_pool::AutoscalingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_spec = v.into();
        self
    }
}

impl wkt::message::Message for ResourcePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourcePool"
    }
}

/// Defines additional types related to ResourcePool
pub mod resource_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The min/max number of replicas allowed if enabling autoscaling
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutoscalingSpec {
        /// Optional. min replicas in the node pool,
        /// must be ≤ replica_count and < max_replica_count or will throw error.
        /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
        /// resource_pool to be 0 to match the OSS Ray
        /// behavior(<https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters>).
        /// As for Persistent Resource, the min_replica_count must be > 0, we added
        /// a corresponding validation inside
        /// CreatePersistentResourceRequestValidator.java.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub min_replica_count: std::option::Option<i64>,

        /// Optional. max replicas in the node pool,
        /// must be ≥ replica_count and > min_replica_count or will throw error
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub max_replica_count: std::option::Option<i64>,
    }

    impl AutoscalingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_replica_count][crate::model::resource_pool::AutoscalingSpec::min_replica_count].
        pub fn set_min_replica_count<T: std::convert::Into<std::option::Option<i64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_replica_count = v.into();
            self
        }

        /// Sets the value of [max_replica_count][crate::model::resource_pool::AutoscalingSpec::max_replica_count].
        pub fn set_max_replica_count<T: std::convert::Into<std::option::Option<i64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_replica_count = v.into();
            self
        }
    }

    impl wkt::message::Message for AutoscalingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ResourcePool.AutoscalingSpec"
        }
    }
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to:
///
/// * Service accounts used to run the workloads.
/// * Whether to make it a dedicated Ray Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRuntimeSpec {
    /// Optional. Configure the use of workload identity on the PersistentResource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_account_spec: std::option::Option<crate::model::ServiceAccountSpec>,

    /// Optional. Ray cluster configuration.
    /// Required when creating a dedicated RayCluster on the PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_spec: std::option::Option<crate::model::RaySpec>,
}

impl ResourceRuntimeSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_spec][crate::model::ResourceRuntimeSpec::service_account_spec].
    pub fn set_service_account_spec<
        T: std::convert::Into<std::option::Option<crate::model::ServiceAccountSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_spec = v.into();
        self
    }

    /// Sets the value of [ray_spec][crate::model::ResourceRuntimeSpec::ray_spec].
    pub fn set_ray_spec<T: std::convert::Into<std::option::Option<crate::model::RaySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ray_spec = v.into();
        self
    }
}

impl wkt::message::Message for ResourceRuntimeSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourceRuntimeSpec"
    }
}

/// Configuration information for the Ray cluster.
/// For experimental launch, Ray cluster creation and Persistent
/// cluster creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RaySpec {
    /// Optional. Default image for user to choose a preferred ML framework
    /// (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt
    /// images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
    /// Either this or the resource_pool_images is required. Use this field if
    /// you need all the resource pools to have the same Ray image. Otherwise, use
    /// the {@code resource_pool_images} field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Optional. Required if image_uri isn't set. A map of resource_pool_id to
    /// prebuild Ray image if user need to use different images for different
    /// head/worker pools. This map needs to cover all the resource pool ids.
    /// Example:
    /// {
    /// "ray_head_node_pool": "head image"
    /// "ray_worker_node_pool1": "worker image"
    /// "ray_worker_node_pool2": "another worker image"
    /// }
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_pool_images: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This will be used to indicate which resource pool will serve as
    /// the Ray head node(the first node within that pool). Will use the machine
    /// from the first workerpool as the head node by default if this field isn't
    /// set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub head_node_resource_pool_id: std::string::String,

    /// Optional. Ray metrics configurations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_metric_spec: std::option::Option<crate::model::RayMetricSpec>,

    /// Optional. OSS Ray logging configurations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_logs_spec: std::option::Option<crate::model::RayLogsSpec>,
}

impl RaySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_uri][crate::model::RaySpec::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [head_node_resource_pool_id][crate::model::RaySpec::head_node_resource_pool_id].
    pub fn set_head_node_resource_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.head_node_resource_pool_id = v.into();
        self
    }

    /// Sets the value of [ray_metric_spec][crate::model::RaySpec::ray_metric_spec].
    pub fn set_ray_metric_spec<
        T: std::convert::Into<std::option::Option<crate::model::RayMetricSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_metric_spec = v.into();
        self
    }

    /// Sets the value of [ray_logs_spec][crate::model::RaySpec::ray_logs_spec].
    pub fn set_ray_logs_spec<
        T: std::convert::Into<std::option::Option<crate::model::RayLogsSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_logs_spec = v.into();
        self
    }

    /// Sets the value of [resource_pool_images][crate::model::RaySpec::resource_pool_images].
    pub fn set_resource_pool_images<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_pool_images = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RaySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RaySpec"
    }
}

/// Persistent Cluster runtime information as output
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRuntime {
    /// Output only. URIs for user to connect to the Cluster.
    /// Example:
    /// {
    /// "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
    /// "RAY_DASHBOARD_URI": "ray-dashboard-address:8888"
    /// }
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub access_uris: std::collections::HashMap<std::string::String, std::string::String>,
}

impl ResourceRuntime {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_uris][crate::model::ResourceRuntime::access_uris].
    pub fn set_access_uris<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.access_uris = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceRuntime {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourceRuntime"
    }
}

/// Configuration for the use of custom service account to run the workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceAccountSpec {
    /// Required. If true, custom user-managed service account is enforced to run
    /// any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses
    /// the [Vertex AI Custom Code Service
    /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
    pub enable_custom_service_account: bool,

    /// Optional. Required when all below conditions are met
    ///
    /// * `enable_custom_service_account` is true;
    /// * any runtime is specified via `ResourceRuntimeSpec` on creation time,
    ///   for example, Ray
    ///
    /// The users must have `iam.serviceAccounts.actAs` permission on this service
    /// account and then the specified runtime containers will run as it.
    ///
    /// Do not set this field if you want to submit jobs using custom service
    /// account to this PersistentResource after creation, but only specify the
    /// `service_account` inside the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,
}

impl ServiceAccountSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_custom_service_account][crate::model::ServiceAccountSpec::enable_custom_service_account].
    pub fn set_enable_custom_service_account<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_custom_service_account = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::ServiceAccountSpec::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for ServiceAccountSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ServiceAccountSpec"
    }
}

/// Configuration for the Ray metrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayMetricSpec {
    /// Optional. Flag to disable the Ray metrics collection.
    pub disabled: bool,
}

impl RayMetricSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::RayMetricSpec::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for RayMetricSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RayMetricSpec"
    }
}

/// Configuration for the Ray OSS Logs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayLogsSpec {
    /// Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
    pub disabled: bool,
}

impl RayLogsSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::RayLogsSpec::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for RayLogsSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RayLogsSpec"
    }
}

/// Request message for
/// [PersistentResourceService.CreatePersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.CreatePersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.CreatePersistentResource]: crate::client::PersistentResourceService::create_persistent_resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePersistentResourceRequest {
    /// Required. The resource name of the Location to create the
    /// PersistentResource in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The PersistentResource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistent_resource: std::option::Option<crate::model::PersistentResource>,

    /// Required. The ID to use for the PersistentResource, which become the final
    /// component of the PersistentResource's resource name.
    ///
    /// The maximum length is 63 characters, and valid characters
    /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub persistent_resource_id: std::string::String,
}

impl CreatePersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePersistentResourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [persistent_resource][crate::model::CreatePersistentResourceRequest::persistent_resource].
    pub fn set_persistent_resource<
        T: std::convert::Into<std::option::Option<crate::model::PersistentResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource = v.into();
        self
    }

    /// Sets the value of [persistent_resource_id][crate::model::CreatePersistentResourceRequest::persistent_resource_id].
    pub fn set_persistent_resource_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource_id = v.into();
        self
    }
}

impl wkt::message::Message for CreatePersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePersistentResourceRequest"
    }
}

/// Details of operations that perform create PersistentResource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePersistentResourceOperationMetadata {
    /// Operation metadata for PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Progress Message for Create LRO
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl CreatePersistentResourceOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreatePersistentResourceOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::CreatePersistentResourceOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for CreatePersistentResourceOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePersistentResourceOperationMetadata"
    }
}

/// Details of operations that perform update PersistentResource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePersistentResourceOperationMetadata {
    /// Operation metadata for PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Progress Message for Update LRO
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl UpdatePersistentResourceOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdatePersistentResourceOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::UpdatePersistentResourceOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePersistentResourceOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdatePersistentResourceOperationMetadata"
    }
}

/// Details of operations that perform reboot PersistentResource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebootPersistentResourceOperationMetadata {
    /// Operation metadata for PersistentResource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// Progress Message for Reboot LRO
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub progress_message: std::string::String,
}

impl RebootPersistentResourceOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::RebootPersistentResourceOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [progress_message][crate::model::RebootPersistentResourceOperationMetadata::progress_message].
    pub fn set_progress_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.progress_message = v.into();
        self
    }
}

impl wkt::message::Message for RebootPersistentResourceOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebootPersistentResourceOperationMetadata"
    }
}

/// Request message for
/// [PersistentResourceService.GetPersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.GetPersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.GetPersistentResource]: crate::client::PersistentResourceService::get_persistent_resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPersistentResourceRequest {
    /// Required. The name of the PersistentResource resource.
    /// Format:
    /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPersistentResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPersistentResourceRequest"
    }
}

/// Request message for
/// [PersistentResourceService.ListPersistentResources][google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources]: crate::client::PersistentResourceService::list_persistent_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPersistentResourcesRequest {
    /// Required. The resource name of the Location to list the PersistentResources
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListPersistentResourcesResponse.next_page_token][google.cloud.aiplatform.v1.ListPersistentResourcesResponse.next_page_token]
    /// of the previous [PersistentResourceService.ListPersistentResource][] call.
    ///
    /// [google.cloud.aiplatform.v1.ListPersistentResourcesResponse.next_page_token]: crate::model::ListPersistentResourcesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListPersistentResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPersistentResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPersistentResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPersistentResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPersistentResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPersistentResourcesRequest"
    }
}

/// Response message for
/// [PersistentResourceService.ListPersistentResources][google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources]
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.ListPersistentResources]: crate::client::PersistentResourceService::list_persistent_resources
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPersistentResourcesResponse {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub persistent_resources: std::vec::Vec<crate::model::PersistentResource>,

    /// A token to retrieve next page of results.
    /// Pass to
    /// [ListPersistentResourcesRequest.page_token][google.cloud.aiplatform.v1.ListPersistentResourcesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListPersistentResourcesRequest.page_token]: crate::model::ListPersistentResourcesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPersistentResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPersistentResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [persistent_resources][crate::model::ListPersistentResourcesResponse::persistent_resources].
    pub fn set_persistent_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PersistentResource>,
    {
        use std::iter::Iterator;
        self.persistent_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPersistentResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPersistentResourcesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPersistentResourcesResponse {
    type PageItem = crate::model::PersistentResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.persistent_resources
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [PersistentResourceService.DeletePersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.DeletePersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.DeletePersistentResource]: crate::client::PersistentResourceService::delete_persistent_resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePersistentResourceRequest {
    /// Required. The name of the PersistentResource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeletePersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePersistentResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeletePersistentResourceRequest"
    }
}

/// Request message for UpdatePersistentResource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePersistentResourceRequest {
    /// Required. The PersistentResource to update.
    ///
    /// The PersistentResource's `name` field is used to identify the
    /// PersistentResource to update. Format:
    /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistent_resource: std::option::Option<crate::model::PersistentResource>,

    /// Required. Specify the fields to be overwritten in the PersistentResource by
    /// the update method.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdatePersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [persistent_resource][crate::model::UpdatePersistentResourceRequest::persistent_resource].
    pub fn set_persistent_resource<
        T: std::convert::Into<std::option::Option<crate::model::PersistentResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.persistent_resource = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePersistentResourceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdatePersistentResourceRequest"
    }
}

/// Request message for
/// [PersistentResourceService.RebootPersistentResource][google.cloud.aiplatform.v1.PersistentResourceService.RebootPersistentResource].
///
/// [google.cloud.aiplatform.v1.PersistentResourceService.RebootPersistentResource]: crate::client::PersistentResourceService::reboot_persistent_resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebootPersistentResourceRequest {
    /// Required. The name of the PersistentResource resource.
    /// Format:
    /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RebootPersistentResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RebootPersistentResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RebootPersistentResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebootPersistentResourceRequest"
    }
}

/// An instance of a machine learning PipelineJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineJob {
    /// Output only. The resource name of the PipelineJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the Pipeline.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Pipeline creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Pipeline start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Pipeline end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this PipelineJob was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The spec of the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_spec: std::option::Option<wkt::Struct>,

    /// Output only. The detailed state of the job.
    pub state: crate::model::PipelineState,

    /// Output only. The details of pipeline run. Not available in the list view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_detail: std::option::Option<crate::model::PipelineJobDetail>,

    /// Output only. The error that occurred during pipeline execution.
    /// Only populated when the pipeline's state is FAILED or CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The labels with user-defined metadata to organize PipelineJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    ///
    /// Note there is some reserved label key for Vertex AI Pipelines.
    ///
    /// - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Runtime config of the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::pipeline_job::RuntimeConfig>,

    /// Customer-managed encryption key spec for a pipelineJob. If set, this
    /// PipelineJob and all of its sub-resources will be secured by this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The service account that the pipeline workload runs as.
    /// If not specified, the Compute Engine default service account in the project
    /// will be used.
    /// See
    /// <https://cloud.google.com/compute/docs/access/service-accounts#default_service_account>
    ///
    /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The full name of the Compute Engine
    /// [network](/compute/docs/networks-and-firewalls#networks) to which the
    /// Pipeline Job's workload should be peered. For example,
    /// `projects/12345/global/networks/myVPC`.
    /// [Format](/compute/docs/reference/rest/v1/networks/insert)
    /// is of the form `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in `12345`, and {network} is a
    /// network name.
    ///
    /// Private services access must already be configured for the network.
    /// Pipeline job will apply the network configuration to the Google Cloud
    /// resources being launched, if applied, such as Vertex AI
    /// Training or Dataflow job. If left unspecified, the workload is not peered
    /// with any network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// A list of names for the reserved ip ranges under the VPC network
    /// that can be used for this Pipeline Job's workload.
    ///
    /// If set, we will deploy the Pipeline Job's workload within the provided ip
    /// ranges. Otherwise, the job will be deployed to any ip ranges under the
    /// provided VPC network.
    ///
    /// Example: ['vertex-ai-ip-range'].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reserved_ip_ranges: std::vec::Vec<std::string::String>,

    /// A template uri from where the
    /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec],
    /// if empty, will be downloaded. Currently, only uri from Vertex Template
    /// Registry & Gallery is supported. Reference to
    /// <https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template>.
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template_uri: std::string::String,

    /// Output only. Pipeline template metadata. Will fill up fields if
    /// [PipelineJob.template_uri][google.cloud.aiplatform.v1.PipelineJob.template_uri]
    /// is from supported template registry.
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.template_uri]: crate::model::PipelineJob::template_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template_metadata: std::option::Option<crate::model::PipelineTemplateMetadata>,

    /// Output only. The schedule resource name.
    /// Only returned if the Pipeline is created by Schedule API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schedule_name: std::string::String,

    /// Optional. Whether to do component level validations before job creation.
    pub preflight_validations: bool,
}

impl PipelineJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PipelineJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PipelineJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PipelineJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::PipelineJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::PipelineJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PipelineJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [pipeline_spec][crate::model::PipelineJob::pipeline_spec].
    pub fn set_pipeline_spec<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PipelineJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::PipelineState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [job_detail][crate::model::PipelineJob::job_detail].
    pub fn set_job_detail<
        T: std::convert::Into<std::option::Option<crate::model::PipelineJobDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_detail = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PipelineJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [runtime_config][crate::model::PipelineJob::runtime_config].
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::pipeline_job::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::PipelineJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::PipelineJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PipelineJob::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [template_uri][crate::model::PipelineJob::template_uri].
    pub fn set_template_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template_uri = v.into();
        self
    }

    /// Sets the value of [template_metadata][crate::model::PipelineJob::template_metadata].
    pub fn set_template_metadata<
        T: std::convert::Into<std::option::Option<crate::model::PipelineTemplateMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template_metadata = v.into();
        self
    }

    /// Sets the value of [schedule_name][crate::model::PipelineJob::schedule_name].
    pub fn set_schedule_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule_name = v.into();
        self
    }

    /// Sets the value of [preflight_validations][crate::model::PipelineJob::preflight_validations].
    pub fn set_preflight_validations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.preflight_validations = v.into();
        self
    }

    /// Sets the value of [reserved_ip_ranges][crate::model::PipelineJob::reserved_ip_ranges].
    pub fn set_reserved_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reserved_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::PipelineJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PipelineJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob"
    }
}

/// Defines additional types related to PipelineJob
pub mod pipeline_job {
    #[allow(unused_imports)]
    use super::*;

    /// The runtime config of a PipelineJob.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RuntimeConfig {
        /// Deprecated. Use
        /// [RuntimeConfig.parameter_values][google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.parameter_values]
        /// instead. The runtime parameters of the PipelineJob. The parameters will
        /// be passed into
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// to replace the placeholders at runtime. This field is used by pipelines
        /// built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower,
        /// such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
        ///
        /// [google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.parameter_values]: crate::model::pipeline_job::RuntimeConfig::parameter_values
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub parameters: std::collections::HashMap<std::string::String, crate::model::Value>,

        /// Required. A path in a Cloud Storage bucket, which will be treated as the
        /// root output directory of the pipeline. It is used by the system to
        /// generate the paths of output artifacts. The artifact paths are generated
        /// with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the
        /// specified output directory. The service account specified in this
        /// pipeline must have the `storage.objects.get` and `storage.objects.create`
        /// permissions for this bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub gcs_output_directory: std::string::String,

        /// The runtime parameters of the PipelineJob. The parameters will be
        /// passed into
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// to replace the placeholders at runtime. This field is used by pipelines
        /// built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as
        /// pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2
        /// DSL.
        ///
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub parameter_values: std::collections::HashMap<std::string::String, wkt::Value>,

        /// Represents the failure policy of a pipeline. Currently, the default of a
        /// pipeline is that the pipeline will continue to run until no more tasks
        /// can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW.
        /// However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it
        /// will stop scheduling any new tasks when a task has failed. Any scheduled
        /// tasks will continue to completion.
        pub failure_policy: crate::model::PipelineFailurePolicy,

        /// The runtime artifacts of the PipelineJob. The key will be the input
        /// artifact name and the value would be one of the InputArtifact.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub input_artifacts: std::collections::HashMap<
            std::string::String,
            crate::model::pipeline_job::runtime_config::InputArtifact,
        >,
    }

    impl RuntimeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [gcs_output_directory][crate::model::pipeline_job::RuntimeConfig::gcs_output_directory].
        pub fn set_gcs_output_directory<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcs_output_directory = v.into();
            self
        }

        /// Sets the value of [failure_policy][crate::model::pipeline_job::RuntimeConfig::failure_policy].
        pub fn set_failure_policy<T: std::convert::Into<crate::model::PipelineFailurePolicy>>(
            mut self,
            v: T,
        ) -> Self {
            self.failure_policy = v.into();
            self
        }

        /// Sets the value of [parameters][crate::model::pipeline_job::RuntimeConfig::parameters].
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::Value>,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [parameter_values][crate::model::pipeline_job::RuntimeConfig::parameter_values].
        pub fn set_parameter_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.parameter_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [input_artifacts][crate::model::pipeline_job::RuntimeConfig::input_artifacts].
        pub fn set_input_artifacts<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::pipeline_job::runtime_config::InputArtifact>,
        {
            use std::iter::Iterator;
            self.input_artifacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for RuntimeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig"
        }
    }

    /// Defines additional types related to RuntimeConfig
    pub mod runtime_config {
        #[allow(unused_imports)]
        use super::*;

        /// The type of an input artifact.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct InputArtifact {
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub kind: std::option::Option<
                crate::model::pipeline_job::runtime_config::input_artifact::Kind,
            >,
        }

        impl InputArtifact {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of `kind`.
            pub fn set_kind<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::pipeline_job::runtime_config::input_artifact::Kind,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.kind = v.into();
                self
            }

            /// The value of [kind][crate::model::pipeline_job::runtime_config::InputArtifact::kind]
            /// if it holds a `ArtifactId`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_artifact_id(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.kind.as_ref().and_then(|v| match v {
                    crate::model::pipeline_job::runtime_config::input_artifact::Kind::ArtifactId(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [kind][crate::model::pipeline_job::runtime_config::InputArtifact::kind]
            /// to hold a `ArtifactId`.
            ///
            /// Note that all the setters affecting `kind` are
            /// mutually exclusive.
            pub fn set_artifact_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kind = std::option::Option::Some(
                    crate::model::pipeline_job::runtime_config::input_artifact::Kind::ArtifactId(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for InputArtifact {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.InputArtifact"
            }
        }

        /// Defines additional types related to InputArtifact
        pub mod input_artifact {
            #[allow(unused_imports)]
            use super::*;

            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Kind {
                /// Artifact resource id from MLMD. Which is the last portion of an
                /// artifact resource name:
                /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
                /// The artifact must stay within the same project, location and default
                /// metadatastore as the pipeline.
                ArtifactId(std::string::String),
            }
        }
    }
}

/// Pipeline template metadata if
/// [PipelineJob.template_uri][google.cloud.aiplatform.v1.PipelineJob.template_uri]
/// is from supported template registry. Currently, the only supported registry
/// is Artifact Registry.
///
/// [google.cloud.aiplatform.v1.PipelineJob.template_uri]: crate::model::PipelineJob::template_uri
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineTemplateMetadata {
    /// The version_name in artifact registry.
    ///
    /// Will always be presented in output if the
    /// [PipelineJob.template_uri][google.cloud.aiplatform.v1.PipelineJob.template_uri]
    /// is from supported template registry.
    ///
    /// Format is "sha256:abcdef123456...".
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.template_uri]: crate::model::PipelineJob::template_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl PipelineTemplateMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::PipelineTemplateMetadata::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for PipelineTemplateMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTemplateMetadata"
    }
}

/// The runtime detail of PipelineJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineJobDetail {
    /// Output only. The context of the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_context: std::option::Option<crate::model::Context>,

    /// Output only. The context of the current pipeline run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_run_context: std::option::Option<crate::model::Context>,

    /// Output only. The runtime details of the tasks under the pipeline.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub task_details: std::vec::Vec<crate::model::PipelineTaskDetail>,
}

impl PipelineJobDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_context][crate::model::PipelineJobDetail::pipeline_context].
    pub fn set_pipeline_context<
        T: std::convert::Into<std::option::Option<crate::model::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_context = v.into();
        self
    }

    /// Sets the value of [pipeline_run_context][crate::model::PipelineJobDetail::pipeline_run_context].
    pub fn set_pipeline_run_context<
        T: std::convert::Into<std::option::Option<crate::model::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_run_context = v.into();
        self
    }

    /// Sets the value of [task_details][crate::model::PipelineJobDetail::task_details].
    pub fn set_task_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineTaskDetail>,
    {
        use std::iter::Iterator;
        self.task_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PipelineJobDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJobDetail"
    }
}

/// The runtime detail of a task execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineTaskDetail {
    /// Output only. The system generated ID of the task.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub task_id: i64,

    /// Output only. The id of the parent task if the task is within a component
    /// scope. Empty if the task is at the root level.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parent_task_id: i64,

    /// Output only. The user specified name of the task that is defined in
    /// [pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec].
    ///
    /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub task_name: std::string::String,

    /// Output only. Task create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Task start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Task end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The detailed execution info.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub executor_detail: std::option::Option<crate::model::PipelineTaskExecutorDetail>,

    /// Output only. State of the task.
    pub state: crate::model::pipeline_task_detail::State,

    /// Output only. The execution metadata of the task.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution: std::option::Option<crate::model::Execution>,

    /// Output only. The error that occurred during task execution.
    /// Only populated when the task's state is FAILED or CANCELLED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. A list of task status. This field keeps a record of task
    /// status evolving over time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_task_status: std::vec::Vec<crate::model::pipeline_task_detail::PipelineTaskStatus>,

    /// Output only. The runtime input artifacts of the task.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub inputs: std::collections::HashMap<
        std::string::String,
        crate::model::pipeline_task_detail::ArtifactList,
    >,

    /// Output only. The runtime output artifacts of the task.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub outputs: std::collections::HashMap<
        std::string::String,
        crate::model::pipeline_task_detail::ArtifactList,
    >,
}

impl PipelineTaskDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [task_id][crate::model::PipelineTaskDetail::task_id].
    pub fn set_task_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.task_id = v.into();
        self
    }

    /// Sets the value of [parent_task_id][crate::model::PipelineTaskDetail::parent_task_id].
    pub fn set_parent_task_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parent_task_id = v.into();
        self
    }

    /// Sets the value of [task_name][crate::model::PipelineTaskDetail::task_name].
    pub fn set_task_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.task_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PipelineTaskDetail::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::PipelineTaskDetail::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::PipelineTaskDetail::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [executor_detail][crate::model::PipelineTaskDetail::executor_detail].
    pub fn set_executor_detail<
        T: std::convert::Into<std::option::Option<crate::model::PipelineTaskExecutorDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.executor_detail = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PipelineTaskDetail::state].
    pub fn set_state<T: std::convert::Into<crate::model::pipeline_task_detail::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::PipelineTaskDetail::execution].
    pub fn set_execution<T: std::convert::Into<std::option::Option<crate::model::Execution>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PipelineTaskDetail::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [pipeline_task_status][crate::model::PipelineTaskDetail::pipeline_task_status].
    pub fn set_pipeline_task_status<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pipeline_task_detail::PipelineTaskStatus>,
    {
        use std::iter::Iterator;
        self.pipeline_task_status = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inputs][crate::model::PipelineTaskDetail::inputs].
    pub fn set_inputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::pipeline_task_detail::ArtifactList>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [outputs][crate::model::PipelineTaskDetail::outputs].
    pub fn set_outputs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::pipeline_task_detail::ArtifactList>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PipelineTaskDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail"
    }
}

/// Defines additional types related to PipelineTaskDetail
pub mod pipeline_task_detail {
    #[allow(unused_imports)]
    use super::*;

    /// A single record of the task status.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PipelineTaskStatus {
        /// Output only. Update time of this status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The state of the task.
        pub state: crate::model::pipeline_task_detail::State,

        /// Output only. The error that occurred during the state. May be set when
        /// the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or
        /// FAILED state. If the state is FAILED, the error here is final and not
        /// going to be retried. If the state is a non-final state, the error
        /// indicates a system-error being retried.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub error: std::option::Option<rpc::model::Status>,
    }

    impl PipelineTaskStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_time][crate::model::pipeline_task_detail::PipelineTaskStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [state][crate::model::pipeline_task_detail::PipelineTaskStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::pipeline_task_detail::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::pipeline_task_detail::PipelineTaskStatus::error].
        pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for PipelineTaskStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail.PipelineTaskStatus"
        }
    }

    /// A list of artifact metadata.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArtifactList {
        /// Output only. A list of artifact metadata.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub artifacts: std::vec::Vec<crate::model::Artifact>,
    }

    impl ArtifactList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [artifacts][crate::model::pipeline_task_detail::ArtifactList::artifacts].
        pub fn set_artifacts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Artifact>,
        {
            use std::iter::Iterator;
            self.artifacts = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ArtifactList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail.ArtifactList"
        }
    }

    /// Specifies state of TaskExecution
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Specifies pending state for the task.
        pub const PENDING: State = State::new("PENDING");

        /// Specifies task is being executed.
        pub const RUNNING: State = State::new("RUNNING");

        /// Specifies task completed successfully.
        pub const SUCCEEDED: State = State::new("SUCCEEDED");

        /// Specifies Task cancel is in pending state.
        pub const CANCEL_PENDING: State = State::new("CANCEL_PENDING");

        /// Specifies task is being cancelled.
        pub const CANCELLING: State = State::new("CANCELLING");

        /// Specifies task was cancelled.
        pub const CANCELLED: State = State::new("CANCELLED");

        /// Specifies task failed.
        pub const FAILED: State = State::new("FAILED");

        /// Specifies task was skipped due to cache hit.
        pub const SKIPPED: State = State::new("SKIPPED");

        /// Specifies that the task was not triggered because the task's trigger
        /// policy is not satisfied. The trigger policy is specified in the
        /// `condition` field of
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec].
        ///
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        pub const NOT_TRIGGERED: State = State::new("NOT_TRIGGERED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// The runtime detail of a pipeline executor.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineTaskExecutorDetail {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::pipeline_task_executor_detail::Details>,
}

impl PipelineTaskExecutorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `details`.
    pub fn set_details<
        T: std::convert::Into<
            std::option::Option<crate::model::pipeline_task_executor_detail::Details>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// if it holds a `ContainerDetail`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_container_detail(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::pipeline_task_executor_detail::ContainerDetail>,
    > {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::pipeline_task_executor_detail::Details::ContainerDetail(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// if it holds a `CustomJobDetail`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_custom_job_detail(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::pipeline_task_executor_detail::CustomJobDetail>,
    > {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::pipeline_task_executor_detail::Details::CustomJobDetail(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// to hold a `ContainerDetail`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_container_detail<
        T: std::convert::Into<
            std::boxed::Box<crate::model::pipeline_task_executor_detail::ContainerDetail>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::pipeline_task_executor_detail::Details::ContainerDetail(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::PipelineTaskExecutorDetail::details]
    /// to hold a `CustomJobDetail`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_custom_job_detail<
        T: std::convert::Into<
            std::boxed::Box<crate::model::pipeline_task_executor_detail::CustomJobDetail>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::pipeline_task_executor_detail::Details::CustomJobDetail(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PipelineTaskExecutorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail"
    }
}

/// Defines additional types related to PipelineTaskExecutorDetail
pub mod pipeline_task_executor_detail {
    #[allow(unused_imports)]
    use super::*;

    /// The detail of a container execution. It contains the job names of the
    /// lifecycle of a container execution.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ContainerDetail {
        /// Output only. The name of the
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the main container
        /// execution.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub main_job: std::string::String,

        /// Output only. The name of the
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the
        /// pre-caching-check container execution. This job will be available if the
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// specifies the `pre_caching_check` hook in the lifecycle events.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pre_caching_check_job: std::string::String,

        /// Output only. The names of the previously failed
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the main container
        /// executions. The list includes the all attempts in chronological order.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failed_main_jobs: std::vec::Vec<std::string::String>,

        /// Output only. The names of the previously failed
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob] for the
        /// pre-caching-check container executions. This job will be available if the
        /// [PipelineJob.pipeline_spec][google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]
        /// specifies the `pre_caching_check` hook in the lifecycle events. The list
        /// includes the all attempts in chronological order.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        /// [google.cloud.aiplatform.v1.PipelineJob.pipeline_spec]: crate::model::PipelineJob::pipeline_spec
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failed_pre_caching_check_jobs: std::vec::Vec<std::string::String>,
    }

    impl ContainerDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [main_job][crate::model::pipeline_task_executor_detail::ContainerDetail::main_job].
        pub fn set_main_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.main_job = v.into();
            self
        }

        /// Sets the value of [pre_caching_check_job][crate::model::pipeline_task_executor_detail::ContainerDetail::pre_caching_check_job].
        pub fn set_pre_caching_check_job<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pre_caching_check_job = v.into();
            self
        }

        /// Sets the value of [failed_main_jobs][crate::model::pipeline_task_executor_detail::ContainerDetail::failed_main_jobs].
        pub fn set_failed_main_jobs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.failed_main_jobs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [failed_pre_caching_check_jobs][crate::model::pipeline_task_executor_detail::ContainerDetail::failed_pre_caching_check_jobs].
        pub fn set_failed_pre_caching_check_jobs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.failed_pre_caching_check_jobs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ContainerDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.ContainerDetail"
        }
    }

    /// The detailed info for a custom job executor.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomJobDetail {
        /// Output only. The name of the
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob].
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub job: std::string::String,

        /// Output only. The names of the previously failed
        /// [CustomJob][google.cloud.aiplatform.v1.CustomJob]. The list includes the
        /// all attempts in chronological order.
        ///
        /// [google.cloud.aiplatform.v1.CustomJob]: crate::model::CustomJob
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failed_jobs: std::vec::Vec<std::string::String>,
    }

    impl CustomJobDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job][crate::model::pipeline_task_executor_detail::CustomJobDetail::job].
        pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.job = v.into();
            self
        }

        /// Sets the value of [failed_jobs][crate::model::pipeline_task_executor_detail::CustomJobDetail::failed_jobs].
        pub fn set_failed_jobs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.failed_jobs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CustomJobDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.CustomJobDetail"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Output only. The detailed info for a container executor.
        ContainerDetail(
            std::boxed::Box<crate::model::pipeline_task_executor_detail::ContainerDetail>,
        ),
        /// Output only. The detailed info for a custom job executor.
        CustomJobDetail(
            std::boxed::Box<crate::model::pipeline_task_executor_detail::CustomJobDetail>,
        ),
    }
}

/// Runtime operation information for
/// [PipelineService.BatchCancelPipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs]: crate::client::PipelineService::batch_cancel_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCancelPipelineJobsOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl BatchCancelPipelineJobsOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::BatchCancelPipelineJobsOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for BatchCancelPipelineJobsOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsOperationMetadata"
    }
}

/// Request message for
/// [PipelineService.CreateTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.CreateTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.CreateTrainingPipeline]: crate::client::PipelineService::create_training_pipeline
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTrainingPipelineRequest {
    /// Required. The resource name of the Location to create the TrainingPipeline
    /// in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The TrainingPipeline to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_pipeline: std::option::Option<crate::model::TrainingPipeline>,
}

impl CreateTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTrainingPipelineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [training_pipeline][crate::model::CreateTrainingPipelineRequest::training_pipeline].
    pub fn set_training_pipeline<
        T: std::convert::Into<std::option::Option<crate::model::TrainingPipeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_pipeline = v.into();
        self
    }
}

impl wkt::message::Message for CreateTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.GetTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.GetTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.GetTrainingPipeline]: crate::client::PipelineService::get_training_pipeline
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTrainingPipelineRequest {
    /// Required. The name of the TrainingPipeline resource.
    /// Format:
    /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTrainingPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.ListTrainingPipelines][google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines].
///
/// [google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]: crate::client::PipelineService::list_training_pipelines
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrainingPipelinesRequest {
    /// Required. The resource name of the Location to list the TrainingPipelines
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list filter.
    ///
    /// Supported fields:
    ///
    /// * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state` supports `=`, `!=` comparisons.
    /// * `training_task_definition` `=`, `!=` comparisons, and `:` wildcard.
    /// * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
    ///   `create_time` must be in RFC 3339 format.
    /// * `labels` supports general map functions that is:
    ///   `labels.key=value` - key:value equality
    ///   `labels.key:* - key existence
    ///
    /// Some examples of using the filter are:
    ///
    /// * `state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"`
    /// * `state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"`
    /// * `NOT display_name="my_pipeline"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `training_task_definition:"*automl_text_classification*"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListTrainingPipelinesResponse.next_page_token][google.cloud.aiplatform.v1.ListTrainingPipelinesResponse.next_page_token]
    /// of the previous
    /// [PipelineService.ListTrainingPipelines][google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListTrainingPipelinesResponse.next_page_token]: crate::model::ListTrainingPipelinesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]: crate::client::PipelineService::list_training_pipelines
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListTrainingPipelinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTrainingPipelinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTrainingPipelinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTrainingPipelinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTrainingPipelinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTrainingPipelinesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListTrainingPipelinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrainingPipelinesRequest"
    }
}

/// Response message for
/// [PipelineService.ListTrainingPipelines][google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]
///
/// [google.cloud.aiplatform.v1.PipelineService.ListTrainingPipelines]: crate::client::PipelineService::list_training_pipelines
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrainingPipelinesResponse {
    /// List of TrainingPipelines in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub training_pipelines: std::vec::Vec<crate::model::TrainingPipeline>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListTrainingPipelinesRequest.page_token][google.cloud.aiplatform.v1.ListTrainingPipelinesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListTrainingPipelinesRequest.page_token]: crate::model::ListTrainingPipelinesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTrainingPipelinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTrainingPipelinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [training_pipelines][crate::model::ListTrainingPipelinesResponse::training_pipelines].
    pub fn set_training_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrainingPipeline>,
    {
        use std::iter::Iterator;
        self.training_pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTrainingPipelinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrainingPipelinesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTrainingPipelinesResponse {
    type PageItem = crate::model::TrainingPipeline;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.training_pipelines
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [PipelineService.DeleteTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.DeleteTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.DeleteTrainingPipeline]: crate::client::PipelineService::delete_training_pipeline
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTrainingPipelineRequest {
    /// Required. The name of the TrainingPipeline resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTrainingPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.CancelTrainingPipeline][google.cloud.aiplatform.v1.PipelineService.CancelTrainingPipeline].
///
/// [google.cloud.aiplatform.v1.PipelineService.CancelTrainingPipeline]: crate::client::PipelineService::cancel_training_pipeline
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelTrainingPipelineRequest {
    /// Required. The name of the TrainingPipeline to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelTrainingPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelTrainingPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelTrainingPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelTrainingPipelineRequest"
    }
}

/// Request message for
/// [PipelineService.CreatePipelineJob][google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob]: crate::client::PipelineService::create_pipeline_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePipelineJobRequest {
    /// Required. The resource name of the Location to create the PipelineJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The PipelineJob to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_job: std::option::Option<crate::model::PipelineJob>,

    /// The ID to use for the PipelineJob, which will become the final component of
    /// the PipelineJob name. If not provided, an ID will be automatically
    /// generated.
    ///
    /// This value should be less than 128 characters, and valid characters
    /// are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pipeline_job_id: std::string::String,
}

impl CreatePipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePipelineJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [pipeline_job][crate::model::CreatePipelineJobRequest::pipeline_job].
    pub fn set_pipeline_job<
        T: std::convert::Into<std::option::Option<crate::model::PipelineJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline_job = v.into();
        self
    }

    /// Sets the value of [pipeline_job_id][crate::model::CreatePipelineJobRequest::pipeline_job_id].
    pub fn set_pipeline_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_job_id = v.into();
        self
    }
}

impl wkt::message::Message for CreatePipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.GetPipelineJob][google.cloud.aiplatform.v1.PipelineService.GetPipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.GetPipelineJob]: crate::client::PipelineService::get_pipeline_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPipelineJobRequest {
    /// Required. The name of the PipelineJob resource.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPipelineJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.ListPipelineJobs][google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]: crate::client::PipelineService::list_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPipelineJobsRequest {
    /// Required. The resource name of the Location to list the PipelineJobs from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the PipelineJobs that match the filter expression. The following
    /// fields are supported:
    ///
    /// * `pipeline_name`: Supports `=` and `!=` comparisons.
    /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and `:` wildcard.
    ///   for example, can check if pipeline's display_name contains *step* by
    ///   doing display_name:\"*step*\"
    /// * `state`: Supports `=` and `!=` comparisons.
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `labels`: Supports key-value equality and key presence.
    /// * `template_uri`: Supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `template_metadata.version`: Supports `=`, `!=` comparisons, and `:`
    ///   wildcard.
    ///
    /// Filter expressions can be combined together using logical operators
    /// (`AND` & `OR`).
    /// For example: `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`.
    ///
    /// The syntax to define filter expression is based on
    /// <https://google.aip.dev/160>.
    ///
    /// Examples:
    ///
    /// * `create_time>"2021-05-18T00:00:00Z" OR
    ///   update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated
    ///   after 2020-05-18 00:00:00 UTC.
    /// * `labels.env = "prod"`
    ///   PipelineJobs with label "env" set to "prod".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListPipelineJobsResponse.next_page_token][google.cloud.aiplatform.v1.ListPipelineJobsResponse.next_page_token]
    /// of the previous
    /// [PipelineService.ListPipelineJobs][google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListPipelineJobsResponse.next_page_token]: crate::model::ListPipelineJobsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]: crate::client::PipelineService::list_pipeline_jobs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by. The default sort order is in
    /// ascending order. Use "desc" after a field name for descending. You can have
    /// multiple order_by fields provided e.g. "create_time desc, end_time",
    /// "end_time, start_time, update_time" For example, using "create_time desc,
    /// end_time" will order results by create time in descending order, and if
    /// there are multiple jobs having the same create time, order them by the end
    /// time in ascending order. if order_by is not specified, it will order by
    /// default order is create time in descending order. Supported fields:
    ///
    /// * `create_time`
    /// * `update_time`
    /// * `end_time`
    /// * `start_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListPipelineJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPipelineJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPipelineJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPipelineJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPipelineJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPipelineJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListPipelineJobsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListPipelineJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPipelineJobsRequest"
    }
}

/// Response message for
/// [PipelineService.ListPipelineJobs][google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]
///
/// [google.cloud.aiplatform.v1.PipelineService.ListPipelineJobs]: crate::client::PipelineService::list_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPipelineJobsResponse {
    /// List of PipelineJobs in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_jobs: std::vec::Vec<crate::model::PipelineJob>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListPipelineJobsRequest.page_token][google.cloud.aiplatform.v1.ListPipelineJobsRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListPipelineJobsRequest.page_token]: crate::model::ListPipelineJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPipelineJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPipelineJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [pipeline_jobs][crate::model::ListPipelineJobsResponse::pipeline_jobs].
    pub fn set_pipeline_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineJob>,
    {
        use std::iter::Iterator;
        self.pipeline_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPipelineJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPipelineJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPipelineJobsResponse {
    type PageItem = crate::model::PipelineJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.pipeline_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [PipelineService.DeletePipelineJob][google.cloud.aiplatform.v1.PipelineService.DeletePipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.DeletePipelineJob]: crate::client::PipelineService::delete_pipeline_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePipelineJobRequest {
    /// Required. The name of the PipelineJob resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeletePipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePipelineJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeletePipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.BatchDeletePipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs]: crate::client::PipelineService::batch_delete_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeletePipelineJobsRequest {
    /// Required. The name of the PipelineJobs' parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The names of the PipelineJobs to delete.
    /// A maximum of 32 PipelineJobs can be deleted in a batch.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,
}

impl BatchDeletePipelineJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeletePipelineJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeletePipelineJobsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeletePipelineJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDeletePipelineJobsRequest"
    }
}

/// Response message for
/// [PipelineService.BatchDeletePipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchDeletePipelineJobs]: crate::client::PipelineService::batch_delete_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeletePipelineJobsResponse {
    /// PipelineJobs deleted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_jobs: std::vec::Vec<crate::model::PipelineJob>,
}

impl BatchDeletePipelineJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_jobs][crate::model::BatchDeletePipelineJobsResponse::pipeline_jobs].
    pub fn set_pipeline_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineJob>,
    {
        use std::iter::Iterator;
        self.pipeline_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeletePipelineJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDeletePipelineJobsResponse"
    }
}

/// Request message for
/// [PipelineService.CancelPipelineJob][google.cloud.aiplatform.v1.PipelineService.CancelPipelineJob].
///
/// [google.cloud.aiplatform.v1.PipelineService.CancelPipelineJob]: crate::client::PipelineService::cancel_pipeline_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelPipelineJobRequest {
    /// Required. The name of the PipelineJob to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl CancelPipelineJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelPipelineJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelPipelineJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelPipelineJobRequest"
    }
}

/// Request message for
/// [PipelineService.BatchCancelPipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs]: crate::client::PipelineService::batch_cancel_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCancelPipelineJobsRequest {
    /// Required. The name of the PipelineJobs' parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The names of the PipelineJobs to cancel.
    /// A maximum of 32 PipelineJobs can be cancelled in a batch.
    /// Format:
    /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,
}

impl BatchCancelPipelineJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCancelPipelineJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchCancelPipelineJobsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCancelPipelineJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsRequest"
    }
}

/// Response message for
/// [PipelineService.BatchCancelPipelineJobs][google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs].
///
/// [google.cloud.aiplatform.v1.PipelineService.BatchCancelPipelineJobs]: crate::client::PipelineService::batch_cancel_pipeline_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCancelPipelineJobsResponse {
    /// PipelineJobs cancelled.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pipeline_jobs: std::vec::Vec<crate::model::PipelineJob>,
}

impl BatchCancelPipelineJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_jobs][crate::model::BatchCancelPipelineJobsResponse::pipeline_jobs].
    pub fn set_pipeline_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PipelineJob>,
    {
        use std::iter::Iterator;
        self.pipeline_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCancelPipelineJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsResponse"
    }
}

/// Request message for
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict].
///
/// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The instances that are the input to the prediction call.
    /// A DeployedModel may have an upper limit on the number of instances it
    /// supports per request, and when it is exceeded the prediction call errors
    /// in case of AutoML Models, or, in case of customer created Models, the
    /// behaviour is as documented by that Model.
    /// The schema of any single instance may be specified via Endpoint's
    /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// The parameters that govern the prediction. The schema of the parameters may
    /// be specified via Endpoint's DeployedModels' [Model's
    /// ][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [parameters_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<wkt::Value>,
}

impl PredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::PredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::PredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::PredictRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictRequest"
    }
}

/// Response message for
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict].
///
/// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictResponse {
    /// The predictions that are the output of the predictions call.
    /// The schema of any single prediction may be specified via Endpoint's
    /// DeployedModels' [Model's ][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]: crate::model::PredictSchemata::prediction_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predictions: std::vec::Vec<wkt::Value>,

    /// ID of the Endpoint's DeployedModel that served this prediction.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// Output only. The resource name of the Model which is deployed as the
    /// DeployedModel that this prediction hits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. The version ID of the Model which is deployed as the
    /// DeployedModel that this prediction hits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version_id: std::string::String,

    /// Output only. The [display
    /// name][google.cloud.aiplatform.v1.Model.display_name] of the Model which is
    /// deployed as the DeployedModel that this prediction hits.
    ///
    /// [google.cloud.aiplatform.v1.Model.display_name]: crate::model::Model::display_name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_display_name: std::string::String,

    /// Output only. Request-level metadata returned by the model. The metadata
    /// type will be dependent upon the model implementation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,
}

impl PredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model_id][crate::model::PredictResponse::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::PredictResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_version_id][crate::model::PredictResponse::model_version_id].
    pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_version_id = v.into();
        self
    }

    /// Sets the value of [model_display_name][crate::model::PredictResponse::model_display_name].
    pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_display_name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::PredictResponse::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [predictions][crate::model::PredictResponse::predictions].
    pub fn set_predictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.predictions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictResponse"
    }
}

/// Request message for
/// [PredictionService.RawPredict][google.cloud.aiplatform.v1.PredictionService.RawPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.RawPredict]: crate::client::PredictionService::raw_predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input. Supports HTTP headers and arbitrary data payload.
    ///
    /// A [DeployedModel][google.cloud.aiplatform.v1.DeployedModel] may have an
    /// upper limit on the number of instances it supports per request. When this
    /// limit it is exceeded for an AutoML model, the
    /// [RawPredict][google.cloud.aiplatform.v1.PredictionService.RawPredict]
    /// method returns an error. When this limit is exceeded for a custom-trained
    /// model, the behavior varies depending on the model.
    ///
    /// You can specify the schema for each instance in the
    /// [predict_schemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
    /// field when you create a [Model][google.cloud.aiplatform.v1.Model]. This
    /// schema applies when you deploy the `Model` as a `DeployedModel` to an
    /// [Endpoint][google.cloud.aiplatform.v1.Endpoint] and use the `RawPredict`
    /// method.
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel]: crate::model::DeployedModel
    /// [google.cloud.aiplatform.v1.Endpoint]: crate::model::Endpoint
    /// [google.cloud.aiplatform.v1.Model]: crate::model::Model
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    /// [google.cloud.aiplatform.v1.PredictionService.RawPredict]: crate::client::PredictionService::raw_predict
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_body: std::option::Option<api::model::HttpBody>,
}

impl RawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::RawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [http_body][crate::model::RawPredictRequest::http_body].
    pub fn set_http_body<T: std::convert::Into<std::option::Option<api::model::HttpBody>>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_body = v.into();
        self
    }
}

impl wkt::message::Message for RawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RawPredictRequest"
    }
}

/// Request message for
/// [PredictionService.StreamRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamRawPredict].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input. Supports HTTP headers and arbitrary data payload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_body: std::option::Option<api::model::HttpBody>,
}

impl StreamRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [http_body][crate::model::StreamRawPredictRequest::http_body].
    pub fn set_http_body<T: std::convert::Into<std::option::Option<api::model::HttpBody>>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_body = v.into();
        self
    }
}

impl wkt::message::Message for StreamRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamRawPredictRequest"
    }
}

/// Request message for
/// [PredictionService.DirectPredict][google.cloud.aiplatform.v1.PredictionService.DirectPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectPredict]: crate::client::PredictionService::direct_predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,
}

impl DirectPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DirectPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::DirectPredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::DirectPredictRequest::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DirectPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectPredictRequest"
    }
}

/// Response message for
/// [PredictionService.DirectPredict][google.cloud.aiplatform.v1.PredictionService.DirectPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectPredict]: crate::client::PredictionService::direct_predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,
}

impl DirectPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::DirectPredictResponse::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::DirectPredictResponse::outputs].
    pub fn set_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DirectPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectPredictResponse"
    }
}

/// Request message for
/// [PredictionService.DirectRawPredict][google.cloud.aiplatform.v1.PredictionService.DirectRawPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectRawPredict]: crate::client::PredictionService::direct_raw_predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Fully qualified name of the API method being invoked to perform
    /// predictions.
    ///
    /// Format:
    /// `/namespace.Service/Method/`
    /// Example:
    /// `/tensorflow.serving.PredictionService/Predict`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub input: bytes::Bytes,
}

impl DirectRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::DirectRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::DirectRawPredictRequest::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::DirectRawPredictRequest::input].
    pub fn set_input<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }
}

impl wkt::message::Message for DirectRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectRawPredictRequest"
    }
}

/// Response message for
/// [PredictionService.DirectRawPredict][google.cloud.aiplatform.v1.PredictionService.DirectRawPredict].
///
/// [google.cloud.aiplatform.v1.PredictionService.DirectRawPredict]: crate::client::PredictionService::direct_raw_predict
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DirectRawPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub output: bytes::Bytes,
}

impl DirectRawPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::DirectRawPredictResponse::output].
    pub fn set_output<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

impl wkt::message::Message for DirectRawPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectRawPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamDirectPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamDirectPredictRequest.endpoint]
/// field and optionally [input][]. The subsequent messages must contain
/// [input][].
///
/// [google.cloud.aiplatform.v1.StreamDirectPredictRequest.endpoint]: crate::model::StreamDirectPredictRequest::endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. The prediction input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inputs: std::vec::Vec<crate::model::Tensor>,

    /// Optional. The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,
}

impl StreamDirectPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamDirectPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::StreamDirectPredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::StreamDirectPredictRequest::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamDirectPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamDirectPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectPredict].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,
}

impl StreamDirectPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::StreamDirectPredictResponse::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::StreamDirectPredictResponse::outputs].
    pub fn set_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamDirectPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamDirectRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectRawPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.endpoint]
/// and
/// [method_name][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.method_name]
/// fields and optionally
/// [input][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.input]. The
/// subsequent messages must contain
/// [input][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.input].
/// [method_name][google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.method_name]
/// in the subsequent messages have no effect.
///
/// [google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.endpoint]: crate::model::StreamDirectRawPredictRequest::endpoint
/// [google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.input]: crate::model::StreamDirectRawPredictRequest::input
/// [google.cloud.aiplatform.v1.StreamDirectRawPredictRequest.method_name]: crate::model::StreamDirectRawPredictRequest::method_name
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. Fully qualified name of the API method being invoked to perform
    /// predictions.
    ///
    /// Format:
    /// `/namespace.Service/Method/`
    /// Example:
    /// `/tensorflow.serving.PredictionService/Predict`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// Optional. The prediction input.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub input: bytes::Bytes,
}

impl StreamDirectRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamDirectRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::StreamDirectRawPredictRequest::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::StreamDirectRawPredictRequest::input].
    pub fn set_input<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }
}

impl wkt::message::Message for StreamDirectRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectRawPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamDirectRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamDirectRawPredict].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamDirectRawPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub output: bytes::Bytes,
}

impl StreamDirectRawPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::StreamDirectRawPredictResponse::output].
    pub fn set_output<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

impl wkt::message::Message for StreamDirectRawPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectRawPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamingPredict][google.cloud.aiplatform.v1.PredictionService.StreamingPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamingPredictRequest.endpoint] field
/// and optionally [input][]. The subsequent messages must contain [input][].
///
/// [google.cloud.aiplatform.v1.StreamingPredictRequest.endpoint]: crate::model::StreamingPredictRequest::endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,
}

impl StreamingPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamingPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::StreamingPredictRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [inputs][crate::model::StreamingPredictRequest::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamingPredict][google.cloud.aiplatform.v1.PredictionService.StreamingPredict].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outputs: std::vec::Vec<crate::model::Tensor>,

    /// The parameters that govern the prediction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Tensor>,
}

impl StreamingPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::StreamingPredictResponse::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Tensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::StreamingPredictResponse::outputs].
    pub fn set_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingPredictResponse"
    }
}

/// Request message for
/// [PredictionService.StreamingRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamingRawPredict].
///
/// The first message must contain
/// [endpoint][google.cloud.aiplatform.v1.StreamingRawPredictRequest.endpoint]
/// and
/// [method_name][google.cloud.aiplatform.v1.StreamingRawPredictRequest.method_name]
/// fields and optionally
/// [input][google.cloud.aiplatform.v1.StreamingRawPredictRequest.input]. The
/// subsequent messages must contain
/// [input][google.cloud.aiplatform.v1.StreamingRawPredictRequest.input].
/// [method_name][google.cloud.aiplatform.v1.StreamingRawPredictRequest.method_name]
/// in the subsequent messages have no effect.
///
/// [google.cloud.aiplatform.v1.StreamingRawPredictRequest.endpoint]: crate::model::StreamingRawPredictRequest::endpoint
/// [google.cloud.aiplatform.v1.StreamingRawPredictRequest.input]: crate::model::StreamingRawPredictRequest::input
/// [google.cloud.aiplatform.v1.StreamingRawPredictRequest.method_name]: crate::model::StreamingRawPredictRequest::method_name
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRawPredictRequest {
    /// Required. The name of the Endpoint requested to serve the prediction.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Fully qualified name of the API method being invoked to perform
    /// predictions.
    ///
    /// Format:
    /// `/namespace.Service/Method/`
    /// Example:
    /// `/tensorflow.serving.PredictionService/Predict`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// The prediction input.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub input: bytes::Bytes,
}

impl StreamingRawPredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::StreamingRawPredictRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::StreamingRawPredictRequest::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::StreamingRawPredictRequest::input].
    pub fn set_input<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }
}

impl wkt::message::Message for StreamingRawPredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingRawPredictRequest"
    }
}

/// Response message for
/// [PredictionService.StreamingRawPredict][google.cloud.aiplatform.v1.PredictionService.StreamingRawPredict].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRawPredictResponse {
    /// The prediction output.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub output: bytes::Bytes,
}

impl StreamingRawPredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::StreamingRawPredictResponse::output].
    pub fn set_output<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

impl wkt::message::Message for StreamingRawPredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingRawPredictResponse"
    }
}

/// Request message for
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
///
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainRequest {
    /// Required. The name of the Endpoint requested to serve the explanation.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Required. The instances that are the input to the explanation call.
    /// A DeployedModel may have an upper limit on the number of instances it
    /// supports per request, and when it is exceeded the explanation call errors
    /// in case of AutoML Models, or, in case of customer created Models, the
    /// behaviour is as documented by that Model.
    /// The schema of any single instance may be specified via Endpoint's
    /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]: crate::model::PredictSchemata::instance_schema_uri
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// The parameters that govern the prediction. The schema of the parameters may
    /// be specified via Endpoint's DeployedModels' [Model's
    /// ][google.cloud.aiplatform.v1.DeployedModel.model]
    /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
    /// [parameters_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.model]: crate::model::DeployedModel::model
    /// [google.cloud.aiplatform.v1.Model.predict_schemata]: crate::model::Model::predict_schemata
    /// [google.cloud.aiplatform.v1.PredictSchemata.parameters_schema_uri]: crate::model::PredictSchemata::parameters_schema_uri
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<wkt::Value>,

    /// If specified, overrides the
    /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
    /// of the DeployedModel. Can be used for explaining prediction results with
    /// different configurations, such as:
    ///
    /// - Explaining top-5 predictions results as opposed to top-1;
    /// - Increasing path count or step count of the attribution methods to reduce
    ///   approximate errors;
    /// - Using different baselines for explaining the prediction results.
    ///
    /// [google.cloud.aiplatform.v1.DeployedModel.explanation_spec]: crate::model::DeployedModel::explanation_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation_spec_override: std::option::Option<crate::model::ExplanationSpecOverride>,

    /// If specified, this ExplainRequest will be served by the chosen
    /// DeployedModel, overriding
    /// [Endpoint.traffic_split][google.cloud.aiplatform.v1.Endpoint.traffic_split].
    ///
    /// [google.cloud.aiplatform.v1.Endpoint.traffic_split]: crate::model::Endpoint::traffic_split
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,
}

impl ExplainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::ExplainRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::ExplainRequest::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [explanation_spec_override][crate::model::ExplainRequest::explanation_spec_override].
    pub fn set_explanation_spec_override<
        T: std::convert::Into<std::option::Option<crate::model::ExplanationSpecOverride>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.explanation_spec_override = v.into();
        self
    }

    /// Sets the value of [deployed_model_id][crate::model::ExplainRequest::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ExplainRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplainRequest"
    }
}

/// Response message for
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
///
/// [google.cloud.aiplatform.v1.PredictionService.Explain]: crate::client::PredictionService::explain
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainResponse {
    /// The explanations of the Model's
    /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions].
    ///
    /// It has the same number of elements as
    /// [instances][google.cloud.aiplatform.v1.ExplainRequest.instances] to be
    /// explained.
    ///
    /// [google.cloud.aiplatform.v1.ExplainRequest.instances]: crate::model::ExplainRequest::instances
    /// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explanations: std::vec::Vec<crate::model::Explanation>,

    /// ID of the Endpoint's DeployedModel that served this explanation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployed_model_id: std::string::String,

    /// The predictions that are the output of the predictions call.
    /// Same as
    /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions].
    ///
    /// [google.cloud.aiplatform.v1.PredictResponse.predictions]: crate::model::PredictResponse::predictions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub predictions: std::vec::Vec<wkt::Value>,
}

impl ExplainResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployed_model_id][crate::model::ExplainResponse::deployed_model_id].
    pub fn set_deployed_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployed_model_id = v.into();
        self
    }

    /// Sets the value of [explanations][crate::model::ExplainResponse::explanations].
    pub fn set_explanations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Explanation>,
    {
        use std::iter::Iterator;
        self.explanations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [predictions][crate::model::ExplainResponse::predictions].
    pub fn set_predictions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.predictions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplainResponse"
    }
}

/// Request message for [PredictionService.CountTokens][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CountTokensRequest {
    /// Required. The name of the Endpoint requested to perform token counting.
    /// Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Optional. The name of the publisher model requested to serve the
    /// prediction. Format:
    /// `projects/{project}/locations/{location}/publishers/*/models/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. The instances that are the input to token counting call.
    /// Schema is identical to the prediction schema of the underlying model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<wkt::Value>,

    /// Optional. Input content.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. The user provided system instructions for the model.
    /// Note: only text should be used in parts and content in each part will be in
    /// a separate paragraph.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::Content>,

    /// Optional. A list of `Tools` the model may use to generate the next
    /// response.
    ///
    /// A `Tool` is a piece of code that enables the system to interact with
    /// external systems to perform an action, or set of actions, outside of
    /// knowledge and scope of the model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tools: std::vec::Vec<crate::model::Tool>,

    /// Optional. Generation config that the model will use to generate the
    /// response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generation_config: std::option::Option<crate::model::GenerationConfig>,
}

impl CountTokensRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint][crate::model::CountTokensRequest::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CountTokensRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::CountTokensRequest::system_instruction].
    pub fn set_system_instruction<
        T: std::convert::Into<std::option::Option<crate::model::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_instruction = v.into();
        self
    }

    /// Sets the value of [generation_config][crate::model::CountTokensRequest::generation_config].
    pub fn set_generation_config<
        T: std::convert::Into<std::option::Option<crate::model::GenerationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generation_config = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::CountTokensRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [contents][crate::model::CountTokensRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tools][crate::model::CountTokensRequest::tools].
    pub fn set_tools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tool>,
    {
        use std::iter::Iterator;
        self.tools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CountTokensRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CountTokensRequest"
    }
}

/// Response message for [PredictionService.CountTokens][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CountTokensResponse {
    /// The total number of tokens counted across all instances from the request.
    pub total_tokens: i32,

    /// The total number of billable characters counted across all instances from
    /// the request.
    pub total_billable_characters: i32,

    /// Output only. List of modalities that were processed in the request input.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub prompt_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,
}

impl CountTokensResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_tokens][crate::model::CountTokensResponse::total_tokens].
    pub fn set_total_tokens<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_tokens = v.into();
        self
    }

    /// Sets the value of [total_billable_characters][crate::model::CountTokensResponse::total_billable_characters].
    pub fn set_total_billable_characters<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_billable_characters = v.into();
        self
    }

    /// Sets the value of [prompt_tokens_details][crate::model::CountTokensResponse::prompt_tokens_details].
    pub fn set_prompt_tokens_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModalityTokenCount>,
    {
        use std::iter::Iterator;
        self.prompt_tokens_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CountTokensResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CountTokensResponse"
    }
}

/// Request message for [PredictionService.GenerateContent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateContentRequest {
    /// Required. The fully qualified name of the publisher model or tuned model
    /// endpoint to use.
    ///
    /// Publisher model format:
    /// `projects/{project}/locations/{location}/publishers/*/models/*`
    ///
    /// Tuned model endpoint format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Required. The content of the current conversation with the model.
    ///
    /// For single-turn queries, this is a single instance. For multi-turn queries,
    /// this is a repeated field that contains conversation history + latest
    /// request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. The user provided system instructions for the model.
    /// Note: only text should be used in parts and content in each part will be in
    /// a separate paragraph.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::Content>,

    /// Optional. The name of the cached content used as context to serve the
    /// prediction. Note: only used in explicit caching, where users can have
    /// control over caching (e.g. what content to cache) and enjoy guaranteed cost
    /// savings. Format:
    /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cached_content: std::string::String,

    /// Optional. A list of `Tools` the model may use to generate the next
    /// response.
    ///
    /// A `Tool` is a piece of code that enables the system to interact with
    /// external systems to perform an action, or set of actions, outside of
    /// knowledge and scope of the model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tools: std::vec::Vec<crate::model::Tool>,

    /// Optional. Tool config. This config is shared for all tools provided in the
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tool_config: std::option::Option<crate::model::ToolConfig>,

    /// Optional. The labels with user-defined metadata for the request. It is used
    /// for billing and reporting only.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints) and can only contain lowercase letters, numeric
    /// characters, underscores, and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Per request settings for blocking unsafe content.
    /// Enforced on GenerateContentResponse.candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub safety_settings: std::vec::Vec<crate::model::SafetySetting>,

    /// Optional. Generation config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generation_config: std::option::Option<crate::model::GenerationConfig>,
}

impl GenerateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::GenerateContentRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::GenerateContentRequest::system_instruction].
    pub fn set_system_instruction<
        T: std::convert::Into<std::option::Option<crate::model::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_instruction = v.into();
        self
    }

    /// Sets the value of [cached_content][crate::model::GenerateContentRequest::cached_content].
    pub fn set_cached_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cached_content = v.into();
        self
    }

    /// Sets the value of [tool_config][crate::model::GenerateContentRequest::tool_config].
    pub fn set_tool_config<T: std::convert::Into<std::option::Option<crate::model::ToolConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tool_config = v.into();
        self
    }

    /// Sets the value of [generation_config][crate::model::GenerateContentRequest::generation_config].
    pub fn set_generation_config<
        T: std::convert::Into<std::option::Option<crate::model::GenerationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generation_config = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::GenerateContentRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tools][crate::model::GenerateContentRequest::tools].
    pub fn set_tools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tool>,
    {
        use std::iter::Iterator;
        self.tools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [safety_settings][crate::model::GenerateContentRequest::safety_settings].
    pub fn set_safety_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SafetySetting>,
    {
        use std::iter::Iterator;
        self.safety_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::GenerateContentRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for GenerateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentRequest"
    }
}

/// Response message for [PredictionService.GenerateContent].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateContentResponse {
    /// Output only. Generated candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub candidates: std::vec::Vec<crate::model::Candidate>,

    /// Output only. The model version used to generate the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_version: std::string::String,

    /// Output only. Timestamp when the request is made to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. response_id is used to identify each response. It is the
    /// encoding of the event_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub response_id: std::string::String,

    /// Output only. Content filter results for a prompt sent in the request.
    /// Note: Sent only in the first stream chunk.
    /// Only happens when no candidates were generated due to content violations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prompt_feedback:
        std::option::Option<crate::model::generate_content_response::PromptFeedback>,

    /// Usage metadata about the response(s).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub usage_metadata: std::option::Option<crate::model::generate_content_response::UsageMetadata>,
}

impl GenerateContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_version][crate::model::GenerateContentResponse::model_version].
    pub fn set_model_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GenerateContentResponse::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [response_id][crate::model::GenerateContentResponse::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [prompt_feedback][crate::model::GenerateContentResponse::prompt_feedback].
    pub fn set_prompt_feedback<
        T: std::convert::Into<
            std::option::Option<crate::model::generate_content_response::PromptFeedback>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prompt_feedback = v.into();
        self
    }

    /// Sets the value of [usage_metadata][crate::model::GenerateContentResponse::usage_metadata].
    pub fn set_usage_metadata<
        T: std::convert::Into<
            std::option::Option<crate::model::generate_content_response::UsageMetadata>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.usage_metadata = v.into();
        self
    }

    /// Sets the value of [candidates][crate::model::GenerateContentResponse::candidates].
    pub fn set_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Candidate>,
    {
        use std::iter::Iterator;
        self.candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse"
    }
}

/// Defines additional types related to GenerateContentResponse
pub mod generate_content_response {
    #[allow(unused_imports)]
    use super::*;

    /// Content filter results for a prompt sent in the request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PromptFeedback {
        /// Output only. Blocked reason.
        pub block_reason: crate::model::generate_content_response::prompt_feedback::BlockedReason,

        /// Output only. Safety ratings.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub safety_ratings: std::vec::Vec<crate::model::SafetyRating>,

        /// Output only. A readable block reason message.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub block_reason_message: std::string::String,
    }

    impl PromptFeedback {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [block_reason][crate::model::generate_content_response::PromptFeedback::block_reason].
        pub fn set_block_reason<
            T: std::convert::Into<
                crate::model::generate_content_response::prompt_feedback::BlockedReason,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.block_reason = v.into();
            self
        }

        /// Sets the value of [block_reason_message][crate::model::generate_content_response::PromptFeedback::block_reason_message].
        pub fn set_block_reason_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.block_reason_message = v.into();
            self
        }

        /// Sets the value of [safety_ratings][crate::model::generate_content_response::PromptFeedback::safety_ratings].
        pub fn set_safety_ratings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::SafetyRating>,
        {
            use std::iter::Iterator;
            self.safety_ratings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PromptFeedback {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse.PromptFeedback"
        }
    }

    /// Defines additional types related to PromptFeedback
    pub mod prompt_feedback {
        #[allow(unused_imports)]
        use super::*;

        /// Blocked reason enumeration.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct BlockedReason(std::borrow::Cow<'static, str>);

        impl BlockedReason {
            /// Creates a new BlockedReason instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [BlockedReason](BlockedReason)
        pub mod blocked_reason {
            use super::BlockedReason;

            /// Unspecified blocked reason.
            pub const BLOCKED_REASON_UNSPECIFIED: BlockedReason =
                BlockedReason::new("BLOCKED_REASON_UNSPECIFIED");

            /// Candidates blocked due to safety.
            pub const SAFETY: BlockedReason = BlockedReason::new("SAFETY");

            /// Candidates blocked due to other reason.
            pub const OTHER: BlockedReason = BlockedReason::new("OTHER");

            /// Candidates blocked due to the terms which are included from the
            /// terminology blocklist.
            pub const BLOCKLIST: BlockedReason = BlockedReason::new("BLOCKLIST");

            /// Candidates blocked due to prohibited content.
            pub const PROHIBITED_CONTENT: BlockedReason = BlockedReason::new("PROHIBITED_CONTENT");
        }

        impl std::convert::From<std::string::String> for BlockedReason {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Usage metadata about response(s).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UsageMetadata {
        /// Number of tokens in the request. When `cached_content` is set, this is
        /// still the total effective prompt size meaning this includes the number of
        /// tokens in the cached content.
        pub prompt_token_count: i32,

        /// Number of tokens in the response(s).
        pub candidates_token_count: i32,

        /// Total token count for prompt and response candidates.
        pub total_token_count: i32,

        /// Output only. Number of tokens in the cached part in the input (the cached
        /// content).
        pub cached_content_token_count: i32,

        /// Output only. List of modalities that were processed in the request input.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub prompt_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,

        /// Output only. List of modalities of the cached content in the request
        /// input.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub cache_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,

        /// Output only. List of modalities that were returned in the response.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub candidates_tokens_details: std::vec::Vec<crate::model::ModalityTokenCount>,
    }

    impl UsageMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [prompt_token_count][crate::model::generate_content_response::UsageMetadata::prompt_token_count].
        pub fn set_prompt_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.prompt_token_count = v.into();
            self
        }

        /// Sets the value of [candidates_token_count][crate::model::generate_content_response::UsageMetadata::candidates_token_count].
        pub fn set_candidates_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.candidates_token_count = v.into();
            self
        }

        /// Sets the value of [total_token_count][crate::model::generate_content_response::UsageMetadata::total_token_count].
        pub fn set_total_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_token_count = v.into();
            self
        }

        /// Sets the value of [cached_content_token_count][crate::model::generate_content_response::UsageMetadata::cached_content_token_count].
        pub fn set_cached_content_token_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.cached_content_token_count = v.into();
            self
        }

        /// Sets the value of [prompt_tokens_details][crate::model::generate_content_response::UsageMetadata::prompt_tokens_details].
        pub fn set_prompt_tokens_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ModalityTokenCount>,
        {
            use std::iter::Iterator;
            self.prompt_tokens_details = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [cache_tokens_details][crate::model::generate_content_response::UsageMetadata::cache_tokens_details].
        pub fn set_cache_tokens_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ModalityTokenCount>,
        {
            use std::iter::Iterator;
            self.cache_tokens_details = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [candidates_tokens_details][crate::model::generate_content_response::UsageMetadata::candidates_tokens_details].
        pub fn set_candidates_tokens_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ModalityTokenCount>,
        {
            use std::iter::Iterator;
            self.candidates_tokens_details = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for UsageMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse.UsageMetadata"
        }
    }
}

/// A Model Garden Publisher Model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PublisherModel {
    /// Output only. The resource name of the PublisherModel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The version ID of the PublisherModel.
    /// A new version is committed when a new model version is uploaded under an
    /// existing model id. It is an auto-incrementing decimal number in string
    /// representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_id: std::string::String,

    /// Required. Indicates the open source category of the publisher model.
    pub open_source_category: crate::model::publisher_model::OpenSourceCategory,

    /// Optional. Supported call-to-action options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub supported_actions: std::option::Option<crate::model::publisher_model::CallToAction>,

    /// Optional. Additional information about the model's Frameworks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub frameworks: std::vec::Vec<std::string::String>,

    /// Optional. Indicates the launch stage of the model.
    pub launch_stage: crate::model::publisher_model::LaunchStage,

    /// Optional. Indicates the state of the model version.
    pub version_state: crate::model::publisher_model::VersionState,

    /// Optional. Output only. Immutable. Used to indicate this model has a
    /// publisher model and provide the template of the publisher model resource
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub publisher_model_template: std::string::String,

    /// Optional. The schemata that describes formats of the PublisherModel's
    /// predictions and explanations as given and returned via
    /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict].
    ///
    /// [google.cloud.aiplatform.v1.PredictionService.Predict]: crate::client::PredictionService::predict
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_schemata: std::option::Option<crate::model::PredictSchemata>,
}

impl PublisherModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PublisherModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::PublisherModel::version_id].
    pub fn set_version_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [open_source_category][crate::model::PublisherModel::open_source_category].
    pub fn set_open_source_category<
        T: std::convert::Into<crate::model::publisher_model::OpenSourceCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.open_source_category = v.into();
        self
    }

    /// Sets the value of [supported_actions][crate::model::PublisherModel::supported_actions].
    pub fn set_supported_actions<
        T: std::convert::Into<std::option::Option<crate::model::publisher_model::CallToAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.supported_actions = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::PublisherModel::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<crate::model::publisher_model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [version_state][crate::model::PublisherModel::version_state].
    pub fn set_version_state<T: std::convert::Into<crate::model::publisher_model::VersionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_state = v.into();
        self
    }

    /// Sets the value of [publisher_model_template][crate::model::PublisherModel::publisher_model_template].
    pub fn set_publisher_model_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.publisher_model_template = v.into();
        self
    }

    /// Sets the value of [predict_schemata][crate::model::PublisherModel::predict_schemata].
    pub fn set_predict_schemata<
        T: std::convert::Into<std::option::Option<crate::model::PredictSchemata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_schemata = v.into();
        self
    }

    /// Sets the value of [frameworks][crate::model::PublisherModel::frameworks].
    pub fn set_frameworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.frameworks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PublisherModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel"
    }
}

/// Defines additional types related to PublisherModel
pub mod publisher_model {
    #[allow(unused_imports)]
    use super::*;

    /// Reference to a resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceReference {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub reference:
            std::option::Option<crate::model::publisher_model::resource_reference::Reference>,
    }

    impl ResourceReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `reference`.
        pub fn set_reference<
            T: std::convert::Into<
                std::option::Option<crate::model::publisher_model::resource_reference::Reference>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.reference = v.into();
            self
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `Uri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::Uri(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `ResourceName`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_resource_name(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::ResourceName(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `UseCase`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_use_case(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::UseCase(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// if it holds a `Description`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_description(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.reference.as_ref().and_then(|v| match v {
                crate::model::publisher_model::resource_reference::Reference::Description(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `Uri`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::Uri(v.into()),
            );
            self
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `ResourceName`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        pub fn set_resource_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::ResourceName(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `UseCase`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        pub fn set_use_case<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::UseCase(v.into()),
            );
            self
        }

        /// Sets the value of [reference][crate::model::publisher_model::ResourceReference::reference]
        /// to hold a `Description`.
        ///
        /// Note that all the setters affecting `reference` are
        /// mutually exclusive.
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reference = std::option::Option::Some(
                crate::model::publisher_model::resource_reference::Reference::Description(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ResourceReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.ResourceReference"
        }
    }

    /// Defines additional types related to ResourceReference
    pub mod resource_reference {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Reference {
            /// The URI of the resource.
            Uri(std::string::String),
            /// The resource name of the Google Cloud resource.
            ResourceName(std::string::String),
            /// Use case (CUJ) of the resource.
            UseCase(std::string::String),
            /// Description of the resource.
            Description(std::string::String),
        }
    }

    /// A named piece of documentation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Documentation {
        /// Required. E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA,
        /// NODE.JS, etc..
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub title: std::string::String,

        /// Required. Content of this piece of document (in Markdown format).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub content: std::string::String,
    }

    impl Documentation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [title][crate::model::publisher_model::Documentation::title].
        pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [content][crate::model::publisher_model::Documentation::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    impl wkt::message::Message for Documentation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.Documentation"
        }
    }

    /// Actions could take on this Publisher Model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CallToAction {
        /// Optional. To view Rest API docs.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub view_rest_api:
            std::option::Option<crate::model::publisher_model::call_to_action::ViewRestApi>,

        /// Optional. Open notebook of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_notebook: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open notebooks of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_notebooks:
            std::option::Option<crate::model::publisher_model::call_to_action::OpenNotebooks>,

        /// Optional. Create application using the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub create_application: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open fine-tuning pipeline of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_fine_tuning_pipeline: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open fine-tuning pipelines of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_fine_tuning_pipelines: std::option::Option<
            crate::model::publisher_model::call_to_action::OpenFineTuningPipelines,
        >,

        /// Optional. Open prompt-tuning pipeline of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_prompt_tuning_pipeline: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open Genie / Playground.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_genie: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Deploy the PublisherModel to Vertex Endpoint.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub deploy: std::option::Option<crate::model::publisher_model::call_to_action::Deploy>,

        /// Optional. Deploy PublisherModel to Google Kubernetes Engine.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub deploy_gke:
            std::option::Option<crate::model::publisher_model::call_to_action::DeployGke>,

        /// Optional. Open in Generation AI Studio.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_generation_ai_studio: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Request for access.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub request_access: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,

        /// Optional. Open evaluation pipeline of the PublisherModel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub open_evaluation_pipeline: std::option::Option<
            crate::model::publisher_model::call_to_action::RegionalResourceReferences,
        >,
    }

    impl CallToAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [view_rest_api][crate::model::publisher_model::CallToAction::view_rest_api].
        pub fn set_view_rest_api<
            T: std::convert::Into<
                std::option::Option<crate::model::publisher_model::call_to_action::ViewRestApi>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.view_rest_api = v.into();
            self
        }

        /// Sets the value of [open_notebook][crate::model::publisher_model::CallToAction::open_notebook].
        pub fn set_open_notebook<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_notebook = v.into();
            self
        }

        /// Sets the value of [open_notebooks][crate::model::publisher_model::CallToAction::open_notebooks].
        pub fn set_open_notebooks<
            T: std::convert::Into<
                std::option::Option<crate::model::publisher_model::call_to_action::OpenNotebooks>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_notebooks = v.into();
            self
        }

        /// Sets the value of [create_application][crate::model::publisher_model::CallToAction::create_application].
        pub fn set_create_application<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.create_application = v.into();
            self
        }

        /// Sets the value of [open_fine_tuning_pipeline][crate::model::publisher_model::CallToAction::open_fine_tuning_pipeline].
        pub fn set_open_fine_tuning_pipeline<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_fine_tuning_pipeline = v.into();
            self
        }

        /// Sets the value of [open_fine_tuning_pipelines][crate::model::publisher_model::CallToAction::open_fine_tuning_pipelines].
        pub fn set_open_fine_tuning_pipelines<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::OpenFineTuningPipelines,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_fine_tuning_pipelines = v.into();
            self
        }

        /// Sets the value of [open_prompt_tuning_pipeline][crate::model::publisher_model::CallToAction::open_prompt_tuning_pipeline].
        pub fn set_open_prompt_tuning_pipeline<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_prompt_tuning_pipeline = v.into();
            self
        }

        /// Sets the value of [open_genie][crate::model::publisher_model::CallToAction::open_genie].
        pub fn set_open_genie<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_genie = v.into();
            self
        }

        /// Sets the value of [deploy][crate::model::publisher_model::CallToAction::deploy].
        pub fn set_deploy<
            T: std::convert::Into<
                std::option::Option<crate::model::publisher_model::call_to_action::Deploy>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.deploy = v.into();
            self
        }

        /// Sets the value of [deploy_gke][crate::model::publisher_model::CallToAction::deploy_gke].
        pub fn set_deploy_gke<
            T: std::convert::Into<
                std::option::Option<crate::model::publisher_model::call_to_action::DeployGke>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.deploy_gke = v.into();
            self
        }

        /// Sets the value of [open_generation_ai_studio][crate::model::publisher_model::CallToAction::open_generation_ai_studio].
        pub fn set_open_generation_ai_studio<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_generation_ai_studio = v.into();
            self
        }

        /// Sets the value of [request_access][crate::model::publisher_model::CallToAction::request_access].
        pub fn set_request_access<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request_access = v.into();
            self
        }

        /// Sets the value of [open_evaluation_pipeline][crate::model::publisher_model::CallToAction::open_evaluation_pipeline].
        pub fn set_open_evaluation_pipeline<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.open_evaluation_pipeline = v.into();
            self
        }
    }

    impl wkt::message::Message for CallToAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction"
        }
    }

    /// Defines additional types related to CallToAction
    pub mod call_to_action {
        #[allow(unused_imports)]
        use super::*;

        /// The regional resource name or the URI. Key is region, e.g.,
        /// us-central1, europe-west2, global, etc..
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RegionalResourceReferences {
            /// Required.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub references: std::collections::HashMap<
                std::string::String,
                crate::model::publisher_model::ResourceReference,
            >,

            /// Required.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// Optional. Title of the resource.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub resource_title: std::option::Option<std::string::String>,

            /// Optional. Use case (CUJ) of the resource.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub resource_use_case: std::option::Option<std::string::String>,

            /// Optional. Description of the resource.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub resource_description: std::option::Option<std::string::String>,
        }

        impl RegionalResourceReferences {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::publisher_model::call_to_action::RegionalResourceReferences::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [resource_title][crate::model::publisher_model::call_to_action::RegionalResourceReferences::resource_title].
            pub fn set_resource_title<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.resource_title = v.into();
                self
            }

            /// Sets the value of [resource_use_case][crate::model::publisher_model::call_to_action::RegionalResourceReferences::resource_use_case].
            pub fn set_resource_use_case<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.resource_use_case = v.into();
                self
            }

            /// Sets the value of [resource_description][crate::model::publisher_model::call_to_action::RegionalResourceReferences::resource_description].
            pub fn set_resource_description<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.resource_description = v.into();
                self
            }

            /// Sets the value of [references][crate::model::publisher_model::call_to_action::RegionalResourceReferences::references].
            pub fn set_references<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<crate::model::publisher_model::ResourceReference>,
            {
                use std::iter::Iterator;
                self.references = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for RegionalResourceReferences {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.RegionalResourceReferences"
            }
        }

        /// Rest API docs.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ViewRestApi {
            /// Required.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub documentations: std::vec::Vec<crate::model::publisher_model::Documentation>,

            /// Required. The title of the view rest API.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,
        }

        impl ViewRestApi {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::publisher_model::call_to_action::ViewRestApi::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [documentations][crate::model::publisher_model::call_to_action::ViewRestApi::documentations].
            pub fn set_documentations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::publisher_model::Documentation>,
            {
                use std::iter::Iterator;
                self.documentations = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ViewRestApi {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.ViewRestApi"
            }
        }

        /// Open notebooks.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OpenNotebooks {
            /// Required. Regional resource references to notebooks.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub notebooks: std::vec::Vec<
                crate::model::publisher_model::call_to_action::RegionalResourceReferences,
            >,
        }

        impl OpenNotebooks {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [notebooks][crate::model::publisher_model::call_to_action::OpenNotebooks::notebooks].
            pub fn set_notebooks<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            {
                use std::iter::Iterator;
                self.notebooks = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for OpenNotebooks {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenNotebooks"
            }
        }

        /// Open fine tuning pipelines.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OpenFineTuningPipelines {
            /// Required. Regional resource references to fine tuning pipelines.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub fine_tuning_pipelines: std::vec::Vec<
                crate::model::publisher_model::call_to_action::RegionalResourceReferences,
            >,
        }

        impl OpenFineTuningPipelines {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [fine_tuning_pipelines][crate::model::publisher_model::call_to_action::OpenFineTuningPipelines::fine_tuning_pipelines].
            pub fn set_fine_tuning_pipelines<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::publisher_model::call_to_action::RegionalResourceReferences,
                >,
            {
                use std::iter::Iterator;
                self.fine_tuning_pipelines = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for OpenFineTuningPipelines {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenFineTuningPipelines"
            }
        }

        /// Model metadata that is needed for UploadModel or
        /// DeployModel/CreateEndpoint requests.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Deploy {
            /// Optional. Default model display name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub model_display_name: std::string::String,

            /// Optional. Large model reference. When this is set, model_artifact_spec
            /// is not needed.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub large_model_reference: std::option::Option<crate::model::LargeModelReference>,

            /// Optional. The specification of the container that is to be used when
            /// deploying this Model in Vertex AI. Not present for Large Models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub container_spec: std::option::Option<crate::model::ModelContainerSpec>,

            /// Optional. The path to the directory containing the Model artifact and
            /// any of its supporting files.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub artifact_uri: std::string::String,

            /// Optional. The name of the deploy task (e.g., "text to image
            /// generation").
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub deploy_task_name: std::option::Option<std::string::String>,

            /// Optional. Metadata information about this deployment config.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub deploy_metadata: std::option::Option<
                crate::model::publisher_model::call_to_action::deploy::DeployMetadata,
            >,

            /// Required. The title of the regional resource reference.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// Optional. The signed URI for ephemeral Cloud Storage access to model
            /// artifact.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub public_artifact_uri: std::string::String,

            /// The prediction (for example, the machine) resources that the
            /// DeployedModel uses.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub prediction_resources: std::option::Option<
                crate::model::publisher_model::call_to_action::deploy::PredictionResources,
            >,
        }

        impl Deploy {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_display_name][crate::model::publisher_model::call_to_action::Deploy::model_display_name].
            pub fn set_model_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.model_display_name = v.into();
                self
            }

            /// Sets the value of [large_model_reference][crate::model::publisher_model::call_to_action::Deploy::large_model_reference].
            pub fn set_large_model_reference<
                T: std::convert::Into<std::option::Option<crate::model::LargeModelReference>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.large_model_reference = v.into();
                self
            }

            /// Sets the value of [container_spec][crate::model::publisher_model::call_to_action::Deploy::container_spec].
            pub fn set_container_spec<
                T: std::convert::Into<std::option::Option<crate::model::ModelContainerSpec>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.container_spec = v.into();
                self
            }

            /// Sets the value of [artifact_uri][crate::model::publisher_model::call_to_action::Deploy::artifact_uri].
            pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.artifact_uri = v.into();
                self
            }

            /// Sets the value of [deploy_task_name][crate::model::publisher_model::call_to_action::Deploy::deploy_task_name].
            pub fn set_deploy_task_name<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.deploy_task_name = v.into();
                self
            }

            /// Sets the value of [deploy_metadata][crate::model::publisher_model::call_to_action::Deploy::deploy_metadata].
            pub fn set_deploy_metadata<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::deploy::DeployMetadata,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.deploy_metadata = v.into();
                self
            }

            /// Sets the value of [title][crate::model::publisher_model::call_to_action::Deploy::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [public_artifact_uri][crate::model::publisher_model::call_to_action::Deploy::public_artifact_uri].
            pub fn set_public_artifact_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.public_artifact_uri = v.into();
                self
            }

            /// Sets the value of `prediction_resources`.
            pub fn set_prediction_resources<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::publisher_model::call_to_action::deploy::PredictionResources,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = v.into();
                self
            }

            /// The value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// if it holds a `DedicatedResources`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_dedicated_resources(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::DedicatedResources>>
            {
                #[allow(unreachable_patterns)]
                self.prediction_resources.as_ref().and_then(|v| match v {
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::DedicatedResources(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// if it holds a `AutomaticResources`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_automatic_resources(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::AutomaticResources>>
            {
                #[allow(unreachable_patterns)]
                self.prediction_resources.as_ref().and_then(|v| match v {
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::AutomaticResources(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// if it holds a `SharedResources`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_shared_resources(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.prediction_resources.as_ref().and_then(|v| match v {
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::SharedResources(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// to hold a `DedicatedResources`.
            ///
            /// Note that all the setters affecting `prediction_resources` are
            /// mutually exclusive.
            pub fn set_dedicated_resources<
                T: std::convert::Into<std::boxed::Box<crate::model::DedicatedResources>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = std::option::Option::Some(
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::DedicatedResources(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// to hold a `AutomaticResources`.
            ///
            /// Note that all the setters affecting `prediction_resources` are
            /// mutually exclusive.
            pub fn set_automatic_resources<
                T: std::convert::Into<std::boxed::Box<crate::model::AutomaticResources>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = std::option::Option::Some(
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::AutomaticResources(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [prediction_resources][crate::model::publisher_model::call_to_action::Deploy::prediction_resources]
            /// to hold a `SharedResources`.
            ///
            /// Note that all the setters affecting `prediction_resources` are
            /// mutually exclusive.
            pub fn set_shared_resources<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.prediction_resources = std::option::Option::Some(
                    crate::model::publisher_model::call_to_action::deploy::PredictionResources::SharedResources(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for Deploy {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy"
            }
        }

        /// Defines additional types related to Deploy
        pub mod deploy {
            #[allow(unused_imports)]
            use super::*;

            /// Metadata information about the deployment for managing deployment
            /// config.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DeployMetadata {
                /// Optional. Labels for the deployment. For managing deployment config
                /// like verifying, source of deployment config, etc.
                #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
                pub labels: std::collections::HashMap<std::string::String, std::string::String>,

                /// Optional. Sample request for deployed endpoint.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub sample_request: std::string::String,
            }

            impl DeployMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [sample_request][crate::model::publisher_model::call_to_action::deploy::DeployMetadata::sample_request].
                pub fn set_sample_request<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.sample_request = v.into();
                    self
                }

                /// Sets the value of [labels][crate::model::publisher_model::call_to_action::deploy::DeployMetadata::labels].
                pub fn set_labels<T, K, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = (K, V)>,
                    K: std::convert::Into<std::string::String>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                    self
                }
            }

            impl wkt::message::Message for DeployMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy.DeployMetadata"
                }
            }

            /// The prediction (for example, the machine) resources that the
            /// DeployedModel uses.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum PredictionResources {
                /// A description of resources that are dedicated to the DeployedModel,
                /// and that need a higher degree of manual configuration.
                DedicatedResources(std::boxed::Box<crate::model::DedicatedResources>),
                /// A description of resources that to large degree are decided by Vertex
                /// AI, and require only a modest additional configuration.
                AutomaticResources(std::boxed::Box<crate::model::AutomaticResources>),
                /// The resource name of the shared DeploymentResourcePool to deploy on.
                /// Format:
                /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
                SharedResources(std::string::String),
            }
        }

        /// Configurations for PublisherModel GKE deployment
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DeployGke {
            /// Optional. GKE deployment configuration in yaml format.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub gke_yaml_configs: std::vec::Vec<std::string::String>,
        }

        impl DeployGke {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gke_yaml_configs][crate::model::publisher_model::call_to_action::DeployGke::gke_yaml_configs].
            pub fn set_gke_yaml_configs<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.gke_yaml_configs = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for DeployGke {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.DeployGke"
            }
        }
    }

    /// An enum representing the open source category of a PublisherModel.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct OpenSourceCategory(std::borrow::Cow<'static, str>);

    impl OpenSourceCategory {
        /// Creates a new OpenSourceCategory instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [OpenSourceCategory](OpenSourceCategory)
    pub mod open_source_category {
        use super::OpenSourceCategory;

        /// The open source category is unspecified, which should not be used.
        pub const OPEN_SOURCE_CATEGORY_UNSPECIFIED: OpenSourceCategory =
            OpenSourceCategory::new("OPEN_SOURCE_CATEGORY_UNSPECIFIED");

        /// Used to indicate the PublisherModel is not open sourced.
        pub const PROPRIETARY: OpenSourceCategory = OpenSourceCategory::new("PROPRIETARY");

        /// Used to indicate the PublisherModel is a Google-owned open source model
        /// w/ Google checkpoint.
        pub const GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT: OpenSourceCategory =
            OpenSourceCategory::new("GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT");

        /// Used to indicate the PublisherModel is a 3p-owned open source model w/
        /// Google checkpoint.
        pub const THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT: OpenSourceCategory =
            OpenSourceCategory::new("THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT");

        /// Used to indicate the PublisherModel is a Google-owned pure open source
        /// model.
        pub const GOOGLE_OWNED_OSS: OpenSourceCategory =
            OpenSourceCategory::new("GOOGLE_OWNED_OSS");

        /// Used to indicate the PublisherModel is a 3p-owned pure open source model.
        pub const THIRD_PARTY_OWNED_OSS: OpenSourceCategory =
            OpenSourceCategory::new("THIRD_PARTY_OWNED_OSS");
    }

    impl std::convert::From<std::string::String> for OpenSourceCategory {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// An enum representing the launch stage of a PublisherModel.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LaunchStage(std::borrow::Cow<'static, str>);

    impl LaunchStage {
        /// Creates a new LaunchStage instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [LaunchStage](LaunchStage)
    pub mod launch_stage {
        use super::LaunchStage;

        /// The model launch stage is unspecified.
        pub const LAUNCH_STAGE_UNSPECIFIED: LaunchStage =
            LaunchStage::new("LAUNCH_STAGE_UNSPECIFIED");

        /// Used to indicate the PublisherModel is at Experimental launch stage,
        /// available to a small set of customers.
        pub const EXPERIMENTAL: LaunchStage = LaunchStage::new("EXPERIMENTAL");

        /// Used to indicate the PublisherModel is at Private Preview launch stage,
        /// only available to a small set of customers, although a larger set of
        /// customers than an Experimental launch. Previews are the first launch
        /// stage used to get feedback from customers.
        pub const PRIVATE_PREVIEW: LaunchStage = LaunchStage::new("PRIVATE_PREVIEW");

        /// Used to indicate the PublisherModel is at Public Preview launch stage,
        /// available to all customers, although not supported for production
        /// workloads.
        pub const PUBLIC_PREVIEW: LaunchStage = LaunchStage::new("PUBLIC_PREVIEW");

        /// Used to indicate the PublisherModel is at GA launch stage, available to
        /// all customers and ready for production workload.
        pub const GA: LaunchStage = LaunchStage::new("GA");
    }

    impl std::convert::From<std::string::String> for LaunchStage {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// An enum representing the state of the PublicModelVersion.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VersionState(std::borrow::Cow<'static, str>);

    impl VersionState {
        /// Creates a new VersionState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [VersionState](VersionState)
    pub mod version_state {
        use super::VersionState;

        /// The version state is unspecified.
        pub const VERSION_STATE_UNSPECIFIED: VersionState =
            VersionState::new("VERSION_STATE_UNSPECIFIED");

        /// Used to indicate the version is stable.
        pub const VERSION_STATE_STABLE: VersionState = VersionState::new("VERSION_STATE_STABLE");

        /// Used to indicate the version is unstable.
        pub const VERSION_STATE_UNSTABLE: VersionState =
            VersionState::new("VERSION_STATE_UNSTABLE");
    }

    impl std::convert::From<std::string::String> for VersionState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// ReasoningEngine configurations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReasoningEngineSpec {
    /// Required. User provided package spec of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub package_spec: std::option::Option<crate::model::reasoning_engine_spec::PackageSpec>,

    /// Optional. Declarations for object class methods in OpenAPI specification
    /// format.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub class_methods: std::vec::Vec<wkt::Struct>,
}

impl ReasoningEngineSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_spec][crate::model::ReasoningEngineSpec::package_spec].
    pub fn set_package_spec<
        T: std::convert::Into<std::option::Option<crate::model::reasoning_engine_spec::PackageSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.package_spec = v.into();
        self
    }

    /// Sets the value of [class_methods][crate::model::ReasoningEngineSpec::class_methods].
    pub fn set_class_methods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Struct>,
    {
        use std::iter::Iterator;
        self.class_methods = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReasoningEngineSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec"
    }
}

/// Defines additional types related to ReasoningEngineSpec
pub mod reasoning_engine_spec {
    #[allow(unused_imports)]
    use super::*;

    /// User provided package spec like pickled object and package requirements.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PackageSpec {
        /// Optional. The Cloud Storage URI of the pickled python object.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pickle_object_gcs_uri: std::string::String,

        /// Optional. The Cloud Storage URI of the dependency files in tar.gz format.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dependency_files_gcs_uri: std::string::String,

        /// Optional. The Cloud Storage URI of the `requirements.txt` file
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub requirements_gcs_uri: std::string::String,

        /// Optional. The Python version. Currently support 3.8, 3.9, 3.10, 3.11.
        /// If not specified, default value is 3.10.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub python_version: std::string::String,
    }

    impl PackageSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pickle_object_gcs_uri][crate::model::reasoning_engine_spec::PackageSpec::pickle_object_gcs_uri].
        pub fn set_pickle_object_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pickle_object_gcs_uri = v.into();
            self
        }

        /// Sets the value of [dependency_files_gcs_uri][crate::model::reasoning_engine_spec::PackageSpec::dependency_files_gcs_uri].
        pub fn set_dependency_files_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dependency_files_gcs_uri = v.into();
            self
        }

        /// Sets the value of [requirements_gcs_uri][crate::model::reasoning_engine_spec::PackageSpec::requirements_gcs_uri].
        pub fn set_requirements_gcs_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.requirements_gcs_uri = v.into();
            self
        }

        /// Sets the value of [python_version][crate::model::reasoning_engine_spec::PackageSpec::python_version].
        pub fn set_python_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.python_version = v.into();
            self
        }
    }

    impl wkt::message::Message for PackageSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec.PackageSpec"
        }
    }
}

/// ReasoningEngine provides a customizable runtime for models to determine
/// which actions to take and in which order.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReasoningEngine {
    /// Identifier. The resource name of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The description of the ReasoningEngine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Configurations of the ReasoningEngine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::ReasoningEngineSpec>,

    /// Output only. Timestamp when this ReasoningEngine was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this ReasoningEngine was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Used to perform consistent read-modify-write updates. If not set,
    /// a blind "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl ReasoningEngine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReasoningEngine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ReasoningEngine::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ReasoningEngine::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::ReasoningEngine::spec].
    pub fn set_spec<
        T: std::convert::Into<std::option::Option<crate::model::ReasoningEngineSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ReasoningEngine::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ReasoningEngine::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ReasoningEngine::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for ReasoningEngine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngine"
    }
}

/// Request message for [ReasoningEngineExecutionService.Query][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource to use.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Input content provided by users in JSON object format. Examples
    /// include text query, function calling parameters, media bytes, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input: std::option::Option<wkt::Struct>,

    /// Optional. Class method to be used for the query.
    /// It is optional and defaults to "query" if unspecified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub class_method: std::string::String,
}

impl QueryReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::QueryReasoningEngineRequest::input].
    pub fn set_input<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// Sets the value of [class_method][crate::model::QueryReasoningEngineRequest::class_method].
    pub fn set_class_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.class_method = v.into();
        self
    }
}

impl wkt::message::Message for QueryReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryReasoningEngineRequest"
    }
}

/// Response message for [ReasoningEngineExecutionService.Query][]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryReasoningEngineResponse {
    /// Response provided by users in JSON object format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output: std::option::Option<wkt::Value>,
}

impl QueryReasoningEngineResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output][crate::model::QueryReasoningEngineResponse::output].
    pub fn set_output<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output = v.into();
        self
    }
}

impl wkt::message::Message for QueryReasoningEngineResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryReasoningEngineResponse"
    }
}

/// Request message for [ReasoningEngineExecutionService.StreamQuery][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamQueryReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource to use.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Input content provided by users in JSON object format. Examples
    /// include text query, function calling parameters, media bytes, etc.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input: std::option::Option<wkt::Struct>,

    /// Optional. Class method to be used for the stream query.
    /// It is optional and defaults to "stream_query" if unspecified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub class_method: std::string::String,
}

impl StreamQueryReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamQueryReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input][crate::model::StreamQueryReasoningEngineRequest::input].
    pub fn set_input<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// Sets the value of [class_method][crate::model::StreamQueryReasoningEngineRequest::class_method].
    pub fn set_class_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.class_method = v.into();
        self
    }
}

impl wkt::message::Message for StreamQueryReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamQueryReasoningEngineRequest"
    }
}

/// Request message for
/// [ReasoningEngineService.CreateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine]: crate::client::ReasoningEngineService::create_reasoning_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReasoningEngineRequest {
    /// Required. The resource name of the Location to create the ReasoningEngine
    /// in. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ReasoningEngine to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reasoning_engine: std::option::Option<crate::model::ReasoningEngine>,
}

impl CreateReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReasoningEngineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reasoning_engine][crate::model::CreateReasoningEngineRequest::reasoning_engine].
    pub fn set_reasoning_engine<
        T: std::convert::Into<std::option::Option<crate::model::ReasoningEngine>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reasoning_engine = v.into();
        self
    }
}

impl wkt::message::Message for CreateReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateReasoningEngineRequest"
    }
}

/// Details of
/// [ReasoningEngineService.CreateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine]
/// operation.
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.CreateReasoningEngine]: crate::client::ReasoningEngineService::create_reasoning_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReasoningEngineOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateReasoningEngineOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateReasoningEngineOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateReasoningEngineOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateReasoningEngineOperationMetadata"
    }
}

/// Request message for
/// [ReasoningEngineService.GetReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.GetReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.GetReasoningEngine]: crate::client::ReasoningEngineService::get_reasoning_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetReasoningEngineRequest"
    }
}

/// Request message for
/// [ReasoningEngineService.UpdateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine]: crate::client::ReasoningEngineService::update_reasoning_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateReasoningEngineRequest {
    /// Required. The ReasoningEngine which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reasoning_engine: std::option::Option<crate::model::ReasoningEngine>,

    /// Optional. Mask specifying which fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reasoning_engine][crate::model::UpdateReasoningEngineRequest::reasoning_engine].
    pub fn set_reasoning_engine<
        T: std::convert::Into<std::option::Option<crate::model::ReasoningEngine>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reasoning_engine = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateReasoningEngineRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateReasoningEngineRequest"
    }
}

/// Details of
/// [ReasoningEngineService.UpdateReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine]
/// operation.
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.UpdateReasoningEngine]: crate::client::ReasoningEngineService::update_reasoning_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateReasoningEngineOperationMetadata {
    /// The common part of the operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateReasoningEngineOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateReasoningEngineOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateReasoningEngineOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateReasoningEngineOperationMetadata"
    }
}

/// Request message for
/// [ReasoningEngineService.ListReasoningEngines][google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines]: crate::client::ReasoningEngineService::list_reasoning_engines
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReasoningEnginesRequest {
    /// Required. The resource name of the Location to list the ReasoningEngines
    /// from. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list filter.
    /// More detail in [AIP-160](https://google.aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListReasoningEnginesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReasoningEnginesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReasoningEnginesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReasoningEnginesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReasoningEnginesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReasoningEnginesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListReasoningEnginesRequest"
    }
}

/// Response message for
/// [ReasoningEngineService.ListReasoningEngines][google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines]
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.ListReasoningEngines]: crate::client::ReasoningEngineService::list_reasoning_engines
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReasoningEnginesResponse {
    /// List of ReasoningEngines in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reasoning_engines: std::vec::Vec<crate::model::ReasoningEngine>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListReasoningEnginesRequest.page_token][google.cloud.aiplatform.v1.ListReasoningEnginesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListReasoningEnginesRequest.page_token]: crate::model::ListReasoningEnginesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListReasoningEnginesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListReasoningEnginesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [reasoning_engines][crate::model::ListReasoningEnginesResponse::reasoning_engines].
    pub fn set_reasoning_engines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReasoningEngine>,
    {
        use std::iter::Iterator;
        self.reasoning_engines = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReasoningEnginesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListReasoningEnginesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListReasoningEnginesResponse {
    type PageItem = crate::model::ReasoningEngine;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reasoning_engines
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ReasoningEngineService.DeleteReasoningEngine][google.cloud.aiplatform.v1.ReasoningEngineService.DeleteReasoningEngine].
///
/// [google.cloud.aiplatform.v1.ReasoningEngineService.DeleteReasoningEngine]: crate::client::ReasoningEngineService::delete_reasoning_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteReasoningEngineRequest {
    /// Required. The name of the ReasoningEngine resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteReasoningEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReasoningEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReasoningEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteReasoningEngineRequest"
    }
}

/// A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a
/// DeployedModel) to draw its Compute Engine resources from a Shared
/// Reservation, or exclusively from on-demand capacity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Required. Specifies the reservation affinity type.
    pub reservation_affinity_type: crate::model::reservation_affinity::Type,

    /// Optional. Corresponds to the label key of a reservation resource. To target
    /// a SPECIFIC_RESERVATION by name, use
    /// `compute.googleapis.com/reservation-name` as the key and specify the name
    /// of your reservation as its value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Optional. Corresponds to the label values of a reservation resource. This
    /// must be the full resource name of the reservation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,
}

impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reservation_affinity_type][crate::model::ReservationAffinity::reservation_affinity_type].
    pub fn set_reservation_affinity_type<
        T: std::convert::Into<crate::model::reservation_affinity::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reservation_affinity_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReservationAffinity"
    }
}

/// Defines additional types related to ReservationAffinity
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Identifies a type of reservation affinity.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::borrow::Cow<'static, str>);

    impl Type {
        /// Creates a new Type instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// Default value. This should not be used.
        pub const TYPE_UNSPECIFIED: Type = Type::new("TYPE_UNSPECIFIED");

        /// Do not consume from any reserved capacity, only use on-demand.
        pub const NO_RESERVATION: Type = Type::new("NO_RESERVATION");

        /// Consume any reservation available, falling back to on-demand.
        pub const ANY_RESERVATION: Type = Type::new("ANY_RESERVATION");

        /// Consume from a specific reservation. When chosen, the reservation
        /// must be identified via the `key` and `values` fields.
        pub const SPECIFIC_RESERVATION: Type = Type::new("SPECIFIC_RESERVATION");
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A SavedQuery is a view of the dataset. It references a subset of annotations
/// by problem type and filters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SavedQuery {
    /// Output only. Resource name of the SavedQuery.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the SavedQuery.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Some additional information about the SavedQuery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Value>,

    /// Output only. Timestamp when this SavedQuery was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when SavedQuery was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Filters on the Annotations in the dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_filter: std::string::String,

    /// Required. Problem type of the SavedQuery.
    /// Allowed values:
    ///
    /// * IMAGE_CLASSIFICATION_SINGLE_LABEL
    /// * IMAGE_CLASSIFICATION_MULTI_LABEL
    /// * IMAGE_BOUNDING_POLY
    /// * IMAGE_BOUNDING_BOX
    /// * TEXT_CLASSIFICATION_SINGLE_LABEL
    /// * TEXT_CLASSIFICATION_MULTI_LABEL
    /// * TEXT_EXTRACTION
    /// * TEXT_SENTIMENT
    /// * VIDEO_CLASSIFICATION
    /// * VIDEO_OBJECT_TRACKING
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub problem_type: std::string::String,

    /// Output only. Number of AnnotationSpecs in the context of the SavedQuery.
    pub annotation_spec_count: i32,

    /// Used to perform a consistent read-modify-write update. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. If the Annotations belonging to the SavedQuery can be used for
    /// AutoML training.
    pub support_automl_training: bool,
}

impl SavedQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SavedQuery::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SavedQuery::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SavedQuery::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SavedQuery::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SavedQuery::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [annotation_filter][crate::model::SavedQuery::annotation_filter].
    pub fn set_annotation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_filter = v.into();
        self
    }

    /// Sets the value of [problem_type][crate::model::SavedQuery::problem_type].
    pub fn set_problem_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.problem_type = v.into();
        self
    }

    /// Sets the value of [annotation_spec_count][crate::model::SavedQuery::annotation_spec_count].
    pub fn set_annotation_spec_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.annotation_spec_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::SavedQuery::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [support_automl_training][crate::model::SavedQuery::support_automl_training].
    pub fn set_support_automl_training<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.support_automl_training = v.into();
        self
    }
}

impl wkt::message::Message for SavedQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SavedQuery"
    }
}

/// An instance of a Schedule periodically schedules runs to make API calls based
/// on user specified time specification and API request type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schedule {
    /// Immutable. The resource name of the Schedule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of the Schedule.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Timestamp after which the first run can be scheduled.
    /// Default to Schedule create time if not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Timestamp after which no new runs can be scheduled.
    /// If specified, The schedule will be completed when either
    /// end_time is reached or when scheduled_run_count >= max_run_count.
    /// If not specified, new runs will keep getting scheduled until this Schedule
    /// is paused or deleted. Already scheduled runs will be allowed to complete.
    /// Unset if not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Maximum run count of the schedule.
    /// If specified, The schedule will be completed when either
    /// started_run_count >= max_run_count or when end_time is reached.
    /// If not specified, new runs will keep getting scheduled until this Schedule
    /// is paused or deleted. Already scheduled runs will be allowed to complete.
    /// Unset if not specified.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_run_count: i64,

    /// Output only. The number of runs started by this schedule.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub started_run_count: i64,

    /// Output only. The state of this Schedule.
    pub state: crate::model::schedule::State,

    /// Output only. Timestamp when this Schedule was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule should schedule the next run.
    /// Having a next_run_time in the past means the runs are being started
    /// behind schedule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule was last paused.
    /// Unset if never paused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_pause_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Schedule was last resumed.
    /// Unset if never resumed from pause.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_resume_time: std::option::Option<wkt::Timestamp>,

    /// Required. Maximum number of runs that can be started concurrently for this
    /// Schedule. This is the limit for starting the scheduled requests and not the
    /// execution of the operations/jobs created by the requests (if applicable).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_concurrent_run_count: i64,

    /// Optional. Whether new scheduled runs can be queued when max_concurrent_runs
    /// limit is reached. If set to true, new runs will be queued instead of
    /// skipped. Default to false.
    pub allow_queueing: bool,

    /// Output only. Whether to backfill missed runs when the schedule is resumed
    /// from PAUSED state. If set to true, all missed runs will be scheduled. New
    /// runs will be scheduled after the backfill is complete. Default to false.
    pub catch_up: bool,

    /// Output only. Response of the last scheduled run.
    /// This is the response for starting the scheduled requests and not the
    /// execution of the operations/jobs created by the requests (if applicable).
    /// Unset if no run has been scheduled yet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_scheduled_run_response: std::option::Option<crate::model::schedule::RunResponse>,

    /// Required.
    /// The time specification to launch scheduled runs.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub time_specification: std::option::Option<crate::model::schedule::TimeSpecification>,

    /// Required.
    /// The API request template to launch the scheduled runs.
    /// User-specified ID is not supported in the request template.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::schedule::Request>,
}

impl Schedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Schedule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Schedule::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Schedule::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Schedule::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [max_run_count][crate::model::Schedule::max_run_count].
    pub fn set_max_run_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_run_count = v.into();
        self
    }

    /// Sets the value of [started_run_count][crate::model::Schedule::started_run_count].
    pub fn set_started_run_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.started_run_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Schedule::state].
    pub fn set_state<T: std::convert::Into<crate::model::schedule::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Schedule::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Schedule::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [next_run_time][crate::model::Schedule::next_run_time].
    pub fn set_next_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_run_time = v.into();
        self
    }

    /// Sets the value of [last_pause_time][crate::model::Schedule::last_pause_time].
    pub fn set_last_pause_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_pause_time = v.into();
        self
    }

    /// Sets the value of [last_resume_time][crate::model::Schedule::last_resume_time].
    pub fn set_last_resume_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_resume_time = v.into();
        self
    }

    /// Sets the value of [max_concurrent_run_count][crate::model::Schedule::max_concurrent_run_count].
    pub fn set_max_concurrent_run_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_concurrent_run_count = v.into();
        self
    }

    /// Sets the value of [allow_queueing][crate::model::Schedule::allow_queueing].
    pub fn set_allow_queueing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_queueing = v.into();
        self
    }

    /// Sets the value of [catch_up][crate::model::Schedule::catch_up].
    pub fn set_catch_up<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.catch_up = v.into();
        self
    }

    /// Sets the value of [last_scheduled_run_response][crate::model::Schedule::last_scheduled_run_response].
    pub fn set_last_scheduled_run_response<
        T: std::convert::Into<std::option::Option<crate::model::schedule::RunResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_scheduled_run_response = v.into();
        self
    }

    /// Sets the value of `time_specification`.
    pub fn set_time_specification<
        T: std::convert::Into<std::option::Option<crate::model::schedule::TimeSpecification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_specification = v.into();
        self
    }

    /// The value of [time_specification][crate::model::Schedule::time_specification]
    /// if it holds a `Cron`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cron(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.time_specification.as_ref().and_then(|v| match v {
            crate::model::schedule::TimeSpecification::Cron(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time_specification][crate::model::Schedule::time_specification]
    /// to hold a `Cron`.
    ///
    /// Note that all the setters affecting `time_specification` are
    /// mutually exclusive.
    pub fn set_cron<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_specification =
            std::option::Option::Some(crate::model::schedule::TimeSpecification::Cron(v.into()));
        self
    }

    /// Sets the value of `request`.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::schedule::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::Schedule::request]
    /// if it holds a `CreatePipelineJobRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_create_pipeline_job_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreatePipelineJobRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::schedule::Request::CreatePipelineJobRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::Schedule::request]
    /// if it holds a `CreateNotebookExecutionJobRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_create_notebook_execution_job_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateNotebookExecutionJobRequest>>
    {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::schedule::Request::CreateNotebookExecutionJobRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::Schedule::request]
    /// to hold a `CreatePipelineJobRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_pipeline_job_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreatePipelineJobRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::schedule::Request::CreatePipelineJobRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::Schedule::request]
    /// to hold a `CreateNotebookExecutionJobRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_notebook_execution_job_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateNotebookExecutionJobRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::schedule::Request::CreateNotebookExecutionJobRequest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Schedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Schedule"
    }
}

/// Defines additional types related to Schedule
pub mod schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Status of a scheduled run.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RunResponse {
        /// The scheduled run time based on the user-specified schedule.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub scheduled_run_time: std::option::Option<wkt::Timestamp>,

        /// The response of the scheduled run.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub run_response: std::string::String,
    }

    impl RunResponse {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scheduled_run_time][crate::model::schedule::RunResponse::scheduled_run_time].
        pub fn set_scheduled_run_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scheduled_run_time = v.into();
            self
        }

        /// Sets the value of [run_response][crate::model::schedule::RunResponse::run_response].
        pub fn set_run_response<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.run_response = v.into();
            self
        }
    }

    impl wkt::message::Message for RunResponse {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Schedule.RunResponse"
        }
    }

    /// Possible state of the schedule.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The Schedule is active. Runs are being scheduled on the user-specified
        /// timespec.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// The schedule is paused. No new runs will be created until the schedule
        /// is resumed. Already started runs will be allowed to complete.
        pub const PAUSED: State = State::new("PAUSED");

        /// The Schedule is completed. No new runs will be scheduled. Already started
        /// runs will be allowed to complete. Schedules in completed state cannot be
        /// paused or resumed.
        pub const COMPLETED: State = State::new("COMPLETED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Required.
    /// The time specification to launch scheduled runs.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TimeSpecification {
        /// Cron schedule (<https://en.wikipedia.org/wiki/Cron>) to launch scheduled
        /// runs. To explicitly set a timezone to the cron tab, apply a prefix in the
        /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
        /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
        /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
        /// "TZ=America/New_York 1 * * * *".
        Cron(std::string::String),
    }

    /// Required.
    /// The API request template to launch the scheduled runs.
    /// User-specified ID is not supported in the request template.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// Request for
        /// [PipelineService.CreatePipelineJob][google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob].
        /// CreatePipelineJobRequest.parent field is required (format:
        /// projects/{project}/locations/{location}).
        ///
        /// [google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob]: crate::client::PipelineService::create_pipeline_job
        CreatePipelineJobRequest(std::boxed::Box<crate::model::CreatePipelineJobRequest>),
        /// Request for
        /// [NotebookService.CreateNotebookExecutionJob][google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob].
        ///
        /// [google.cloud.aiplatform.v1.NotebookService.CreateNotebookExecutionJob]: crate::client::NotebookService::create_notebook_execution_job
        CreateNotebookExecutionJobRequest(
            std::boxed::Box<crate::model::CreateNotebookExecutionJobRequest>,
        ),
    }
}

/// Request message for
/// [ScheduleService.CreateSchedule][google.cloud.aiplatform.v1.ScheduleService.CreateSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.CreateSchedule]: crate::client::ScheduleService::create_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateScheduleRequest {
    /// Required. The resource name of the Location to create the Schedule in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Schedule to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::Schedule>,
}

impl CreateScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateScheduleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::CreateScheduleRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<std::option::Option<crate::model::Schedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }
}

impl wkt::message::Message for CreateScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.GetSchedule][google.cloud.aiplatform.v1.ScheduleService.GetSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.GetSchedule]: crate::client::ScheduleService::get_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetScheduleRequest {
    /// Required. The name of the Schedule resource.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.ListSchedules][google.cloud.aiplatform.v1.ScheduleService.ListSchedules].
///
/// [google.cloud.aiplatform.v1.ScheduleService.ListSchedules]: crate::client::ScheduleService::list_schedules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSchedulesRequest {
    /// Required. The resource name of the Location to list the Schedules from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the Schedules that match the filter expression. The following
    /// fields are supported:
    ///
    /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
    /// * `state`: Supports `=` and `!=` comparisons.
    /// * `request`: Supports existence of the <request_type> check.
    ///   (e.g. `create_pipeline_job_request:*` --> Schedule has
    ///   create_pipeline_job_request).
    /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
    ///   Values must be in RFC 3339 format.
    /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, `>=` comparisons and `:*`
    ///   existence check. Values must be in RFC 3339 format.
    /// * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
    ///   comparisons. Values must be in RFC 3339 format.
    ///
    /// Filter expressions can be combined together using logical operators
    /// (`NOT`, `AND` & `OR`).
    /// The syntax to define filter expression is based on
    /// <https://google.aip.dev/160>.
    ///
    /// Examples:
    ///
    /// * `state="ACTIVE" AND display_name:"my_schedule_*"`
    /// * `NOT display_name="my_schedule"`
    /// * `create_time>"2021-05-18T00:00:00Z"`
    /// * `end_time>"2021-05-18T00:00:00Z" OR NOT end_time:*`
    /// * `create_pipeline_job_request:*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The standard list page size.
    /// Default to 100 if not specified.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained via
    /// [ListSchedulesResponse.next_page_token][google.cloud.aiplatform.v1.ListSchedulesResponse.next_page_token]
    /// of the previous
    /// [ScheduleService.ListSchedules][google.cloud.aiplatform.v1.ScheduleService.ListSchedules]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListSchedulesResponse.next_page_token]: crate::model::ListSchedulesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.ScheduleService.ListSchedules]: crate::client::ScheduleService::list_schedules
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A comma-separated list of fields to order by. The default sort order is in
    /// ascending order. Use "desc" after a field name for descending. You can have
    /// multiple order_by fields provided.
    ///
    /// For example, using "create_time desc, end_time" will order results by
    /// create time in descending order, and if there are multiple schedules having
    /// the same create time, order them by the end time in ascending order.
    ///
    /// If order_by is not specified, it will order by default with create_time in
    /// descending order.
    ///
    /// Supported fields:
    ///
    /// * `create_time`
    /// * `start_time`
    /// * `end_time`
    /// * `next_run_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListSchedulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchedulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSchedulesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchedulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchedulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSchedulesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSchedulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSchedulesRequest"
    }
}

/// Response message for
/// [ScheduleService.ListSchedules][google.cloud.aiplatform.v1.ScheduleService.ListSchedules]
///
/// [google.cloud.aiplatform.v1.ScheduleService.ListSchedules]: crate::client::ScheduleService::list_schedules
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSchedulesResponse {
    /// List of Schedules in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schedules: std::vec::Vec<crate::model::Schedule>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListSchedulesRequest.page_token][google.cloud.aiplatform.v1.ListSchedulesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListSchedulesRequest.page_token]: crate::model::ListSchedulesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSchedulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSchedulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [schedules][crate::model::ListSchedulesResponse::schedules].
    pub fn set_schedules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schedule>,
    {
        use std::iter::Iterator;
        self.schedules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSchedulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSchedulesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSchedulesResponse {
    type PageItem = crate::model::Schedule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schedules
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [ScheduleService.DeleteSchedule][google.cloud.aiplatform.v1.ScheduleService.DeleteSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.DeleteSchedule]: crate::client::ScheduleService::delete_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteScheduleRequest {
    /// Required. The name of the Schedule resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.PauseSchedule][google.cloud.aiplatform.v1.ScheduleService.PauseSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.PauseSchedule]: crate::client::ScheduleService::pause_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseScheduleRequest {
    /// Required. The name of the Schedule resource to be paused.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl PauseScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PauseScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.ResumeSchedule][google.cloud.aiplatform.v1.ScheduleService.ResumeSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.ResumeSchedule]: crate::client::ScheduleService::resume_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeScheduleRequest {
    /// Required. The name of the Schedule resource to be resumed.
    /// Format:
    /// `projects/{project}/locations/{location}/schedules/{schedule}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Whether to backfill missed runs when the schedule is resumed from
    /// PAUSED state. If set to true, all missed runs will be scheduled. New runs
    /// will be scheduled after the backfill is complete. This will also update
    /// [Schedule.catch_up][google.cloud.aiplatform.v1.Schedule.catch_up] field.
    /// Default to false.
    ///
    /// [google.cloud.aiplatform.v1.Schedule.catch_up]: crate::model::Schedule::catch_up
    pub catch_up: bool,
}

impl ResumeScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeScheduleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [catch_up][crate::model::ResumeScheduleRequest::catch_up].
    pub fn set_catch_up<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.catch_up = v.into();
        self
    }
}

impl wkt::message::Message for ResumeScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResumeScheduleRequest"
    }
}

/// Request message for
/// [ScheduleService.UpdateSchedule][google.cloud.aiplatform.v1.ScheduleService.UpdateSchedule].
///
/// [google.cloud.aiplatform.v1.ScheduleService.UpdateSchedule]: crate::client::ScheduleService::update_schedule
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateScheduleRequest {
    /// Required. The Schedule which replaces the resource on the server.
    /// The following restrictions will be applied:
    ///
    /// * The scheduled request type cannot be changed.
    /// * The non-empty fields cannot be unset.
    /// * The output_only fields will be ignored if specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::Schedule>,

    /// Required. The update mask applies to the resource. See
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask].
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateScheduleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule][crate::model::UpdateScheduleRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<std::option::Option<crate::model::Schedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateScheduleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateScheduleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateScheduleRequest"
    }
}

/// PSC config that is used to automatically create forwarding rule via
/// ServiceConnectionMap.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PSCAutomationConfig {
    /// Required. Project id used to create forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The full name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
    /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
    /// `projects/{project}/global/networks/{network}`.
    /// Where {project} is a project number, as in '12345', and {network} is
    /// network name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,
}

impl PSCAutomationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PSCAutomationConfig::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PSCAutomationConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for PSCAutomationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PSCAutomationConfig"
    }
}

/// Represents configuration for private service connect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateServiceConnectConfig {
    /// Required. If true, expose the IndexEndpoint via private service connect.
    pub enable_private_service_connect: bool,

    /// A list of Projects from which the forwarding rule will target the service
    /// attachment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub project_allowlist: std::vec::Vec<std::string::String>,

    /// Output only. The name of the generated service attachment resource.
    /// This is only populated if the endpoint is deployed with
    /// PrivateServiceConnect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,
}

impl PrivateServiceConnectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_service_connect][crate::model::PrivateServiceConnectConfig::enable_private_service_connect].
    pub fn set_enable_private_service_connect<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_service_connect = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PrivateServiceConnectConfig::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [project_allowlist][crate::model::PrivateServiceConnectConfig::project_allowlist].
    pub fn set_project_allowlist<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.project_allowlist = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PrivateServiceConnectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PrivateServiceConnectConfig"
    }
}

/// PscAutomatedEndpoints defines the output of the forwarding rule
/// automatically created by each PscAutomationConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscAutomatedEndpoints {
    /// Corresponding project_id in pscAutomationConfigs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Corresponding network in pscAutomationConfigs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Ip Address created by the automated forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub match_address: std::string::String,
}

impl PscAutomatedEndpoints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PscAutomatedEndpoints::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscAutomatedEndpoints::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [match_address][crate::model::PscAutomatedEndpoints::match_address].
    pub fn set_match_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.match_address = v.into();
        self
    }
}

impl wkt::message::Message for PscAutomatedEndpoints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PscAutomatedEndpoints"
    }
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs. It includes a group of specialist managers and workers.
/// Managers are responsible for managing the workers in this pool as well as
/// customers' data labeling jobs associated with this pool. Customers create
/// specialist pool as well as start data labeling jobs on Cloud, managers and
/// workers handle the jobs using CrowdCompute console.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpecialistPool {
    /// Required. The resource name of the SpecialistPool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of the SpecialistPool.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    /// This field should be unique on project-level.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The number of managers in this SpecialistPool.
    pub specialist_managers_count: i32,

    /// The email addresses of the managers in the SpecialistPool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_manager_emails: std::vec::Vec<std::string::String>,

    /// Output only. The resource name of the pending data labeling jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pending_data_labeling_jobs: std::vec::Vec<std::string::String>,

    /// The email addresses of workers in the SpecialistPool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_worker_emails: std::vec::Vec<std::string::String>,
}

impl SpecialistPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SpecialistPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SpecialistPool::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [specialist_managers_count][crate::model::SpecialistPool::specialist_managers_count].
    pub fn set_specialist_managers_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.specialist_managers_count = v.into();
        self
    }

    /// Sets the value of [specialist_manager_emails][crate::model::SpecialistPool::specialist_manager_emails].
    pub fn set_specialist_manager_emails<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specialist_manager_emails = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pending_data_labeling_jobs][crate::model::SpecialistPool::pending_data_labeling_jobs].
    pub fn set_pending_data_labeling_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pending_data_labeling_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [specialist_worker_emails][crate::model::SpecialistPool::specialist_worker_emails].
    pub fn set_specialist_worker_emails<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.specialist_worker_emails = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpecialistPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SpecialistPool"
    }
}

/// Request message for
/// [SpecialistPoolService.CreateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool]: crate::client::SpecialistPoolService::create_specialist_pool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSpecialistPoolRequest {
    /// Required. The parent Project name for the new SpecialistPool.
    /// The form is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The SpecialistPool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub specialist_pool: std::option::Option<crate::model::SpecialistPool>,
}

impl CreateSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSpecialistPoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [specialist_pool][crate::model::CreateSpecialistPoolRequest::specialist_pool].
    pub fn set_specialist_pool<
        T: std::convert::Into<std::option::Option<crate::model::SpecialistPool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.specialist_pool = v.into();
        self
    }
}

impl wkt::message::Message for CreateSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateSpecialistPoolRequest"
    }
}

/// Runtime operation information for
/// [SpecialistPoolService.CreateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.CreateSpecialistPool]: crate::client::SpecialistPoolService::create_specialist_pool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSpecialistPoolOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateSpecialistPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateSpecialistPoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateSpecialistPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateSpecialistPoolOperationMetadata"
    }
}

/// Request message for
/// [SpecialistPoolService.GetSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.GetSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.GetSpecialistPool]: crate::client::SpecialistPoolService::get_specialist_pool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSpecialistPoolRequest {
    /// Required. The name of the SpecialistPool resource.
    /// The form is
    /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSpecialistPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetSpecialistPoolRequest"
    }
}

/// Request message for
/// [SpecialistPoolService.ListSpecialistPools][google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]: crate::client::SpecialistPoolService::list_specialist_pools
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSpecialistPoolsRequest {
    /// Required. The name of the SpecialistPool's parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The standard list page size.
    pub page_size: i32,

    /// The standard list page token.
    /// Typically obtained by
    /// [ListSpecialistPoolsResponse.next_page_token][google.cloud.aiplatform.v1.ListSpecialistPoolsResponse.next_page_token]
    /// of the previous
    /// [SpecialistPoolService.ListSpecialistPools][google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]
    /// call. Return first page if empty.
    ///
    /// [google.cloud.aiplatform.v1.ListSpecialistPoolsResponse.next_page_token]: crate::model::ListSpecialistPoolsResponse::next_page_token
    /// [google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]: crate::client::SpecialistPoolService::list_specialist_pools
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Mask specifying which fields to read. FieldMask represents a set of
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListSpecialistPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSpecialistPoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSpecialistPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSpecialistPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListSpecialistPoolsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListSpecialistPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSpecialistPoolsRequest"
    }
}

/// Response message for
/// [SpecialistPoolService.ListSpecialistPools][google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.ListSpecialistPools]: crate::client::SpecialistPoolService::list_specialist_pools
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSpecialistPoolsResponse {
    /// A list of SpecialistPools that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub specialist_pools: std::vec::Vec<crate::model::SpecialistPool>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSpecialistPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSpecialistPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [specialist_pools][crate::model::ListSpecialistPoolsResponse::specialist_pools].
    pub fn set_specialist_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpecialistPool>,
    {
        use std::iter::Iterator;
        self.specialist_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSpecialistPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSpecialistPoolsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSpecialistPoolsResponse {
    type PageItem = crate::model::SpecialistPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.specialist_pools
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [SpecialistPoolService.DeleteSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.DeleteSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.DeleteSpecialistPool]: crate::client::SpecialistPoolService::delete_specialist_pool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSpecialistPoolRequest {
    /// Required. The resource name of the SpecialistPool to delete. Format:
    /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, any specialist managers in this SpecialistPool will also be
    /// deleted. (Otherwise, the request will only work if the SpecialistPool has
    /// no specialist managers.)
    pub force: bool,
}

impl DeleteSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSpecialistPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteSpecialistPoolRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteSpecialistPoolRequest"
    }
}

/// Request message for
/// [SpecialistPoolService.UpdateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool]: crate::client::SpecialistPoolService::update_specialist_pool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSpecialistPoolRequest {
    /// Required. The SpecialistPool which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub specialist_pool: std::option::Option<crate::model::SpecialistPool>,

    /// Required. The update mask applies to the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateSpecialistPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [specialist_pool][crate::model::UpdateSpecialistPoolRequest::specialist_pool].
    pub fn set_specialist_pool<
        T: std::convert::Into<std::option::Option<crate::model::SpecialistPool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.specialist_pool = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSpecialistPoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSpecialistPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateSpecialistPoolRequest"
    }
}

/// Runtime operation metadata for
/// [SpecialistPoolService.UpdateSpecialistPool][google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool].
///
/// [google.cloud.aiplatform.v1.SpecialistPoolService.UpdateSpecialistPool]: crate::client::SpecialistPoolService::update_specialist_pool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSpecialistPoolOperationMetadata {
    /// Output only. The name of the SpecialistPool to which the specialists are
    /// being added. Format:
    /// `projects/{project_id}/locations/{location_id}/specialistPools/{specialist_pool}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub specialist_pool: std::string::String,

    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateSpecialistPoolOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [specialist_pool][crate::model::UpdateSpecialistPoolOperationMetadata::specialist_pool].
    pub fn set_specialist_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.specialist_pool = v.into();
        self
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateSpecialistPoolOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSpecialistPoolOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateSpecialistPoolOperationMetadata"
    }
}

/// A message representing a Study.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Study {
    /// Output only. The name of a study. The study's globally unique identifier.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Describes the Study, default value is empty string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Configuration of the Study.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study_spec: std::option::Option<crate::model::StudySpec>,

    /// Output only. The detailed state of a Study.
    pub state: crate::model::study::State,

    /// Output only. Time at which the study was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A human readable reason why the Study is inactive.
    /// This should be empty if a study is ACTIVE or COMPLETED.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inactive_reason: std::string::String,
}

impl Study {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Study::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Study::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [study_spec][crate::model::Study::study_spec].
    pub fn set_study_spec<T: std::convert::Into<std::option::Option<crate::model::StudySpec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.study_spec = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Study::state].
    pub fn set_state<T: std::convert::Into<crate::model::study::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Study::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [inactive_reason][crate::model::Study::inactive_reason].
    pub fn set_inactive_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.inactive_reason = v.into();
        self
    }
}

impl wkt::message::Message for Study {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Study"
    }
}

/// Defines additional types related to Study
pub mod study {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the Study state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The study state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The study is active.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// The study is stopped due to an internal error.
        pub const INACTIVE: State = State::new("INACTIVE");

        /// The study is done when the service exhausts the parameter search space
        /// or max_trial_count is reached.
        pub const COMPLETED: State = State::new("COMPLETED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A message representing a Trial. A Trial contains a unique set of Parameters
/// that has been or will be evaluated, along with the objective metrics got by
/// running the Trial.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trial {
    /// Output only. Resource name of the Trial assigned by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The identifier of the Trial assigned by the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The detailed state of the Trial.
    pub state: crate::model::trial::State,

    /// Output only. The parameters of the Trial.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::trial::Parameter>,

    /// Output only. The final measurement containing the objective value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_measurement: std::option::Option<crate::model::Measurement>,

    /// Output only. A list of measurements that are strictly lexicographically
    /// ordered by their induced tuples (steps, elapsed_duration).
    /// These are used for early stopping computations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub measurements: std::vec::Vec<crate::model::Measurement>,

    /// Output only. Time when the Trial was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the Trial's status changed to `SUCCEEDED` or
    /// `INFEASIBLE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The identifier of the client that originally requested this
    /// Trial. Each client is identified by a unique client_id. When a client asks
    /// for a suggestion, Vertex AI Vizier will assign it a Trial. The client
    /// should evaluate the Trial, complete it, and report back to Vertex AI
    /// Vizier. If suggestion is asked again by same client_id before the Trial is
    /// completed, the same Trial will be returned. Multiple clients with
    /// different client_ids can ask for suggestions simultaneously, each of them
    /// will get their own Trial.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,

    /// Output only. A human readable string describing why the Trial is
    /// infeasible. This is set only if Trial state is `INFEASIBLE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub infeasible_reason: std::string::String,

    /// Output only. The CustomJob name linked to the Trial.
    /// It's set for a HyperparameterTuningJob's Trial.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub custom_job: std::string::String,

    /// Output only. URIs for accessing [interactive
    /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
    /// (one URI for each training node). Only available if this trial is part of
    /// a
    /// [HyperparameterTuningJob][google.cloud.aiplatform.v1.HyperparameterTuningJob]
    /// and the job's
    /// [trial_job_spec.enable_web_access][google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]
    /// field is `true`.
    ///
    /// The keys are names of each node used for the trial; for example,
    /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
    /// the second worker pool, and `workerpool1-1` for the second node in the
    /// second worker pool.
    ///
    /// The values are the URIs for each node's interactive shell.
    ///
    /// [google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]: crate::model::CustomJobSpec::enable_web_access
    /// [google.cloud.aiplatform.v1.HyperparameterTuningJob]: crate::model::HyperparameterTuningJob
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub web_access_uris: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Trial {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Trial::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Trial::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Trial::state].
    pub fn set_state<T: std::convert::Into<crate::model::trial::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [final_measurement][crate::model::Trial::final_measurement].
    pub fn set_final_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.final_measurement = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Trial::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Trial::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::Trial::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [infeasible_reason][crate::model::Trial::infeasible_reason].
    pub fn set_infeasible_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.infeasible_reason = v.into();
        self
    }

    /// Sets the value of [custom_job][crate::model::Trial::custom_job].
    pub fn set_custom_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_job = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::Trial::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::trial::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [measurements][crate::model::Trial::measurements].
    pub fn set_measurements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Measurement>,
    {
        use std::iter::Iterator;
        self.measurements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [web_access_uris][crate::model::Trial::web_access_uris].
    pub fn set_web_access_uris<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.web_access_uris = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Trial {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Trial"
    }
}

/// Defines additional types related to Trial
pub mod trial {
    #[allow(unused_imports)]
    use super::*;

    /// A message representing a parameter to be tuned.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Parameter {
        /// Output only. The ID of the parameter. The parameter should be defined in
        /// [StudySpec's
        /// Parameters][google.cloud.aiplatform.v1.StudySpec.parameters].
        ///
        /// [google.cloud.aiplatform.v1.StudySpec.parameters]: crate::model::StudySpec::parameters
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub parameter_id: std::string::String,

        /// Output only. The value of the parameter.
        /// `number_value` will be set if a parameter defined in StudySpec is
        /// in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
        /// `string_value` will be set if a parameter defined in StudySpec is
        /// in type 'CATEGORICAL'.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<wkt::Value>,
    }

    impl Parameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter_id][crate::model::trial::Parameter::parameter_id].
        pub fn set_parameter_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_id = v.into();
            self
        }

        /// Sets the value of [value][crate::model::trial::Parameter::value].
        pub fn set_value<T: std::convert::Into<std::option::Option<wkt::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Parameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Trial.Parameter"
        }
    }

    /// Describes a Trial state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The Trial state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Indicates that a specific Trial has been requested, but it has not yet
        /// been suggested by the service.
        pub const REQUESTED: State = State::new("REQUESTED");

        /// Indicates that the Trial has been suggested.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// Indicates that the Trial should stop according to the service.
        pub const STOPPING: State = State::new("STOPPING");

        /// Indicates that the Trial is completed successfully.
        pub const SUCCEEDED: State = State::new("SUCCEEDED");

        /// Indicates that the Trial should not be attempted again.
        /// The service will set a Trial to INFEASIBLE when it's done but missing
        /// the final_measurement.
        pub const INFEASIBLE: State = State::new("INFEASIBLE");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrialContext {
    /// A human-readable field which can store a description of this context.
    /// This will become part of the resulting Trial's description field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// If/when a Trial is generated or selected from this Context,
    /// its Parameters will match any parameters specified here.
    /// (I.e. if this context specifies parameter name:'a' int_value:3,
    /// then a resulting Trial will have int_value:3 for its parameter named
    /// 'a'.) Note that we first attempt to match existing REQUESTED Trials with
    /// contexts, and if there are no matches, we generate suggestions in the
    /// subspace defined by the parameters specified here.
    /// NOTE: a Context without any Parameters matches the entire feasible search
    /// space.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::trial::Parameter>,
}

impl TrialContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::TrialContext::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::TrialContext::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::trial::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TrialContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrialContext"
    }
}

/// Time-based Constraint for Study
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StudyTimeConstraint {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub constraint: std::option::Option<crate::model::study_time_constraint::Constraint>,
}

impl StudyTimeConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `constraint`.
    pub fn set_constraint<
        T: std::convert::Into<std::option::Option<crate::model::study_time_constraint::Constraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = v.into();
        self
    }

    /// The value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// if it holds a `MaxDuration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_max_duration(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::study_time_constraint::Constraint::MaxDuration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// if it holds a `EndTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_end_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::study_time_constraint::Constraint::EndTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// to hold a `MaxDuration`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_max_duration<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = std::option::Option::Some(
            crate::model::study_time_constraint::Constraint::MaxDuration(v.into()),
        );
        self
    }

    /// Sets the value of [constraint][crate::model::StudyTimeConstraint::constraint]
    /// to hold a `EndTime`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_end_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = std::option::Option::Some(
            crate::model::study_time_constraint::Constraint::EndTime(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StudyTimeConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StudyTimeConstraint"
    }
}

/// Defines additional types related to StudyTimeConstraint
pub mod study_time_constraint {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Constraint {
        /// Counts the wallclock time passed since the creation of this Study.
        MaxDuration(std::boxed::Box<wkt::Duration>),
        /// Compares the wallclock time to this time. Must use UTC timezone.
        EndTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// Represents specification of a Study.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StudySpec {
    /// Required. Metric specs for the Study.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::study_spec::MetricSpec>,

    /// Required. The set of parameters to tune.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::study_spec::ParameterSpec>,

    /// The search algorithm specified for the Study.
    pub algorithm: crate::model::study_spec::Algorithm,

    /// The observation noise level of the study.
    /// Currently only supported by the Vertex AI Vizier service. Not supported by
    /// HyperparameterTuningJob or TrainingPipeline.
    pub observation_noise: crate::model::study_spec::ObservationNoise,

    /// Describe which measurement selection type will be used
    pub measurement_selection_type: crate::model::study_spec::MeasurementSelectionType,

    /// Conditions for automated stopping of a Study. Enable automated stopping by
    /// configuring at least one condition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study_stopping_config: std::option::Option<crate::model::study_spec::StudyStoppingConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub automated_stopping_spec:
        std::option::Option<crate::model::study_spec::AutomatedStoppingSpec>,
}

impl StudySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [algorithm][crate::model::StudySpec::algorithm].
    pub fn set_algorithm<T: std::convert::Into<crate::model::study_spec::Algorithm>>(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [observation_noise][crate::model::StudySpec::observation_noise].
    pub fn set_observation_noise<
        T: std::convert::Into<crate::model::study_spec::ObservationNoise>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.observation_noise = v.into();
        self
    }

    /// Sets the value of [measurement_selection_type][crate::model::StudySpec::measurement_selection_type].
    pub fn set_measurement_selection_type<
        T: std::convert::Into<crate::model::study_spec::MeasurementSelectionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.measurement_selection_type = v.into();
        self
    }

    /// Sets the value of [study_stopping_config][crate::model::StudySpec::study_stopping_config].
    pub fn set_study_stopping_config<
        T: std::convert::Into<std::option::Option<crate::model::study_spec::StudyStoppingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.study_stopping_config = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::StudySpec::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::study_spec::MetricSpec>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parameters][crate::model::StudySpec::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::study_spec::ParameterSpec>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `automated_stopping_spec`.
    pub fn set_automated_stopping_spec<
        T: std::convert::Into<std::option::Option<crate::model::study_spec::AutomatedStoppingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = v.into();
        self
    }

    /// The value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// if it holds a `DecayCurveStoppingSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_decay_curve_stopping_spec(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::study_spec::DecayCurveAutomatedStoppingSpec>,
    > {
        #[allow(unreachable_patterns)]
        self.automated_stopping_spec.as_ref().and_then(|v| match v {
            crate::model::study_spec::AutomatedStoppingSpec::DecayCurveStoppingSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// if it holds a `MedianAutomatedStoppingSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_median_automated_stopping_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::MedianAutomatedStoppingSpec>>
    {
        #[allow(unreachable_patterns)]
        self.automated_stopping_spec.as_ref().and_then(|v| match v {
            crate::model::study_spec::AutomatedStoppingSpec::MedianAutomatedStoppingSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// if it holds a `ConvexAutomatedStoppingSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_convex_automated_stopping_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::ConvexAutomatedStoppingSpec>>
    {
        #[allow(unreachable_patterns)]
        self.automated_stopping_spec.as_ref().and_then(|v| match v {
            crate::model::study_spec::AutomatedStoppingSpec::ConvexAutomatedStoppingSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// to hold a `DecayCurveStoppingSpec`.
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are
    /// mutually exclusive.
    pub fn set_decay_curve_stopping_spec<
        T: std::convert::Into<
            std::boxed::Box<crate::model::study_spec::DecayCurveAutomatedStoppingSpec>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = std::option::Option::Some(
            crate::model::study_spec::AutomatedStoppingSpec::DecayCurveStoppingSpec(v.into()),
        );
        self
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// to hold a `MedianAutomatedStoppingSpec`.
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are
    /// mutually exclusive.
    pub fn set_median_automated_stopping_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::study_spec::MedianAutomatedStoppingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = std::option::Option::Some(
            crate::model::study_spec::AutomatedStoppingSpec::MedianAutomatedStoppingSpec(v.into()),
        );
        self
    }

    /// Sets the value of [automated_stopping_spec][crate::model::StudySpec::automated_stopping_spec]
    /// to hold a `ConvexAutomatedStoppingSpec`.
    ///
    /// Note that all the setters affecting `automated_stopping_spec` are
    /// mutually exclusive.
    pub fn set_convex_automated_stopping_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::study_spec::ConvexAutomatedStoppingSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_stopping_spec = std::option::Option::Some(
            crate::model::study_spec::AutomatedStoppingSpec::ConvexAutomatedStoppingSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StudySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec"
    }
}

/// Defines additional types related to StudySpec
pub mod study_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a metric to optimize.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetricSpec {
        /// Required. The ID of the metric. Must not contain whitespaces and must be
        /// unique amongst all MetricSpecs.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metric_id: std::string::String,

        /// Required. The optimization goal of the metric.
        pub goal: crate::model::study_spec::metric_spec::GoalType,

        /// Used for safe search. In the case, the metric will be a safety
        /// metric. You must provide a separate metric for objective metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub safety_config:
            std::option::Option<crate::model::study_spec::metric_spec::SafetyMetricConfig>,
    }

    impl MetricSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metric_id][crate::model::study_spec::MetricSpec::metric_id].
        pub fn set_metric_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.metric_id = v.into();
            self
        }

        /// Sets the value of [goal][crate::model::study_spec::MetricSpec::goal].
        pub fn set_goal<T: std::convert::Into<crate::model::study_spec::metric_spec::GoalType>>(
            mut self,
            v: T,
        ) -> Self {
            self.goal = v.into();
            self
        }

        /// Sets the value of [safety_config][crate::model::study_spec::MetricSpec::safety_config].
        pub fn set_safety_config<
            T: std::convert::Into<
                std::option::Option<crate::model::study_spec::metric_spec::SafetyMetricConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.safety_config = v.into();
            self
        }
    }

    impl wkt::message::Message for MetricSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MetricSpec"
        }
    }

    /// Defines additional types related to MetricSpec
    pub mod metric_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Used in safe optimization to specify threshold levels and risk tolerance.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SafetyMetricConfig {
            /// Safety threshold (boundary value between safe and unsafe). NOTE that if
            /// you leave SafetyMetricConfig unset, a default value of 0 will be used.
            pub safety_threshold: f64,

            /// Desired minimum fraction of safe trials (over total number of trials)
            /// that should be targeted by the algorithm at any time during the
            /// study (best effort). This should be between 0.0 and 1.0 and a value of
            /// 0.0 means that there is no minimum and an algorithm proceeds without
            /// targeting any specific fraction. A value of 1.0 means that the
            /// algorithm attempts to only Suggest safe Trials.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub desired_min_safe_trials_fraction: std::option::Option<f64>,
        }

        impl SafetyMetricConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [safety_threshold][crate::model::study_spec::metric_spec::SafetyMetricConfig::safety_threshold].
            pub fn set_safety_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.safety_threshold = v.into();
                self
            }

            /// Sets the value of [desired_min_safe_trials_fraction][crate::model::study_spec::metric_spec::SafetyMetricConfig::desired_min_safe_trials_fraction].
            pub fn set_desired_min_safe_trials_fraction<
                T: std::convert::Into<std::option::Option<f64>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.desired_min_safe_trials_fraction = v.into();
                self
            }
        }

        impl wkt::message::Message for SafetyMetricConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MetricSpec.SafetyMetricConfig"
            }
        }

        /// The available types of optimization goals.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct GoalType(std::borrow::Cow<'static, str>);

        impl GoalType {
            /// Creates a new GoalType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [GoalType](GoalType)
        pub mod goal_type {
            use super::GoalType;

            /// Goal Type will default to maximize.
            pub const GOAL_TYPE_UNSPECIFIED: GoalType = GoalType::new("GOAL_TYPE_UNSPECIFIED");

            /// Maximize the goal metric.
            pub const MAXIMIZE: GoalType = GoalType::new("MAXIMIZE");

            /// Minimize the goal metric.
            pub const MINIMIZE: GoalType = GoalType::new("MINIMIZE");
        }

        impl std::convert::From<std::string::String> for GoalType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Represents a single parameter to optimize.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ParameterSpec {
        /// Required. The ID of the parameter. Must not contain whitespaces and must
        /// be unique amongst all ParameterSpecs.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub parameter_id: std::string::String,

        /// How the parameter should be scaled.
        /// Leave unset for `CATEGORICAL` parameters.
        pub scale_type: crate::model::study_spec::parameter_spec::ScaleType,

        /// A conditional parameter node is active if the parameter's value matches
        /// the conditional node's parent_value_condition.
        ///
        /// If two items in conditional_parameter_specs have the same name, they
        /// must have disjoint parent_value_condition.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub conditional_parameter_specs:
            std::vec::Vec<crate::model::study_spec::parameter_spec::ConditionalParameterSpec>,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub parameter_value_spec:
            std::option::Option<crate::model::study_spec::parameter_spec::ParameterValueSpec>,
    }

    impl ParameterSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter_id][crate::model::study_spec::ParameterSpec::parameter_id].
        pub fn set_parameter_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_id = v.into();
            self
        }

        /// Sets the value of [scale_type][crate::model::study_spec::ParameterSpec::scale_type].
        pub fn set_scale_type<
            T: std::convert::Into<crate::model::study_spec::parameter_spec::ScaleType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scale_type = v.into();
            self
        }

        /// Sets the value of [conditional_parameter_specs][crate::model::study_spec::ParameterSpec::conditional_parameter_specs].
        pub fn set_conditional_parameter_specs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::study_spec::parameter_spec::ConditionalParameterSpec,
            >,
        {
            use std::iter::Iterator;
            self.conditional_parameter_specs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of `parameter_value_spec`.
        pub fn set_parameter_value_spec<
            T: std::convert::Into<
                std::option::Option<crate::model::study_spec::parameter_spec::ParameterValueSpec>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = v.into();
            self
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `DoubleValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_double_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::DoubleValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DoubleValueSpec(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `IntegerValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_integer_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::IntegerValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::IntegerValueSpec(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `CategoricalValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_categorical_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::CategoricalValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::CategoricalValueSpec(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// if it holds a `DiscreteValueSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_discrete_value_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::study_spec::parameter_spec::DiscreteValueSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.parameter_value_spec.as_ref().and_then(|v| match v {
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DiscreteValueSpec(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `DoubleValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_double_value_spec<
            T: std::convert::Into<
                std::boxed::Box<crate::model::study_spec::parameter_spec::DoubleValueSpec>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DoubleValueSpec(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `IntegerValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_integer_value_spec<
            T: std::convert::Into<
                std::boxed::Box<crate::model::study_spec::parameter_spec::IntegerValueSpec>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::IntegerValueSpec(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `CategoricalValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_categorical_value_spec<
            T: std::convert::Into<
                std::boxed::Box<crate::model::study_spec::parameter_spec::CategoricalValueSpec>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::CategoricalValueSpec(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [parameter_value_spec][crate::model::study_spec::ParameterSpec::parameter_value_spec]
        /// to hold a `DiscreteValueSpec`.
        ///
        /// Note that all the setters affecting `parameter_value_spec` are
        /// mutually exclusive.
        pub fn set_discrete_value_spec<
            T: std::convert::Into<
                std::boxed::Box<crate::model::study_spec::parameter_spec::DiscreteValueSpec>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.parameter_value_spec = std::option::Option::Some(
                crate::model::study_spec::parameter_spec::ParameterValueSpec::DiscreteValueSpec(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ParameterSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec"
        }
    }

    /// Defines additional types related to ParameterSpec
    pub mod parameter_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Value specification for a parameter in `DOUBLE` type.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DoubleValueSpec {
            /// Required. Inclusive minimum value of the parameter.
            pub min_value: f64,

            /// Required. Inclusive maximum value of the parameter.
            pub max_value: f64,

            /// A default value for a `DOUBLE` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<f64>,
        }

        impl DoubleValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_value][crate::model::study_spec::parameter_spec::DoubleValueSpec::min_value].
            pub fn set_min_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::study_spec::parameter_spec::DoubleValueSpec::max_value].
            pub fn set_max_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::DoubleValueSpec::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<f64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }
        }

        impl wkt::message::Message for DoubleValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DoubleValueSpec"
            }
        }

        /// Value specification for a parameter in `INTEGER` type.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IntegerValueSpec {
            /// Required. Inclusive minimum value of the parameter.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub min_value: i64,

            /// Required. Inclusive maximum value of the parameter.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_value: i64,

            /// A default value for an `INTEGER` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub default_value: std::option::Option<i64>,
        }

        impl IntegerValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min_value][crate::model::study_spec::parameter_spec::IntegerValueSpec::min_value].
            pub fn set_min_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::study_spec::parameter_spec::IntegerValueSpec::max_value].
            pub fn set_max_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::IntegerValueSpec::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<i64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }
        }

        impl wkt::message::Message for IntegerValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.IntegerValueSpec"
            }
        }

        /// Value specification for a parameter in `CATEGORICAL` type.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CategoricalValueSpec {
            /// Required. The list of possible categories.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub values: std::vec::Vec<std::string::String>,

            /// A default value for a `CATEGORICAL` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<std::string::String>,
        }

        impl CategoricalValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::CategoricalValueSpec::default_value].
            pub fn set_default_value<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }

            /// Sets the value of [values][crate::model::study_spec::parameter_spec::CategoricalValueSpec::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CategoricalValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.CategoricalValueSpec"
            }
        }

        /// Value specification for a parameter in `DISCRETE` type.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DiscreteValueSpec {
            /// Required. A list of possible values.
            /// The list should be in increasing order and at least 1e-10 apart.
            /// For instance, this parameter might have possible settings of 1.5, 2.5,
            /// and 4.0. This list should not contain more than 1,000 values.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub values: std::vec::Vec<f64>,

            /// A default value for a `DISCRETE` parameter that is assumed to be a
            /// relatively good starting point.  Unset value signals that there is no
            /// offered starting point.  It automatically rounds to the
            /// nearest feasible discrete point.
            ///
            /// Currently only supported by the Vertex AI Vizier service. Not supported
            /// by HyperparameterTuningJob or TrainingPipeline.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub default_value: std::option::Option<f64>,
        }

        impl DiscreteValueSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [default_value][crate::model::study_spec::parameter_spec::DiscreteValueSpec::default_value].
            pub fn set_default_value<T: std::convert::Into<std::option::Option<f64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_value = v.into();
                self
            }

            /// Sets the value of [values][crate::model::study_spec::parameter_spec::DiscreteValueSpec::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<f64>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for DiscreteValueSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DiscreteValueSpec"
            }
        }

        /// Represents a parameter spec with condition from its parent parameter.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ConditionalParameterSpec {

            /// Required. The spec for a conditional parameter.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub parameter_spec: std::option::Option<std::boxed::Box<crate::model::study_spec::ParameterSpec>>,

            /// A set of parameter values from the parent ParameterSpec's feasible
            /// space.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub parent_value_condition: std::option::Option<crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition>,
        }

        impl ConditionalParameterSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [parameter_spec][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parameter_spec].
            pub fn set_parameter_spec<
                T: std::convert::Into<
                    std::option::Option<std::boxed::Box<crate::model::study_spec::ParameterSpec>>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.parameter_spec = v.into();
                self
            }

            /// Sets the value of `parent_value_condition`.
            pub fn set_parent_value_condition<T: std::convert::Into<std::option::Option<crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition>>>(mut self, v: T) -> Self
            {
                self.parent_value_condition = v.into();
                self
            }

            /// The value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// if it holds a `ParentDiscreteValues`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_parent_discrete_values(&self) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition>>{
                #[allow(unreachable_patterns)]
                self.parent_value_condition.as_ref().and_then(|v| match v {
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentDiscreteValues(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// if it holds a `ParentIntValues`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_parent_int_values(&self) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition>>{
                #[allow(unreachable_patterns)]
                self.parent_value_condition.as_ref().and_then(|v| match v {
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentIntValues(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// The value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// if it holds a `ParentCategoricalValues`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_parent_categorical_values(&self) -> std::option::Option<&std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition>>{
                #[allow(unreachable_patterns)]
                self.parent_value_condition.as_ref().and_then(|v| match v {
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentCategoricalValues(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// to hold a `ParentDiscreteValues`.
            ///
            /// Note that all the setters affecting `parent_value_condition` are
            /// mutually exclusive.
            pub fn set_parent_discrete_values<T: std::convert::Into<std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition>>>(mut self, v: T) -> Self{
                self.parent_value_condition = std::option::Option::Some(
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentDiscreteValues(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// to hold a `ParentIntValues`.
            ///
            /// Note that all the setters affecting `parent_value_condition` are
            /// mutually exclusive.
            pub fn set_parent_int_values<T: std::convert::Into<std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition>>>(mut self, v: T) -> Self{
                self.parent_value_condition = std::option::Option::Some(
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentIntValues(
                        v.into()
                    )
                );
                self
            }

            /// Sets the value of [parent_value_condition][crate::model::study_spec::parameter_spec::ConditionalParameterSpec::parent_value_condition]
            /// to hold a `ParentCategoricalValues`.
            ///
            /// Note that all the setters affecting `parent_value_condition` are
            /// mutually exclusive.
            pub fn set_parent_categorical_values<T: std::convert::Into<std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition>>>(mut self, v: T) -> Self{
                self.parent_value_condition = std::option::Option::Some(
                    crate::model::study_spec::parameter_spec::conditional_parameter_spec::ParentValueCondition::ParentCategoricalValues(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for ConditionalParameterSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec"
            }
        }

        /// Defines additional types related to ConditionalParameterSpec
        pub mod conditional_parameter_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Represents the spec to match discrete values from parent parameter.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DiscreteValueCondition {
                /// Required. Matches values of the parent parameter of 'DISCRETE' type.
                /// All values must exist in `discrete_value_spec` of parent parameter.
                ///
                /// The Epsilon of the value matching is 1e-10.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub values: std::vec::Vec<f64>,
            }

            impl DiscreteValueCondition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [values][crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition::values].
                pub fn set_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<f64>,
                {
                    use std::iter::Iterator;
                    self.values = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for DiscreteValueCondition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition"
                }
            }

            /// Represents the spec to match integer values from parent parameter.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct IntValueCondition {
                /// Required. Matches values of the parent parameter of 'INTEGER' type.
                /// All values must lie in `integer_value_spec` of parent parameter.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
                pub values: std::vec::Vec<i64>,
            }

            impl IntValueCondition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [values][crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition::values].
                pub fn set_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<i64>,
                {
                    use std::iter::Iterator;
                    self.values = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for IntValueCondition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition"
                }
            }

            /// Represents the spec to match categorical values from parent parameter.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct CategoricalValueCondition {
                /// Required. Matches values of the parent parameter of 'CATEGORICAL'
                /// type. All values must exist in `categorical_value_spec` of parent
                /// parameter.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub values: std::vec::Vec<std::string::String>,
            }

            impl CategoricalValueCondition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [values][crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition::values].
                pub fn set_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.values = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for CategoricalValueCondition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition"
                }
            }

            /// A set of parameter values from the parent ParameterSpec's feasible
            /// space.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum ParentValueCondition {
                /// The spec for matching values from a parent parameter of
                /// `DISCRETE` type.
                ParentDiscreteValues(std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::DiscreteValueCondition>),
                /// The spec for matching values from a parent parameter of `INTEGER`
                /// type.
                ParentIntValues(std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::IntValueCondition>),
                /// The spec for matching values from a parent parameter of
                /// `CATEGORICAL` type.
                ParentCategoricalValues(std::boxed::Box<crate::model::study_spec::parameter_spec::conditional_parameter_spec::CategoricalValueCondition>),
            }
        }

        /// The type of scaling that should be applied to this parameter.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ScaleType(std::borrow::Cow<'static, str>);

        impl ScaleType {
            /// Creates a new ScaleType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ScaleType](ScaleType)
        pub mod scale_type {
            use super::ScaleType;

            /// By default, no scaling is applied.
            pub const SCALE_TYPE_UNSPECIFIED: ScaleType = ScaleType::new("SCALE_TYPE_UNSPECIFIED");

            /// Scales the feasible space to (0, 1) linearly.
            pub const UNIT_LINEAR_SCALE: ScaleType = ScaleType::new("UNIT_LINEAR_SCALE");

            /// Scales the feasible space logarithmically to (0, 1). The entire
            /// feasible space must be strictly positive.
            pub const UNIT_LOG_SCALE: ScaleType = ScaleType::new("UNIT_LOG_SCALE");

            /// Scales the feasible space "reverse" logarithmically to (0, 1). The
            /// result is that values close to the top of the feasible space are spread
            /// out more than points near the bottom. The entire feasible space must be
            /// strictly positive.
            pub const UNIT_REVERSE_LOG_SCALE: ScaleType = ScaleType::new("UNIT_REVERSE_LOG_SCALE");
        }

        impl std::convert::From<std::string::String> for ScaleType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ParameterValueSpec {
            /// The value spec for a 'DOUBLE' parameter.
            DoubleValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::DoubleValueSpec>,
            ),
            /// The value spec for an 'INTEGER' parameter.
            IntegerValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::IntegerValueSpec>,
            ),
            /// The value spec for a 'CATEGORICAL' parameter.
            CategoricalValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::CategoricalValueSpec>,
            ),
            /// The value spec for a 'DISCRETE' parameter.
            DiscreteValueSpec(
                std::boxed::Box<crate::model::study_spec::parameter_spec::DiscreteValueSpec>,
            ),
        }
    }

    /// The decay curve automated stopping rule builds a Gaussian Process
    /// Regressor to predict the final objective value of a Trial based on the
    /// already completed Trials and the intermediate measurements of the current
    /// Trial. Early stopping is requested for the current Trial if there is very
    /// low probability to exceed the optimal value found so far.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DecayCurveAutomatedStoppingSpec {
        /// True if
        /// [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration]
        /// is used as the x-axis of each Trials Decay Curve. Otherwise,
        /// [Measurement.step_count][google.cloud.aiplatform.v1.Measurement.step_count]
        /// will be used as the x-axis.
        ///
        /// [google.cloud.aiplatform.v1.Measurement.elapsed_duration]: crate::model::Measurement::elapsed_duration
        /// [google.cloud.aiplatform.v1.Measurement.step_count]: crate::model::Measurement::step_count
        pub use_elapsed_duration: bool,
    }

    impl DecayCurveAutomatedStoppingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [use_elapsed_duration][crate::model::study_spec::DecayCurveAutomatedStoppingSpec::use_elapsed_duration].
        pub fn set_use_elapsed_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_elapsed_duration = v.into();
            self
        }
    }

    impl wkt::message::Message for DecayCurveAutomatedStoppingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.DecayCurveAutomatedStoppingSpec"
        }
    }

    /// The median automated stopping rule stops a pending Trial if the Trial's
    /// best objective_value is strictly below the median 'performance' of all
    /// completed Trials reported up to the Trial's last measurement.
    /// Currently, 'performance' refers to the running average of the objective
    /// values reported by the Trial in each measurement.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MedianAutomatedStoppingSpec {
        /// True if median automated stopping rule applies on
        /// [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration].
        /// It means that elapsed_duration field of latest measurement of current
        /// Trial is used to compute median objective value for each completed
        /// Trials.
        ///
        /// [google.cloud.aiplatform.v1.Measurement.elapsed_duration]: crate::model::Measurement::elapsed_duration
        pub use_elapsed_duration: bool,
    }

    impl MedianAutomatedStoppingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [use_elapsed_duration][crate::model::study_spec::MedianAutomatedStoppingSpec::use_elapsed_duration].
        pub fn set_use_elapsed_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_elapsed_duration = v.into();
            self
        }
    }

    impl wkt::message::Message for MedianAutomatedStoppingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MedianAutomatedStoppingSpec"
        }
    }

    /// Configuration for ConvexAutomatedStoppingSpec.
    /// When there are enough completed trials (configured by
    /// min_measurement_count), for pending trials with enough measurements and
    /// steps, the policy first computes an overestimate of the objective value at
    /// max_num_steps according to the slope of the incomplete objective value
    /// curve. No prediction can be made if the curve is completely flat. If the
    /// overestimation is worse than the best objective value of the completed
    /// trials, this pending trial will be early-stopped, but a last measurement
    /// will be added to the pending trial with max_num_steps and predicted
    /// objective value from the autoregression model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConvexAutomatedStoppingSpec {
        /// Steps used in predicting the final objective for early stopped trials. In
        /// general, it's set to be the same as the defined steps in training /
        /// tuning. If not defined, it will learn it from the completed trials. When
        /// use_steps is false, this field is set to the maximum elapsed seconds.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_step_count: i64,

        /// Minimum number of steps for a trial to complete. Trials which do not have
        /// a measurement with step_count > min_step_count won't be considered for
        /// early stopping. It's ok to set it to 0, and a trial can be early stopped
        /// at any stage. By default, min_step_count is set to be one-tenth of the
        /// max_step_count.
        /// When use_elapsed_duration is true, this field is set to the minimum
        /// elapsed seconds.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub min_step_count: i64,

        /// The minimal number of measurements in a Trial.  Early-stopping checks
        /// will not trigger if less than min_measurement_count+1 completed trials or
        /// pending trials with less than min_measurement_count measurements. If not
        /// defined, the default value is 5.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub min_measurement_count: i64,

        /// The hyper-parameter name used in the tuning job that stands for learning
        /// rate. Leave it blank if learning rate is not in a parameter in tuning.
        /// The learning_rate is used to estimate the objective value of the ongoing
        /// trial.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub learning_rate_parameter_name: std::string::String,

        /// This bool determines whether or not the rule is applied based on
        /// elapsed_secs or steps. If use_elapsed_duration==false, the early stopping
        /// decision is made according to the predicted objective values according to
        /// the target steps. If use_elapsed_duration==true, elapsed_secs is used
        /// instead of steps. Also, in this case, the parameters max_num_steps and
        /// min_num_steps are overloaded to contain max_elapsed_seconds and
        /// min_elapsed_seconds.
        pub use_elapsed_duration: bool,

        /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
        /// to be early stopped using a newly trained auto-regressive model. When
        /// this flag is set to True, all stopped trials from the beginning are
        /// potentially updated in terms of their `final_measurement`. Also, note
        /// that the training logic of autoregressive models is different in this
        /// case. Enabling this option has shown better results and this may be the
        /// default option in the future.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_all_stopped_trials: std::option::Option<bool>,
    }

    impl ConvexAutomatedStoppingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_step_count][crate::model::study_spec::ConvexAutomatedStoppingSpec::max_step_count].
        pub fn set_max_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_step_count = v.into();
            self
        }

        /// Sets the value of [min_step_count][crate::model::study_spec::ConvexAutomatedStoppingSpec::min_step_count].
        pub fn set_min_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.min_step_count = v.into();
            self
        }

        /// Sets the value of [min_measurement_count][crate::model::study_spec::ConvexAutomatedStoppingSpec::min_measurement_count].
        pub fn set_min_measurement_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.min_measurement_count = v.into();
            self
        }

        /// Sets the value of [learning_rate_parameter_name][crate::model::study_spec::ConvexAutomatedStoppingSpec::learning_rate_parameter_name].
        pub fn set_learning_rate_parameter_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.learning_rate_parameter_name = v.into();
            self
        }

        /// Sets the value of [use_elapsed_duration][crate::model::study_spec::ConvexAutomatedStoppingSpec::use_elapsed_duration].
        pub fn set_use_elapsed_duration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_elapsed_duration = v.into();
            self
        }

        /// Sets the value of [update_all_stopped_trials][crate::model::study_spec::ConvexAutomatedStoppingSpec::update_all_stopped_trials].
        pub fn set_update_all_stopped_trials<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_all_stopped_trials = v.into();
            self
        }
    }

    impl wkt::message::Message for ConvexAutomatedStoppingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ConvexAutomatedStoppingSpec"
        }
    }

    /// The configuration (stopping conditions) for automated stopping of a Study.
    /// Conditions include trial budgets, time budgets, and convergence detection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StudyStoppingConfig {
        /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
        /// STOPPING state.
        ///
        /// The bottom line is: set to true if you want to interrupt on-going
        /// evaluations of Trials as soon as the study stopping condition is met.
        /// (Please see Study.State documentation for the source of truth).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub should_stop_asap: std::option::Option<wkt::BoolValue>,

        /// Each "stopping rule" in this proto specifies an "if" condition. Before
        /// Vizier would generate a new suggestion, it first checks each specified
        /// stopping rule, from top to bottom in this list.
        /// Note that the first few rules (e.g. minimum_runtime_constraint,
        /// min_num_trials) will prevent other stopping rules from being evaluated
        /// until they are met. For example, setting `min_num_trials=5` and
        /// `always_stop_after= 1 hour` means that the Study will ONLY stop after it
        /// has 5 COMPLETED trials, even if more than an hour has passed since its
        /// creation. It follows the first applicable rule (whose "if" condition is
        /// satisfied) to make a stopping decision. If none of the specified rules
        /// are applicable, then Vizier decides that the study should not stop.
        /// If Vizier decides that the study should stop, the study enters
        /// STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
        /// IMPORTANT: The automatic study state transition happens precisely as
        /// described above; that is, deleting trials or updating StudyConfig NEVER
        /// automatically moves the study state back to ACTIVE. If you want to
        /// _resume_ a Study that was stopped, 1) change the stopping conditions if
        /// necessary, 2) activate the study, and then 3) ask for suggestions.
        /// If the specified time or duration has not passed, do not stop the
        /// study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub minimum_runtime_constraint: std::option::Option<crate::model::StudyTimeConstraint>,

        /// If the specified time or duration has passed, stop the study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub maximum_runtime_constraint: std::option::Option<crate::model::StudyTimeConstraint>,

        /// If there are fewer than this many COMPLETED trials, do not stop the
        /// study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_num_trials: std::option::Option<wkt::Int32Value>,

        /// If there are more than this many trials, stop the study.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_num_trials: std::option::Option<wkt::Int32Value>,

        /// If the objective value has not improved for this many consecutive
        /// trials, stop the study.
        ///
        /// WARNING: Effective only for single-objective studies.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_num_trials_no_progress: std::option::Option<wkt::Int32Value>,

        /// If the objective value has not improved for this much time, stop the
        /// study.
        ///
        /// WARNING: Effective only for single-objective studies.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_duration_no_progress: std::option::Option<wkt::Duration>,
    }

    impl StudyStoppingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [should_stop_asap][crate::model::study_spec::StudyStoppingConfig::should_stop_asap].
        pub fn set_should_stop_asap<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.should_stop_asap = v.into();
            self
        }

        /// Sets the value of [minimum_runtime_constraint][crate::model::study_spec::StudyStoppingConfig::minimum_runtime_constraint].
        pub fn set_minimum_runtime_constraint<
            T: std::convert::Into<std::option::Option<crate::model::StudyTimeConstraint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.minimum_runtime_constraint = v.into();
            self
        }

        /// Sets the value of [maximum_runtime_constraint][crate::model::study_spec::StudyStoppingConfig::maximum_runtime_constraint].
        pub fn set_maximum_runtime_constraint<
            T: std::convert::Into<std::option::Option<crate::model::StudyTimeConstraint>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.maximum_runtime_constraint = v.into();
            self
        }

        /// Sets the value of [min_num_trials][crate::model::study_spec::StudyStoppingConfig::min_num_trials].
        pub fn set_min_num_trials<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_num_trials = v.into();
            self
        }

        /// Sets the value of [max_num_trials][crate::model::study_spec::StudyStoppingConfig::max_num_trials].
        pub fn set_max_num_trials<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_num_trials = v.into();
            self
        }

        /// Sets the value of [max_num_trials_no_progress][crate::model::study_spec::StudyStoppingConfig::max_num_trials_no_progress].
        pub fn set_max_num_trials_no_progress<
            T: std::convert::Into<std::option::Option<wkt::Int32Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_num_trials_no_progress = v.into();
            self
        }

        /// Sets the value of [max_duration_no_progress][crate::model::study_spec::StudyStoppingConfig::max_duration_no_progress].
        pub fn set_max_duration_no_progress<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_duration_no_progress = v.into();
            self
        }
    }

    impl wkt::message::Message for StudyStoppingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.StudyStoppingConfig"
        }
    }

    /// The available search algorithms for the Study.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Algorithm(std::borrow::Cow<'static, str>);

    impl Algorithm {
        /// Creates a new Algorithm instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Algorithm](Algorithm)
    pub mod algorithm {
        use super::Algorithm;

        /// The default algorithm used by Vertex AI for [hyperparameter
        /// tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
        /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
        pub const ALGORITHM_UNSPECIFIED: Algorithm = Algorithm::new("ALGORITHM_UNSPECIFIED");

        /// Simple grid search within the feasible space. To use grid search,
        /// all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
        pub const GRID_SEARCH: Algorithm = Algorithm::new("GRID_SEARCH");

        /// Simple random search within the feasible space.
        pub const RANDOM_SEARCH: Algorithm = Algorithm::new("RANDOM_SEARCH");
    }

    impl std::convert::From<std::string::String> for Algorithm {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Describes the noise level of the repeated observations.
    ///
    /// "Noisy" means that the repeated observations with the same Trial parameters
    /// may lead to different metric evaluations.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ObservationNoise(std::borrow::Cow<'static, str>);

    impl ObservationNoise {
        /// Creates a new ObservationNoise instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ObservationNoise](ObservationNoise)
    pub mod observation_noise {
        use super::ObservationNoise;

        /// The default noise level chosen by Vertex AI.
        pub const OBSERVATION_NOISE_UNSPECIFIED: ObservationNoise =
            ObservationNoise::new("OBSERVATION_NOISE_UNSPECIFIED");

        /// Vertex AI assumes that the objective function is (nearly)
        /// perfectly reproducible, and will never repeat the same Trial
        /// parameters.
        pub const LOW: ObservationNoise = ObservationNoise::new("LOW");

        /// Vertex AI will estimate the amount of noise in metric
        /// evaluations, it may repeat the same Trial parameters more than once.
        pub const HIGH: ObservationNoise = ObservationNoise::new("HIGH");
    }

    impl std::convert::From<std::string::String> for ObservationNoise {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// This indicates which measurement to use if/when the service automatically
    /// selects the final measurement from previously reported intermediate
    /// measurements. Choose this based on two considerations:
    /// A) Do you expect your measurements to monotonically improve?
    /// If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
    /// situation where your system can "over-train" and you expect the
    /// performance to get better for a while but then start declining,
    /// choose BEST_MEASUREMENT.
    /// B) Are your measurements significantly noisy and/or irreproducible?
    /// If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
    /// may be better to choose LAST_MEASUREMENT.
    /// If both or neither of (A) and (B) apply, it doesn't matter which
    /// selection type is chosen.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MeasurementSelectionType(std::borrow::Cow<'static, str>);

    impl MeasurementSelectionType {
        /// Creates a new MeasurementSelectionType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [MeasurementSelectionType](MeasurementSelectionType)
    pub mod measurement_selection_type {
        use super::MeasurementSelectionType;

        /// Will be treated as LAST_MEASUREMENT.
        pub const MEASUREMENT_SELECTION_TYPE_UNSPECIFIED: MeasurementSelectionType =
            MeasurementSelectionType::new("MEASUREMENT_SELECTION_TYPE_UNSPECIFIED");

        /// Use the last measurement reported.
        pub const LAST_MEASUREMENT: MeasurementSelectionType =
            MeasurementSelectionType::new("LAST_MEASUREMENT");

        /// Use the best measurement reported.
        pub const BEST_MEASUREMENT: MeasurementSelectionType =
            MeasurementSelectionType::new("BEST_MEASUREMENT");
    }

    impl std::convert::From<std::string::String> for MeasurementSelectionType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AutomatedStoppingSpec {
        /// The automated early stopping spec using decay curve rule.
        DecayCurveStoppingSpec(
            std::boxed::Box<crate::model::study_spec::DecayCurveAutomatedStoppingSpec>,
        ),
        /// The automated early stopping spec using median rule.
        MedianAutomatedStoppingSpec(
            std::boxed::Box<crate::model::study_spec::MedianAutomatedStoppingSpec>,
        ),
        /// The automated early stopping spec using convex stopping rule.
        ConvexAutomatedStoppingSpec(
            std::boxed::Box<crate::model::study_spec::ConvexAutomatedStoppingSpec>,
        ),
    }
}

/// A message representing a Measurement of a Trial. A Measurement contains
/// the Metrics got by executing a Trial using suggested hyperparameter
/// values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Measurement {
    /// Output only. Time that the Trial has been running at the point of this
    /// Measurement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub elapsed_duration: std::option::Option<wkt::Duration>,

    /// Output only. The number of steps the machine learning model has been
    /// trained for. Must be non-negative.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub step_count: i64,

    /// Output only. A list of metrics got by evaluating the objective functions
    /// using suggested Parameter values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::measurement::Metric>,
}

impl Measurement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [elapsed_duration][crate::model::Measurement::elapsed_duration].
    pub fn set_elapsed_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.elapsed_duration = v.into();
        self
    }

    /// Sets the value of [step_count][crate::model::Measurement::step_count].
    pub fn set_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.step_count = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::Measurement::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::measurement::Metric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Measurement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Measurement"
    }
}

/// Defines additional types related to Measurement
pub mod measurement {
    #[allow(unused_imports)]
    use super::*;

    /// A message representing a metric in the measurement.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metric {
        /// Output only. The ID of the Metric. The Metric should be defined in
        /// [StudySpec's Metrics][google.cloud.aiplatform.v1.StudySpec.metrics].
        ///
        /// [google.cloud.aiplatform.v1.StudySpec.metrics]: crate::model::StudySpec::metrics
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metric_id: std::string::String,

        /// Output only. The value for this metric.
        pub value: f64,
    }

    impl Metric {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metric_id][crate::model::measurement::Metric::metric_id].
        pub fn set_metric_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.metric_id = v.into();
            self
        }

        /// Sets the value of [value][crate::model::measurement::Metric::value].
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Metric {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Measurement.Metric"
        }
    }
}

/// Tensorboard is a physical database that stores users' training metrics.
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tensorboard {
    /// Output only. Name of the Tensorboard.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of this Tensorboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this Tensorboard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Customer-managed encryption key spec for a Tensorboard. If set, this
    /// Tensorboard and all sub-resources of this Tensorboard will be secured by
    /// this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// Output only. Consumer project Cloud Storage path prefix used to store blob
    /// data, which can either be a bucket or directory. Does not end with a '/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub blob_storage_path_prefix: std::string::String,

    /// Output only. The number of Runs stored in this Tensorboard.
    pub run_count: i32,

    /// Output only. Timestamp when this Tensorboard was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this Tensorboard was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize your Tensorboards.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Tensorboard
    /// (System labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Used to indicate if the TensorBoard instance is the default one.
    /// Each project & region can have at most one default TensorBoard instance.
    /// Creation of a default TensorBoard instance and updating an existing
    /// TensorBoard instance to be default will mark all other TensorBoard
    /// instances (if any) as non default.
    pub is_default: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,
}

impl Tensorboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tensorboard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Tensorboard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Tensorboard::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::Tensorboard::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [blob_storage_path_prefix][crate::model::Tensorboard::blob_storage_path_prefix].
    pub fn set_blob_storage_path_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.blob_storage_path_prefix = v.into();
        self
    }

    /// Sets the value of [run_count][crate::model::Tensorboard::run_count].
    pub fn set_run_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.run_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Tensorboard::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Tensorboard::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Tensorboard::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [is_default][crate::model::Tensorboard::is_default].
    pub fn set_is_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_default = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Tensorboard::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Tensorboard::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Tensorboard::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Tensorboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tensorboard"
    }
}

/// All the data stored in a TensorboardTimeSeries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesData {
    /// Required. The ID of the TensorboardTimeSeries, which will become the final
    /// component of the TensorboardTimeSeries' resource name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series_id: std::string::String,

    /// Required. Immutable. The value type of this time series. All the values in
    /// this time series data must match this value type.
    pub value_type: crate::model::tensorboard_time_series::ValueType,

    /// Required. Data points in this time series.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::TimeSeriesDataPoint>,
}

impl TimeSeriesData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series_id][crate::model::TimeSeriesData::tensorboard_time_series_id].
    pub fn set_tensorboard_time_series_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series_id = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TimeSeriesData::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::tensorboard_time_series::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [values][crate::model::TimeSeriesData::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesDataPoint>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeriesData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimeSeriesData"
    }
}

/// A TensorboardTimeSeries data point.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeriesDataPoint {
    /// Wall clock timestamp when this data point is generated by the end user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wall_time: std::option::Option<wkt::Timestamp>,

    /// Step index of this data point within the run.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub step: i64,

    /// Value of this time series data point.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::time_series_data_point::Value>,
}

impl TimeSeriesDataPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [wall_time][crate::model::TimeSeriesDataPoint::wall_time].
    pub fn set_wall_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.wall_time = v.into();
        self
    }

    /// Sets the value of [step][crate::model::TimeSeriesDataPoint::step].
    pub fn set_step<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::time_series_data_point::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::TimeSeriesDataPoint::value]
    /// if it holds a `Scalar`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_scalar(&self) -> std::option::Option<&std::boxed::Box<crate::model::Scalar>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::time_series_data_point::Value::Scalar(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TimeSeriesDataPoint::value]
    /// if it holds a `Tensor`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tensor(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TensorboardTensor>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::time_series_data_point::Value::Tensor(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::TimeSeriesDataPoint::value]
    /// if it holds a `Blobs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_blobs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TensorboardBlobSequence>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::time_series_data_point::Value::Blobs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value]
    /// to hold a `Scalar`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_scalar<T: std::convert::Into<std::boxed::Box<crate::model::Scalar>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::time_series_data_point::Value::Scalar(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value]
    /// to hold a `Tensor`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_tensor<T: std::convert::Into<std::boxed::Box<crate::model::TensorboardTensor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::time_series_data_point::Value::Tensor(v.into()),
        );
        self
    }

    /// Sets the value of [value][crate::model::TimeSeriesDataPoint::value]
    /// to hold a `Blobs`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_blobs<
        T: std::convert::Into<std::boxed::Box<crate::model::TensorboardBlobSequence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value =
            std::option::Option::Some(crate::model::time_series_data_point::Value::Blobs(v.into()));
        self
    }
}

impl wkt::message::Message for TimeSeriesDataPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimeSeriesDataPoint"
    }
}

/// Defines additional types related to TimeSeriesDataPoint
pub mod time_series_data_point {
    #[allow(unused_imports)]
    use super::*;

    /// Value of this time series data point.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A scalar value.
        Scalar(std::boxed::Box<crate::model::Scalar>),
        /// A tensor value.
        Tensor(std::boxed::Box<crate::model::TensorboardTensor>),
        /// A blob sequence value.
        Blobs(std::boxed::Box<crate::model::TensorboardBlobSequence>),
    }
}

/// One point viewable on a scalar metric plot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scalar {
    /// Value of the point at this step / timestamp.
    pub value: f64,
}

impl Scalar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::Scalar::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Scalar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Scalar"
    }
}

/// One point viewable on a tensor metric plot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardTensor {
    /// Required. Serialized form of
    /// <https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto>
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub value: bytes::Bytes,

    /// Optional. Version number of TensorProto used to serialize
    /// [value][google.cloud.aiplatform.v1.TensorboardTensor.value].
    ///
    /// [google.cloud.aiplatform.v1.TensorboardTensor.value]: crate::model::TensorboardTensor::value
    pub version_number: i32,
}

impl TensorboardTensor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TensorboardTensor::value].
    pub fn set_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [version_number][crate::model::TensorboardTensor::version_number].
    pub fn set_version_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version_number = v.into();
        self
    }
}

impl wkt::message::Message for TensorboardTensor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTensor"
    }
}

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardBlobSequence {
    /// List of blobs contained within the sequence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::TensorboardBlob>,
}

impl TensorboardBlobSequence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::TensorboardBlobSequence::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardBlob>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TensorboardBlobSequence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardBlobSequence"
    }
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardBlob {
    /// Output only. A URI safe key uniquely identifying a blob. Can be used to
    /// locate the blob stored in the Cloud Storage bucket of the consumer project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Optional. The bytes of the blob is not present unless it's returned by the
    /// ReadTensorboardBlobData endpoint.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: bytes::Bytes,
}

impl TensorboardBlob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TensorboardBlob::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [data][crate::model::TensorboardBlob::data].
    pub fn set_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }
}

impl wkt::message::Message for TensorboardBlob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardBlob"
    }
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically the
/// results of a training job run, in a Tensorboard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardExperiment {
    /// Output only. Name of the TensorboardExperiment.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided name of this TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this TensorboardExperiment was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this TensorboardExperiment was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize your
    /// TensorboardExperiment.
    ///
    /// Label keys and values cannot be longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one Dataset (System
    /// labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with `aiplatform.googleapis.com/`
    /// and are immutable. The following system labels exist for each Dataset:
    ///
    /// * `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
    ///   value is the
    ///   [metadata_schema's][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]
    ///   title.
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. Source of the TensorboardExperiment. Example: a custom training
    /// job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,
}

impl TensorboardExperiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TensorboardExperiment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TensorboardExperiment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TensorboardExperiment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TensorboardExperiment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TensorboardExperiment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TensorboardExperiment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [source][crate::model::TensorboardExperiment::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TensorboardExperiment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TensorboardExperiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardExperiment"
    }
}

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardRun {
    /// Output only. Name of the TensorboardRun.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of this TensorboardRun.
    /// This value must be unique among all TensorboardRuns
    /// belonging to the same parent TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this TensorboardRun.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this TensorboardRun was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this TensorboardRun was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize your TensorboardRuns.
    ///
    /// This field will be used to filter and visualize Runs in the Tensorboard UI.
    /// For example, a Vertex AI training job can set a label
    /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
    /// within that job. An end user can set a label experiment_id=xxxxx for all
    /// the runs produced in a Jupyter notebook. These runs can be grouped by a
    /// label value and visualized together in the Tensorboard UI.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// No more than 64 user labels can be associated with one TensorboardRun
    /// (System labels are excluded).
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
    /// and are immutable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl TensorboardRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TensorboardRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TensorboardRun::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TensorboardRun::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TensorboardRun::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TensorboardRun::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TensorboardRun::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TensorboardRun::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TensorboardRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardRun"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboard][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboard]: crate::client::TensorboardService::create_tensorboard
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardRequest {
    /// Required. The resource name of the Location to create the Tensorboard in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Tensorboard to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard: std::option::Option<crate::model::Tensorboard>,
}

impl CreateTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard][crate::model::CreateTensorboardRequest::tensorboard].
    pub fn set_tensorboard<
        T: std::convert::Into<std::option::Option<crate::model::Tensorboard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard = v.into();
        self
    }
}

impl wkt::message::Message for CreateTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboard][google.cloud.aiplatform.v1.TensorboardService.GetTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboard]: crate::client::TensorboardService::get_tensorboard
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardRequest {
    /// Required. The name of the Tensorboard resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]: crate::client::TensorboardService::list_tensorboards
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardsRequest {
    /// Required. The resource name of the Location to list Tensorboards.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the Tensorboards that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of Tensorboards to return. The service may return
    /// fewer than this value. If unspecified, at most 100 Tensorboards are
    /// returned. The maximum value is 100; values above 100 are coerced to
    /// 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]: crate::client::TensorboardService::list_tensorboards
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListTensorboardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListTensorboardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardsRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboards][google.cloud.aiplatform.v1.TensorboardService.ListTensorboards].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboards]: crate::client::TensorboardService::list_tensorboards
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardsResponse {
    /// The Tensorboards mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboards: std::vec::Vec<crate::model::Tensorboard>,

    /// A token, which can be sent as
    /// [ListTensorboardsRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardsRequest.page_token]: crate::model::ListTensorboardsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTensorboardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboards][crate::model::ListTensorboardsResponse::tensorboards].
    pub fn set_tensorboards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensorboard>,
    {
        use std::iter::Iterator;
        self.tensorboards = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTensorboardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTensorboardsResponse {
    type PageItem = crate::model::Tensorboard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboards
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboard][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboard]: crate::client::TensorboardService::update_tensorboard
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Tensorboard resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The Tensorboard's `name` field is used to identify the
    /// Tensorboard to be updated. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard: std::option::Option<crate::model::Tensorboard>,
}

impl UpdateTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard][crate::model::UpdateTensorboardRequest::tensorboard].
    pub fn set_tensorboard<
        T: std::convert::Into<std::option::Option<crate::model::Tensorboard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboard][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboard].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboard]: crate::client::TensorboardService::delete_tensorboard
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardRequest {
    /// Required. The name of the Tensorboard to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTensorboardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTensorboardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardRequest"
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardUsage][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage]: crate::client::TensorboardService::read_tensorboard_usage
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardUsageRequest {
    /// Required. The name of the Tensorboard resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,
}

impl ReadTensorboardUsageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard][crate::model::ReadTensorboardUsageRequest::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }
}

impl wkt::message::Message for ReadTensorboardUsageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardUsage][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardUsage]: crate::client::TensorboardService::read_tensorboard_usage
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardUsageResponse {
    /// Maps year-month (YYYYMM) string to per month usage data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub monthly_usage_data: std::collections::HashMap<
        std::string::String,
        crate::model::read_tensorboard_usage_response::PerMonthUsageData,
    >,
}

impl ReadTensorboardUsageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [monthly_usage_data][crate::model::ReadTensorboardUsageResponse::monthly_usage_data].
    pub fn set_monthly_usage_data<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::read_tensorboard_usage_response::PerMonthUsageData>,
    {
        use std::iter::Iterator;
        self.monthly_usage_data = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ReadTensorboardUsageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse"
    }
}

/// Defines additional types related to ReadTensorboardUsageResponse
pub mod read_tensorboard_usage_response {
    #[allow(unused_imports)]
    use super::*;

    /// Per user usage data.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerUserUsageData {
        /// User's username
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub username: std::string::String,

        /// Number of times the user has read data within the Tensorboard.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub view_count: i64,
    }

    impl PerUserUsageData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [username][crate::model::read_tensorboard_usage_response::PerUserUsageData::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [view_count][crate::model::read_tensorboard_usage_response::PerUserUsageData::view_count].
        pub fn set_view_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.view_count = v.into();
            self
        }
    }

    impl wkt::message::Message for PerUserUsageData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerUserUsageData"
        }
    }

    /// Per month usage data
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerMonthUsageData {
        /// Usage data for each user in the given month.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub user_usage_data:
            std::vec::Vec<crate::model::read_tensorboard_usage_response::PerUserUsageData>,
    }

    impl PerMonthUsageData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user_usage_data][crate::model::read_tensorboard_usage_response::PerMonthUsageData::user_usage_data].
        pub fn set_user_usage_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::read_tensorboard_usage_response::PerUserUsageData>,
        {
            use std::iter::Iterator;
            self.user_usage_data = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PerMonthUsageData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerMonthUsageData"
        }
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardSize][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize]: crate::client::TensorboardService::read_tensorboard_size
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardSizeRequest {
    /// Required. The name of the Tensorboard resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,
}

impl ReadTensorboardSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard][crate::model::ReadTensorboardSizeRequest::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }
}

impl wkt::message::Message for ReadTensorboardSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardSizeRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardSize][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardSize]: crate::client::TensorboardService::read_tensorboard_size
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardSizeResponse {
    /// Payload storage size for the TensorBoard
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub storage_size_byte: i64,
}

impl ReadTensorboardSizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_size_byte][crate::model::ReadTensorboardSizeResponse::storage_size_byte].
    pub fn set_storage_size_byte<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.storage_size_byte = v.into();
        self
    }
}

impl wkt::message::Message for ReadTensorboardSizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardSizeResponse"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardExperiment]: crate::client::TensorboardService::create_tensorboard_experiment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardExperimentRequest {
    /// Required. The resource name of the Tensorboard to create the
    /// TensorboardExperiment in. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The TensorboardExperiment to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_experiment: std::option::Option<crate::model::TensorboardExperiment>,

    /// Required. The ID to use for the Tensorboard experiment, which becomes the
    /// final component of the Tensorboard experiment's resource name.
    ///
    /// This value should be 1-128 characters, and valid characters
    /// are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_experiment_id: std::string::String,
}

impl CreateTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardExperimentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiment][crate::model::CreateTensorboardExperimentRequest::tensorboard_experiment].
    pub fn set_tensorboard_experiment<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardExperiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiment_id][crate::model::CreateTensorboardExperimentRequest::tensorboard_experiment_id].
    pub fn set_tensorboard_experiment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.GetTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboardExperiment]: crate::client::TensorboardService::get_tensorboard_experiment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardExperimentRequest {
    /// Required. The name of the TensorboardExperiment resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]: crate::client::TensorboardService::list_tensorboard_experiments
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardExperimentsRequest {
    /// Required. The resource name of the Tensorboard to list
    /// TensorboardExperiments. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the TensorboardExperiments that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of TensorboardExperiments to return. The service may
    /// return fewer than this value. If unspecified, at most 50
    /// TensorboardExperiments are returned. The maximum value is 1000; values
    /// above 1000 are coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]: crate::client::TensorboardService::list_tensorboard_experiments
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListTensorboardExperimentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardExperimentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardExperimentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardExperimentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardExperimentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardExperimentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardExperimentsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListTensorboardExperimentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboardExperiments][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardExperiments]: crate::client::TensorboardService::list_tensorboard_experiments
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardExperimentsResponse {
    /// The TensorboardExperiments mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_experiments: std::vec::Vec<crate::model::TensorboardExperiment>,

    /// A token, which can be sent as
    /// [ListTensorboardExperimentsRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest.page_token]: crate::model::ListTensorboardExperimentsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTensorboardExperimentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardExperimentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiments][crate::model::ListTensorboardExperimentsResponse::tensorboard_experiments].
    pub fn set_tensorboard_experiments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardExperiment>,
    {
        use std::iter::Iterator;
        self.tensorboard_experiments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTensorboardExperimentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardExperimentsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTensorboardExperimentsResponse {
    type PageItem = crate::model::TensorboardExperiment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboard_experiments
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardExperiment]: crate::client::TensorboardService::update_tensorboard_experiment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardExperimentRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// TensorboardExperiment resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The TensorboardExperiment's `name` field is used to identify the
    /// TensorboardExperiment to be updated. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_experiment: std::option::Option<crate::model::TensorboardExperiment>,
}

impl UpdateTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardExperimentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard_experiment][crate::model::UpdateTensorboardExperimentRequest::tensorboard_experiment].
    pub fn set_tensorboard_experiment<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardExperiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboardExperiment][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardExperiment].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardExperiment]: crate::client::TensorboardService::delete_tensorboard_experiment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardExperimentRequest {
    /// Required. The name of the TensorboardExperiment to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTensorboardExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTensorboardExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardExperimentRequest"
    }
}

/// Request message for
/// [TensorboardService.BatchCreateTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns]: crate::client::TensorboardService::batch_create_tensorboard_runs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardRunsRequest {
    /// Required. The resource name of the TensorboardExperiment to create the
    /// TensorboardRuns in. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    /// The parent field in the CreateTensorboardRunRequest messages must match
    /// this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the TensorboardRuns to create.
    /// A maximum of 1000 TensorboardRuns can be created in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateTensorboardRunRequest>,
}

impl BatchCreateTensorboardRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateTensorboardRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateTensorboardRunsRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateTensorboardRunRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateTensorboardRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardRunsRequest"
    }
}

/// Response message for
/// [TensorboardService.BatchCreateTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardRuns]: crate::client::TensorboardService::batch_create_tensorboard_runs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardRunsResponse {
    /// The created TensorboardRuns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_runs: std::vec::Vec<crate::model::TensorboardRun>,
}

impl BatchCreateTensorboardRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_runs][crate::model::BatchCreateTensorboardRunsResponse::tensorboard_runs].
    pub fn set_tensorboard_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardRun>,
    {
        use std::iter::Iterator;
        self.tensorboard_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateTensorboardRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardRunsResponse"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardRun]: crate::client::TensorboardService::create_tensorboard_run
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardRunRequest {
    /// Required. The resource name of the TensorboardExperiment to create the
    /// TensorboardRun in. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The TensorboardRun to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_run: std::option::Option<crate::model::TensorboardRun>,

    /// Required. The ID to use for the Tensorboard run, which becomes the final
    /// component of the Tensorboard run's resource name.
    ///
    /// This value should be 1-128 characters, and valid characters
    /// are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_run_id: std::string::String,
}

impl CreateTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardRunRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard_run][crate::model::CreateTensorboardRunRequest::tensorboard_run].
    pub fn set_tensorboard_run<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_run = v.into();
        self
    }

    /// Sets the value of [tensorboard_run_id][crate::model::CreateTensorboardRunRequest::tensorboard_run_id].
    pub fn set_tensorboard_run_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_run_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.GetTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboardRun]: crate::client::TensorboardService::get_tensorboard_run
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardRunRequest {
    /// Required. The name of the TensorboardRun resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardBlobData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardBlobData].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardBlobDataRequest {
    /// Required. The resource name of the TensorboardTimeSeries to list Blobs.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_series: std::string::String,

    /// IDs of the blobs to read.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blob_ids: std::vec::Vec<std::string::String>,
}

impl ReadTensorboardBlobDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series][crate::model::ReadTensorboardBlobDataRequest::time_series].
    pub fn set_time_series<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_series = v.into();
        self
    }

    /// Sets the value of [blob_ids][crate::model::ReadTensorboardBlobDataRequest::blob_ids].
    pub fn set_blob_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.blob_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReadTensorboardBlobDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardBlobDataRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardBlobData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardBlobData].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardBlobDataResponse {
    /// Blob messages containing blob bytes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blobs: std::vec::Vec<crate::model::TensorboardBlob>,
}

impl ReadTensorboardBlobDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blobs][crate::model::ReadTensorboardBlobDataResponse::blobs].
    pub fn set_blobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardBlob>,
    {
        use std::iter::Iterator;
        self.blobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReadTensorboardBlobDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardBlobDataResponse"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]: crate::client::TensorboardService::list_tensorboard_runs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardRunsRequest {
    /// Required. The resource name of the TensorboardExperiment to list
    /// TensorboardRuns. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the TensorboardRuns that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of TensorboardRuns to return. The service may return
    /// fewer than this value. If unspecified, at most 50 TensorboardRuns are
    /// returned. The maximum value is 1000; values above 1000 are coerced to
    /// 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]: crate::client::TensorboardService::list_tensorboard_runs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListTensorboardRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardRunsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardRunsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardRunsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListTensorboardRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardRunsRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboardRuns][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardRuns]: crate::client::TensorboardService::list_tensorboard_runs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardRunsResponse {
    /// The TensorboardRuns mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_runs: std::vec::Vec<crate::model::TensorboardRun>,

    /// A token, which can be sent as
    /// [ListTensorboardRunsRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardRunsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardRunsRequest.page_token]: crate::model::ListTensorboardRunsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTensorboardRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboard_runs][crate::model::ListTensorboardRunsResponse::tensorboard_runs].
    pub fn set_tensorboard_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardRun>,
    {
        use std::iter::Iterator;
        self.tensorboard_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTensorboardRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardRunsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTensorboardRunsResponse {
    type PageItem = crate::model::TensorboardRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboard_runs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardRun]: crate::client::TensorboardService::update_tensorboard_run
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardRunRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// TensorboardRun resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The TensorboardRun's `name` field is used to identify the
    /// TensorboardRun to be updated. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_run: std::option::Option<crate::model::TensorboardRun>,
}

impl UpdateTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardRunRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard_run][crate::model::UpdateTensorboardRunRequest::tensorboard_run].
    pub fn set_tensorboard_run<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_run = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboardRun][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardRun].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardRun]: crate::client::TensorboardService::delete_tensorboard_run
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardRunRequest {
    /// Required. The name of the TensorboardRun to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTensorboardRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTensorboardRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardRunRequest"
    }
}

/// Request message for
/// [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries]: crate::client::TensorboardService::batch_create_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardTimeSeriesRequest {
    /// Required. The resource name of the TensorboardExperiment to create the
    /// TensorboardTimeSeries in.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    /// The TensorboardRuns referenced by the parent fields in the
    /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
    /// TensorboardExperiment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the TensorboardTimeSeries to
    /// create. A maximum of 1000 TensorboardTimeSeries can be created in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateTensorboardTimeSeriesRequest>,
}

impl BatchCreateTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateTensorboardTimeSeriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateTensorboardTimeSeriesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateTensorboardTimeSeriesRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesRequest"
    }
}

/// Response message for
/// [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchCreateTensorboardTimeSeries]: crate::client::TensorboardService::batch_create_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTensorboardTimeSeriesResponse {
    /// The created TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_time_series: std::vec::Vec<crate::model::TensorboardTimeSeries>,
}

impl BatchCreateTensorboardTimeSeriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series][crate::model::BatchCreateTensorboardTimeSeriesResponse::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardTimeSeries>,
    {
        use std::iter::Iterator;
        self.tensorboard_time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateTensorboardTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesResponse"
    }
}

/// Request message for
/// [TensorboardService.CreateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.CreateTensorboardTimeSeries]: crate::client::TensorboardService::create_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardTimeSeriesRequest {
    /// Required. The resource name of the TensorboardRun to create the
    /// TensorboardTimeSeries in.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The user specified unique ID to use for the
    /// TensorboardTimeSeries, which becomes the final component of the
    /// TensorboardTimeSeries's resource name. This value should match
    /// "[a-z0-9][a-z0-9-]{0, 127}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series_id: std::string::String,

    /// Required. The TensorboardTimeSeries to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_time_series: std::option::Option<crate::model::TensorboardTimeSeries>,
}

impl CreateTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTensorboardTimeSeriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series_id][crate::model::CreateTensorboardTimeSeriesRequest::tensorboard_time_series_id].
    pub fn set_tensorboard_time_series_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series_id = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series][crate::model::CreateTensorboardTimeSeriesRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardTimeSeries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }
}

impl wkt::message::Message for CreateTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.GetTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.GetTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.GetTensorboardTimeSeries]: crate::client::TensorboardService::get_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTensorboardTimeSeriesRequest {
    /// Required. The name of the TensorboardTimeSeries resource.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTensorboardTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]: crate::client::TensorboardService::list_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardTimeSeriesRequest {
    /// Required. The resource name of the TensorboardRun to list
    /// TensorboardTimeSeries. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Lists the TensorboardTimeSeries that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of TensorboardTimeSeries to return. The service may
    /// return fewer than this value. If unspecified, at most 50
    /// TensorboardTimeSeries are returned. The maximum value is 1000; values
    /// above 1000 are coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]: crate::client::TensorboardService::list_tensorboard_time_series
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Mask specifying which fields to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,
}

impl ListTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTensorboardTimeSeriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTensorboardTimeSeriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTensorboardTimeSeriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTensorboardTimeSeriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTensorboardTimeSeriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListTensorboardTimeSeriesRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest"
    }
}

/// Response message for
/// [TensorboardService.ListTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ListTensorboardTimeSeries]: crate::client::TensorboardService::list_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTensorboardTimeSeriesResponse {
    /// The TensorboardTimeSeries mathching the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tensorboard_time_series: std::vec::Vec<crate::model::TensorboardTimeSeries>,

    /// A token, which can be sent as
    /// [ListTensorboardTimeSeriesRequest.page_token][google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest.page_token]: crate::model::ListTensorboardTimeSeriesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTensorboardTimeSeriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTensorboardTimeSeriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series][crate::model::ListTensorboardTimeSeriesResponse::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TensorboardTimeSeries>,
    {
        use std::iter::Iterator;
        self.tensorboard_time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTensorboardTimeSeriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardTimeSeriesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTensorboardTimeSeriesResponse {
    type PageItem = crate::model::TensorboardTimeSeries;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tensorboard_time_series
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [TensorboardService.UpdateTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.UpdateTensorboardTimeSeries]: crate::client::TensorboardService::update_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardTimeSeriesRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// TensorboardTimeSeries resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field is overwritten if it's in the mask. If the
    /// user does not provide a mask then all fields are overwritten if new
    /// values are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The TensorboardTimeSeries' `name` field is used to identify the
    /// TensorboardTimeSeries to be updated.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tensorboard_time_series: std::option::Option<crate::model::TensorboardTimeSeries>,
}

impl UpdateTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTensorboardTimeSeriesRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [tensorboard_time_series][crate::model::UpdateTensorboardTimeSeriesRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<
        T: std::convert::Into<std::option::Option<crate::model::TensorboardTimeSeries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.DeleteTensorboardTimeSeries][google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardTimeSeries].
///
/// [google.cloud.aiplatform.v1.TensorboardService.DeleteTensorboardTimeSeries]: crate::client::TensorboardService::delete_tensorboard_time_series
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTensorboardTimeSeriesRequest {
    /// Required. The name of the TensorboardTimeSeries to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTensorboardTimeSeriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTensorboardTimeSeriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTensorboardTimeSeriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardTimeSeriesRequest"
    }
}

/// Request message for
/// [TensorboardService.BatchReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData]: crate::client::TensorboardService::batch_read_tensorboard_time_series_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadTensorboardTimeSeriesDataRequest {
    /// Required. The resource name of the Tensorboard containing
    /// TensorboardTimeSeries to read data from. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`.
    /// The TensorboardTimeSeries referenced by
    /// [time_series][google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest.time_series]
    /// must be sub resources of this Tensorboard.
    ///
    /// [google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest.time_series]: crate::model::BatchReadTensorboardTimeSeriesDataRequest::time_series
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard: std::string::String,

    /// Required. The resource names of the TensorboardTimeSeries to read data
    /// from. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series: std::vec::Vec<std::string::String>,
}

impl BatchReadTensorboardTimeSeriesDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard][crate::model::BatchReadTensorboardTimeSeriesDataRequest::tensorboard].
    pub fn set_tensorboard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard = v.into();
        self
    }

    /// Sets the value of [time_series][crate::model::BatchReadTensorboardTimeSeriesDataRequest::time_series].
    pub fn set_time_series<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.time_series = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchReadTensorboardTimeSeriesDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest"
    }
}

/// Response message for
/// [TensorboardService.BatchReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.BatchReadTensorboardTimeSeriesData]: crate::client::TensorboardService::batch_read_tensorboard_time_series_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchReadTensorboardTimeSeriesDataResponse {
    /// The returned time series data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data: std::vec::Vec<crate::model::TimeSeriesData>,
}

impl BatchReadTensorboardTimeSeriesDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_data][crate::model::BatchReadTensorboardTimeSeriesDataResponse::time_series_data].
    pub fn set_time_series_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesData>,
    {
        use std::iter::Iterator;
        self.time_series_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchReadTensorboardTimeSeriesDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataResponse"
    }
}

/// Request message for
/// [TensorboardService.ReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData]: crate::client::TensorboardService::read_tensorboard_time_series_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardTimeSeriesDataRequest {
    /// Required. The resource name of the TensorboardTimeSeries to read data from.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series: std::string::String,

    /// The maximum number of TensorboardTimeSeries' data to return.
    ///
    /// This value should be a positive integer.
    /// This value can be set to -1 to return all data.
    pub max_data_points: i32,

    /// Reads the TensorboardTimeSeries' data that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ReadTensorboardTimeSeriesDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series][crate::model::ReadTensorboardTimeSeriesDataRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }

    /// Sets the value of [max_data_points][crate::model::ReadTensorboardTimeSeriesDataRequest::max_data_points].
    pub fn set_max_data_points<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_data_points = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ReadTensorboardTimeSeriesDataRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ReadTensorboardTimeSeriesDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataRequest"
    }
}

/// Response message for
/// [TensorboardService.ReadTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ReadTensorboardTimeSeriesData]: crate::client::TensorboardService::read_tensorboard_time_series_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadTensorboardTimeSeriesDataResponse {
    /// The returned time series data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_series_data: std::option::Option<crate::model::TimeSeriesData>,
}

impl ReadTensorboardTimeSeriesDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_series_data][crate::model::ReadTensorboardTimeSeriesDataResponse::time_series_data].
    pub fn set_time_series_data<
        T: std::convert::Into<std::option::Option<crate::model::TimeSeriesData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_series_data = v.into();
        self
    }
}

impl wkt::message::Message for ReadTensorboardTimeSeriesDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataResponse"
    }
}

/// Request message for
/// [TensorboardService.WriteTensorboardExperimentData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData]: crate::client::TensorboardService::write_tensorboard_experiment_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardExperimentDataRequest {
    /// Required. The resource name of the TensorboardExperiment to write data to.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_experiment: std::string::String,

    /// Required. Requests containing per-run TensorboardTimeSeries data to write.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub write_run_data_requests: std::vec::Vec<crate::model::WriteTensorboardRunDataRequest>,
}

impl WriteTensorboardExperimentDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_experiment][crate::model::WriteTensorboardExperimentDataRequest::tensorboard_experiment].
    pub fn set_tensorboard_experiment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_experiment = v.into();
        self
    }

    /// Sets the value of [write_run_data_requests][crate::model::WriteTensorboardExperimentDataRequest::write_run_data_requests].
    pub fn set_write_run_data_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WriteTensorboardRunDataRequest>,
    {
        use std::iter::Iterator;
        self.write_run_data_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WriteTensorboardExperimentDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardExperimentDataRequest"
    }
}

/// Response message for
/// [TensorboardService.WriteTensorboardExperimentData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardExperimentData]: crate::client::TensorboardService::write_tensorboard_experiment_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardExperimentDataResponse {}

impl WriteTensorboardExperimentDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for WriteTensorboardExperimentDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardExperimentDataResponse"
    }
}

/// Request message for
/// [TensorboardService.WriteTensorboardRunData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData]: crate::client::TensorboardService::write_tensorboard_run_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardRunDataRequest {
    /// Required. The resource name of the TensorboardRun to write data to.
    /// Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_run: std::string::String,

    /// Required. The TensorboardTimeSeries data to write.
    /// Values with in a time series are indexed by their step value.
    /// Repeated writes to the same step will overwrite the existing value for that
    /// step.
    /// The upper limit of data points per write request is 5000.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data: std::vec::Vec<crate::model::TimeSeriesData>,
}

impl WriteTensorboardRunDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_run][crate::model::WriteTensorboardRunDataRequest::tensorboard_run].
    pub fn set_tensorboard_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tensorboard_run = v.into();
        self
    }

    /// Sets the value of [time_series_data][crate::model::WriteTensorboardRunDataRequest::time_series_data].
    pub fn set_time_series_data<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesData>,
    {
        use std::iter::Iterator;
        self.time_series_data = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WriteTensorboardRunDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardRunDataRequest"
    }
}

/// Response message for
/// [TensorboardService.WriteTensorboardRunData][google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.WriteTensorboardRunData]: crate::client::TensorboardService::write_tensorboard_run_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteTensorboardRunDataResponse {}

impl WriteTensorboardRunDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for WriteTensorboardRunDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardRunDataResponse"
    }
}

/// Request message for
/// [TensorboardService.ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]: crate::client::TensorboardService::export_tensorboard_time_series_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportTensorboardTimeSeriesDataRequest {
    /// Required. The resource name of the TensorboardTimeSeries to export data
    /// from. Format:
    /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tensorboard_time_series: std::string::String,

    /// Exports the TensorboardTimeSeries' data that match the filter expression.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of data points to return per page.
    /// The default page_size is 1000. Values must be between 1 and 10000.
    /// Values above 10000 are coerced to 10000.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]: crate::client::TensorboardService::export_tensorboard_time_series_data
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Field to use to sort the TensorboardTimeSeries' data.
    /// By default, TensorboardTimeSeries' data is returned in a pseudo random
    /// order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ExportTensorboardTimeSeriesDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tensorboard_time_series][crate::model::ExportTensorboardTimeSeriesDataRequest::tensorboard_time_series].
    pub fn set_tensorboard_time_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tensorboard_time_series = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ExportTensorboardTimeSeriesDataRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ExportTensorboardTimeSeriesDataRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ExportTensorboardTimeSeriesDataRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ExportTensorboardTimeSeriesDataRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ExportTensorboardTimeSeriesDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest"
    }
}

/// Response message for
/// [TensorboardService.ExportTensorboardTimeSeriesData][google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData].
///
/// [google.cloud.aiplatform.v1.TensorboardService.ExportTensorboardTimeSeriesData]: crate::client::TensorboardService::export_tensorboard_time_series_data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportTensorboardTimeSeriesDataResponse {
    /// The returned time series data points.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub time_series_data_points: std::vec::Vec<crate::model::TimeSeriesDataPoint>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest.page_token]: crate::model::ExportTensorboardTimeSeriesDataRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ExportTensorboardTimeSeriesDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ExportTensorboardTimeSeriesDataResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [time_series_data_points][crate::model::ExportTensorboardTimeSeriesDataResponse::time_series_data_points].
    pub fn set_time_series_data_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeriesDataPoint>,
    {
        use std::iter::Iterator;
        self.time_series_data_points = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportTensorboardTimeSeriesDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ExportTensorboardTimeSeriesDataResponse {
    type PageItem = crate::model::TimeSeriesDataPoint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.time_series_data_points
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Details of operations that perform create Tensorboard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTensorboardOperationMetadata {
    /// Operation metadata for Tensorboard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateTensorboardOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateTensorboardOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateTensorboardOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardOperationMetadata"
    }
}

/// Details of operations that perform update Tensorboard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTensorboardOperationMetadata {
    /// Operation metadata for Tensorboard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateTensorboardOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateTensorboardOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTensorboardOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardOperationMetadata"
    }
}

/// TensorboardTimeSeries maps to times series produced in training runs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TensorboardTimeSeries {
    /// Output only. Name of the TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. User provided name of this TensorboardTimeSeries.
    /// This value should be unique among all TensorboardTimeSeries resources
    /// belonging to the same TensorboardRun resource (parent resource).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of this TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Immutable. Type of TensorboardTimeSeries value.
    pub value_type: crate::model::tensorboard_time_series::ValueType,

    /// Output only. Timestamp when this TensorboardTimeSeries was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this TensorboardTimeSeries was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Used to perform a consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. Name of the plugin this time series pertain to. Such as Scalar,
    /// Tensor, Blob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub plugin_name: std::string::String,

    /// Data of the current plugin, with the size limited to 65KB.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plugin_data: bytes::Bytes,

    /// Output only. Scalar, Tensor, or Blob metadata for this
    /// TensorboardTimeSeries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::tensorboard_time_series::Metadata>,
}

impl TensorboardTimeSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TensorboardTimeSeries::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TensorboardTimeSeries::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TensorboardTimeSeries::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TensorboardTimeSeries::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::tensorboard_time_series::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TensorboardTimeSeries::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TensorboardTimeSeries::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TensorboardTimeSeries::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [plugin_name][crate::model::TensorboardTimeSeries::plugin_name].
    pub fn set_plugin_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.plugin_name = v.into();
        self
    }

    /// Sets the value of [plugin_data][crate::model::TensorboardTimeSeries::plugin_data].
    pub fn set_plugin_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.plugin_data = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::TensorboardTimeSeries::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::tensorboard_time_series::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }
}

impl wkt::message::Message for TensorboardTimeSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTimeSeries"
    }
}

/// Defines additional types related to TensorboardTimeSeries
pub mod tensorboard_time_series {
    #[allow(unused_imports)]
    use super::*;

    /// Describes metadata for a TensorboardTimeSeries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metadata {
        /// Output only. Max step index of all data points within a
        /// TensorboardTimeSeries.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_step: i64,

        /// Output only. Max wall clock timestamp of all data points within a
        /// TensorboardTimeSeries.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_wall_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The largest blob sequence length (number of blobs) of all
        /// data points in this time series, if its ValueType is BLOB_SEQUENCE.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_blob_sequence_length: i64,
    }

    impl Metadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_step][crate::model::tensorboard_time_series::Metadata::max_step].
        pub fn set_max_step<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_step = v.into();
            self
        }

        /// Sets the value of [max_wall_time][crate::model::tensorboard_time_series::Metadata::max_wall_time].
        pub fn set_max_wall_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_wall_time = v.into();
            self
        }

        /// Sets the value of [max_blob_sequence_length][crate::model::tensorboard_time_series::Metadata::max_blob_sequence_length].
        pub fn set_max_blob_sequence_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_blob_sequence_length = v.into();
            self
        }
    }

    impl wkt::message::Message for Metadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTimeSeries.Metadata"
        }
    }

    /// An enum representing the value type of a TensorboardTimeSeries.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ValueType(std::borrow::Cow<'static, str>);

    impl ValueType {
        /// Creates a new ValueType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ValueType](ValueType)
    pub mod value_type {
        use super::ValueType;

        /// The value type is unspecified.
        pub const VALUE_TYPE_UNSPECIFIED: ValueType = ValueType::new("VALUE_TYPE_UNSPECIFIED");

        /// Used for TensorboardTimeSeries that is a list of scalars.
        /// E.g. accuracy of a model over epochs/time.
        pub const SCALAR: ValueType = ValueType::new("SCALAR");

        /// Used for TensorboardTimeSeries that is a list of tensors.
        /// E.g. histograms of weights of layer in a model over epoch/time.
        pub const TENSOR: ValueType = ValueType::new("TENSOR");

        /// Used for TensorboardTimeSeries that is a list of blob sequences.
        /// E.g. set of sample images with labels over epochs/time.
        pub const BLOB_SEQUENCE: ValueType = ValueType::new("BLOB_SEQUENCE");
    }

    impl std::convert::From<std::string::String> for ValueType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model. A Tool object should contain exactly
/// one type of Tool (e.g FunctionDeclaration, Retrieval or
/// GoogleSearchRetrieval).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tool {
    /// Optional. Function tool type.
    /// One or more function declarations to be passed to the model along with the
    /// current user query. Model may decide to call a subset of these functions
    /// by populating [FunctionCall][content.part.function_call] in the response.
    /// User should provide a [FunctionResponse][content.part.function_response]
    /// for each function call in the next turn. Based on the function responses,
    /// Model will generate the final response back to the user.
    /// Maximum 128 function declarations can be provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub function_declarations: std::vec::Vec<crate::model::FunctionDeclaration>,

    /// Optional. Retrieval tool type.
    /// System will always execute the provided retrieval tool(s) to get external
    /// knowledge to answer the prompt. Retrieval results are presented to the
    /// model for generation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retrieval: std::option::Option<crate::model::Retrieval>,

    /// Optional. GoogleSearchRetrieval tool type.
    /// Specialized retrieval tool that is powered by Google search.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_search_retrieval: std::option::Option<crate::model::GoogleSearchRetrieval>,

    /// Optional. CodeExecution tool type.
    /// Enables the model to execute code as part of generation.
    /// This field is only used by the Gemini Developer API services.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub code_execution: std::option::Option<crate::model::tool::CodeExecution>,
}

impl Tool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retrieval][crate::model::Tool::retrieval].
    pub fn set_retrieval<T: std::convert::Into<std::option::Option<crate::model::Retrieval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retrieval = v.into();
        self
    }

    /// Sets the value of [google_search_retrieval][crate::model::Tool::google_search_retrieval].
    pub fn set_google_search_retrieval<
        T: std::convert::Into<std::option::Option<crate::model::GoogleSearchRetrieval>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_search_retrieval = v.into();
        self
    }

    /// Sets the value of [code_execution][crate::model::Tool::code_execution].
    pub fn set_code_execution<
        T: std::convert::Into<std::option::Option<crate::model::tool::CodeExecution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.code_execution = v.into();
        self
    }

    /// Sets the value of [function_declarations][crate::model::Tool::function_declarations].
    pub fn set_function_declarations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FunctionDeclaration>,
    {
        use std::iter::Iterator;
        self.function_declarations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Tool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tool"
    }
}

/// Defines additional types related to Tool
pub mod tool {
    #[allow(unused_imports)]
    use super::*;

    /// Tool that executes code generated by the model, and automatically returns
    /// the result to the model.
    ///
    /// See also [ExecutableCode]and [CodeExecutionResult] which are input and
    /// output to this tool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CodeExecution {}

    impl CodeExecution {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CodeExecution {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.Tool.CodeExecution"
        }
    }
}

/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
/// in this declaration are the function name, description, parameters and
/// response type. This FunctionDeclaration is a representation of a block of
/// code that can be used as a `Tool` by the model and executed by the client.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionDeclaration {
    /// Required. The name of the function to call.
    /// Must start with a letter or an underscore.
    /// Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a
    /// maximum length of 64.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description and purpose of the function.
    /// Model uses it to decide how and whether to call the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Describes the parameters to this function in JSON Schema Object
    /// format. Reflects the Open API 3.03 Parameter Object. string Key: the name
    /// of the parameter. Parameter names are case sensitive. Schema Value: the
    /// Schema defining the type used for the parameter. For function with no
    /// parameters, this can be left unset. Parameter names must start with a
    /// letter or an underscore and must only contain chars a-z, A-Z, 0-9, or
    /// underscores with a maximum length of 64. Example with 1 required and 1
    /// optional parameter: type: OBJECT properties:
    /// param1:
    /// type: STRING
    /// param2:
    /// type: INTEGER
    /// required:
    ///
    /// - param1
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::Schema>,

    /// Optional. Describes the output from this function in JSON Schema format.
    /// Reflects the Open API 3.03 Response Object. The Schema defines the type
    /// used for the response value of the function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::Schema>,
}

impl FunctionDeclaration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FunctionDeclaration::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FunctionDeclaration::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::FunctionDeclaration::parameters].
    pub fn set_parameters<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [response][crate::model::FunctionDeclaration::response].
    pub fn set_response<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }
}

impl wkt::message::Message for FunctionDeclaration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionDeclaration"
    }
}

/// A predicted [FunctionCall] returned from the model that contains a string
/// representing the [FunctionDeclaration.name] and a structured JSON object
/// containing the parameters and their values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionCall {
    /// Required. The name of the function to call.
    /// Matches [FunctionDeclaration.name].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Required. The function parameters and values in JSON object
    /// format. See [FunctionDeclaration.parameters] for parameter details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub args: std::option::Option<wkt::Struct>,
}

impl FunctionCall {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FunctionCall::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [args][crate::model::FunctionCall::args].
    pub fn set_args<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.args = v.into();
        self
    }
}

impl wkt::message::Message for FunctionCall {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionCall"
    }
}

/// The result output from a [FunctionCall] that contains a string representing
/// the [FunctionDeclaration.name] and a structured JSON object containing any
/// output from the function is used as context to the model. This should contain
/// the result of a [FunctionCall] made based on model prediction.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionResponse {
    /// Required. The name of the function to call.
    /// Matches [FunctionDeclaration.name] and [FunctionCall.name].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The function response in JSON object format.
    /// Use "output" key to specify function output and "error" key to specify
    /// error details (if any). If "output" and "error" keys are not specified,
    /// then whole "response" is treated as function output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<wkt::Struct>,
}

impl FunctionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FunctionResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [response][crate::model::FunctionResponse::response].
    pub fn set_response<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }
}

impl wkt::message::Message for FunctionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionResponse"
    }
}

/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Generated when using the [FunctionDeclaration] tool and
/// [FunctionCallingConfig] mode is set to [Mode.CODE].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutableCode {
    /// Required. Programming language of the `code`.
    pub language: crate::model::executable_code::Language,

    /// Required. The code to be executed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,
}

impl ExecutableCode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language][crate::model::ExecutableCode::language].
    pub fn set_language<T: std::convert::Into<crate::model::executable_code::Language>>(
        mut self,
        v: T,
    ) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [code][crate::model::ExecutableCode::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for ExecutableCode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExecutableCode"
    }
}

/// Defines additional types related to ExecutableCode
pub mod executable_code {
    #[allow(unused_imports)]
    use super::*;

    /// Supported programming languages for the generated code.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Language(std::borrow::Cow<'static, str>);

    impl Language {
        /// Creates a new Language instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Language](Language)
    pub mod language {
        use super::Language;

        /// Unspecified language. This value should not be used.
        pub const LANGUAGE_UNSPECIFIED: Language = Language::new("LANGUAGE_UNSPECIFIED");

        /// Python >= 3.10, with numpy and simpy available.
        pub const PYTHON: Language = Language::new("PYTHON");
    }

    impl std::convert::From<std::string::String> for Language {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Result of executing the [ExecutableCode].
///
/// Always follows a `part` containing the [ExecutableCode].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CodeExecutionResult {
    /// Required. Outcome of the code execution.
    pub outcome: crate::model::code_execution_result::Outcome,

    /// Optional. Contains stdout when code execution is successful, stderr or
    /// other description otherwise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output: std::string::String,
}

impl CodeExecutionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [outcome][crate::model::CodeExecutionResult::outcome].
    pub fn set_outcome<T: std::convert::Into<crate::model::code_execution_result::Outcome>>(
        mut self,
        v: T,
    ) -> Self {
        self.outcome = v.into();
        self
    }

    /// Sets the value of [output][crate::model::CodeExecutionResult::output].
    pub fn set_output<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output = v.into();
        self
    }
}

impl wkt::message::Message for CodeExecutionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CodeExecutionResult"
    }
}

/// Defines additional types related to CodeExecutionResult
pub mod code_execution_result {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of possible outcomes of the code execution.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Outcome(std::borrow::Cow<'static, str>);

    impl Outcome {
        /// Creates a new Outcome instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Outcome](Outcome)
    pub mod outcome {
        use super::Outcome;

        /// Unspecified status. This value should not be used.
        pub const OUTCOME_UNSPECIFIED: Outcome = Outcome::new("OUTCOME_UNSPECIFIED");

        /// Code execution completed successfully.
        pub const OUTCOME_OK: Outcome = Outcome::new("OUTCOME_OK");

        /// Code execution finished but with a failure. `stderr` should contain the
        /// reason.
        pub const OUTCOME_FAILED: Outcome = Outcome::new("OUTCOME_FAILED");

        /// Code execution ran for too long, and was cancelled. There may or may not
        /// be a partial output present.
        pub const OUTCOME_DEADLINE_EXCEEDED: Outcome = Outcome::new("OUTCOME_DEADLINE_EXCEEDED");
    }

    impl std::convert::From<std::string::String> for Outcome {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Defines a retrieval tool that model can call to access external knowledge.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Retrieval {
    /// Optional. Deprecated. This option is no longer supported.
    pub disable_attribution: bool,

    /// The source of the retrieval.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::retrieval::Source>,
}

impl Retrieval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_attribution][crate::model::Retrieval::disable_attribution].
    pub fn set_disable_attribution<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_attribution = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::retrieval::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Retrieval::source]
    /// if it holds a `VertexAiSearch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_ai_search(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexAISearch>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::retrieval::Source::VertexAiSearch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Retrieval::source]
    /// if it holds a `VertexRagStore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_rag_store(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexRagStore>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::retrieval::Source::VertexRagStore(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Retrieval::source]
    /// to hold a `VertexAiSearch`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_vertex_ai_search<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexAISearch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::retrieval::Source::VertexAiSearch(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Retrieval::source]
    /// to hold a `VertexRagStore`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_store<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexRagStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::retrieval::Source::VertexRagStore(v.into()));
        self
    }
}

impl wkt::message::Message for Retrieval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Retrieval"
    }
}

/// Defines additional types related to Retrieval
pub mod retrieval {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the retrieval.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Set to use data source powered by Vertex AI Search.
        VertexAiSearch(std::boxed::Box<crate::model::VertexAISearch>),
        /// Set to use data source powered by Vertex RAG store.
        /// User data is uploaded via the VertexRagDataService.
        VertexRagStore(std::boxed::Box<crate::model::VertexRagStore>),
    }
}

/// Retrieve from Vertex RAG Store for grounding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexRagStore {
    /// Optional. The representation of the rag source. It can be used to specify
    /// corpus only or ragfiles. Currently only support one corpus or multiple
    /// files from one corpus. In the future we may open up multiple corpora
    /// support.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rag_resources: std::vec::Vec<crate::model::vertex_rag_store::RagResource>,

    /// Optional. Number of top k results to return from the selected corpora.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub similarity_top_k: std::option::Option<i32>,

    /// Optional. Only return results with vector distance smaller than the
    /// threshold.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vector_distance_threshold: std::option::Option<f64>,

    /// Optional. The retrieval config for the Rag query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_retrieval_config: std::option::Option<crate::model::RagRetrievalConfig>,
}

impl VertexRagStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [similarity_top_k][crate::model::VertexRagStore::similarity_top_k].
    pub fn set_similarity_top_k<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.similarity_top_k = v.into();
        self
    }

    /// Sets the value of [vector_distance_threshold][crate::model::VertexRagStore::vector_distance_threshold].
    pub fn set_vector_distance_threshold<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vector_distance_threshold = v.into();
        self
    }

    /// Sets the value of [rag_retrieval_config][crate::model::VertexRagStore::rag_retrieval_config].
    pub fn set_rag_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::RagRetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_retrieval_config = v.into();
        self
    }

    /// Sets the value of [rag_resources][crate::model::VertexRagStore::rag_resources].
    pub fn set_rag_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vertex_rag_store::RagResource>,
    {
        use std::iter::Iterator;
        self.rag_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VertexRagStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexRagStore"
    }
}

/// Defines additional types related to VertexRagStore
pub mod vertex_rag_store {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of the Rag resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RagResource {
        /// Optional. RagCorpora resource name.
        /// Format:
        /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub rag_corpus: std::string::String,

        /// Optional. rag_file_id. The files should be in the same rag_corpus set in
        /// rag_corpus field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rag_file_ids: std::vec::Vec<std::string::String>,
    }

    impl RagResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rag_corpus][crate::model::vertex_rag_store::RagResource::rag_corpus].
        pub fn set_rag_corpus<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.rag_corpus = v.into();
            self
        }

        /// Sets the value of [rag_file_ids][crate::model::vertex_rag_store::RagResource::rag_file_ids].
        pub fn set_rag_file_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.rag_file_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for RagResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.VertexRagStore.RagResource"
        }
    }
}

/// Retrieve from Vertex AI Search datastore for grounding.
/// See <https://cloud.google.com/products/agent-builder>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VertexAISearch {
    /// Required. Fully-qualified Vertex AI Search data store resource ID.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datastore: std::string::String,
}

impl VertexAISearch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datastore][crate::model::VertexAISearch::datastore].
    pub fn set_datastore<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datastore = v.into();
        self
    }
}

impl wkt::message::Message for VertexAISearch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexAISearch"
    }
}

/// Tool to retrieve public web data for grounding, powered by Google.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleSearchRetrieval {
    /// Specifies the dynamic retrieval configuration for the given source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dynamic_retrieval_config: std::option::Option<crate::model::DynamicRetrievalConfig>,
}

impl GoogleSearchRetrieval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dynamic_retrieval_config][crate::model::GoogleSearchRetrieval::dynamic_retrieval_config].
    pub fn set_dynamic_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::DynamicRetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dynamic_retrieval_config = v.into();
        self
    }
}

impl wkt::message::Message for GoogleSearchRetrieval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleSearchRetrieval"
    }
}

/// Describes the options to customize dynamic retrieval.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DynamicRetrievalConfig {
    /// The mode of the predictor to be used in dynamic retrieval.
    pub mode: crate::model::dynamic_retrieval_config::Mode,

    /// Optional. The threshold to be used in dynamic retrieval.
    /// If not set, a system default value is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dynamic_threshold: std::option::Option<f32>,
}

impl DynamicRetrievalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::DynamicRetrievalConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::dynamic_retrieval_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [dynamic_threshold][crate::model::DynamicRetrievalConfig::dynamic_threshold].
    pub fn set_dynamic_threshold<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dynamic_threshold = v.into();
        self
    }
}

impl wkt::message::Message for DynamicRetrievalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DynamicRetrievalConfig"
    }
}

/// Defines additional types related to DynamicRetrievalConfig
pub mod dynamic_retrieval_config {
    #[allow(unused_imports)]
    use super::*;

    /// The mode of the predictor to be used in dynamic retrieval.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Mode(std::borrow::Cow<'static, str>);

    impl Mode {
        /// Creates a new Mode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Mode](Mode)
    pub mod mode {
        use super::Mode;

        /// Always trigger retrieval.
        pub const MODE_UNSPECIFIED: Mode = Mode::new("MODE_UNSPECIFIED");

        /// Run retrieval only when system decides it is necessary.
        pub const MODE_DYNAMIC: Mode = Mode::new("MODE_DYNAMIC");
    }

    impl std::convert::From<std::string::String> for Mode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Tool config. This config is shared for all tools provided in the request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ToolConfig {
    /// Optional. Function calling config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub function_calling_config: std::option::Option<crate::model::FunctionCallingConfig>,

    /// Optional. Retrieval config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retrieval_config: std::option::Option<crate::model::RetrievalConfig>,
}

impl ToolConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function_calling_config][crate::model::ToolConfig::function_calling_config].
    pub fn set_function_calling_config<
        T: std::convert::Into<std::option::Option<crate::model::FunctionCallingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.function_calling_config = v.into();
        self
    }

    /// Sets the value of [retrieval_config][crate::model::ToolConfig::retrieval_config].
    pub fn set_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::RetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retrieval_config = v.into();
        self
    }
}

impl wkt::message::Message for ToolConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolConfig"
    }
}

/// Function calling config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionCallingConfig {
    /// Optional. Function calling mode.
    pub mode: crate::model::function_calling_config::Mode,

    /// Optional. Function names to call. Only set when the Mode is ANY. Function
    /// names should match [FunctionDeclaration.name]. With mode set to ANY, model
    /// will predict a function call from the set of function names provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_function_names: std::vec::Vec<std::string::String>,
}

impl FunctionCallingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::FunctionCallingConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::function_calling_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [allowed_function_names][crate::model::FunctionCallingConfig::allowed_function_names].
    pub fn set_allowed_function_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_function_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FunctionCallingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionCallingConfig"
    }
}

/// Defines additional types related to FunctionCallingConfig
pub mod function_calling_config {
    #[allow(unused_imports)]
    use super::*;

    /// Function calling mode.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Mode(std::borrow::Cow<'static, str>);

    impl Mode {
        /// Creates a new Mode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Mode](Mode)
    pub mod mode {
        use super::Mode;

        /// Unspecified function calling mode. This value should not be used.
        pub const MODE_UNSPECIFIED: Mode = Mode::new("MODE_UNSPECIFIED");

        /// Default model behavior, model decides to predict either a function call
        /// or a natural language response.
        pub const AUTO: Mode = Mode::new("AUTO");

        /// Model is constrained to always predicting a function call only.
        /// If "allowed_function_names" are set, the predicted function call will be
        /// limited to any one of "allowed_function_names", else the predicted
        /// function call will be any one of the provided "function_declarations".
        pub const ANY: Mode = Mode::new("ANY");

        /// Model will not predict any function call. Model behavior is same as when
        /// not passing any function declarations.
        pub const NONE: Mode = Mode::new("NONE");
    }

    impl std::convert::From<std::string::String> for Mode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Retrieval config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrievalConfig {
    /// The location of the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lat_lng: std::option::Option<gtype::model::LatLng>,

    /// The language code of the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub language_code: std::option::Option<std::string::String>,
}

impl RetrievalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lat_lng][crate::model::RetrievalConfig::lat_lng].
    pub fn set_lat_lng<T: std::convert::Into<std::option::Option<gtype::model::LatLng>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lat_lng = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::RetrievalConfig::language_code].
    pub fn set_language_code<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for RetrievalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrievalConfig"
    }
}

/// Specifies the context retrieval config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagRetrievalConfig {
    /// Optional. The number of contexts to retrieve.
    pub top_k: i32,

    /// Optional. Config for filters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::rag_retrieval_config::Filter>,
}

impl RagRetrievalConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [top_k][crate::model::RagRetrievalConfig::top_k].
    pub fn set_top_k<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top_k = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::RagRetrievalConfig::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::rag_retrieval_config::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for RagRetrievalConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig"
    }
}

/// Defines additional types related to RagRetrievalConfig
pub mod rag_retrieval_config {
    #[allow(unused_imports)]
    use super::*;

    /// Config for filters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Filter {
        /// Optional. String for metadata filtering.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metadata_filter: std::string::String,

        /// Filter contexts retrieved from the vector DB based on either vector
        /// distance or vector similarity.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub vector_db_threshold:
            std::option::Option<crate::model::rag_retrieval_config::filter::VectorDbThreshold>,
    }

    impl Filter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metadata_filter][crate::model::rag_retrieval_config::Filter::metadata_filter].
        pub fn set_metadata_filter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.metadata_filter = v.into();
            self
        }

        /// Sets the value of `vector_db_threshold`.
        pub fn set_vector_db_threshold<
            T: std::convert::Into<
                std::option::Option<crate::model::rag_retrieval_config::filter::VectorDbThreshold>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vector_db_threshold = v.into();
            self
        }

        /// The value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// if it holds a `VectorDistanceThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_vector_distance_threshold(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.vector_db_threshold.as_ref().and_then(|v| match v {
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorDistanceThreshold(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// if it holds a `VectorSimilarityThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_vector_similarity_threshold(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.vector_db_threshold.as_ref().and_then(|v| match v {
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorSimilarityThreshold(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// to hold a `VectorDistanceThreshold`.
        ///
        /// Note that all the setters affecting `vector_db_threshold` are
        /// mutually exclusive.
        pub fn set_vector_distance_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.vector_db_threshold = std::option::Option::Some(
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorDistanceThreshold(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [vector_db_threshold][crate::model::rag_retrieval_config::Filter::vector_db_threshold]
        /// to hold a `VectorSimilarityThreshold`.
        ///
        /// Note that all the setters affecting `vector_db_threshold` are
        /// mutually exclusive.
        pub fn set_vector_similarity_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.vector_db_threshold = std::option::Option::Some(
                crate::model::rag_retrieval_config::filter::VectorDbThreshold::VectorSimilarityThreshold(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Filter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Filter"
        }
    }

    /// Defines additional types related to Filter
    pub mod filter {
        #[allow(unused_imports)]
        use super::*;

        /// Filter contexts retrieved from the vector DB based on either vector
        /// distance or vector similarity.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum VectorDbThreshold {
            /// Optional. Only returns contexts with vector distance smaller than the
            /// threshold.
            VectorDistanceThreshold(f64),
            /// Optional. Only returns contexts with vector similarity larger than the
            /// threshold.
            VectorSimilarityThreshold(f64),
        }
    }
}

/// The TrainingPipeline orchestrates tasks associated with training a Model. It
/// always executes the training task, and optionally may also
/// export data from Vertex AI's Dataset which becomes the training input,
/// [upload][google.cloud.aiplatform.v1.ModelService.UploadModel] the Model to
/// Vertex AI, and evaluate the Model.
///
/// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainingPipeline {
    /// Output only. Resource name of the TrainingPipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-defined name of this TrainingPipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Specifies Vertex AI owned input data that may be used for training the
    /// Model. The TrainingPipeline's
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]
    /// should make clear whether this config is used and if there are any special
    /// requirements on how it should be filled. If nothing about this config is
    /// mentioned in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition],
    /// then it should be assumed that the TrainingPipeline does not depend on this
    /// configuration.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,

    /// Required. A Google Cloud Storage path to the YAML file that defines the
    /// training task which is responsible for producing the model artifact, and
    /// may also include additional auxiliary work. The definition files that can
    /// be used here are found in
    /// gs://google-cloud-aiplatform/schema/trainingjob/definition/.
    /// Note: The URI given on output will be immutable and probably different,
    /// including the URI scheme, than the one given on input. The output URI will
    /// point to a location where the user only has a read access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_task_definition: std::string::String,

    /// Required. The training task's parameter(s), as specified in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]'s
    /// `inputs`.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_task_inputs: std::option::Option<wkt::Value>,

    /// Output only. The metadata information as specified in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]'s
    /// `metadata`. This metadata is an auxiliary runtime and final information
    /// about the training task. While the pipeline is running this information is
    /// populated only at a best effort basis. Only present if the
    /// pipeline's
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]
    /// contains `metadata` object.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_task_metadata: std::option::Option<wkt::Value>,

    /// Describes the Model that may be uploaded (via
    /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel])
    /// by this TrainingPipeline. The TrainingPipeline's
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]
    /// should make clear whether this Model description should be populated, and
    /// if there are any special requirements regarding how it should be filled. If
    /// nothing is mentioned in the
    /// [training_task_definition][google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition],
    /// then it should be assumed that this field should not be filled and the
    /// training task either uploads the Model without a need of this information,
    /// or that training task does not support uploading a Model as part of the
    /// pipeline. When the Pipeline's state becomes `PIPELINE_STATE_SUCCEEDED` and
    /// the trained Model had been uploaded into Vertex AI, then the
    /// model_to_upload's resource [name][google.cloud.aiplatform.v1.Model.name] is
    /// populated. The Model is always uploaded into the Project and Location in
    /// which this pipeline is.
    ///
    /// [google.cloud.aiplatform.v1.Model.name]: crate::model::Model::name
    /// [google.cloud.aiplatform.v1.ModelService.UploadModel]: crate::client::ModelService::upload_model
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition]: crate::model::TrainingPipeline::training_task_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_to_upload: std::option::Option<crate::model::Model>,

    /// Optional. The ID to use for the uploaded Model, which will become the final
    /// component of the model resource name.
    ///
    /// This value may be up to 63 characters, and valid characters are
    /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Optional. When specify this field, the `model_to_upload` will not be
    /// uploaded as a new model, instead, it will become a new version of this
    /// `parent_model`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_model: std::string::String,

    /// Output only. The detailed state of the pipeline.
    pub state: crate::model::PipelineState,

    /// Output only. Only populated when the pipeline's state is
    /// `PIPELINE_STATE_FAILED` or `PIPELINE_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Time when the TrainingPipeline was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TrainingPipeline for the first time entered the
    /// `PIPELINE_STATE_RUNNING` state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TrainingPipeline entered any of the following
    /// states: `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
    /// `PIPELINE_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TrainingPipeline was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels with user-defined metadata to organize TrainingPipelines.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Customer-managed encryption key spec for a TrainingPipeline. If set, this
    /// TrainingPipeline will be secured by this key.
    ///
    /// Note: Model trained by this TrainingPipeline is also secured by this key if
    /// [model_to_upload][google.cloud.aiplatform.v1.TrainingPipeline.encryption_spec]
    /// is not set separately.
    ///
    /// [google.cloud.aiplatform.v1.TrainingPipeline.encryption_spec]: crate::model::TrainingPipeline::encryption_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,
}

impl TrainingPipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TrainingPipeline::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TrainingPipeline::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [input_data_config][crate::model::TrainingPipeline::input_data_config].
    pub fn set_input_data_config<
        T: std::convert::Into<std::option::Option<crate::model::InputDataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_data_config = v.into();
        self
    }

    /// Sets the value of [training_task_definition][crate::model::TrainingPipeline::training_task_definition].
    pub fn set_training_task_definition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_task_definition = v.into();
        self
    }

    /// Sets the value of [training_task_inputs][crate::model::TrainingPipeline::training_task_inputs].
    pub fn set_training_task_inputs<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_task_inputs = v.into();
        self
    }

    /// Sets the value of [training_task_metadata][crate::model::TrainingPipeline::training_task_metadata].
    pub fn set_training_task_metadata<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_task_metadata = v.into();
        self
    }

    /// Sets the value of [model_to_upload][crate::model::TrainingPipeline::model_to_upload].
    pub fn set_model_to_upload<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_to_upload = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::TrainingPipeline::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [parent_model][crate::model::TrainingPipeline::parent_model].
    pub fn set_parent_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_model = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TrainingPipeline::state].
    pub fn set_state<T: std::convert::Into<crate::model::PipelineState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::TrainingPipeline::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TrainingPipeline::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TrainingPipeline::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TrainingPipeline::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TrainingPipeline::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::TrainingPipeline::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TrainingPipeline::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TrainingPipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrainingPipeline"
    }
}

/// Specifies Vertex AI owned input data to be used for training, and
/// possibly evaluating, the Model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InputDataConfig {
    /// Required. The ID of the Dataset in the same Project and Location which data
    /// will be used to train the Model. The Dataset must use schema compatible
    /// with Model being trained, and what is compatible should be described in the
    /// used TrainingPipeline's [training_task_definition]
    /// [google.cloud.aiplatform.v1.TrainingPipeline.training_task_definition].
    /// For tabular Datasets, all their data is exported to training, to pick
    /// and choose from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Applicable only to Datasets that have DataItems and Annotations.
    ///
    /// A filter on Annotations of the Dataset. Only Annotations that both
    /// match this filter and belong to DataItems not ignored by the split method
    /// are used in respectively training, validation or test role, depending on
    /// the role of the DataItem they are on (for the auto-assigned that role is
    /// decided by Vertex AI). A filter with same syntax as the one used in
    /// [ListAnnotations][google.cloud.aiplatform.v1.DatasetService.ListAnnotations]
    /// may be used, but note here it filters across all Annotations of the
    /// Dataset, and not just within a single DataItem.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListAnnotations]: crate::client::DatasetService::list_annotations
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotations_filter: std::string::String,

    /// Applicable only to custom training with Datasets that have DataItems and
    /// Annotations.
    ///
    /// Cloud Storage URI that points to a YAML file describing the annotation
    /// schema. The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// The schema files that can be used here are found in
    /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
    /// chosen schema must be consistent with
    /// [metadata][google.cloud.aiplatform.v1.Dataset.metadata_schema_uri] of the
    /// Dataset specified by
    /// [dataset_id][google.cloud.aiplatform.v1.InputDataConfig.dataset_id].
    ///
    /// Only Annotations that both match this schema and belong to DataItems not
    /// ignored by the split method are used in respectively training, validation
    /// or test role, depending on the role of the DataItem they are on.
    ///
    /// When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri].
    ///
    /// [google.cloud.aiplatform.v1.Dataset.metadata_schema_uri]: crate::model::Dataset::metadata_schema_uri
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri]: crate::model::InputDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotations_filter]: crate::model::InputDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.InputDataConfig.dataset_id]: crate::model::InputDataConfig::dataset_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_schema_uri: std::string::String,

    /// Only applicable to Datasets that have SavedQueries.
    ///
    /// The ID of a SavedQuery (annotation set) under the Dataset specified by
    /// [dataset_id][google.cloud.aiplatform.v1.InputDataConfig.dataset_id] used
    /// for filtering Annotations for training.
    ///
    /// Only Annotations that are associated with this SavedQuery are used in
    /// respectively training. When used in conjunction with
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter],
    /// the Annotations used for training are filtered by both
    /// [saved_query_id][google.cloud.aiplatform.v1.InputDataConfig.saved_query_id]
    /// and
    /// [annotations_filter][google.cloud.aiplatform.v1.InputDataConfig.annotations_filter].
    ///
    /// Only one of
    /// [saved_query_id][google.cloud.aiplatform.v1.InputDataConfig.saved_query_id]
    /// and
    /// [annotation_schema_uri][google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri]
    /// should be specified as both of them represent the same thing: problem type.
    ///
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotation_schema_uri]: crate::model::InputDataConfig::annotation_schema_uri
    /// [google.cloud.aiplatform.v1.InputDataConfig.annotations_filter]: crate::model::InputDataConfig::annotations_filter
    /// [google.cloud.aiplatform.v1.InputDataConfig.dataset_id]: crate::model::InputDataConfig::dataset_id
    /// [google.cloud.aiplatform.v1.InputDataConfig.saved_query_id]: crate::model::InputDataConfig::saved_query_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub saved_query_id: std::string::String,

    /// Whether to persist the ML use assignment to data item system labels.
    pub persist_ml_use_assignment: bool,

    /// The instructions how the input data should be split between the
    /// training, validation and test sets.
    /// If no split type is provided, the
    /// [fraction_split][google.cloud.aiplatform.v1.InputDataConfig.fraction_split]
    /// is used by default.
    ///
    /// [google.cloud.aiplatform.v1.InputDataConfig.fraction_split]: crate::model::InputDataConfig::split
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::input_data_config::Split>,

    /// Only applicable to Custom and Hyperparameter Tuning TrainingPipelines.
    ///
    /// The destination of the training data to be written to.
    ///
    /// Supported destination file formats:
    ///
    /// * For non-tabular data: "jsonl".
    /// * For tabular data: "csv" and "bigquery".
    ///
    /// The following Vertex AI environment variables are passed to containers
    /// or python modules of the training task when this field is set:
    ///
    /// * AIP_DATA_FORMAT : Exported data format.
    /// * AIP_TRAINING_DATA_URI : Sharded exported training data uris.
    /// * AIP_VALIDATION_DATA_URI : Sharded exported validation data uris.
    /// * AIP_TEST_DATA_URI : Sharded exported test data uris.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::input_data_config::Destination>,
}

impl InputDataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::InputDataConfig::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [annotations_filter][crate::model::InputDataConfig::annotations_filter].
    pub fn set_annotations_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotations_filter = v.into();
        self
    }

    /// Sets the value of [annotation_schema_uri][crate::model::InputDataConfig::annotation_schema_uri].
    pub fn set_annotation_schema_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_schema_uri = v.into();
        self
    }

    /// Sets the value of [saved_query_id][crate::model::InputDataConfig::saved_query_id].
    pub fn set_saved_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.saved_query_id = v.into();
        self
    }

    /// Sets the value of [persist_ml_use_assignment][crate::model::InputDataConfig::persist_ml_use_assignment].
    pub fn set_persist_ml_use_assignment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.persist_ml_use_assignment = v.into();
        self
    }

    /// Sets the value of `split`.
    pub fn set_split<
        T: std::convert::Into<std::option::Option<crate::model::input_data_config::Split>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = v.into();
        self
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `FractionSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fraction_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FractionSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::FractionSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `FilterSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_filter_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FilterSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::FilterSplit(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `PredefinedSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_predefined_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PredefinedSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::PredefinedSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `TimestampSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_timestamp_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimestampSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::TimestampSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [split][crate::model::InputDataConfig::split]
    /// if it holds a `StratifiedSplit`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_stratified_split(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StratifiedSplit>> {
        #[allow(unreachable_patterns)]
        self.split.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Split::StratifiedSplit(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `FractionSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_fraction_split<
        T: std::convert::Into<std::boxed::Box<crate::model::FractionSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::FractionSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `FilterSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_filter_split<T: std::convert::Into<std::boxed::Box<crate::model::FilterSplit>>>(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::FilterSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `PredefinedSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_predefined_split<
        T: std::convert::Into<std::boxed::Box<crate::model::PredefinedSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::PredefinedSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `TimestampSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_timestamp_split<
        T: std::convert::Into<std::boxed::Box<crate::model::TimestampSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::TimestampSplit(v.into()),
        );
        self
    }

    /// Sets the value of [split][crate::model::InputDataConfig::split]
    /// to hold a `StratifiedSplit`.
    ///
    /// Note that all the setters affecting `split` are
    /// mutually exclusive.
    pub fn set_stratified_split<
        T: std::convert::Into<std::boxed::Box<crate::model::StratifiedSplit>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.split = std::option::Option::Some(
            crate::model::input_data_config::Split::StratifiedSplit(v.into()),
        );
        self
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::input_data_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::InputDataConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [destination][crate::model::InputDataConfig::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bigquery_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::input_data_config::Destination::BigqueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::InputDataConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::input_data_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// Sets the value of [destination][crate::model::InputDataConfig::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::input_data_config::Destination::BigqueryDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InputDataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.InputDataConfig"
    }
}

/// Defines additional types related to InputDataConfig
pub mod input_data_config {
    #[allow(unused_imports)]
    use super::*;

    /// The instructions how the input data should be split between the
    /// training, validation and test sets.
    /// If no split type is provided, the
    /// [fraction_split][google.cloud.aiplatform.v1.InputDataConfig.fraction_split]
    /// is used by default.
    ///
    /// [google.cloud.aiplatform.v1.InputDataConfig.fraction_split]: crate::model::InputDataConfig::split
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Split {
        /// Split based on fractions defining the size of each set.
        FractionSplit(std::boxed::Box<crate::model::FractionSplit>),
        /// Split based on the provided filters for each set.
        FilterSplit(std::boxed::Box<crate::model::FilterSplit>),
        /// Supported only for tabular Datasets.
        ///
        /// Split based on a predefined key.
        PredefinedSplit(std::boxed::Box<crate::model::PredefinedSplit>),
        /// Supported only for tabular Datasets.
        ///
        /// Split based on the timestamp of the input data pieces.
        TimestampSplit(std::boxed::Box<crate::model::TimestampSplit>),
        /// Supported only for tabular Datasets.
        ///
        /// Split based on the distribution of the specified column.
        StratifiedSplit(std::boxed::Box<crate::model::StratifiedSplit>),
    }

    /// Only applicable to Custom and Hyperparameter Tuning TrainingPipelines.
    ///
    /// The destination of the training data to be written to.
    ///
    /// Supported destination file formats:
    ///
    /// * For non-tabular data: "jsonl".
    /// * For tabular data: "csv" and "bigquery".
    ///
    /// The following Vertex AI environment variables are passed to containers
    /// or python modules of the training task when this field is set:
    ///
    /// * AIP_DATA_FORMAT : Exported data format.
    /// * AIP_TRAINING_DATA_URI : Sharded exported training data uris.
    /// * AIP_VALIDATION_DATA_URI : Sharded exported validation data uris.
    /// * AIP_TEST_DATA_URI : Sharded exported test data uris.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// The Cloud Storage location where the training data is to be
        /// written to. In the given directory a new directory is created with
        /// name:
        /// `dataset-<dataset-id>-<annotation-type>-<timestamp-of-training-call>`
        /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
        /// All training input data is written into that directory.
        ///
        /// The Vertex AI environment variables representing Cloud Storage
        /// data URIs are represented in the Cloud Storage wildcard
        /// format to support sharded data. e.g.: "gs://.../training-*.jsonl"
        ///
        /// * AIP_DATA_FORMAT = "jsonl" for non-tabular data, "csv" for tabular data
        ///
        /// * AIP_TRAINING_DATA_URI =
        ///   "gcs_destination/dataset-\<dataset-id\>-\<annotation-type\>-\<time\>/training-*.${AIP_DATA_FORMAT}"
        ///
        /// * AIP_VALIDATION_DATA_URI =
        ///   "gcs_destination/dataset-\<dataset-id\>-\<annotation-type\>-\<time\>/validation-*.${AIP_DATA_FORMAT}"
        ///
        /// * AIP_TEST_DATA_URI =
        ///   "gcs_destination/dataset-\<dataset-id\>-\<annotation-type\>-\<time\>/test-*.${AIP_DATA_FORMAT}"
        ///
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
        /// Only applicable to custom training with tabular Dataset with BigQuery
        /// source.
        ///
        /// The BigQuery project location where the training data is to be written
        /// to. In the given project a new dataset is created with name
        /// `dataset_<dataset-id>_<annotation-type>_<timestamp-of-training-call>`
        /// where timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training
        /// input data is written into that dataset. In the dataset three
        /// tables are created, `training`, `validation` and `test`.
        ///
        /// * AIP_DATA_FORMAT = "bigquery".
        ///
        /// * AIP_TRAINING_DATA_URI  =
        ///   "bigquery_destination.dataset_\<dataset-id\>_<annotation-type>_\<time\>.training"
        ///
        /// * AIP_VALIDATION_DATA_URI =
        ///   "bigquery_destination.dataset_\<dataset-id\>_<annotation-type>_\<time\>.validation"
        ///
        /// * AIP_TEST_DATA_URI =
        ///   "bigquery_destination.dataset_\<dataset-id\>_<annotation-type>_\<time\>.test"
        ///
        BigqueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
    }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FractionSplit {
    /// The fraction of the input data that is to be used to train the Model.
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    pub test_fraction: f64,
}

impl FractionSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::FractionSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::FractionSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::FractionSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }
}

impl wkt::message::Message for FractionSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FractionSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored. Currently only
/// supported for Datasets containing DataItems.
/// If any of the filters in this message are to match nothing, then they can be
/// set as '-' (the minus sign).
///
/// Supported only for unstructured Datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterSplit {
    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to train the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to validate the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub validation_filter: std::string::String,

    /// Required. A filter on DataItems of the Dataset. DataItems that match
    /// this filter are used to test the Model. A filter with same syntax
    /// as the one used in
    /// [DatasetService.ListDataItems][google.cloud.aiplatform.v1.DatasetService.ListDataItems]
    /// may be used. If a single DataItem is matched by more than one of the
    /// FilterSplit filters, then it is assigned to the first set that applies to
    /// it in the training, validation, test order.
    ///
    /// [google.cloud.aiplatform.v1.DatasetService.ListDataItems]: crate::client::DatasetService::list_data_items
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub test_filter: std::string::String,
}

impl FilterSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_filter][crate::model::FilterSplit::training_filter].
    pub fn set_training_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.training_filter = v.into();
        self
    }

    /// Sets the value of [validation_filter][crate::model::FilterSplit::validation_filter].
    pub fn set_validation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_filter = v.into();
        self
    }

    /// Sets the value of [test_filter][crate::model::FilterSplit::test_filter].
    pub fn set_test_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_filter = v.into();
        self
    }
}

impl wkt::message::Message for FilterSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FilterSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on the
/// value of a provided key.
///
/// Supported only for tabular Datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredefinedSplit {
    /// Required. The key is a name of one of the Dataset's data columns.
    /// The value of the key (either the label's value or value in the column)
    /// must be one of {`training`, `validation`, `test`}, and it defines to which
    /// set the given piece of data is assigned. If for a piece of data the key
    /// is not present or has an invalid value, that piece is ignored by the
    /// pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,
}

impl PredefinedSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::PredefinedSplit::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for PredefinedSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredefinedSplit"
    }
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps. The youngest data pieces are assigned to training set,
/// next to validation set, and the oldest to the test set.
///
/// Supported only for tabular Datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimestampSplit {
    /// The fraction of the input data that is to be used to train the Model.
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    pub test_fraction: f64,

    /// Required. The key is a name of one of the Dataset's data columns.
    /// The values of the key (the values in the column) must be in RFC 3339
    /// `date-time` format, where `time-offset` = `"Z"`
    /// (e.g. 1985-04-12T23:20:50.52Z). If for a piece of data the key is not
    /// present or has an invalid value, that piece is ignored by the pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,
}

impl TimestampSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::TimestampSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::TimestampSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::TimestampSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }

    /// Sets the value of [key][crate::model::TimestampSplit::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for TimestampSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimestampSplit"
    }
}

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split. The fraction values determine
/// the relative sizes of the splits.
///
/// For example, if the specified column has three values, with 50% of the rows
/// having value "A", 25% value "B", and 25% value "C", and the split fractions
/// are specified as 80/10/10, then the training set will constitute 80% of the
/// training data, with about 50% of the training set rows having the value "A"
/// for the specified column, about 25% having the value "B", and about 25%
/// having the value "C".
///
/// Only the top 500 occurring values are used; any values not in the top
/// 500 values are randomly assigned to a split. If less than three rows contain
/// a specific value, those rows are randomly assigned.
///
/// Supported only for tabular Datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StratifiedSplit {
    /// The fraction of the input data that is to be used to train the Model.
    pub training_fraction: f64,

    /// The fraction of the input data that is to be used to validate the Model.
    pub validation_fraction: f64,

    /// The fraction of the input data that is to be used to evaluate the Model.
    pub test_fraction: f64,

    /// Required. The key is a name of one of the Dataset's data columns.
    /// The key provided must be for a categorical column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,
}

impl StratifiedSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_fraction][crate::model::StratifiedSplit::training_fraction].
    pub fn set_training_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.training_fraction = v.into();
        self
    }

    /// Sets the value of [validation_fraction][crate::model::StratifiedSplit::validation_fraction].
    pub fn set_validation_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.validation_fraction = v.into();
        self
    }

    /// Sets the value of [test_fraction][crate::model::StratifiedSplit::test_fraction].
    pub fn set_test_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.test_fraction = v.into();
        self
    }

    /// Sets the value of [key][crate::model::StratifiedSplit::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for StratifiedSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StratifiedSplit"
    }
}

/// Represents a TuningJob that runs with Google owned models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuningJob {
    /// Output only. Identifier. Resource name of a TuningJob. Format:
    /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The display name of the
    /// [TunedModel][google.cloud.aiplatform.v1.Model]. The name can be up to 128
    /// characters long and can consist of any UTF-8 characters.
    ///
    /// [google.cloud.aiplatform.v1.Model]: crate::model::Model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tuned_model_display_name: std::string::String,

    /// Optional. The description of the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The detailed state of the job.
    pub state: crate::model::JobState,

    /// Output only. Time when the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] was created.
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] for the first time
    /// entered the `JOB_STATE_RUNNING` state.
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the TuningJob entered any of the following
    /// [JobStates][google.cloud.aiplatform.v1.JobState]: `JOB_STATE_SUCCEEDED`,
    /// `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`, `JOB_STATE_EXPIRED`.
    ///
    /// [google.cloud.aiplatform.v1.JobState]: crate::model::JobState
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when the
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] was most recently
    /// updated.
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
    /// `JOB_STATE_CANCELLED`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Optional. The labels with user-defined metadata to organize
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob] and generated resources
    /// such as [Model][google.cloud.aiplatform.v1.Model] and
    /// [Endpoint][google.cloud.aiplatform.v1.Endpoint].
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    ///
    /// See <https://goo.gl/xmQnxf> for more information and examples of labels.
    ///
    /// [google.cloud.aiplatform.v1.Endpoint]: crate::model::Endpoint
    /// [google.cloud.aiplatform.v1.Model]: crate::model::Model
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The Experiment associated with this
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub experiment: std::string::String,

    /// Output only. The tuned model resources assiociated with this
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuned_model: std::option::Option<crate::model::TunedModel>,

    /// Output only. The tuning data statistics associated with this
    /// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
    ///
    /// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_data_stats: std::option::Option<crate::model::TuningDataStats>,

    /// Customer-managed encryption key options for a TuningJob. If this is set,
    /// then all resources created by the TuningJob will be encrypted with the
    /// provided encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    /// The service account that the tuningJob workload runs as.
    /// If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the
    /// project will be used. See
    /// <https://cloud.google.com/iam/docs/service-agents#vertex-ai-secure-fine-tuning-service-agent>
    ///
    /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
    /// permission on this service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_model: std::option::Option<crate::model::tuning_job::SourceModel>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_spec: std::option::Option<crate::model::tuning_job::TuningSpec>,
}

impl TuningJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TuningJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tuned_model_display_name][crate::model::TuningJob::tuned_model_display_name].
    pub fn set_tuned_model_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model_display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TuningJob::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TuningJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TuningJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TuningJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TuningJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TuningJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::TuningJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [experiment][crate::model::TuningJob::experiment].
    pub fn set_experiment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment = v.into();
        self
    }

    /// Sets the value of [tuned_model][crate::model::TuningJob::tuned_model].
    pub fn set_tuned_model<T: std::convert::Into<std::option::Option<crate::model::TunedModel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model = v.into();
        self
    }

    /// Sets the value of [tuning_data_stats][crate::model::TuningJob::tuning_data_stats].
    pub fn set_tuning_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::TuningDataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_data_stats = v.into();
        self
    }

    /// Sets the value of [encryption_spec][crate::model::TuningJob::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::TuningJob::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TuningJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `source_model`.
    pub fn set_source_model<
        T: std::convert::Into<std::option::Option<crate::model::tuning_job::SourceModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_model = v.into();
        self
    }

    /// The value of [source_model][crate::model::TuningJob::source_model]
    /// if it holds a `BaseModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_base_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source_model.as_ref().and_then(|v| match v {
            crate::model::tuning_job::SourceModel::BaseModel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_model][crate::model::TuningJob::source_model]
    /// to hold a `BaseModel`.
    ///
    /// Note that all the setters affecting `source_model` are
    /// mutually exclusive.
    pub fn set_base_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_model =
            std::option::Option::Some(crate::model::tuning_job::SourceModel::BaseModel(v.into()));
        self
    }

    /// Sets the value of `tuning_spec`.
    pub fn set_tuning_spec<
        T: std::convert::Into<std::option::Option<crate::model::tuning_job::TuningSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_spec = v.into();
        self
    }

    /// The value of [tuning_spec][crate::model::TuningJob::tuning_spec]
    /// if it holds a `SupervisedTuningSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_supervised_tuning_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SupervisedTuningSpec>> {
        #[allow(unreachable_patterns)]
        self.tuning_spec.as_ref().and_then(|v| match v {
            crate::model::tuning_job::TuningSpec::SupervisedTuningSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tuning_spec][crate::model::TuningJob::tuning_spec]
    /// to hold a `SupervisedTuningSpec`.
    ///
    /// Note that all the setters affecting `tuning_spec` are
    /// mutually exclusive.
    pub fn set_supervised_tuning_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::SupervisedTuningSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_spec = std::option::Option::Some(
            crate::model::tuning_job::TuningSpec::SupervisedTuningSpec(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TuningJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TuningJob"
    }
}

/// Defines additional types related to TuningJob
pub mod tuning_job {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceModel {
        /// The base model that is being tuned, e.g., "gemini-1.0-pro-002".
        BaseModel(std::string::String),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TuningSpec {
        /// Tuning Spec for Supervised Fine Tuning.
        SupervisedTuningSpec(std::boxed::Box<crate::model::SupervisedTuningSpec>),
    }
}

/// The Model Registry Model and Online Prediction Endpoint assiociated with
/// this [TuningJob][google.cloud.aiplatform.v1.TuningJob].
///
/// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TunedModel {
    /// Output only. The resource name of the TunedModel. Format:
    /// `projects/{project}/locations/{location}/models/{model}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Output only. A resource name of an Endpoint. Format:
    /// `projects/{project}/locations/{location}/endpoints/{endpoint}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,
}

impl TunedModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::TunedModel::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::TunedModel::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }
}

impl wkt::message::Message for TunedModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModel"
    }
}

/// Dataset distribution for Supervised Tuning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedTuningDatasetDistribution {
    /// Output only. Sum of a given population of values.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sum: i64,

    /// Output only. Sum of a given population of values that are billable.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub billable_sum: i64,

    /// Output only. The minimum of the population values.
    pub min: f64,

    /// Output only. The maximum of the population values.
    pub max: f64,

    /// Output only. The arithmetic mean of the values in the population.
    pub mean: f64,

    /// Output only. The median of the values in the population.
    pub median: f64,

    /// Output only. The 5th percentile of the values in the population.
    pub p5: f64,

    /// Output only. The 95th percentile of the values in the population.
    pub p95: f64,

    /// Output only. Defines the histogram bucket.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub buckets: std::vec::Vec<crate::model::supervised_tuning_dataset_distribution::DatasetBucket>,
}

impl SupervisedTuningDatasetDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sum][crate::model::SupervisedTuningDatasetDistribution::sum].
    pub fn set_sum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sum = v.into();
        self
    }

    /// Sets the value of [billable_sum][crate::model::SupervisedTuningDatasetDistribution::billable_sum].
    pub fn set_billable_sum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.billable_sum = v.into();
        self
    }

    /// Sets the value of [min][crate::model::SupervisedTuningDatasetDistribution::min].
    pub fn set_min<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::SupervisedTuningDatasetDistribution::max].
    pub fn set_max<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }

    /// Sets the value of [mean][crate::model::SupervisedTuningDatasetDistribution::mean].
    pub fn set_mean<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.mean = v.into();
        self
    }

    /// Sets the value of [median][crate::model::SupervisedTuningDatasetDistribution::median].
    pub fn set_median<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.median = v.into();
        self
    }

    /// Sets the value of [p5][crate::model::SupervisedTuningDatasetDistribution::p5].
    pub fn set_p5<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.p5 = v.into();
        self
    }

    /// Sets the value of [p95][crate::model::SupervisedTuningDatasetDistribution::p95].
    pub fn set_p95<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.p95 = v.into();
        self
    }

    /// Sets the value of [buckets][crate::model::SupervisedTuningDatasetDistribution::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::supervised_tuning_dataset_distribution::DatasetBucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SupervisedTuningDatasetDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution"
    }
}

/// Defines additional types related to SupervisedTuningDatasetDistribution
pub mod supervised_tuning_dataset_distribution {
    #[allow(unused_imports)]
    use super::*;

    /// Dataset bucket used to create a histogram for the distribution given a
    /// population of values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DatasetBucket {
        /// Output only. Number of values in the bucket.
        pub count: f64,

        /// Output only. Left bound of the bucket.
        pub left: f64,

        /// Output only. Right bound of the bucket.
        pub right: f64,
    }

    impl DatasetBucket {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::supervised_tuning_dataset_distribution::DatasetBucket::count].
        pub fn set_count<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }

        /// Sets the value of [left][crate::model::supervised_tuning_dataset_distribution::DatasetBucket::left].
        pub fn set_left<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.left = v.into();
            self
        }

        /// Sets the value of [right][crate::model::supervised_tuning_dataset_distribution::DatasetBucket::right].
        pub fn set_right<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.right = v.into();
            self
        }
    }

    impl wkt::message::Message for DatasetBucket {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution.DatasetBucket"
        }
    }
}

/// Tuning data statistics for Supervised Tuning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedTuningDataStats {
    /// Output only. Number of examples in the tuning dataset.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub tuning_dataset_example_count: i64,

    /// Output only. Number of tuning characters in the tuning dataset.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_tuning_character_count: i64,

    /// Output only. Number of billable characters in the tuning dataset.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_character_count: i64,

    /// Output only. Number of billable tokens in the tuning dataset.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_token_count: i64,

    /// Output only. Number of tuning steps for this Tuning Job.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub tuning_step_count: i64,

    /// Output only. Dataset distributions for the user input tokens.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_input_token_distribution:
        std::option::Option<crate::model::SupervisedTuningDatasetDistribution>,

    /// Output only. Dataset distributions for the user output tokens.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_output_token_distribution:
        std::option::Option<crate::model::SupervisedTuningDatasetDistribution>,

    /// Output only. Dataset distributions for the messages per example.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_message_per_example_distribution:
        std::option::Option<crate::model::SupervisedTuningDatasetDistribution>,

    /// Output only. Sample user messages in the training dataset uri.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_dataset_examples: std::vec::Vec<crate::model::Content>,

    /// The number of examples in the dataset that have been truncated by any
    /// amount.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_truncated_example_count: i64,

    /// A partial sample of the indices (starting from 1) of the truncated
    /// examples.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub truncated_example_indices: std::vec::Vec<i64>,
}

impl SupervisedTuningDataStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tuning_dataset_example_count][crate::model::SupervisedTuningDataStats::tuning_dataset_example_count].
    pub fn set_tuning_dataset_example_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.tuning_dataset_example_count = v.into();
        self
    }

    /// Sets the value of [total_tuning_character_count][crate::model::SupervisedTuningDataStats::total_tuning_character_count].
    pub fn set_total_tuning_character_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_tuning_character_count = v.into();
        self
    }

    /// Sets the value of [total_billable_character_count][crate::model::SupervisedTuningDataStats::total_billable_character_count].
    pub fn set_total_billable_character_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_character_count = v.into();
        self
    }

    /// Sets the value of [total_billable_token_count][crate::model::SupervisedTuningDataStats::total_billable_token_count].
    pub fn set_total_billable_token_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_token_count = v.into();
        self
    }

    /// Sets the value of [tuning_step_count][crate::model::SupervisedTuningDataStats::tuning_step_count].
    pub fn set_tuning_step_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.tuning_step_count = v.into();
        self
    }

    /// Sets the value of [user_input_token_distribution][crate::model::SupervisedTuningDataStats::user_input_token_distribution].
    pub fn set_user_input_token_distribution<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedTuningDatasetDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_input_token_distribution = v.into();
        self
    }

    /// Sets the value of [user_output_token_distribution][crate::model::SupervisedTuningDataStats::user_output_token_distribution].
    pub fn set_user_output_token_distribution<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedTuningDatasetDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_output_token_distribution = v.into();
        self
    }

    /// Sets the value of [user_message_per_example_distribution][crate::model::SupervisedTuningDataStats::user_message_per_example_distribution].
    pub fn set_user_message_per_example_distribution<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedTuningDatasetDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_message_per_example_distribution = v.into();
        self
    }

    /// Sets the value of [total_truncated_example_count][crate::model::SupervisedTuningDataStats::total_truncated_example_count].
    pub fn set_total_truncated_example_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_truncated_example_count = v.into();
        self
    }

    /// Sets the value of [user_dataset_examples][crate::model::SupervisedTuningDataStats::user_dataset_examples].
    pub fn set_user_dataset_examples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.user_dataset_examples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [truncated_example_indices][crate::model::SupervisedTuningDataStats::truncated_example_indices].
    pub fn set_truncated_example_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.truncated_example_indices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SupervisedTuningDataStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDataStats"
    }
}

/// The tuning data statistic values for
/// [TuningJob][google.cloud.aiplatform.v1.TuningJob].
///
/// [google.cloud.aiplatform.v1.TuningJob]: crate::model::TuningJob
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuningDataStats {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_data_stats: std::option::Option<crate::model::tuning_data_stats::TuningDataStats>,
}

impl TuningDataStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `tuning_data_stats`.
    pub fn set_tuning_data_stats<
        T: std::convert::Into<std::option::Option<crate::model::tuning_data_stats::TuningDataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_data_stats = v.into();
        self
    }

    /// The value of [tuning_data_stats][crate::model::TuningDataStats::tuning_data_stats]
    /// if it holds a `SupervisedTuningDataStats`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_supervised_tuning_data_stats(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SupervisedTuningDataStats>> {
        #[allow(unreachable_patterns)]
        self.tuning_data_stats.as_ref().and_then(|v| match v {
            crate::model::tuning_data_stats::TuningDataStats::SupervisedTuningDataStats(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tuning_data_stats][crate::model::TuningDataStats::tuning_data_stats]
    /// to hold a `SupervisedTuningDataStats`.
    ///
    /// Note that all the setters affecting `tuning_data_stats` are
    /// mutually exclusive.
    pub fn set_supervised_tuning_data_stats<
        T: std::convert::Into<std::boxed::Box<crate::model::SupervisedTuningDataStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_data_stats = std::option::Option::Some(
            crate::model::tuning_data_stats::TuningDataStats::SupervisedTuningDataStats(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TuningDataStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TuningDataStats"
    }
}

/// Defines additional types related to TuningDataStats
pub mod tuning_data_stats {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TuningDataStats {
        /// The SFT Tuning data stats.
        SupervisedTuningDataStats(std::boxed::Box<crate::model::SupervisedTuningDataStats>),
    }
}

/// Hyperparameters for SFT.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedHyperParameters {
    /// Optional. Number of complete passes the model makes over the entire
    /// training dataset during training.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub epoch_count: i64,

    /// Optional. Multiplier for adjusting the default learning rate.
    pub learning_rate_multiplier: f64,

    /// Optional. Adapter size for tuning.
    pub adapter_size: crate::model::supervised_hyper_parameters::AdapterSize,
}

impl SupervisedHyperParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [epoch_count][crate::model::SupervisedHyperParameters::epoch_count].
    pub fn set_epoch_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.epoch_count = v.into();
        self
    }

    /// Sets the value of [learning_rate_multiplier][crate::model::SupervisedHyperParameters::learning_rate_multiplier].
    pub fn set_learning_rate_multiplier<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.learning_rate_multiplier = v.into();
        self
    }

    /// Sets the value of [adapter_size][crate::model::SupervisedHyperParameters::adapter_size].
    pub fn set_adapter_size<
        T: std::convert::Into<crate::model::supervised_hyper_parameters::AdapterSize>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.adapter_size = v.into();
        self
    }
}

impl wkt::message::Message for SupervisedHyperParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedHyperParameters"
    }
}

/// Defines additional types related to SupervisedHyperParameters
pub mod supervised_hyper_parameters {
    #[allow(unused_imports)]
    use super::*;

    /// Supported adapter sizes for tuning.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AdapterSize(std::borrow::Cow<'static, str>);

    impl AdapterSize {
        /// Creates a new AdapterSize instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [AdapterSize](AdapterSize)
    pub mod adapter_size {
        use super::AdapterSize;

        /// Adapter size is unspecified.
        pub const ADAPTER_SIZE_UNSPECIFIED: AdapterSize =
            AdapterSize::new("ADAPTER_SIZE_UNSPECIFIED");

        /// Adapter size 1.
        pub const ADAPTER_SIZE_ONE: AdapterSize = AdapterSize::new("ADAPTER_SIZE_ONE");

        /// Adapter size 4.
        pub const ADAPTER_SIZE_FOUR: AdapterSize = AdapterSize::new("ADAPTER_SIZE_FOUR");

        /// Adapter size 8.
        pub const ADAPTER_SIZE_EIGHT: AdapterSize = AdapterSize::new("ADAPTER_SIZE_EIGHT");

        /// Adapter size 16.
        pub const ADAPTER_SIZE_SIXTEEN: AdapterSize = AdapterSize::new("ADAPTER_SIZE_SIXTEEN");
    }

    impl std::convert::From<std::string::String> for AdapterSize {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Tuning Spec for Supervised Tuning for first party models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupervisedTuningSpec {
    /// Required. Cloud Storage path to file containing training dataset for
    /// tuning. The dataset must be formatted as a JSONL file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub training_dataset_uri: std::string::String,

    /// Optional. Cloud Storage path to file containing validation dataset for
    /// tuning. The dataset must be formatted as a JSONL file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub validation_dataset_uri: std::string::String,

    /// Optional. Hyperparameters for SFT.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hyper_parameters: std::option::Option<crate::model::SupervisedHyperParameters>,
}

impl SupervisedTuningSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_dataset_uri][crate::model::SupervisedTuningSpec::training_dataset_uri].
    pub fn set_training_dataset_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_dataset_uri = v.into();
        self
    }

    /// Sets the value of [validation_dataset_uri][crate::model::SupervisedTuningSpec::validation_dataset_uri].
    pub fn set_validation_dataset_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_dataset_uri = v.into();
        self
    }

    /// Sets the value of [hyper_parameters][crate::model::SupervisedTuningSpec::hyper_parameters].
    pub fn set_hyper_parameters<
        T: std::convert::Into<std::option::Option<crate::model::SupervisedHyperParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyper_parameters = v.into();
        self
    }
}

impl wkt::message::Message for SupervisedTuningSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningSpec"
    }
}

/// TunedModel Reference for legacy model migration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TunedModelRef {
    /// The Tuned Model Reference for the model.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub tuned_model_ref: std::option::Option<crate::model::tuned_model_ref::TunedModelRef>,
}

impl TunedModelRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `tuned_model_ref`.
    pub fn set_tuned_model_ref<
        T: std::convert::Into<std::option::Option<crate::model::tuned_model_ref::TunedModelRef>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuned_model_ref = v.into();
        self
    }

    /// The value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// if it holds a `TunedModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tuned_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tuned_model_ref.as_ref().and_then(|v| match v {
            crate::model::tuned_model_ref::TunedModelRef::TunedModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// if it holds a `TuningJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_tuning_job(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tuned_model_ref.as_ref().and_then(|v| match v {
            crate::model::tuned_model_ref::TunedModelRef::TuningJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// if it holds a `PipelineJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pipeline_job(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.tuned_model_ref.as_ref().and_then(|v| match v {
            crate::model::tuned_model_ref::TunedModelRef::PipelineJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// to hold a `TunedModel`.
    ///
    /// Note that all the setters affecting `tuned_model_ref` are
    /// mutually exclusive.
    pub fn set_tuned_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tuned_model_ref = std::option::Option::Some(
            crate::model::tuned_model_ref::TunedModelRef::TunedModel(v.into()),
        );
        self
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// to hold a `TuningJob`.
    ///
    /// Note that all the setters affecting `tuned_model_ref` are
    /// mutually exclusive.
    pub fn set_tuning_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tuned_model_ref = std::option::Option::Some(
            crate::model::tuned_model_ref::TunedModelRef::TuningJob(v.into()),
        );
        self
    }

    /// Sets the value of [tuned_model_ref][crate::model::TunedModelRef::tuned_model_ref]
    /// to hold a `PipelineJob`.
    ///
    /// Note that all the setters affecting `tuned_model_ref` are
    /// mutually exclusive.
    pub fn set_pipeline_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tuned_model_ref = std::option::Option::Some(
            crate::model::tuned_model_ref::TunedModelRef::PipelineJob(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TunedModelRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModelRef"
    }
}

/// Defines additional types related to TunedModelRef
pub mod tuned_model_ref {
    #[allow(unused_imports)]
    use super::*;

    /// The Tuned Model Reference for the model.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TunedModelRef {
        /// Support migration from model registry.
        TunedModel(std::string::String),
        /// Support migration from tuning job list page, from gemini-1.0-pro-002
        /// to 1.5 and above.
        TuningJob(std::string::String),
        /// Support migration from tuning job list page, from bison model to gemini
        /// model.
        PipelineJob(std::string::String),
    }
}

/// A list of boolean values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BoolArray {
    /// A list of bool values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<bool>,
}

impl BoolArray {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::BoolArray::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BoolArray {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.BoolArray"
    }
}

/// A list of double values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DoubleArray {
    /// A list of double values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<f64>,
}

impl DoubleArray {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::DoubleArray::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DoubleArray {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DoubleArray"
    }
}

/// A list of int64 values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Int64Array {
    /// A list of int64 values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub values: std::vec::Vec<i64>,
}

impl Int64Array {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::Int64Array::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Int64Array {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Int64Array"
    }
}

/// A list of string values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StringArray {
    /// A list of string values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,
}

impl StringArray {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::StringArray::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StringArray {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StringArray"
    }
}

/// A tensor value type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tensor {
    /// The data type of tensor.
    pub dtype: crate::model::tensor::DataType,

    /// Shape of the tensor.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub shape: std::vec::Vec<i64>,

    /// Type specific representations that make it easy to create tensor protos in
    /// all languages.  Only the representation corresponding to "dtype" can
    /// be set.  The values hold the flattened representation of the tensor in
    /// row major order.
    ///
    /// [BOOL][google.cloud.aiplatform.v1.Tensor.DataType.BOOL]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.BOOL]: crate::model::tensor::data_type::BOOL
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bool_val: std::vec::Vec<bool>,

    /// [STRING][google.cloud.aiplatform.v1.Tensor.DataType.STRING]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.STRING]: crate::model::tensor::data_type::STRING
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub string_val: std::vec::Vec<std::string::String>,

    /// [STRING][google.cloud.aiplatform.v1.Tensor.DataType.STRING]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.STRING]: crate::model::tensor::data_type::STRING
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub bytes_val: std::vec::Vec<bytes::Bytes>,

    /// [FLOAT][google.cloud.aiplatform.v1.Tensor.DataType.FLOAT]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.FLOAT]: crate::model::tensor::data_type::FLOAT
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub float_val: std::vec::Vec<f32>,

    /// [DOUBLE][google.cloud.aiplatform.v1.Tensor.DataType.DOUBLE]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.DOUBLE]: crate::model::tensor::data_type::DOUBLE
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub double_val: std::vec::Vec<f64>,

    /// [INT_8][google.cloud.aiplatform.v1.Tensor.DataType.INT8]
    /// [INT_16][google.cloud.aiplatform.v1.Tensor.DataType.INT16]
    /// [INT_32][google.cloud.aiplatform.v1.Tensor.DataType.INT32]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT16]: crate::model::tensor::data_type::INT16
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT32]: crate::model::tensor::data_type::INT32
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT8]: crate::model::tensor::data_type::INT8
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub int_val: std::vec::Vec<i32>,

    /// [INT64][google.cloud.aiplatform.v1.Tensor.DataType.INT64]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.INT64]: crate::model::tensor::data_type::INT64
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub int64_val: std::vec::Vec<i64>,

    /// [UINT8][google.cloud.aiplatform.v1.Tensor.DataType.UINT8]
    /// [UINT16][google.cloud.aiplatform.v1.Tensor.DataType.UINT16]
    /// [UINT32][google.cloud.aiplatform.v1.Tensor.DataType.UINT32]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT16]: crate::model::tensor::data_type::UINT16
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT32]: crate::model::tensor::data_type::UINT32
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT8]: crate::model::tensor::data_type::UINT8
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uint_val: std::vec::Vec<u32>,

    /// [UINT64][google.cloud.aiplatform.v1.Tensor.DataType.UINT64]
    ///
    /// [google.cloud.aiplatform.v1.Tensor.DataType.UINT64]: crate::model::tensor::data_type::UINT64
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub uint64_val: std::vec::Vec<u64>,

    /// A list of tensor values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub list_val: std::vec::Vec<crate::model::Tensor>,

    /// A map of string to tensor.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub struct_val: std::collections::HashMap<std::string::String, crate::model::Tensor>,

    /// Serialized raw tensor content.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub tensor_val: bytes::Bytes,
}

impl Tensor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dtype][crate::model::Tensor::dtype].
    pub fn set_dtype<T: std::convert::Into<crate::model::tensor::DataType>>(
        mut self,
        v: T,
    ) -> Self {
        self.dtype = v.into();
        self
    }

    /// Sets the value of [tensor_val][crate::model::Tensor::tensor_val].
    pub fn set_tensor_val<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.tensor_val = v.into();
        self
    }

    /// Sets the value of [shape][crate::model::Tensor::shape].
    pub fn set_shape<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.shape = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bool_val][crate::model::Tensor::bool_val].
    pub fn set_bool_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.bool_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [string_val][crate::model::Tensor::string_val].
    pub fn set_string_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.string_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bytes_val][crate::model::Tensor::bytes_val].
    pub fn set_bytes_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.bytes_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [float_val][crate::model::Tensor::float_val].
    pub fn set_float_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.float_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [double_val][crate::model::Tensor::double_val].
    pub fn set_double_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.double_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [int_val][crate::model::Tensor::int_val].
    pub fn set_int_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.int_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [int64_val][crate::model::Tensor::int64_val].
    pub fn set_int64_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.int64_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uint_val][crate::model::Tensor::uint_val].
    pub fn set_uint_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.uint_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uint64_val][crate::model::Tensor::uint64_val].
    pub fn set_uint64_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.uint64_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [list_val][crate::model::Tensor::list_val].
    pub fn set_list_val<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.list_val = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [struct_val][crate::model::Tensor::struct_val].
    pub fn set_struct_val<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Tensor>,
    {
        use std::iter::Iterator;
        self.struct_val = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Tensor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tensor"
    }
}

/// Defines additional types related to Tensor
pub mod tensor {
    #[allow(unused_imports)]
    use super::*;

    /// Data type of the tensor.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataType(std::borrow::Cow<'static, str>);

    impl DataType {
        /// Creates a new DataType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DataType](DataType)
    pub mod data_type {
        use super::DataType;

        /// Not a legal value for DataType. Used to indicate a DataType field has not
        /// been set.
        pub const DATA_TYPE_UNSPECIFIED: DataType = DataType::new("DATA_TYPE_UNSPECIFIED");

        /// Data types that all computation devices are expected to be
        /// capable to support.
        pub const BOOL: DataType = DataType::new("BOOL");

        pub const STRING: DataType = DataType::new("STRING");

        pub const FLOAT: DataType = DataType::new("FLOAT");

        pub const DOUBLE: DataType = DataType::new("DOUBLE");

        pub const INT8: DataType = DataType::new("INT8");

        pub const INT16: DataType = DataType::new("INT16");

        pub const INT32: DataType = DataType::new("INT32");

        pub const INT64: DataType = DataType::new("INT64");

        pub const UINT8: DataType = DataType::new("UINT8");

        pub const UINT16: DataType = DataType::new("UINT16");

        pub const UINT32: DataType = DataType::new("UINT32");

        pub const UINT64: DataType = DataType::new("UINT64");
    }

    impl std::convert::From<std::string::String> for DataType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnmanagedContainerModel {
    /// The path to the directory containing the Model artifact and any of its
    /// supporting files.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub artifact_uri: std::string::String,

    /// Contains the schemata used in Model's predictions and explanations
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predict_schemata: std::option::Option<crate::model::PredictSchemata>,

    /// Input only. The specification of the container that is to be used when
    /// deploying this Model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container_spec: std::option::Option<crate::model::ModelContainerSpec>,
}

impl UnmanagedContainerModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_uri][crate::model::UnmanagedContainerModel::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [predict_schemata][crate::model::UnmanagedContainerModel::predict_schemata].
    pub fn set_predict_schemata<
        T: std::convert::Into<std::option::Option<crate::model::PredictSchemata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.predict_schemata = v.into();
        self
    }

    /// Sets the value of [container_spec][crate::model::UnmanagedContainerModel::container_spec].
    pub fn set_container_spec<
        T: std::convert::Into<std::option::Option<crate::model::ModelContainerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container_spec = v.into();
        self
    }
}

impl wkt::message::Message for UnmanagedContainerModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UnmanagedContainerModel"
    }
}

/// References an API call. It contains more information about long running
/// operation and Jobs that are triggered by the API call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserActionReference {
    /// The method name of the API RPC call. For example,
    /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<crate::model::user_action_reference::Reference>,
}

impl UserActionReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [method][crate::model::UserActionReference::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of `reference`.
    pub fn set_reference<
        T: std::convert::Into<std::option::Option<crate::model::user_action_reference::Reference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// The value of [reference][crate::model::UserActionReference::reference]
    /// if it holds a `Operation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_operation(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.reference.as_ref().and_then(|v| match v {
            crate::model::user_action_reference::Reference::Operation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [reference][crate::model::UserActionReference::reference]
    /// if it holds a `DataLabelingJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_data_labeling_job(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.reference.as_ref().and_then(|v| match v {
            crate::model::user_action_reference::Reference::DataLabelingJob(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [reference][crate::model::UserActionReference::reference]
    /// to hold a `Operation`.
    ///
    /// Note that all the setters affecting `reference` are
    /// mutually exclusive.
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference = std::option::Option::Some(
            crate::model::user_action_reference::Reference::Operation(v.into()),
        );
        self
    }

    /// Sets the value of [reference][crate::model::UserActionReference::reference]
    /// to hold a `DataLabelingJob`.
    ///
    /// Note that all the setters affecting `reference` are
    /// mutually exclusive.
    pub fn set_data_labeling_job<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = std::option::Option::Some(
            crate::model::user_action_reference::Reference::DataLabelingJob(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UserActionReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UserActionReference"
    }
}

/// Defines additional types related to UserActionReference
pub mod user_action_reference {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Reference {
        /// For API calls that return a long running operation.
        /// Resource name of the long running operation.
        /// Format:
        /// `projects/{project}/locations/{location}/operations/{operation}`
        Operation(std::string::String),
        /// For API calls that start a LabelingJob.
        /// Resource name of the LabelingJob.
        /// Format:
        /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
        DataLabelingJob(std::string::String),
    }
}

/// Value is the value of the field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Value {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::value::Value>,
}

impl Value {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `value`.
    pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::value::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::Value::value]
    /// if it holds a `IntValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::value::Value::IntValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::Value::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::Value::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::Value::value]
    /// to hold a `IntValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = std::option::Option::Some(crate::model::value::Value::IntValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::Value::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = std::option::Option::Some(crate::model::value::Value::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::Value::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = std::option::Option::Some(crate::model::value::Value::StringValue(v.into()));
        self
    }
}

impl wkt::message::Message for Value {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Value"
    }
}

/// Defines additional types related to Value
pub mod value {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// An integer value.
        IntValue(i64),
        /// A double value.
        DoubleValue(f64),
        /// A string value.
        StringValue(std::string::String),
    }
}

/// Config for the embedding model to use for RAG.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagEmbeddingModelConfig {
    /// The model config to use.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub model_config: std::option::Option<crate::model::rag_embedding_model_config::ModelConfig>,
}

impl RagEmbeddingModelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `model_config`.
    pub fn set_model_config<
        T: std::convert::Into<
            std::option::Option<crate::model::rag_embedding_model_config::ModelConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_config = v.into();
        self
    }

    /// The value of [model_config][crate::model::RagEmbeddingModelConfig::model_config]
    /// if it holds a `VertexPredictionEndpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_prediction_endpoint(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::rag_embedding_model_config::VertexPredictionEndpoint>,
    > {
        #[allow(unreachable_patterns)]
        self.model_config.as_ref().and_then(|v| match v {
            crate::model::rag_embedding_model_config::ModelConfig::VertexPredictionEndpoint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [model_config][crate::model::RagEmbeddingModelConfig::model_config]
    /// to hold a `VertexPredictionEndpoint`.
    ///
    /// Note that all the setters affecting `model_config` are
    /// mutually exclusive.
    pub fn set_vertex_prediction_endpoint<
        T: std::convert::Into<
            std::boxed::Box<crate::model::rag_embedding_model_config::VertexPredictionEndpoint>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_config = std::option::Option::Some(
            crate::model::rag_embedding_model_config::ModelConfig::VertexPredictionEndpoint(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for RagEmbeddingModelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagEmbeddingModelConfig"
    }
}

/// Defines additional types related to RagEmbeddingModelConfig
pub mod rag_embedding_model_config {
    #[allow(unused_imports)]
    use super::*;

    /// Config representing a model hosted on Vertex Prediction Endpoint.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexPredictionEndpoint {
        /// Required. The endpoint resource name.
        /// Format:
        /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
        /// or
        /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Output only. The resource name of the model that is deployed on the
        /// endpoint. Present only when the endpoint is not a publisher model.
        /// Pattern:
        /// `projects/{project}/locations/{location}/models/{model}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// Output only. Version ID of the model that is deployed on the endpoint.
        /// Present only when the endpoint is not a publisher model.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_version_id: std::string::String,
    }

    impl VertexPredictionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::rag_embedding_model_config::VertexPredictionEndpoint::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [model][crate::model::rag_embedding_model_config::VertexPredictionEndpoint::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_version_id][crate::model::rag_embedding_model_config::VertexPredictionEndpoint::model_version_id].
        pub fn set_model_version_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_version_id = v.into();
            self
        }
    }

    impl wkt::message::Message for VertexPredictionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagEmbeddingModelConfig.VertexPredictionEndpoint"
        }
    }

    /// The model config to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ModelConfig {
        /// The Vertex AI Prediction Endpoint that either refers to a publisher model
        /// or an endpoint that is hosting a 1P fine-tuned text embedding model.
        /// Endpoints hosting non-1P fine-tuned text embedding models are
        /// currently not supported.
        /// This is used for dense vector search.
        VertexPredictionEndpoint(
            std::boxed::Box<crate::model::rag_embedding_model_config::VertexPredictionEndpoint>,
        ),
    }
}

/// Config for the Vector DB to use for RAG.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagVectorDbConfig {
    /// Authentication config for the chosen Vector DB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub api_auth: std::option::Option<crate::model::ApiAuth>,

    /// Optional. Immutable. The embedding model config of the Vector DB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_embedding_model_config: std::option::Option<crate::model::RagEmbeddingModelConfig>,

    /// The config for the Vector DB.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vector_db: std::option::Option<crate::model::rag_vector_db_config::VectorDb>,
}

impl RagVectorDbConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_auth][crate::model::RagVectorDbConfig::api_auth].
    pub fn set_api_auth<T: std::convert::Into<std::option::Option<crate::model::ApiAuth>>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_auth = v.into();
        self
    }

    /// Sets the value of [rag_embedding_model_config][crate::model::RagVectorDbConfig::rag_embedding_model_config].
    pub fn set_rag_embedding_model_config<
        T: std::convert::Into<std::option::Option<crate::model::RagEmbeddingModelConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_embedding_model_config = v.into();
        self
    }

    /// Sets the value of `vector_db`.
    pub fn set_vector_db<
        T: std::convert::Into<std::option::Option<crate::model::rag_vector_db_config::VectorDb>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = v.into();
        self
    }

    /// The value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// if it holds a `RagManagedDb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rag_managed_db(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_vector_db_config::RagManagedDb>>
    {
        #[allow(unreachable_patterns)]
        self.vector_db.as_ref().and_then(|v| match v {
            crate::model::rag_vector_db_config::VectorDb::RagManagedDb(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// if it holds a `Pinecone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pinecone(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_vector_db_config::Pinecone>> {
        #[allow(unreachable_patterns)]
        self.vector_db.as_ref().and_then(|v| match v {
            crate::model::rag_vector_db_config::VectorDb::Pinecone(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// if it holds a `VertexVectorSearch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_vector_search(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rag_vector_db_config::VertexVectorSearch>>
    {
        #[allow(unreachable_patterns)]
        self.vector_db.as_ref().and_then(|v| match v {
            crate::model::rag_vector_db_config::VectorDb::VertexVectorSearch(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// to hold a `RagManagedDb`.
    ///
    /// Note that all the setters affecting `vector_db` are
    /// mutually exclusive.
    pub fn set_rag_managed_db<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_vector_db_config::RagManagedDb>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = std::option::Option::Some(
            crate::model::rag_vector_db_config::VectorDb::RagManagedDb(v.into()),
        );
        self
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// to hold a `Pinecone`.
    ///
    /// Note that all the setters affecting `vector_db` are
    /// mutually exclusive.
    pub fn set_pinecone<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_vector_db_config::Pinecone>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = std::option::Option::Some(
            crate::model::rag_vector_db_config::VectorDb::Pinecone(v.into()),
        );
        self
    }

    /// Sets the value of [vector_db][crate::model::RagVectorDbConfig::vector_db]
    /// to hold a `VertexVectorSearch`.
    ///
    /// Note that all the setters affecting `vector_db` are
    /// mutually exclusive.
    pub fn set_vertex_vector_search<
        T: std::convert::Into<std::boxed::Box<crate::model::rag_vector_db_config::VertexVectorSearch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_db = std::option::Option::Some(
            crate::model::rag_vector_db_config::VectorDb::VertexVectorSearch(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RagVectorDbConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig"
    }
}

/// Defines additional types related to RagVectorDbConfig
pub mod rag_vector_db_config {
    #[allow(unused_imports)]
    use super::*;

    /// The config for the default RAG-managed Vector DB.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RagManagedDb {}

    impl RagManagedDb {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for RagManagedDb {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb"
        }
    }

    /// The config for the Pinecone.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Pinecone {
        /// Pinecone index name.
        /// This value cannot be changed after it's set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub index_name: std::string::String,
    }

    impl Pinecone {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index_name][crate::model::rag_vector_db_config::Pinecone::index_name].
        pub fn set_index_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.index_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Pinecone {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.Pinecone"
        }
    }

    /// The config for the Vertex Vector Search.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexVectorSearch {
        /// The resource name of the Index Endpoint.
        /// Format:
        /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub index_endpoint: std::string::String,

        /// The resource name of the Index.
        /// Format:
        /// `projects/{project}/locations/{location}/indexes/{index}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub index: std::string::String,
    }

    impl VertexVectorSearch {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index_endpoint][crate::model::rag_vector_db_config::VertexVectorSearch::index_endpoint].
        pub fn set_index_endpoint<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.index_endpoint = v.into();
            self
        }

        /// Sets the value of [index][crate::model::rag_vector_db_config::VertexVectorSearch::index].
        pub fn set_index<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.index = v.into();
            self
        }
    }

    impl wkt::message::Message for VertexVectorSearch {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.VertexVectorSearch"
        }
    }

    /// The config for the Vector DB.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VectorDb {
        /// The config for the RAG-managed Vector DB.
        RagManagedDb(std::boxed::Box<crate::model::rag_vector_db_config::RagManagedDb>),
        /// The config for the Pinecone.
        Pinecone(std::boxed::Box<crate::model::rag_vector_db_config::Pinecone>),
        /// The config for the Vertex Vector Search.
        VertexVectorSearch(std::boxed::Box<crate::model::rag_vector_db_config::VertexVectorSearch>),
    }
}

/// RagFile status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileStatus {
    /// Output only. RagFile state.
    pub state: crate::model::file_status::State,

    /// Output only. Only when the `state` field is ERROR.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_status: std::string::String,
}

impl FileStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::FileStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::file_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_status][crate::model::FileStatus::error_status].
    pub fn set_error_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_status = v.into();
        self
    }
}

impl wkt::message::Message for FileStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.FileStatus"
    }
}

/// Defines additional types related to FileStatus
pub mod file_status {
    #[allow(unused_imports)]
    use super::*;

    /// RagFile state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// RagFile state is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// RagFile resource has been created and indexed successfully.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// RagFile resource is in a problematic state.
        /// See `error_message` field for details.
        pub const ERROR: State = State::new("ERROR");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// RagCorpus status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CorpusStatus {
    /// Output only. RagCorpus life state.
    pub state: crate::model::corpus_status::State,

    /// Output only. Only when the `state` field is ERROR.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_status: std::string::String,
}

impl CorpusStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CorpusStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::corpus_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_status][crate::model::CorpusStatus::error_status].
    pub fn set_error_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_status = v.into();
        self
    }
}

impl wkt::message::Message for CorpusStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorpusStatus"
    }
}

/// Defines additional types related to CorpusStatus
pub mod corpus_status {
    #[allow(unused_imports)]
    use super::*;

    /// RagCorpus life state.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// This state is not supposed to happen.
        pub const UNKNOWN: State = State::new("UNKNOWN");

        /// RagCorpus resource entry is initialized, but hasn't done validation.
        pub const INITIALIZED: State = State::new("INITIALIZED");

        /// RagCorpus is provisioned successfully and is ready to serve.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// RagCorpus is in a problematic situation.
        /// See `error_message` field for details.
        pub const ERROR: State = State::new("ERROR");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// A RagCorpus is a RagFile container and a project can have multiple
/// RagCorpora.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagCorpus {
    /// Output only. The resource name of the RagCorpus.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the RagCorpus.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The description of the RagCorpus.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this RagCorpus was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this RagCorpus was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. RagCorpus state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub corpus_status: std::option::Option<crate::model::CorpusStatus>,

    /// The backend config of the RagCorpus.
    /// It can be data store and/or retrieval engine.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub backend_config: std::option::Option<crate::model::rag_corpus::BackendConfig>,
}

impl RagCorpus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RagCorpus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RagCorpus::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::RagCorpus::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RagCorpus::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::RagCorpus::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [corpus_status][crate::model::RagCorpus::corpus_status].
    pub fn set_corpus_status<
        T: std::convert::Into<std::option::Option<crate::model::CorpusStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.corpus_status = v.into();
        self
    }

    /// Sets the value of `backend_config`.
    pub fn set_backend_config<
        T: std::convert::Into<std::option::Option<crate::model::rag_corpus::BackendConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_config = v.into();
        self
    }

    /// The value of [backend_config][crate::model::RagCorpus::backend_config]
    /// if it holds a `VectorDbConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vector_db_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RagVectorDbConfig>> {
        #[allow(unreachable_patterns)]
        self.backend_config.as_ref().and_then(|v| match v {
            crate::model::rag_corpus::BackendConfig::VectorDbConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backend_config][crate::model::RagCorpus::backend_config]
    /// to hold a `VectorDbConfig`.
    ///
    /// Note that all the setters affecting `backend_config` are
    /// mutually exclusive.
    pub fn set_vector_db_config<
        T: std::convert::Into<std::boxed::Box<crate::model::RagVectorDbConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_config = std::option::Option::Some(
            crate::model::rag_corpus::BackendConfig::VectorDbConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RagCorpus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagCorpus"
    }
}

/// Defines additional types related to RagCorpus
pub mod rag_corpus {
    #[allow(unused_imports)]
    use super::*;

    /// The backend config of the RagCorpus.
    /// It can be data store and/or retrieval engine.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BackendConfig {
        /// Optional. Immutable. The config for the Vector DBs.
        VectorDbConfig(std::boxed::Box<crate::model::RagVectorDbConfig>),
    }
}

/// A RagFile contains user data for chunking, embedding and indexing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFile {
    /// Output only. The resource name of the RagFile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the RagFile.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The description of the RagFile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Timestamp when this RagFile was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this RagFile was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the RagFile.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub file_status: std::option::Option<crate::model::FileStatus>,

    /// The origin location of the RagFile if it is imported from Google Cloud
    /// Storage or Google Drive.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_source: std::option::Option<crate::model::rag_file::RagFileSource>,
}

impl RagFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RagFile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RagFile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::RagFile::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RagFile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::RagFile::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [file_status][crate::model::RagFile::file_status].
    pub fn set_file_status<T: std::convert::Into<std::option::Option<crate::model::FileStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_status = v.into();
        self
    }

    /// Sets the value of `rag_file_source`.
    pub fn set_rag_file_source<
        T: std::convert::Into<std::option::Option<crate::model::rag_file::RagFileSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = v.into();
        self
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `GoogleDriveSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_google_drive_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleDriveSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::GoogleDriveSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `DirectUploadSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_direct_upload_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DirectUploadSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::DirectUploadSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `SlackSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_slack_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SlackSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::SlackSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `JiraSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_jira_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JiraSource>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::JiraSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// if it holds a `SharePointSources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_share_point_sources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SharePointSources>> {
        #[allow(unreachable_patterns)]
        self.rag_file_source.as_ref().and_then(|v| match v {
            crate::model::rag_file::RagFileSource::SharePointSources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source =
            std::option::Option::Some(crate::model::rag_file::RagFileSource::GcsSource(v.into()));
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `GoogleDriveSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_google_drive_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleDriveSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = std::option::Option::Some(
            crate::model::rag_file::RagFileSource::GoogleDriveSource(v.into()),
        );
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `DirectUploadSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_direct_upload_source<
        T: std::convert::Into<std::boxed::Box<crate::model::DirectUploadSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = std::option::Option::Some(
            crate::model::rag_file::RagFileSource::DirectUploadSource(v.into()),
        );
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `SlackSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_slack_source<T: std::convert::Into<std::boxed::Box<crate::model::SlackSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source =
            std::option::Option::Some(crate::model::rag_file::RagFileSource::SlackSource(v.into()));
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `JiraSource`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_jira_source<T: std::convert::Into<std::boxed::Box<crate::model::JiraSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source =
            std::option::Option::Some(crate::model::rag_file::RagFileSource::JiraSource(v.into()));
        self
    }

    /// Sets the value of [rag_file_source][crate::model::RagFile::rag_file_source]
    /// to hold a `SharePointSources`.
    ///
    /// Note that all the setters affecting `rag_file_source` are
    /// mutually exclusive.
    pub fn set_share_point_sources<
        T: std::convert::Into<std::boxed::Box<crate::model::SharePointSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_source = std::option::Option::Some(
            crate::model::rag_file::RagFileSource::SharePointSources(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RagFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFile"
    }
}

/// Defines additional types related to RagFile
pub mod rag_file {
    #[allow(unused_imports)]
    use super::*;

    /// The origin location of the RagFile if it is imported from Google Cloud
    /// Storage or Google Drive.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RagFileSource {
        /// Output only. Google Cloud Storage location of the RagFile.
        /// It does not support wildcards in the Cloud Storage uri for now.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// Output only. Google Drive location. Supports importing individual files
        /// as well as Google Drive folders.
        GoogleDriveSource(std::boxed::Box<crate::model::GoogleDriveSource>),
        /// Output only. The RagFile is encapsulated and uploaded in the
        /// UploadRagFile request.
        DirectUploadSource(std::boxed::Box<crate::model::DirectUploadSource>),
        /// The RagFile is imported from a Slack channel.
        SlackSource(std::boxed::Box<crate::model::SlackSource>),
        /// The RagFile is imported from a Jira query.
        JiraSource(std::boxed::Box<crate::model::JiraSource>),
        /// The RagFile is imported from a SharePoint source.
        SharePointSources(std::boxed::Box<crate::model::SharePointSources>),
    }
}

/// Specifies the size and overlap of chunks for RagFiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFileChunkingConfig {
    /// Specifies the chunking config for RagFiles.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub chunking_config:
        std::option::Option<crate::model::rag_file_chunking_config::ChunkingConfig>,
}

impl RagFileChunkingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `chunking_config`.
    pub fn set_chunking_config<
        T: std::convert::Into<
            std::option::Option<crate::model::rag_file_chunking_config::ChunkingConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunking_config = v.into();
        self
    }

    /// The value of [chunking_config][crate::model::RagFileChunkingConfig::chunking_config]
    /// if it holds a `FixedLengthChunking`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fixed_length_chunking(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::rag_file_chunking_config::FixedLengthChunking>,
    > {
        #[allow(unreachable_patterns)]
        self.chunking_config.as_ref().and_then(|v| match v {
            crate::model::rag_file_chunking_config::ChunkingConfig::FixedLengthChunking(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [chunking_config][crate::model::RagFileChunkingConfig::chunking_config]
    /// to hold a `FixedLengthChunking`.
    ///
    /// Note that all the setters affecting `chunking_config` are
    /// mutually exclusive.
    pub fn set_fixed_length_chunking<
        T: std::convert::Into<
            std::boxed::Box<crate::model::rag_file_chunking_config::FixedLengthChunking>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.chunking_config = std::option::Option::Some(
            crate::model::rag_file_chunking_config::ChunkingConfig::FixedLengthChunking(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RagFileChunkingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileChunkingConfig"
    }
}

/// Defines additional types related to RagFileChunkingConfig
pub mod rag_file_chunking_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the fixed length chunking config.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FixedLengthChunking {
        /// The size of the chunks.
        pub chunk_size: i32,

        /// The overlap between chunks.
        pub chunk_overlap: i32,
    }

    impl FixedLengthChunking {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [chunk_size][crate::model::rag_file_chunking_config::FixedLengthChunking::chunk_size].
        pub fn set_chunk_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.chunk_size = v.into();
            self
        }

        /// Sets the value of [chunk_overlap][crate::model::rag_file_chunking_config::FixedLengthChunking::chunk_overlap].
        pub fn set_chunk_overlap<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.chunk_overlap = v.into();
            self
        }
    }

    impl wkt::message::Message for FixedLengthChunking {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagFileChunkingConfig.FixedLengthChunking"
        }
    }

    /// Specifies the chunking config for RagFiles.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ChunkingConfig {
        /// Specifies the fixed length chunking config.
        FixedLengthChunking(
            std::boxed::Box<crate::model::rag_file_chunking_config::FixedLengthChunking>,
        ),
    }
}

/// Specifies the transformation config for RagFiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagFileTransformationConfig {
    /// Specifies the chunking config for RagFiles.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_chunking_config: std::option::Option<crate::model::RagFileChunkingConfig>,
}

impl RagFileTransformationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_file_chunking_config][crate::model::RagFileTransformationConfig::rag_file_chunking_config].
    pub fn set_rag_file_chunking_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileChunkingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_chunking_config = v.into();
        self
    }
}

impl wkt::message::Message for RagFileTransformationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileTransformationConfig"
    }
}

/// Config for uploading RagFile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadRagFileConfig {
    /// Specifies the transformation config for RagFiles.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_transformation_config:
        std::option::Option<crate::model::RagFileTransformationConfig>,
}

impl UploadRagFileConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_file_transformation_config][crate::model::UploadRagFileConfig::rag_file_transformation_config].
    pub fn set_rag_file_transformation_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileTransformationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_transformation_config = v.into();
        self
    }
}

impl wkt::message::Message for UploadRagFileConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileConfig"
    }
}

/// Config for importing RagFiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesConfig {
    /// Specifies the transformation config for RagFiles.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file_transformation_config:
        std::option::Option<crate::model::RagFileTransformationConfig>,

    /// Optional. The max number of queries per minute that this job is allowed to
    /// make to the embedding model specified on the corpus. This value is specific
    /// to this job and not shared across other import jobs. Consult the Quotas
    /// page on the project to set an appropriate value here.
    /// If unspecified, a default value of 1,000 QPM would be used.
    pub max_embedding_requests_per_min: i32,

    /// The source of the import.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub import_source: std::option::Option<crate::model::import_rag_files_config::ImportSource>,

    /// Optional. If provided, all partial failures are written to the sink.
    /// Deprecated. Prefer to use the `import_result_sink`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub partial_failure_sink:
        std::option::Option<crate::model::import_rag_files_config::PartialFailureSink>,
}

impl ImportRagFilesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_file_transformation_config][crate::model::ImportRagFilesConfig::rag_file_transformation_config].
    pub fn set_rag_file_transformation_config<
        T: std::convert::Into<std::option::Option<crate::model::RagFileTransformationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file_transformation_config = v.into();
        self
    }

    /// Sets the value of [max_embedding_requests_per_min][crate::model::ImportRagFilesConfig::max_embedding_requests_per_min].
    pub fn set_max_embedding_requests_per_min<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_embedding_requests_per_min = v.into();
        self
    }

    /// Sets the value of `import_source`.
    pub fn set_import_source<
        T: std::convert::Into<
            std::option::Option<crate::model::import_rag_files_config::ImportSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = v.into();
        self
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `GoogleDriveSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_google_drive_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleDriveSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::GoogleDriveSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `SlackSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_slack_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SlackSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::SlackSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `JiraSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_jira_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JiraSource>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::JiraSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// if it holds a `SharePointSources`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_share_point_sources(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SharePointSources>> {
        #[allow(unreachable_patterns)]
        self.import_source.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::ImportSource::SharePointSources(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::GcsSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `GoogleDriveSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_google_drive_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleDriveSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::GoogleDriveSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `SlackSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_slack_source<T: std::convert::Into<std::boxed::Box<crate::model::SlackSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::SlackSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `JiraSource`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_jira_source<T: std::convert::Into<std::boxed::Box<crate::model::JiraSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::JiraSource(v.into()),
        );
        self
    }

    /// Sets the value of [import_source][crate::model::ImportRagFilesConfig::import_source]
    /// to hold a `SharePointSources`.
    ///
    /// Note that all the setters affecting `import_source` are
    /// mutually exclusive.
    pub fn set_share_point_sources<
        T: std::convert::Into<std::boxed::Box<crate::model::SharePointSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_source = std::option::Option::Some(
            crate::model::import_rag_files_config::ImportSource::SharePointSources(v.into()),
        );
        self
    }

    /// Sets the value of `partial_failure_sink`.
    pub fn set_partial_failure_sink<
        T: std::convert::Into<
            std::option::Option<crate::model::import_rag_files_config::PartialFailureSink>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = v.into();
        self
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// if it holds a `PartialFailureGcsSink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_partial_failure_gcs_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureGcsSink(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// if it holds a `PartialFailureBigquerySink`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_partial_failure_bigquery_sink(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureBigquerySink(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// to hold a `PartialFailureGcsSink`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    pub fn set_partial_failure_gcs_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureGcsSink(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesConfig::partial_failure_sink]
    /// to hold a `PartialFailureBigquerySink`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    pub fn set_partial_failure_bigquery_sink<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_config::PartialFailureSink::PartialFailureBigquerySink(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ImportRagFilesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesConfig"
    }
}

/// Defines additional types related to ImportRagFilesConfig
pub mod import_rag_files_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the import.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ImportSource {
        /// Google Cloud Storage location. Supports importing individual files as
        /// well as entire Google Cloud Storage directories. Sample formats:
        ///
        /// - `gs://bucket_name/my_directory/object_name/my_file.txt`
        /// - `gs://bucket_name/my_directory`
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// Google Drive location. Supports importing individual files as
        /// well as Google Drive folders.
        GoogleDriveSource(std::boxed::Box<crate::model::GoogleDriveSource>),
        /// Slack channels with their corresponding access tokens.
        SlackSource(std::boxed::Box<crate::model::SlackSource>),
        /// Jira queries with their corresponding authentication.
        JiraSource(std::boxed::Box<crate::model::JiraSource>),
        /// SharePoint sources.
        SharePointSources(std::boxed::Box<crate::model::SharePointSources>),
    }

    /// Optional. If provided, all partial failures are written to the sink.
    /// Deprecated. Prefer to use the `import_result_sink`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PartialFailureSink {
        /// The Cloud Storage path to write partial failures to.
        /// Deprecated. Prefer to use `import_result_gcs_sink`.
        PartialFailureGcsSink(std::boxed::Box<crate::model::GcsDestination>),
        /// The BigQuery destination to write partial failures to. It should be a
        /// bigquery table resource name (e.g.
        /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
        /// table does not exist, it will be created with the expected schema. If the
        /// table exists, the schema will be validated and data will be added to this
        /// existing table.
        /// Deprecated. Prefer to use `import_result_bq_sink`.
        PartialFailureBigquerySink(std::boxed::Box<crate::model::BigQueryDestination>),
    }
}

/// Request message for
/// [VertexRagDataService.CreateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus]: crate::client::VertexRagDataService::create_rag_corpus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRagCorpusRequest {
    /// Required. The resource name of the Location to create the RagCorpus in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The RagCorpus to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_corpus: std::option::Option<crate::model::RagCorpus>,
}

impl CreateRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRagCorpusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rag_corpus][crate::model::CreateRagCorpusRequest::rag_corpus].
    pub fn set_rag_corpus<T: std::convert::Into<std::option::Option<crate::model::RagCorpus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_corpus = v.into();
        self
    }
}

impl wkt::message::Message for CreateRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRagCorpusRequest"
    }
}

/// Request message for
/// [VertexRagDataService.GetRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.GetRagCorpus]
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.GetRagCorpus]: crate::client::VertexRagDataService::get_rag_corpus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRagCorpusRequest {
    /// Required. The name of the RagCorpus resource.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRagCorpusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagCorpusRequest"
    }
}

/// Request message for
/// [VertexRagDataService.ListRagCorpora][google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]: crate::client::VertexRagDataService::list_rag_corpora
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagCorporaRequest {
    /// Required. The resource name of the Location from which to list the
    /// RagCorpora. Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListRagCorporaResponse.next_page_token][google.cloud.aiplatform.v1.ListRagCorporaResponse.next_page_token]
    /// of the previous
    /// [VertexRagDataService.ListRagCorpora][google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListRagCorporaResponse.next_page_token]: crate::model::ListRagCorporaResponse::next_page_token
    /// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]: crate::client::VertexRagDataService::list_rag_corpora
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListRagCorporaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRagCorporaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRagCorporaRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRagCorporaRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRagCorporaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagCorporaRequest"
    }
}

/// Response message for
/// [VertexRagDataService.ListRagCorpora][google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagCorpora]: crate::client::VertexRagDataService::list_rag_corpora
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagCorporaResponse {
    /// List of RagCorpora in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rag_corpora: std::vec::Vec<crate::model::RagCorpus>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListRagCorporaRequest.page_token][google.cloud.aiplatform.v1.ListRagCorporaRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListRagCorporaRequest.page_token]: crate::model::ListRagCorporaRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListRagCorporaResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRagCorporaResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [rag_corpora][crate::model::ListRagCorporaResponse::rag_corpora].
    pub fn set_rag_corpora<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RagCorpus>,
    {
        use std::iter::Iterator;
        self.rag_corpora = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRagCorporaResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagCorporaResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListRagCorporaResponse {
    type PageItem = crate::model::RagCorpus;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rag_corpora
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [VertexRagDataService.DeleteRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagCorpus]: crate::client::VertexRagDataService::delete_rag_corpus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRagCorpusRequest {
    /// Required. The name of the RagCorpus resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, any RagFiles in this RagCorpus will also be
    /// deleted. Otherwise, the request will only work if the RagCorpus has no
    /// RagFiles.
    pub force: bool,
}

impl DeleteRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRagCorpusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRagCorpusRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteRagCorpusRequest"
    }
}

/// Request message for
/// [VertexRagDataService.UploadRagFile][google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile]: crate::client::VertexRagDataService::upload_rag_file
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadRagFileRequest {
    /// Required. The name of the RagCorpus resource into which to upload the file.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The RagFile to upload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_file: std::option::Option<crate::model::RagFile>,

    /// Required. The config for the RagFiles to be uploaded into the RagCorpus.
    /// [VertexRagDataService.UploadRagFile][google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile].
    ///
    /// [google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile]: crate::client::VertexRagDataService::upload_rag_file
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upload_rag_file_config: std::option::Option<crate::model::UploadRagFileConfig>,
}

impl UploadRagFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UploadRagFileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rag_file][crate::model::UploadRagFileRequest::rag_file].
    pub fn set_rag_file<T: std::convert::Into<std::option::Option<crate::model::RagFile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_file = v.into();
        self
    }

    /// Sets the value of [upload_rag_file_config][crate::model::UploadRagFileRequest::upload_rag_file_config].
    pub fn set_upload_rag_file_config<
        T: std::convert::Into<std::option::Option<crate::model::UploadRagFileConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upload_rag_file_config = v.into();
        self
    }
}

impl wkt::message::Message for UploadRagFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileRequest"
    }
}

/// Response message for
/// [VertexRagDataService.UploadRagFile][google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UploadRagFile]: crate::client::VertexRagDataService::upload_rag_file
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadRagFileResponse {
    /// The result of the upload.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::upload_rag_file_response::Result>,
}

impl UploadRagFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `result`.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::upload_rag_file_response::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::UploadRagFileResponse::result]
    /// if it holds a `RagFile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rag_file(&self) -> std::option::Option<&std::boxed::Box<crate::model::RagFile>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::upload_rag_file_response::Result::RagFile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::UploadRagFileResponse::result]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::upload_rag_file_response::Result::Error(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::UploadRagFileResponse::result]
    /// to hold a `RagFile`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_rag_file<T: std::convert::Into<std::boxed::Box<crate::model::RagFile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::upload_rag_file_response::Result::RagFile(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::UploadRagFileResponse::result]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::upload_rag_file_response::Result::Error(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UploadRagFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileResponse"
    }
}

/// Defines additional types related to UploadRagFileResponse
pub mod upload_rag_file_response {
    #[allow(unused_imports)]
    use super::*;

    /// The result of the upload.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// The RagFile that had been uploaded into the RagCorpus.
        RagFile(std::boxed::Box<crate::model::RagFile>),
        /// The error that occurred while processing the RagFile.
        Error(std::boxed::Box<rpc::model::Status>),
    }
}

/// Request message for
/// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesRequest {
    /// Required. The name of the RagCorpus resource into which to import files.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The config for the RagFiles to be synced and imported into the
    /// RagCorpus.
    /// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
    ///
    /// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_rag_files_config: std::option::Option<crate::model::ImportRagFilesConfig>,
}

impl ImportRagFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportRagFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_rag_files_config][crate::model::ImportRagFilesRequest::import_rag_files_config].
    pub fn set_import_rag_files_config<
        T: std::convert::Into<std::option::Option<crate::model::ImportRagFilesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_rag_files_config = v.into();
        self
    }
}

impl wkt::message::Message for ImportRagFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesRequest"
    }
}

/// Response message for
/// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesResponse {
    /// The number of RagFiles that had been imported into the RagCorpus.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub imported_rag_files_count: i64,

    /// The number of RagFiles that had failed while importing into the RagCorpus.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_rag_files_count: i64,

    /// The number of RagFiles that was skipped while importing into the RagCorpus.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub skipped_rag_files_count: i64,

    /// The location into which the partial failures were written.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub partial_failure_sink:
        std::option::Option<crate::model::import_rag_files_response::PartialFailureSink>,
}

impl ImportRagFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [imported_rag_files_count][crate::model::ImportRagFilesResponse::imported_rag_files_count].
    pub fn set_imported_rag_files_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_rag_files_count = v.into();
        self
    }

    /// Sets the value of [failed_rag_files_count][crate::model::ImportRagFilesResponse::failed_rag_files_count].
    pub fn set_failed_rag_files_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_rag_files_count = v.into();
        self
    }

    /// Sets the value of [skipped_rag_files_count][crate::model::ImportRagFilesResponse::skipped_rag_files_count].
    pub fn set_skipped_rag_files_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.skipped_rag_files_count = v.into();
        self
    }

    /// Sets the value of `partial_failure_sink`.
    pub fn set_partial_failure_sink<
        T: std::convert::Into<
            std::option::Option<crate::model::import_rag_files_response::PartialFailureSink>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = v.into();
        self
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// if it holds a `PartialFailuresGcsPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_partial_failures_gcs_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresGcsPath(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// if it holds a `PartialFailuresBigqueryTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_partial_failures_bigquery_table(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.partial_failure_sink.as_ref().and_then(|v| match v {
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresBigqueryTable(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// to hold a `PartialFailuresGcsPath`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    pub fn set_partial_failures_gcs_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresGcsPath(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [partial_failure_sink][crate::model::ImportRagFilesResponse::partial_failure_sink]
    /// to hold a `PartialFailuresBigqueryTable`.
    ///
    /// Note that all the setters affecting `partial_failure_sink` are
    /// mutually exclusive.
    pub fn set_partial_failures_bigquery_table<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partial_failure_sink = std::option::Option::Some(
            crate::model::import_rag_files_response::PartialFailureSink::PartialFailuresBigqueryTable(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ImportRagFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesResponse"
    }
}

/// Defines additional types related to ImportRagFilesResponse
pub mod import_rag_files_response {
    #[allow(unused_imports)]
    use super::*;

    /// The location into which the partial failures were written.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PartialFailureSink {
        /// The Google Cloud Storage path into which the partial failures were
        /// written.
        PartialFailuresGcsPath(std::string::String),
        /// The BigQuery table into which the partial failures were written.
        PartialFailuresBigqueryTable(std::string::String),
    }
}

/// Request message for
/// [VertexRagDataService.GetRagFile][google.cloud.aiplatform.v1.VertexRagDataService.GetRagFile]
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.GetRagFile]: crate::client::VertexRagDataService::get_rag_file
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRagFileRequest {
    /// Required. The name of the RagFile resource.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetRagFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRagFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRagFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagFileRequest"
    }
}

/// Request message for
/// [VertexRagDataService.ListRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]: crate::client::VertexRagDataService::list_rag_files
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagFilesRequest {
    /// Required. The resource name of the RagCorpus from which to list the
    /// RagFiles. Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The standard list page size.
    pub page_size: i32,

    /// Optional. The standard list page token.
    /// Typically obtained via
    /// [ListRagFilesResponse.next_page_token][google.cloud.aiplatform.v1.ListRagFilesResponse.next_page_token]
    /// of the previous
    /// [VertexRagDataService.ListRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]
    /// call.
    ///
    /// [google.cloud.aiplatform.v1.ListRagFilesResponse.next_page_token]: crate::model::ListRagFilesResponse::next_page_token
    /// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]: crate::client::VertexRagDataService::list_rag_files
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListRagFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRagFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRagFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRagFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRagFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagFilesRequest"
    }
}

/// Response message for
/// [VertexRagDataService.ListRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ListRagFiles]: crate::client::VertexRagDataService::list_rag_files
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRagFilesResponse {
    /// List of RagFiles in the requested page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rag_files: std::vec::Vec<crate::model::RagFile>,

    /// A token to retrieve the next page of results.
    /// Pass to
    /// [ListRagFilesRequest.page_token][google.cloud.aiplatform.v1.ListRagFilesRequest.page_token]
    /// to obtain that page.
    ///
    /// [google.cloud.aiplatform.v1.ListRagFilesRequest.page_token]: crate::model::ListRagFilesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListRagFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRagFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [rag_files][crate::model::ListRagFilesResponse::rag_files].
    pub fn set_rag_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RagFile>,
    {
        use std::iter::Iterator;
        self.rag_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRagFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagFilesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListRagFilesResponse {
    type PageItem = crate::model::RagFile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rag_files
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [VertexRagDataService.DeleteRagFile][google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagFile].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.DeleteRagFile]: crate::client::VertexRagDataService::delete_rag_file
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRagFileRequest {
    /// Required. The name of the RagFile resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteRagFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRagFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRagFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteRagFileRequest"
    }
}

/// Runtime operation information for
/// [VertexRagDataService.CreateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.CreateRagCorpus]: crate::client::VertexRagDataService::create_rag_corpus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRagCorpusOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl CreateRagCorpusOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CreateRagCorpusOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for CreateRagCorpusOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRagCorpusOperationMetadata"
    }
}

/// Request message for
/// [VertexRagDataService.UpdateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus]: crate::client::VertexRagDataService::update_rag_corpus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRagCorpusRequest {
    /// Required. The RagCorpus which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_corpus: std::option::Option<crate::model::RagCorpus>,
}

impl UpdateRagCorpusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_corpus][crate::model::UpdateRagCorpusRequest::rag_corpus].
    pub fn set_rag_corpus<T: std::convert::Into<std::option::Option<crate::model::RagCorpus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rag_corpus = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRagCorpusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagCorpusRequest"
    }
}

/// Runtime operation information for
/// [VertexRagDataService.UpdateRagCorpus][google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.UpdateRagCorpus]: crate::client::VertexRagDataService::update_rag_corpus
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRagCorpusOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,
}

impl UpdateRagCorpusOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::UpdateRagCorpusOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRagCorpusOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagCorpusOperationMetadata"
    }
}

/// Runtime operation information for
/// [VertexRagDataService.ImportRagFiles][google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles].
///
/// [google.cloud.aiplatform.v1.VertexRagDataService.ImportRagFiles]: crate::client::VertexRagDataService::import_rag_files
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRagFilesOperationMetadata {
    /// The operation generic information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The resource ID of RagCorpus that this operation is executed on.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub rag_corpus_id: i64,

    /// Output only. The config that was passed in the ImportRagFilesRequest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_rag_files_config: std::option::Option<crate::model::ImportRagFilesConfig>,

    /// The progress percentage of the operation. Value is in the range [0, 100].
    /// This percentage is calculated as follows:
    /// progress_percentage = 100 * (successes + failures + skips) / total
    pub progress_percentage: i32,
}

impl ImportRagFilesOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::ImportRagFilesOperationMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [rag_corpus_id][crate::model::ImportRagFilesOperationMetadata::rag_corpus_id].
    pub fn set_rag_corpus_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rag_corpus_id = v.into();
        self
    }

    /// Sets the value of [import_rag_files_config][crate::model::ImportRagFilesOperationMetadata::import_rag_files_config].
    pub fn set_import_rag_files_config<
        T: std::convert::Into<std::option::Option<crate::model::ImportRagFilesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_rag_files_config = v.into();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::ImportRagFilesOperationMetadata::progress_percentage].
    pub fn set_progress_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percentage = v.into();
        self
    }
}

impl wkt::message::Message for ImportRagFilesOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesOperationMetadata"
    }
}

/// A query to retrieve relevant contexts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagQuery {
    /// Optional. The retrieval config for the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rag_retrieval_config: std::option::Option<crate::model::RagRetrievalConfig>,

    /// The query to retrieve contexts.
    /// Currently only text query is supported.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::rag_query::Query>,
}

impl RagQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rag_retrieval_config][crate::model::RagQuery::rag_retrieval_config].
    pub fn set_rag_retrieval_config<
        T: std::convert::Into<std::option::Option<crate::model::RagRetrievalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rag_retrieval_config = v.into();
        self
    }

    /// Sets the value of `query`.
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::rag_query::Query>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// The value of [query][crate::model::RagQuery::query]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::rag_query::Query::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::RagQuery::query]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(crate::model::rag_query::Query::Text(v.into()));
        self
    }
}

impl wkt::message::Message for RagQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagQuery"
    }
}

/// Defines additional types related to RagQuery
pub mod rag_query {
    #[allow(unused_imports)]
    use super::*;

    /// The query to retrieve contexts.
    /// Currently only text query is supported.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Query {
        /// Optional. The query in text format to get relevant contexts.
        Text(std::string::String),
    }
}

/// Request message for
/// [VertexRagService.RetrieveContexts][google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts].
///
/// [google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts]: crate::client::VertexRagService::retrieve_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveContextsRequest {
    /// Required. The resource name of the Location from which to retrieve
    /// RagContexts. The users must have permission to make a call in the project.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Single RAG retrieve query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::RagQuery>,

    /// Data Source to retrieve contexts.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::retrieve_contexts_request::DataSource>,
}

impl RetrieveContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RetrieveContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::RetrieveContextsRequest::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::RagQuery>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of `data_source`.
    pub fn set_data_source<
        T: std::convert::Into<
            std::option::Option<crate::model::retrieve_contexts_request::DataSource>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::RetrieveContextsRequest::data_source]
    /// if it holds a `VertexRagStore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_rag_store(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::retrieve_contexts_request::VertexRagStore>,
    > {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::retrieve_contexts_request::DataSource::VertexRagStore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::RetrieveContextsRequest::data_source]
    /// to hold a `VertexRagStore`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_store<
        T: std::convert::Into<
            std::boxed::Box<crate::model::retrieve_contexts_request::VertexRagStore>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::retrieve_contexts_request::DataSource::VertexRagStore(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RetrieveContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest"
    }
}

/// Defines additional types related to RetrieveContextsRequest
pub mod retrieve_contexts_request {
    #[allow(unused_imports)]
    use super::*;

    /// The data source for Vertex RagStore.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VertexRagStore {
        /// Optional. The representation of the rag source. It can be used to specify
        /// corpus only or ragfiles. Currently only support one corpus or multiple
        /// files from one corpus. In the future we may open up multiple corpora
        /// support.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rag_resources:
            std::vec::Vec<crate::model::retrieve_contexts_request::vertex_rag_store::RagResource>,

        /// Optional. Only return contexts with vector distance smaller than the
        /// threshold.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub vector_distance_threshold: std::option::Option<f64>,
    }

    impl VertexRagStore {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [vector_distance_threshold][crate::model::retrieve_contexts_request::VertexRagStore::vector_distance_threshold].
        pub fn set_vector_distance_threshold<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.vector_distance_threshold = v.into();
            self
        }

        /// Sets the value of [rag_resources][crate::model::retrieve_contexts_request::VertexRagStore::rag_resources].
        pub fn set_rag_resources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::retrieve_contexts_request::vertex_rag_store::RagResource,
            >,
        {
            use std::iter::Iterator;
            self.rag_resources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for VertexRagStore {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore"
        }
    }

    /// Defines additional types related to VertexRagStore
    pub mod vertex_rag_store {
        #[allow(unused_imports)]
        use super::*;

        /// The definition of the Rag resource.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RagResource {
            /// Optional. RagCorpora resource name.
            /// Format:
            /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub rag_corpus: std::string::String,

            /// Optional. rag_file_id. The files should be in the same rag_corpus set
            /// in rag_corpus field.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub rag_file_ids: std::vec::Vec<std::string::String>,
        }

        impl RagResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [rag_corpus][crate::model::retrieve_contexts_request::vertex_rag_store::RagResource::rag_corpus].
            pub fn set_rag_corpus<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.rag_corpus = v.into();
                self
            }

            /// Sets the value of [rag_file_ids][crate::model::retrieve_contexts_request::vertex_rag_store::RagResource::rag_file_ids].
            pub fn set_rag_file_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.rag_file_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for RagResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore.RagResource"
            }
        }
    }

    /// Data Source to retrieve contexts.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSource {
        /// The data source for Vertex RagStore.
        VertexRagStore(std::boxed::Box<crate::model::retrieve_contexts_request::VertexRagStore>),
    }
}

/// Relevant contexts for one query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RagContexts {
    /// All its contexts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contexts: std::vec::Vec<crate::model::rag_contexts::Context>,
}

impl RagContexts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contexts][crate::model::RagContexts::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rag_contexts::Context>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RagContexts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagContexts"
    }
}

/// Defines additional types related to RagContexts
pub mod rag_contexts {
    #[allow(unused_imports)]
    use super::*;

    /// A context of the query.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Context {
        /// If the file is imported from Cloud Storage or Google Drive, source_uri
        /// will be original file URI in Cloud Storage or Google Drive; if file is
        /// uploaded, source_uri will be file display name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_uri: std::string::String,

        /// The file display name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_display_name: std::string::String,

        /// The text chunk.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,

        /// According to the underlying Vector DB and the selected metric type, the
        /// score can be either the distance or the similarity between the query and
        /// the context and its range depends on the metric type.
        ///
        /// For example, if the metric type is COSINE_DISTANCE, it represents the
        /// distance between the query and the context. The larger the distance, the
        /// less relevant the context is to the query. The range is [0, 2], while 0
        /// means the most relevant and 2 means the least relevant.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub score: std::option::Option<f64>,
    }

    impl Context {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_uri][crate::model::rag_contexts::Context::source_uri].
        pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source_uri = v.into();
            self
        }

        /// Sets the value of [source_display_name][crate::model::rag_contexts::Context::source_display_name].
        pub fn set_source_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_display_name = v.into();
            self
        }

        /// Sets the value of [text][crate::model::rag_contexts::Context::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [score][crate::model::rag_contexts::Context::score].
        pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }
    }

    impl wkt::message::Message for Context {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagContexts.Context"
        }
    }
}

/// Response message for
/// [VertexRagService.RetrieveContexts][google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts].
///
/// [google.cloud.aiplatform.v1.VertexRagService.RetrieveContexts]: crate::client::VertexRagService::retrieve_contexts
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveContextsResponse {
    /// The contexts of the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub contexts: std::option::Option<crate::model::RagContexts>,
}

impl RetrieveContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contexts][crate::model::RetrieveContextsResponse::contexts].
    pub fn set_contexts<T: std::convert::Into<std::option::Option<crate::model::RagContexts>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contexts = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsResponse"
    }
}

/// Request message for AugmentPrompt.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AugmentPromptRequest {
    /// Required. The resource name of the Location from which to augment prompt.
    /// The users must have permission to make a call in the project.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Input content to augment, only text format is supported for now.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::Content>,

    /// Optional. Metadata of the backend deployed model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::augment_prompt_request::Model>,

    /// The data source for retrieving contexts.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::augment_prompt_request::DataSource>,
}

impl AugmentPromptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AugmentPromptRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::AugmentPromptRequest::model].
    pub fn set_model<
        T: std::convert::Into<std::option::Option<crate::model::augment_prompt_request::Model>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::AugmentPromptRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `data_source`.
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::augment_prompt_request::DataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// The value of [data_source][crate::model::AugmentPromptRequest::data_source]
    /// if it holds a `VertexRagStore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vertex_rag_store(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VertexRagStore>> {
        #[allow(unreachable_patterns)]
        self.data_source.as_ref().and_then(|v| match v {
            crate::model::augment_prompt_request::DataSource::VertexRagStore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_source][crate::model::AugmentPromptRequest::data_source]
    /// to hold a `VertexRagStore`.
    ///
    /// Note that all the setters affecting `data_source` are
    /// mutually exclusive.
    pub fn set_vertex_rag_store<
        T: std::convert::Into<std::boxed::Box<crate::model::VertexRagStore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = std::option::Option::Some(
            crate::model::augment_prompt_request::DataSource::VertexRagStore(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AugmentPromptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptRequest"
    }
}

/// Defines additional types related to AugmentPromptRequest
pub mod augment_prompt_request {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata of the backend deployed model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Model {
        /// Optional. The model that the user will send the augmented prompt for
        /// content generation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model: std::string::String,

        /// Optional. The model version of the backend deployed model.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_version: std::string::String,
    }

    impl Model {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::augment_prompt_request::Model::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [model_version][crate::model::augment_prompt_request::Model::model_version].
        pub fn set_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_version = v.into();
            self
        }
    }

    impl wkt::message::Message for Model {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptRequest.Model"
        }
    }

    /// The data source for retrieving contexts.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataSource {
        /// Optional. Retrieves contexts from the Vertex RagStore.
        VertexRagStore(std::boxed::Box<crate::model::VertexRagStore>),
    }
}

/// Response message for AugmentPrompt.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AugmentPromptResponse {
    /// Augmented prompt, only text format is supported for now.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub augmented_prompt: std::vec::Vec<crate::model::Content>,

    /// Retrieved facts from RAG data sources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facts: std::vec::Vec<crate::model::Fact>,
}

impl AugmentPromptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [augmented_prompt][crate::model::AugmentPromptResponse::augmented_prompt].
    pub fn set_augmented_prompt<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.augmented_prompt = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [facts][crate::model::AugmentPromptResponse::facts].
    pub fn set_facts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Fact>,
    {
        use std::iter::Iterator;
        self.facts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AugmentPromptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptResponse"
    }
}

/// Request message for CorroborateContent.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CorroborateContentRequest {
    /// Required. The resource name of the Location from which to corroborate text.
    /// The users must have permission to make a call in the project.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Input content to corroborate, only text format is supported for
    /// now.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::Content>,

    /// Optional. Facts used to generate the text can also be used to corroborate
    /// the text.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facts: std::vec::Vec<crate::model::Fact>,

    /// Optional. Parameters that can be set to override default settings per
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameters: std::option::Option<crate::model::corroborate_content_request::Parameters>,
}

impl CorroborateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CorroborateContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [content][crate::model::CorroborateContentRequest::content].
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::CorroborateContentRequest::parameters].
    pub fn set_parameters<
        T: std::convert::Into<
            std::option::Option<crate::model::corroborate_content_request::Parameters>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameters = v.into();
        self
    }

    /// Sets the value of [facts][crate::model::CorroborateContentRequest::facts].
    pub fn set_facts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Fact>,
    {
        use std::iter::Iterator;
        self.facts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CorroborateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentRequest"
    }
}

/// Defines additional types related to CorroborateContentRequest
pub mod corroborate_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters that can be overrided per request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Parameters {
        /// Optional. Only return claims with citation score larger than the
        /// threshold.
        pub citation_threshold: f64,
    }

    impl Parameters {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [citation_threshold][crate::model::corroborate_content_request::Parameters::citation_threshold].
        pub fn set_citation_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.citation_threshold = v.into();
            self
        }
    }

    impl wkt::message::Message for Parameters {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentRequest.Parameters"
        }
    }
}

/// Response message for CorroborateContent.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CorroborateContentResponse {
    /// Confidence score of corroborating content. Value is [0,1] with 1 is the
    /// most confidence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub corroboration_score: std::option::Option<f32>,

    /// Claims that are extracted from the input content and facts that support the
    /// claims.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub claims: std::vec::Vec<crate::model::Claim>,
}

impl CorroborateContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [corroboration_score][crate::model::CorroborateContentResponse::corroboration_score].
    pub fn set_corroboration_score<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.corroboration_score = v.into();
        self
    }

    /// Sets the value of [claims][crate::model::CorroborateContentResponse::claims].
    pub fn set_claims<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Claim>,
    {
        use std::iter::Iterator;
        self.claims = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CorroborateContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentResponse"
    }
}

/// The fact used in grounding.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Fact {
    /// Query that is used to retrieve this fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<std::string::String>,

    /// If present, it refers to the title of this fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub title: std::option::Option<std::string::String>,

    /// If present, this uri links to the source of the fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub uri: std::option::Option<std::string::String>,

    /// If present, the summary/snippet of the fact.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summary: std::option::Option<std::string::String>,

    /// If present, the distance between the query vector and this fact vector.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vector_distance: std::option::Option<f64>,

    /// If present, according to the underlying Vector DB and the selected metric
    /// type, the score can be either the distance or the similarity between the
    /// query and the fact and its range depends on the metric type.
    ///
    /// For example, if the metric type is COSINE_DISTANCE, it represents the
    /// distance between the query and the fact. The larger the distance, the less
    /// relevant the fact is to the query. The range is [0, 2], while 0 means the
    /// most relevant and 2 means the least relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f64>,
}

impl Fact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::Fact::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Fact::title].
    pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Fact::uri].
    pub fn set_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [summary][crate::model::Fact::summary].
    pub fn set_summary<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.summary = v.into();
        self
    }

    /// Sets the value of [vector_distance][crate::model::Fact::vector_distance].
    pub fn set_vector_distance<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vector_distance = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Fact::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for Fact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Fact"
    }
}

/// Claim that is extracted from the input text and facts that support it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Claim {
    /// Index in the input text where the claim starts (inclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_index: std::option::Option<i32>,

    /// Index in the input text where the claim ends (exclusive).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_index: std::option::Option<i32>,

    /// Indexes of the facts supporting this claim.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fact_indexes: std::vec::Vec<i32>,

    /// Confidence score of this corroboration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub score: std::option::Option<f32>,
}

impl Claim {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_index][crate::model::Claim::start_index].
    pub fn set_start_index<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_index = v.into();
        self
    }

    /// Sets the value of [end_index][crate::model::Claim::end_index].
    pub fn set_end_index<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.end_index = v.into();
        self
    }

    /// Sets the value of [score][crate::model::Claim::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [fact_indexes][crate::model::Claim::fact_indexes].
    pub fn set_fact_indexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.fact_indexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Claim {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.Claim"
    }
}

/// Request message for
/// [VizierService.GetStudy][google.cloud.aiplatform.v1.VizierService.GetStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.GetStudy]: crate::client::VizierService::get_study
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStudyRequest {
    /// Required. The name of the Study resource.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStudyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetStudyRequest"
    }
}

/// Request message for
/// [VizierService.CreateStudy][google.cloud.aiplatform.v1.VizierService.CreateStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.CreateStudy]: crate::client::VizierService::create_study
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStudyRequest {
    /// Required. The resource name of the Location to create the CustomJob in.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Study configuration used to create the Study.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub study: std::option::Option<crate::model::Study>,
}

impl CreateStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStudyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [study][crate::model::CreateStudyRequest::study].
    pub fn set_study<T: std::convert::Into<std::option::Option<crate::model::Study>>>(
        mut self,
        v: T,
    ) -> Self {
        self.study = v.into();
        self
    }
}

impl wkt::message::Message for CreateStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateStudyRequest"
    }
}

/// Request message for
/// [VizierService.ListStudies][google.cloud.aiplatform.v1.VizierService.ListStudies].
///
/// [google.cloud.aiplatform.v1.VizierService.ListStudies]: crate::client::VizierService::list_studies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStudiesRequest {
    /// Required. The resource name of the Location to list the Study from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. A page token to request the next page of results.
    /// If unspecified, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of studies to return per "page" of results.
    /// If unspecified, service will pick an appropriate default.
    pub page_size: i32,
}

impl ListStudiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStudiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStudiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStudiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListStudiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListStudiesRequest"
    }
}

/// Response message for
/// [VizierService.ListStudies][google.cloud.aiplatform.v1.VizierService.ListStudies].
///
/// [google.cloud.aiplatform.v1.VizierService.ListStudies]: crate::client::VizierService::list_studies
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStudiesResponse {
    /// The studies associated with the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub studies: std::vec::Vec<crate::model::Study>,

    /// Passes this token as the `page_token` field of the request for a
    /// subsequent call.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListStudiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListStudiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [studies][crate::model::ListStudiesResponse::studies].
    pub fn set_studies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Study>,
    {
        use std::iter::Iterator;
        self.studies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListStudiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListStudiesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListStudiesResponse {
    type PageItem = crate::model::Study;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.studies
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [VizierService.DeleteStudy][google.cloud.aiplatform.v1.VizierService.DeleteStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.DeleteStudy]: crate::client::VizierService::delete_study
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteStudyRequest {
    /// Required. The name of the Study resource to be deleted.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStudyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteStudyRequest"
    }
}

/// Request message for
/// [VizierService.LookupStudy][google.cloud.aiplatform.v1.VizierService.LookupStudy].
///
/// [google.cloud.aiplatform.v1.VizierService.LookupStudy]: crate::client::VizierService::lookup_study
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LookupStudyRequest {
    /// Required. The resource name of the Location to get the Study from.
    /// Format: `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-defined display name of the Study
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl LookupStudyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupStudyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::LookupStudyRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for LookupStudyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.LookupStudyRequest"
    }
}

/// Request message for
/// [VizierService.SuggestTrials][google.cloud.aiplatform.v1.VizierService.SuggestTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.SuggestTrials]: crate::client::VizierService::suggest_trials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestTrialsRequest {
    /// Required. The project and location that the Study belongs to.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The number of suggestions requested. It must be positive.
    pub suggestion_count: i32,

    /// Required. The identifier of the client that is requesting the suggestion.
    ///
    /// If multiple SuggestTrialsRequests have the same `client_id`,
    /// the service will return the identical suggested Trial if the Trial is
    /// pending, and provide a new Trial if the last suggested Trial was completed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,

    /// Optional. This allows you to specify the "context" for a Trial; a context
    /// is a slice (a subspace) of the search space.
    ///
    /// Typical uses for contexts:
    ///
    /// ) You are using Vizier to tune a server for best performance, but there's
    ///   a strong weekly cycle.  The context specifies the day-of-week.
    ///   This allows Tuesday to generalize from Wednesday without assuming that
    ///   everything is identical.
    /// ) Imagine you're optimizing some medical treatment for people.
    ///   As they walk in the door, you know certain facts about them
    ///   (e.g. sex, weight, height, blood-pressure).  Put that information in the
    ///   context, and Vizier will adapt its suggestions to the patient.
    /// ) You want to do a fair A/B test efficiently.  Specify the "A" and "B"
    ///   conditions as contexts, and Vizier will generalize between "A" and "B"
    ///   conditions.  If they are similar, this will allow Vizier to converge
    ///   to the optimum faster than if "A" and "B" were separate Studies.
    ///   NOTE: You can also enter contexts as REQUESTED Trials, e.g. via the
    ///   CreateTrial() RPC; that's the asynchronous option where you don't need a
    ///   close association between contexts and suggestions.
    ///
    /// NOTE: All the Parameters you set in a context MUST be defined in the
    /// Study.
    /// NOTE: You must supply 0 or $suggestion_count contexts.
    /// If you don't supply any contexts, Vizier will make suggestions
    /// from the full search space specified in the StudySpec; if you supply
    /// a full set of context, each suggestion will match the corresponding
    /// context.
    /// NOTE: A Context with no features set matches anything, and allows
    /// suggestions from the full search space.
    /// NOTE: Contexts MUST lie within the search space specified in the
    /// StudySpec.  It's an error if they don't.
    /// NOTE: Contexts preferentially match ACTIVE then REQUESTED trials before
    /// new suggestions are generated.
    /// NOTE: Generation of suggestions involves a match between a Context and
    /// (optionally) a REQUESTED trial; if that match is not fully specified, a
    /// suggestion will be geneated in the merged subspace.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contexts: std::vec::Vec<crate::model::TrialContext>,
}

impl SuggestTrialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SuggestTrialsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [suggestion_count][crate::model::SuggestTrialsRequest::suggestion_count].
    pub fn set_suggestion_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.suggestion_count = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::SuggestTrialsRequest::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [contexts][crate::model::SuggestTrialsRequest::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrialContext>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SuggestTrialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsRequest"
    }
}

/// Response message for
/// [VizierService.SuggestTrials][google.cloud.aiplatform.v1.VizierService.SuggestTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.SuggestTrials]: crate::client::VizierService::suggest_trials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestTrialsResponse {
    /// A list of Trials.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trials: std::vec::Vec<crate::model::Trial>,

    /// The state of the Study.
    pub study_state: crate::model::study::State,

    /// The time at which the operation was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time at which operation processing completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl SuggestTrialsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [study_state][crate::model::SuggestTrialsResponse::study_state].
    pub fn set_study_state<T: std::convert::Into<crate::model::study::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.study_state = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::SuggestTrialsResponse::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::SuggestTrialsResponse::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [trials][crate::model::SuggestTrialsResponse::trials].
    pub fn set_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SuggestTrialsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsResponse"
    }
}

/// Details of operations that perform Trials suggestion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestTrialsMetadata {
    /// Operation metadata for suggesting Trials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The identifier of the client that is requesting the suggestion.
    ///
    /// If multiple SuggestTrialsRequests have the same `client_id`,
    /// the service will return the identical suggested Trial if the Trial is
    /// pending, and provide a new Trial if the last suggested Trial was completed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,
}

impl SuggestTrialsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::SuggestTrialsMetadata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::SuggestTrialsMetadata::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }
}

impl wkt::message::Message for SuggestTrialsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsMetadata"
    }
}

/// Request message for
/// [VizierService.CreateTrial][google.cloud.aiplatform.v1.VizierService.CreateTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.CreateTrial]: crate::client::VizierService::create_trial
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTrialRequest {
    /// Required. The resource name of the Study to create the Trial in.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Trial to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trial: std::option::Option<crate::model::Trial>,
}

impl CreateTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTrialRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [trial][crate::model::CreateTrialRequest::trial].
    pub fn set_trial<T: std::convert::Into<std::option::Option<crate::model::Trial>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trial = v.into();
        self
    }
}

impl wkt::message::Message for CreateTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTrialRequest"
    }
}

/// Request message for
/// [VizierService.GetTrial][google.cloud.aiplatform.v1.VizierService.GetTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.GetTrial]: crate::client::VizierService::get_trial
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTrialRequest {
    /// Required. The name of the Trial resource.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTrialRequest"
    }
}

/// Request message for
/// [VizierService.ListTrials][google.cloud.aiplatform.v1.VizierService.ListTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListTrials]: crate::client::VizierService::list_trials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrialsRequest {
    /// Required. The resource name of the Study to list the Trial from.
    /// Format: `projects/{project}/locations/{location}/studies/{study}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. A page token to request the next page of results.
    /// If unspecified, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The number of Trials to retrieve per "page" of results.
    /// If unspecified, the service will pick an appropriate default.
    pub page_size: i32,
}

impl ListTrialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTrialsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTrialsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTrialsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListTrialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrialsRequest"
    }
}

/// Response message for
/// [VizierService.ListTrials][google.cloud.aiplatform.v1.VizierService.ListTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListTrials]: crate::client::VizierService::list_trials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTrialsResponse {
    /// The Trials associated with the Study.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trials: std::vec::Vec<crate::model::Trial>,

    /// Pass this token as the `page_token` field of the request for a
    /// subsequent call.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTrialsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTrialsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [trials][crate::model::ListTrialsResponse::trials].
    pub fn set_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTrialsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrialsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTrialsResponse {
    type PageItem = crate::model::Trial;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.trials
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [VizierService.AddTrialMeasurement][google.cloud.aiplatform.v1.VizierService.AddTrialMeasurement].
///
/// [google.cloud.aiplatform.v1.VizierService.AddTrialMeasurement]: crate::client::VizierService::add_trial_measurement
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddTrialMeasurementRequest {
    /// Required. The name of the trial to add measurement.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trial_name: std::string::String,

    /// Required. The measurement to be added to a Trial.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub measurement: std::option::Option<crate::model::Measurement>,
}

impl AddTrialMeasurementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trial_name][crate::model::AddTrialMeasurementRequest::trial_name].
    pub fn set_trial_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trial_name = v.into();
        self
    }

    /// Sets the value of [measurement][crate::model::AddTrialMeasurementRequest::measurement].
    pub fn set_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.measurement = v.into();
        self
    }
}

impl wkt::message::Message for AddTrialMeasurementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddTrialMeasurementRequest"
    }
}

/// Request message for
/// [VizierService.CompleteTrial][google.cloud.aiplatform.v1.VizierService.CompleteTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.CompleteTrial]: crate::client::VizierService::complete_trial
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompleteTrialRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If provided, it will be used as the completed Trial's
    /// final_measurement; Otherwise, the service will auto-select a
    /// previously reported measurement as the final-measurement
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub final_measurement: std::option::Option<crate::model::Measurement>,

    /// Optional. True if the Trial cannot be run with the given Parameter, and
    /// final_measurement will be ignored.
    pub trial_infeasible: bool,

    /// Optional. A human readable reason why the trial was infeasible. This should
    /// only be provided if `trial_infeasible` is true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub infeasible_reason: std::string::String,
}

impl CompleteTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompleteTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [final_measurement][crate::model::CompleteTrialRequest::final_measurement].
    pub fn set_final_measurement<
        T: std::convert::Into<std::option::Option<crate::model::Measurement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.final_measurement = v.into();
        self
    }

    /// Sets the value of [trial_infeasible][crate::model::CompleteTrialRequest::trial_infeasible].
    pub fn set_trial_infeasible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.trial_infeasible = v.into();
        self
    }

    /// Sets the value of [infeasible_reason][crate::model::CompleteTrialRequest::infeasible_reason].
    pub fn set_infeasible_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.infeasible_reason = v.into();
        self
    }
}

impl wkt::message::Message for CompleteTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CompleteTrialRequest"
    }
}

/// Request message for
/// [VizierService.DeleteTrial][google.cloud.aiplatform.v1.VizierService.DeleteTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.DeleteTrial]: crate::client::VizierService::delete_trial
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTrialRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTrialRequest"
    }
}

/// Request message for
/// [VizierService.CheckTrialEarlyStoppingState][google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState].
///
/// [google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState]: crate::client::VizierService::check_trial_early_stopping_state
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckTrialEarlyStoppingStateRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trial_name: std::string::String,
}

impl CheckTrialEarlyStoppingStateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [trial_name][crate::model::CheckTrialEarlyStoppingStateRequest::trial_name].
    pub fn set_trial_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trial_name = v.into();
        self
    }
}

impl wkt::message::Message for CheckTrialEarlyStoppingStateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateRequest"
    }
}

/// Response message for
/// [VizierService.CheckTrialEarlyStoppingState][google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState].
///
/// [google.cloud.aiplatform.v1.VizierService.CheckTrialEarlyStoppingState]: crate::client::VizierService::check_trial_early_stopping_state
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckTrialEarlyStoppingStateResponse {
    /// True if the Trial should stop.
    pub should_stop: bool,
}

impl CheckTrialEarlyStoppingStateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [should_stop][crate::model::CheckTrialEarlyStoppingStateResponse::should_stop].
    pub fn set_should_stop<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.should_stop = v.into();
        self
    }
}

impl wkt::message::Message for CheckTrialEarlyStoppingStateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateResponse"
    }
}

/// This message will be placed in the metadata field of a
/// google.longrunning.Operation associated with a CheckTrialEarlyStoppingState
/// request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckTrialEarlyStoppingStateMetatdata {
    /// Operation metadata for suggesting Trials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generic_metadata: std::option::Option<crate::model::GenericOperationMetadata>,

    /// The name of the Study that the Trial belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub study: std::string::String,

    /// The Trial name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trial: std::string::String,
}

impl CheckTrialEarlyStoppingStateMetatdata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generic_metadata][crate::model::CheckTrialEarlyStoppingStateMetatdata::generic_metadata].
    pub fn set_generic_metadata<
        T: std::convert::Into<std::option::Option<crate::model::GenericOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generic_metadata = v.into();
        self
    }

    /// Sets the value of [study][crate::model::CheckTrialEarlyStoppingStateMetatdata::study].
    pub fn set_study<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.study = v.into();
        self
    }

    /// Sets the value of [trial][crate::model::CheckTrialEarlyStoppingStateMetatdata::trial].
    pub fn set_trial<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trial = v.into();
        self
    }
}

impl wkt::message::Message for CheckTrialEarlyStoppingStateMetatdata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateMetatdata"
    }
}

/// Request message for
/// [VizierService.StopTrial][google.cloud.aiplatform.v1.VizierService.StopTrial].
///
/// [google.cloud.aiplatform.v1.VizierService.StopTrial]: crate::client::VizierService::stop_trial
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopTrialRequest {
    /// Required. The Trial's name.
    /// Format:
    /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StopTrialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopTrialRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopTrialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopTrialRequest"
    }
}

/// Request message for
/// [VizierService.ListOptimalTrials][google.cloud.aiplatform.v1.VizierService.ListOptimalTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListOptimalTrials]: crate::client::VizierService::list_optimal_trials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOptimalTrialsRequest {
    /// Required. The name of the Study that the optimal Trial belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,
}

impl ListOptimalTrialsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOptimalTrialsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListOptimalTrialsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListOptimalTrialsRequest"
    }
}

/// Response message for
/// [VizierService.ListOptimalTrials][google.cloud.aiplatform.v1.VizierService.ListOptimalTrials].
///
/// [google.cloud.aiplatform.v1.VizierService.ListOptimalTrials]: crate::client::VizierService::list_optimal_trials
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOptimalTrialsResponse {
    /// The pareto-optimal Trials for multiple objective Study or the
    /// optimal trial for single objective Study. The definition of
    /// pareto-optimal can be checked in wiki page.
    /// <https://en.wikipedia.org/wiki/Pareto_efficiency>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub optimal_trials: std::vec::Vec<crate::model::Trial>,
}

impl ListOptimalTrialsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [optimal_trials][crate::model::ListOptimalTrialsResponse::optimal_trials].
    pub fn set_optimal_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trial>,
    {
        use std::iter::Iterator;
        self.optimal_trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOptimalTrialsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListOptimalTrialsResponse"
    }
}

/// Represents a hardware accelerator type.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct AcceleratorType(std::borrow::Cow<'static, str>);

impl AcceleratorType {
    /// Creates a new AcceleratorType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [AcceleratorType](AcceleratorType)
pub mod accelerator_type {
    use super::AcceleratorType;

    /// Unspecified accelerator type, which means no accelerator.
    pub const ACCELERATOR_TYPE_UNSPECIFIED: AcceleratorType =
        AcceleratorType::new("ACCELERATOR_TYPE_UNSPECIFIED");

    /// Deprecated: Nvidia Tesla K80 GPU has reached end of support,
    /// see <https://cloud.google.com/compute/docs/eol/k80-eol>.
    pub const NVIDIA_TESLA_K80: AcceleratorType = AcceleratorType::new("NVIDIA_TESLA_K80");

    /// Nvidia Tesla P100 GPU.
    pub const NVIDIA_TESLA_P100: AcceleratorType = AcceleratorType::new("NVIDIA_TESLA_P100");

    /// Nvidia Tesla V100 GPU.
    pub const NVIDIA_TESLA_V100: AcceleratorType = AcceleratorType::new("NVIDIA_TESLA_V100");

    /// Nvidia Tesla P4 GPU.
    pub const NVIDIA_TESLA_P4: AcceleratorType = AcceleratorType::new("NVIDIA_TESLA_P4");

    /// Nvidia Tesla T4 GPU.
    pub const NVIDIA_TESLA_T4: AcceleratorType = AcceleratorType::new("NVIDIA_TESLA_T4");

    /// Nvidia Tesla A100 GPU.
    pub const NVIDIA_TESLA_A100: AcceleratorType = AcceleratorType::new("NVIDIA_TESLA_A100");

    /// Nvidia A100 80GB GPU.
    pub const NVIDIA_A100_80GB: AcceleratorType = AcceleratorType::new("NVIDIA_A100_80GB");

    /// Nvidia L4 GPU.
    pub const NVIDIA_L4: AcceleratorType = AcceleratorType::new("NVIDIA_L4");

    /// Nvidia H100 80Gb GPU.
    pub const NVIDIA_H100_80GB: AcceleratorType = AcceleratorType::new("NVIDIA_H100_80GB");

    /// Nvidia H100 Mega 80Gb GPU.
    pub const NVIDIA_H100_MEGA_80GB: AcceleratorType =
        AcceleratorType::new("NVIDIA_H100_MEGA_80GB");

    /// TPU v2.
    pub const TPU_V2: AcceleratorType = AcceleratorType::new("TPU_V2");

    /// TPU v3.
    pub const TPU_V3: AcceleratorType = AcceleratorType::new("TPU_V3");

    /// TPU v4.
    pub const TPU_V4_POD: AcceleratorType = AcceleratorType::new("TPU_V4_POD");

    /// TPU v5.
    pub const TPU_V5_LITEPOD: AcceleratorType = AcceleratorType::new("TPU_V5_LITEPOD");
}

impl std::convert::From<std::string::String> for AcceleratorType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Harm categories that will block the content.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct HarmCategory(std::borrow::Cow<'static, str>);

impl HarmCategory {
    /// Creates a new HarmCategory instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [HarmCategory](HarmCategory)
pub mod harm_category {
    use super::HarmCategory;

    /// The harm category is unspecified.
    pub const HARM_CATEGORY_UNSPECIFIED: HarmCategory =
        HarmCategory::new("HARM_CATEGORY_UNSPECIFIED");

    /// The harm category is hate speech.
    pub const HARM_CATEGORY_HATE_SPEECH: HarmCategory =
        HarmCategory::new("HARM_CATEGORY_HATE_SPEECH");

    /// The harm category is dangerous content.
    pub const HARM_CATEGORY_DANGEROUS_CONTENT: HarmCategory =
        HarmCategory::new("HARM_CATEGORY_DANGEROUS_CONTENT");

    /// The harm category is harassment.
    pub const HARM_CATEGORY_HARASSMENT: HarmCategory =
        HarmCategory::new("HARM_CATEGORY_HARASSMENT");

    /// The harm category is sexually explicit content.
    pub const HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmCategory =
        HarmCategory::new("HARM_CATEGORY_SEXUALLY_EXPLICIT");

    /// The harm category is civic integrity.
    pub const HARM_CATEGORY_CIVIC_INTEGRITY: HarmCategory =
        HarmCategory::new("HARM_CATEGORY_CIVIC_INTEGRITY");
}

impl std::convert::From<std::string::String> for HarmCategory {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Content Part modality
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Modality(std::borrow::Cow<'static, str>);

impl Modality {
    /// Creates a new Modality instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [Modality](Modality)
pub mod modality {
    use super::Modality;

    /// Unspecified modality.
    pub const MODALITY_UNSPECIFIED: Modality = Modality::new("MODALITY_UNSPECIFIED");

    /// Plain text.
    pub const TEXT: Modality = Modality::new("TEXT");

    /// Image.
    pub const IMAGE: Modality = Modality::new("IMAGE");

    /// Video.
    pub const VIDEO: Modality = Modality::new("VIDEO");

    /// Audio.
    pub const AUDIO: Modality = Modality::new("AUDIO");

    /// Document, e.g. PDF.
    pub const DOCUMENT: Modality = Modality::new("DOCUMENT");
}

impl std::convert::From<std::string::String> for Modality {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Pairwise prediction autorater preference.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PairwiseChoice(std::borrow::Cow<'static, str>);

impl PairwiseChoice {
    /// Creates a new PairwiseChoice instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [PairwiseChoice](PairwiseChoice)
pub mod pairwise_choice {
    use super::PairwiseChoice;

    /// Unspecified prediction choice.
    pub const PAIRWISE_CHOICE_UNSPECIFIED: PairwiseChoice =
        PairwiseChoice::new("PAIRWISE_CHOICE_UNSPECIFIED");

    /// Baseline prediction wins
    pub const BASELINE: PairwiseChoice = PairwiseChoice::new("BASELINE");

    /// Candidate prediction wins
    pub const CANDIDATE: PairwiseChoice = PairwiseChoice::new("CANDIDATE");

    /// Winner cannot be determined
    pub const TIE: PairwiseChoice = PairwiseChoice::new("TIE");
}

impl std::convert::From<std::string::String> for PairwiseChoice {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Format of the data in the Feature View.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FeatureViewDataFormat(std::borrow::Cow<'static, str>);

impl FeatureViewDataFormat {
    /// Creates a new FeatureViewDataFormat instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [FeatureViewDataFormat](FeatureViewDataFormat)
pub mod feature_view_data_format {
    use super::FeatureViewDataFormat;

    /// Not set. Will be treated as the KeyValue format.
    pub const FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED: FeatureViewDataFormat =
        FeatureViewDataFormat::new("FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED");

    /// Return response data in key-value format.
    pub const KEY_VALUE: FeatureViewDataFormat = FeatureViewDataFormat::new("KEY_VALUE");

    /// Return response data in proto Struct format.
    pub const PROTO_STRUCT: FeatureViewDataFormat = FeatureViewDataFormat::new("PROTO_STRUCT");
}

impl std::convert::From<std::string::String> for FeatureViewDataFormat {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Describes the state of a job.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct JobState(std::borrow::Cow<'static, str>);

impl JobState {
    /// Creates a new JobState instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [JobState](JobState)
pub mod job_state {
    use super::JobState;

    /// The job state is unspecified.
    pub const JOB_STATE_UNSPECIFIED: JobState = JobState::new("JOB_STATE_UNSPECIFIED");

    /// The job has been just created or resumed and processing has not yet begun.
    pub const JOB_STATE_QUEUED: JobState = JobState::new("JOB_STATE_QUEUED");

    /// The service is preparing to run the job.
    pub const JOB_STATE_PENDING: JobState = JobState::new("JOB_STATE_PENDING");

    /// The job is in progress.
    pub const JOB_STATE_RUNNING: JobState = JobState::new("JOB_STATE_RUNNING");

    /// The job completed successfully.
    pub const JOB_STATE_SUCCEEDED: JobState = JobState::new("JOB_STATE_SUCCEEDED");

    /// The job failed.
    pub const JOB_STATE_FAILED: JobState = JobState::new("JOB_STATE_FAILED");

    /// The job is being cancelled. From this state the job may only go to
    /// either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    pub const JOB_STATE_CANCELLING: JobState = JobState::new("JOB_STATE_CANCELLING");

    /// The job has been cancelled.
    pub const JOB_STATE_CANCELLED: JobState = JobState::new("JOB_STATE_CANCELLED");

    /// The job has been stopped, and can be resumed.
    pub const JOB_STATE_PAUSED: JobState = JobState::new("JOB_STATE_PAUSED");

    /// The job has expired.
    pub const JOB_STATE_EXPIRED: JobState = JobState::new("JOB_STATE_EXPIRED");

    /// The job is being updated. Only jobs in the `RUNNING` state can be updated.
    /// After updating, the job goes back to the `RUNNING` state.
    pub const JOB_STATE_UPDATING: JobState = JobState::new("JOB_STATE_UPDATING");

    /// The job is partially succeeded, some results may be missing due to errors.
    pub const JOB_STATE_PARTIALLY_SUCCEEDED: JobState =
        JobState::new("JOB_STATE_PARTIALLY_SUCCEEDED");
}

impl std::convert::From<std::string::String> for JobState {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// The Model Monitoring Objective types.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ModelDeploymentMonitoringObjectiveType(std::borrow::Cow<'static, str>);

impl ModelDeploymentMonitoringObjectiveType {
    /// Creates a new ModelDeploymentMonitoringObjectiveType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ModelDeploymentMonitoringObjectiveType](ModelDeploymentMonitoringObjectiveType)
pub mod model_deployment_monitoring_objective_type {
    use super::ModelDeploymentMonitoringObjectiveType;

    /// Default value, should not be set.
    pub const MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED:
        ModelDeploymentMonitoringObjectiveType = ModelDeploymentMonitoringObjectiveType::new(
        "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED",
    );

    /// Raw feature values' stats to detect skew between Training-Prediction
    /// datasets.
    pub const RAW_FEATURE_SKEW: ModelDeploymentMonitoringObjectiveType =
        ModelDeploymentMonitoringObjectiveType::new("RAW_FEATURE_SKEW");

    /// Raw feature values' stats to detect drift between Serving-Prediction
    /// datasets.
    pub const RAW_FEATURE_DRIFT: ModelDeploymentMonitoringObjectiveType =
        ModelDeploymentMonitoringObjectiveType::new("RAW_FEATURE_DRIFT");

    /// Feature attribution scores to detect skew between Training-Prediction
    /// datasets.
    pub const FEATURE_ATTRIBUTION_SKEW: ModelDeploymentMonitoringObjectiveType =
        ModelDeploymentMonitoringObjectiveType::new("FEATURE_ATTRIBUTION_SKEW");

    /// Feature attribution scores to detect skew between Prediction datasets
    /// collected within different time windows.
    pub const FEATURE_ATTRIBUTION_DRIFT: ModelDeploymentMonitoringObjectiveType =
        ModelDeploymentMonitoringObjectiveType::new("FEATURE_ATTRIBUTION_DRIFT");
}

impl std::convert::From<std::string::String> for ModelDeploymentMonitoringObjectiveType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// View enumeration of PublisherModel.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PublisherModelView(std::borrow::Cow<'static, str>);

impl PublisherModelView {
    /// Creates a new PublisherModelView instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [PublisherModelView](PublisherModelView)
pub mod publisher_model_view {
    use super::PublisherModelView;

    /// The default / unset value. The API will default to the BASIC view.
    pub const PUBLISHER_MODEL_VIEW_UNSPECIFIED: PublisherModelView =
        PublisherModelView::new("PUBLISHER_MODEL_VIEW_UNSPECIFIED");

    /// Include basic metadata about the publisher model, but not the full
    /// contents.
    pub const PUBLISHER_MODEL_VIEW_BASIC: PublisherModelView =
        PublisherModelView::new("PUBLISHER_MODEL_VIEW_BASIC");

    /// Include everything.
    pub const PUBLISHER_MODEL_VIEW_FULL: PublisherModelView =
        PublisherModelView::new("PUBLISHER_MODEL_VIEW_FULL");

    /// Include: VersionId, ModelVersionExternalName, and SupportedActions.
    pub const PUBLISHER_MODEL_VERSION_VIEW_BASIC: PublisherModelView =
        PublisherModelView::new("PUBLISHER_MODEL_VERSION_VIEW_BASIC");
}

impl std::convert::From<std::string::String> for PublisherModelView {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Represents a notebook runtime type.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct NotebookRuntimeType(std::borrow::Cow<'static, str>);

impl NotebookRuntimeType {
    /// Creates a new NotebookRuntimeType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [NotebookRuntimeType](NotebookRuntimeType)
pub mod notebook_runtime_type {
    use super::NotebookRuntimeType;

    /// Unspecified notebook runtime type, NotebookRuntimeType will default to
    /// USER_DEFINED.
    pub const NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED: NotebookRuntimeType =
        NotebookRuntimeType::new("NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED");

    /// runtime or template with coustomized configurations from user.
    pub const USER_DEFINED: NotebookRuntimeType = NotebookRuntimeType::new("USER_DEFINED");

    /// runtime or template with system defined configurations.
    pub const ONE_CLICK: NotebookRuntimeType = NotebookRuntimeType::new("ONE_CLICK");
}

impl std::convert::From<std::string::String> for NotebookRuntimeType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Views for Get/List NotebookExecutionJob
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct NotebookExecutionJobView(std::borrow::Cow<'static, str>);

impl NotebookExecutionJobView {
    /// Creates a new NotebookExecutionJobView instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [NotebookExecutionJobView](NotebookExecutionJobView)
pub mod notebook_execution_job_view {
    use super::NotebookExecutionJobView;

    /// When unspecified, the API defaults to the BASIC view.
    pub const NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED: NotebookExecutionJobView =
        NotebookExecutionJobView::new("NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED");

    /// Includes all fields except for direct notebook inputs.
    pub const NOTEBOOK_EXECUTION_JOB_VIEW_BASIC: NotebookExecutionJobView =
        NotebookExecutionJobView::new("NOTEBOOK_EXECUTION_JOB_VIEW_BASIC");

    /// Includes all fields.
    pub const NOTEBOOK_EXECUTION_JOB_VIEW_FULL: NotebookExecutionJobView =
        NotebookExecutionJobView::new("NOTEBOOK_EXECUTION_JOB_VIEW_FULL");
}

impl std::convert::From<std::string::String> for NotebookExecutionJobView {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Type contains the list of OpenAPI data types as defined by
/// <https://swagger.io/docs/specification/data-models/data-types/>
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Type(std::borrow::Cow<'static, str>);

impl Type {
    /// Creates a new Type instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [Type](Type)
pub mod r#type {
    use super::Type;

    /// Not specified, should not be used.
    pub const TYPE_UNSPECIFIED: Type = Type::new("TYPE_UNSPECIFIED");

    /// OpenAPI string type
    pub const STRING: Type = Type::new("STRING");

    /// OpenAPI number type
    pub const NUMBER: Type = Type::new("NUMBER");

    /// OpenAPI integer type
    pub const INTEGER: Type = Type::new("INTEGER");

    /// OpenAPI boolean type
    pub const BOOLEAN: Type = Type::new("BOOLEAN");

    /// OpenAPI array type
    pub const ARRAY: Type = Type::new("ARRAY");

    /// OpenAPI object type
    pub const OBJECT: Type = Type::new("OBJECT");
}

impl std::convert::From<std::string::String> for Type {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Represents the failure policy of a pipeline. Currently, the default of a
/// pipeline is that the pipeline will continue to run until no more tasks can be
/// executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a
/// pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling
/// any new tasks when a task has failed. Any scheduled tasks will continue to
/// completion.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PipelineFailurePolicy(std::borrow::Cow<'static, str>);

impl PipelineFailurePolicy {
    /// Creates a new PipelineFailurePolicy instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [PipelineFailurePolicy](PipelineFailurePolicy)
pub mod pipeline_failure_policy {
    use super::PipelineFailurePolicy;

    /// Default value, and follows fail slow behavior.
    pub const PIPELINE_FAILURE_POLICY_UNSPECIFIED: PipelineFailurePolicy =
        PipelineFailurePolicy::new("PIPELINE_FAILURE_POLICY_UNSPECIFIED");

    /// Indicates that the pipeline should continue to run until all possible
    /// tasks have been scheduled and completed.
    pub const PIPELINE_FAILURE_POLICY_FAIL_SLOW: PipelineFailurePolicy =
        PipelineFailurePolicy::new("PIPELINE_FAILURE_POLICY_FAIL_SLOW");

    /// Indicates that the pipeline should stop scheduling new tasks after a task
    /// has failed.
    pub const PIPELINE_FAILURE_POLICY_FAIL_FAST: PipelineFailurePolicy =
        PipelineFailurePolicy::new("PIPELINE_FAILURE_POLICY_FAIL_FAST");
}

impl std::convert::From<std::string::String> for PipelineFailurePolicy {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Describes the state of a pipeline.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PipelineState(std::borrow::Cow<'static, str>);

impl PipelineState {
    /// Creates a new PipelineState instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [PipelineState](PipelineState)
pub mod pipeline_state {
    use super::PipelineState;

    /// The pipeline state is unspecified.
    pub const PIPELINE_STATE_UNSPECIFIED: PipelineState =
        PipelineState::new("PIPELINE_STATE_UNSPECIFIED");

    /// The pipeline has been created or resumed, and processing has not yet
    /// begun.
    pub const PIPELINE_STATE_QUEUED: PipelineState = PipelineState::new("PIPELINE_STATE_QUEUED");

    /// The service is preparing to run the pipeline.
    pub const PIPELINE_STATE_PENDING: PipelineState = PipelineState::new("PIPELINE_STATE_PENDING");

    /// The pipeline is in progress.
    pub const PIPELINE_STATE_RUNNING: PipelineState = PipelineState::new("PIPELINE_STATE_RUNNING");

    /// The pipeline completed successfully.
    pub const PIPELINE_STATE_SUCCEEDED: PipelineState =
        PipelineState::new("PIPELINE_STATE_SUCCEEDED");

    /// The pipeline failed.
    pub const PIPELINE_STATE_FAILED: PipelineState = PipelineState::new("PIPELINE_STATE_FAILED");

    /// The pipeline is being cancelled. From this state, the pipeline may only go
    /// to either PIPELINE_STATE_SUCCEEDED, PIPELINE_STATE_FAILED or
    /// PIPELINE_STATE_CANCELLED.
    pub const PIPELINE_STATE_CANCELLING: PipelineState =
        PipelineState::new("PIPELINE_STATE_CANCELLING");

    /// The pipeline has been cancelled.
    pub const PIPELINE_STATE_CANCELLED: PipelineState =
        PipelineState::new("PIPELINE_STATE_CANCELLED");

    /// The pipeline has been stopped, and can be resumed.
    pub const PIPELINE_STATE_PAUSED: PipelineState = PipelineState::new("PIPELINE_STATE_PAUSED");
}

impl std::convert::From<std::string::String> for PipelineState {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}
