// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(
    feature = "data-foundry-service",
    feature = "dataset-service",
    feature = "deployment-resource-pool-service",
    feature = "endpoint-service",
    feature = "evaluation-service",
    feature = "feature-online-store-admin-service",
    feature = "feature-online-store-service",
    feature = "feature-registry-service",
    feature = "featurestore-online-serving-service",
    feature = "featurestore-service",
    feature = "gen-ai-cache-service",
    feature = "gen-ai-tuning-service",
    feature = "index-endpoint-service",
    feature = "index-service",
    feature = "job-service",
    feature = "llm-utility-service",
    feature = "match-service",
    feature = "metadata-service",
    feature = "migration-service",
    feature = "model-garden-service",
    feature = "model-service",
    feature = "notebook-service",
    feature = "persistent-resource-service",
    feature = "pipeline-service",
    feature = "prediction-service",
    feature = "reasoning-engine-execution-service",
    feature = "reasoning-engine-service",
    feature = "schedule-service",
    feature = "specialist-pool-service",
    feature = "tensorboard-service",
    feature = "vertex-rag-data-service",
    feature = "vertex-rag-service",
    feature = "vizier-service",
))]
use crate::Result;

/// Implements a [DataFoundryService](super::stub::DataFoundryService) decorator for logging and tracing.
#[cfg(feature = "data-foundry-service")]
#[derive(Clone, Debug)]
pub struct DataFoundryService<T>
where
    T: super::stub::DataFoundryService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "data-foundry-service")]
impl<T> DataFoundryService<T>
where
    T: super::stub::DataFoundryService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "data-foundry-service")]
impl<T> super::stub::DataFoundryService for DataFoundryService<T>
where
    T: super::stub::DataFoundryService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn generate_synthetic_data(
        &self,
        req: crate::model::GenerateSyntheticDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateSyntheticDataResponse>> {
        self.inner.generate_synthetic_data(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [DatasetService](super::stub::DatasetService) decorator for logging and tracing.
#[cfg(feature = "dataset-service")]
#[derive(Clone, Debug)]
pub struct DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "dataset-service")]
impl<T> DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "dataset-service")]
impl<T> super::stub::DatasetService for DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_dataset(
        &self,
        req: crate::model::CreateDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_dataset(
        &self,
        req: crate::model::GetDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.get_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_dataset(
        &self,
        req: crate::model::UpdateDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.update_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_datasets(
        &self,
        req: crate::model::ListDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDatasetsResponse>> {
        self.inner.list_datasets(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_dataset(
        &self,
        req: crate::model::DeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_data(
        &self,
        req: crate::model::ImportDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_data(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_data(
        &self,
        req: crate::model::ExportDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_data(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_dataset_version(
        &self,
        req: crate::model::CreateDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_dataset_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_dataset_version(
        &self,
        req: crate::model::UpdateDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetVersion>> {
        self.inner.update_dataset_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_dataset_version(
        &self,
        req: crate::model::DeleteDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_dataset_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_dataset_version(
        &self,
        req: crate::model::GetDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetVersion>> {
        self.inner.get_dataset_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_dataset_versions(
        &self,
        req: crate::model::ListDatasetVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDatasetVersionsResponse>> {
        self.inner.list_dataset_versions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn restore_dataset_version(
        &self,
        req: crate::model::RestoreDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.restore_dataset_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_data_items(
        &self,
        req: crate::model::ListDataItemsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataItemsResponse>> {
        self.inner.list_data_items(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_data_items(
        &self,
        req: crate::model::SearchDataItemsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchDataItemsResponse>> {
        self.inner.search_data_items(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_saved_queries(
        &self,
        req: crate::model::ListSavedQueriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSavedQueriesResponse>> {
        self.inner.list_saved_queries(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_saved_query(
        &self,
        req: crate::model::DeleteSavedQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_saved_query(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_annotation_spec(
        &self,
        req: crate::model::GetAnnotationSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnnotationSpec>> {
        self.inner.get_annotation_spec(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_annotations(
        &self,
        req: crate::model::ListAnnotationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAnnotationsResponse>> {
        self.inner.list_annotations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [DeploymentResourcePoolService](super::stub::DeploymentResourcePoolService) decorator for logging and tracing.
#[cfg(feature = "deployment-resource-pool-service")]
#[derive(Clone, Debug)]
pub struct DeploymentResourcePoolService<T>
where
    T: super::stub::DeploymentResourcePoolService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "deployment-resource-pool-service")]
impl<T> DeploymentResourcePoolService<T>
where
    T: super::stub::DeploymentResourcePoolService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "deployment-resource-pool-service")]
impl<T> super::stub::DeploymentResourcePoolService for DeploymentResourcePoolService<T>
where
    T: super::stub::DeploymentResourcePoolService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_deployment_resource_pool(
        &self,
        req: crate::model::CreateDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .create_deployment_resource_pool(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_deployment_resource_pool(
        &self,
        req: crate::model::GetDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DeploymentResourcePool>> {
        self.inner.get_deployment_resource_pool(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_deployment_resource_pools(
        &self,
        req: crate::model::ListDeploymentResourcePoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDeploymentResourcePoolsResponse>> {
        self.inner
            .list_deployment_resource_pools(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn update_deployment_resource_pool(
        &self,
        req: crate::model::UpdateDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .update_deployment_resource_pool(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn delete_deployment_resource_pool(
        &self,
        req: crate::model::DeleteDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_deployment_resource_pool(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn query_deployed_models(
        &self,
        req: crate::model::QueryDeployedModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryDeployedModelsResponse>> {
        self.inner.query_deployed_models(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EndpointService](super::stub::EndpointService) decorator for logging and tracing.
#[cfg(feature = "endpoint-service")]
#[derive(Clone, Debug)]
pub struct EndpointService<T>
where
    T: super::stub::EndpointService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "endpoint-service")]
impl<T> EndpointService<T>
where
    T: super::stub::EndpointService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "endpoint-service")]
impl<T> super::stub::EndpointService for EndpointService<T>
where
    T: super::stub::EndpointService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_endpoint(
        &self,
        req: crate::model::CreateEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_endpoint(
        &self,
        req: crate::model::GetEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Endpoint>> {
        self.inner.get_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_endpoints(
        &self,
        req: crate::model::ListEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEndpointsResponse>> {
        self.inner.list_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_endpoint(
        &self,
        req: crate::model::UpdateEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Endpoint>> {
        self.inner.update_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_endpoint_long_running(
        &self,
        req: crate::model::UpdateEndpointLongRunningRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_endpoint_long_running(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_endpoint(
        &self,
        req: crate::model::DeleteEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deploy_model(
        &self,
        req: crate::model::DeployModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn undeploy_model(
        &self,
        req: crate::model::UndeployModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.undeploy_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn mutate_deployed_model(
        &self,
        req: crate::model::MutateDeployedModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.mutate_deployed_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EvaluationService](super::stub::EvaluationService) decorator for logging and tracing.
#[cfg(feature = "evaluation-service")]
#[derive(Clone, Debug)]
pub struct EvaluationService<T>
where
    T: super::stub::EvaluationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "evaluation-service")]
impl<T> EvaluationService<T>
where
    T: super::stub::EvaluationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "evaluation-service")]
impl<T> super::stub::EvaluationService for EvaluationService<T>
where
    T: super::stub::EvaluationService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn evaluate_instances(
        &self,
        req: crate::model::EvaluateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EvaluateInstancesResponse>> {
        self.inner.evaluate_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [FeatureOnlineStoreAdminService](super::stub::FeatureOnlineStoreAdminService) decorator for logging and tracing.
#[cfg(feature = "feature-online-store-admin-service")]
#[derive(Clone, Debug)]
pub struct FeatureOnlineStoreAdminService<T>
where
    T: super::stub::FeatureOnlineStoreAdminService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "feature-online-store-admin-service")]
impl<T> FeatureOnlineStoreAdminService<T>
where
    T: super::stub::FeatureOnlineStoreAdminService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "feature-online-store-admin-service")]
impl<T> super::stub::FeatureOnlineStoreAdminService for FeatureOnlineStoreAdminService<T>
where
    T: super::stub::FeatureOnlineStoreAdminService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_feature_online_store(
        &self,
        req: crate::model::CreateFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature_online_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_feature_online_store(
        &self,
        req: crate::model::GetFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureOnlineStore>> {
        self.inner.get_feature_online_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_feature_online_stores(
        &self,
        req: crate::model::ListFeatureOnlineStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureOnlineStoresResponse>> {
        self.inner.list_feature_online_stores(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_feature_online_store(
        &self,
        req: crate::model::UpdateFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature_online_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_feature_online_store(
        &self,
        req: crate::model::DeleteFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_online_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_feature_view(
        &self,
        req: crate::model::CreateFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature_view(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_feature_view(
        &self,
        req: crate::model::GetFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureView>> {
        self.inner.get_feature_view(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_feature_views(
        &self,
        req: crate::model::ListFeatureViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureViewsResponse>> {
        self.inner.list_feature_views(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_feature_view(
        &self,
        req: crate::model::UpdateFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature_view(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_feature_view(
        &self,
        req: crate::model::DeleteFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_view(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn sync_feature_view(
        &self,
        req: crate::model::SyncFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SyncFeatureViewResponse>> {
        self.inner.sync_feature_view(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_feature_view_sync(
        &self,
        req: crate::model::GetFeatureViewSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureViewSync>> {
        self.inner.get_feature_view_sync(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_feature_view_syncs(
        &self,
        req: crate::model::ListFeatureViewSyncsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureViewSyncsResponse>> {
        self.inner.list_feature_view_syncs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [FeatureOnlineStoreService](super::stub::FeatureOnlineStoreService) decorator for logging and tracing.
#[cfg(feature = "feature-online-store-service")]
#[derive(Clone, Debug)]
pub struct FeatureOnlineStoreService<T>
where
    T: super::stub::FeatureOnlineStoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "feature-online-store-service")]
impl<T> FeatureOnlineStoreService<T>
where
    T: super::stub::FeatureOnlineStoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "feature-online-store-service")]
impl<T> super::stub::FeatureOnlineStoreService for FeatureOnlineStoreService<T>
where
    T: super::stub::FeatureOnlineStoreService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn fetch_feature_values(
        &self,
        req: crate::model::FetchFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchFeatureValuesResponse>> {
        self.inner.fetch_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_nearest_entities(
        &self,
        req: crate::model::SearchNearestEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchNearestEntitiesResponse>> {
        self.inner.search_nearest_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [FeatureRegistryService](super::stub::FeatureRegistryService) decorator for logging and tracing.
#[cfg(feature = "feature-registry-service")]
#[derive(Clone, Debug)]
pub struct FeatureRegistryService<T>
where
    T: super::stub::FeatureRegistryService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "feature-registry-service")]
impl<T> FeatureRegistryService<T>
where
    T: super::stub::FeatureRegistryService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "feature-registry-service")]
impl<T> super::stub::FeatureRegistryService for FeatureRegistryService<T>
where
    T: super::stub::FeatureRegistryService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_feature_group(
        &self,
        req: crate::model::CreateFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_feature_group(
        &self,
        req: crate::model::GetFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureGroup>> {
        self.inner.get_feature_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_feature_groups(
        &self,
        req: crate::model::ListFeatureGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureGroupsResponse>> {
        self.inner.list_feature_groups(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_feature_group(
        &self,
        req: crate::model::UpdateFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_feature_group(
        &self,
        req: crate::model::DeleteFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_group(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_feature(
        &self,
        req: crate::model::CreateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_features(
        &self,
        req: crate::model::BatchCreateFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_feature(
        &self,
        req: crate::model::GetFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        self.inner.get_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_features(
        &self,
        req: crate::model::ListFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturesResponse>> {
        self.inner.list_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_feature(
        &self,
        req: crate::model::UpdateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_feature(
        &self,
        req: crate::model::DeleteFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [FeaturestoreOnlineServingService](super::stub::FeaturestoreOnlineServingService) decorator for logging and tracing.
#[cfg(feature = "featurestore-online-serving-service")]
#[derive(Clone, Debug)]
pub struct FeaturestoreOnlineServingService<T>
where
    T: super::stub::FeaturestoreOnlineServingService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "featurestore-online-serving-service")]
impl<T> FeaturestoreOnlineServingService<T>
where
    T: super::stub::FeaturestoreOnlineServingService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "featurestore-online-serving-service")]
impl<T> super::stub::FeaturestoreOnlineServingService for FeaturestoreOnlineServingService<T>
where
    T: super::stub::FeaturestoreOnlineServingService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn read_feature_values(
        &self,
        req: crate::model::ReadFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadFeatureValuesResponse>> {
        self.inner.read_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn write_feature_values(
        &self,
        req: crate::model::WriteFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteFeatureValuesResponse>> {
        self.inner.write_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [FeaturestoreService](super::stub::FeaturestoreService) decorator for logging and tracing.
#[cfg(feature = "featurestore-service")]
#[derive(Clone, Debug)]
pub struct FeaturestoreService<T>
where
    T: super::stub::FeaturestoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "featurestore-service")]
impl<T> FeaturestoreService<T>
where
    T: super::stub::FeaturestoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "featurestore-service")]
impl<T> super::stub::FeaturestoreService for FeaturestoreService<T>
where
    T: super::stub::FeaturestoreService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_featurestore(
        &self,
        req: crate::model::CreateFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_featurestore(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_featurestore(
        &self,
        req: crate::model::GetFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Featurestore>> {
        self.inner.get_featurestore(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_featurestores(
        &self,
        req: crate::model::ListFeaturestoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturestoresResponse>> {
        self.inner.list_featurestores(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_featurestore(
        &self,
        req: crate::model::UpdateFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_featurestore(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_featurestore(
        &self,
        req: crate::model::DeleteFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_featurestore(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.get_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        self.inner.list_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.update_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_feature(
        &self,
        req: crate::model::CreateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_features(
        &self,
        req: crate::model::BatchCreateFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_feature(
        &self,
        req: crate::model::GetFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        self.inner.get_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_features(
        &self,
        req: crate::model::ListFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturesResponse>> {
        self.inner.list_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_feature(
        &self,
        req: crate::model::UpdateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        self.inner.update_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_feature(
        &self,
        req: crate::model::DeleteFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_feature_values(
        &self,
        req: crate::model::ImportFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_read_feature_values(
        &self,
        req: crate::model::BatchReadFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_read_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_feature_values(
        &self,
        req: crate::model::ExportFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_feature_values(
        &self,
        req: crate::model::DeleteFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_values(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_features(
        &self,
        req: crate::model::SearchFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchFeaturesResponse>> {
        self.inner.search_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GenAiCacheService](super::stub::GenAiCacheService) decorator for logging and tracing.
#[cfg(feature = "gen-ai-cache-service")]
#[derive(Clone, Debug)]
pub struct GenAiCacheService<T>
where
    T: super::stub::GenAiCacheService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "gen-ai-cache-service")]
impl<T> GenAiCacheService<T>
where
    T: super::stub::GenAiCacheService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "gen-ai-cache-service")]
impl<T> super::stub::GenAiCacheService for GenAiCacheService<T>
where
    T: super::stub::GenAiCacheService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_cached_content(
        &self,
        req: crate::model::CreateCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        self.inner.create_cached_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_cached_content(
        &self,
        req: crate::model::GetCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        self.inner.get_cached_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_cached_content(
        &self,
        req: crate::model::UpdateCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        self.inner.update_cached_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_cached_content(
        &self,
        req: crate::model::DeleteCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_cached_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_cached_contents(
        &self,
        req: crate::model::ListCachedContentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCachedContentsResponse>> {
        self.inner.list_cached_contents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [GenAiTuningService](super::stub::GenAiTuningService) decorator for logging and tracing.
#[cfg(feature = "gen-ai-tuning-service")]
#[derive(Clone, Debug)]
pub struct GenAiTuningService<T>
where
    T: super::stub::GenAiTuningService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "gen-ai-tuning-service")]
impl<T> GenAiTuningService<T>
where
    T: super::stub::GenAiTuningService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "gen-ai-tuning-service")]
impl<T> super::stub::GenAiTuningService for GenAiTuningService<T>
where
    T: super::stub::GenAiTuningService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_tuning_job(
        &self,
        req: crate::model::CreateTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TuningJob>> {
        self.inner.create_tuning_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_tuning_job(
        &self,
        req: crate::model::GetTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TuningJob>> {
        self.inner.get_tuning_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_tuning_jobs(
        &self,
        req: crate::model::ListTuningJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTuningJobsResponse>> {
        self.inner.list_tuning_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_tuning_job(
        &self,
        req: crate::model::CancelTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_tuning_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn rebase_tuned_model(
        &self,
        req: crate::model::RebaseTunedModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.rebase_tuned_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [IndexEndpointService](super::stub::IndexEndpointService) decorator for logging and tracing.
#[cfg(feature = "index-endpoint-service")]
#[derive(Clone, Debug)]
pub struct IndexEndpointService<T>
where
    T: super::stub::IndexEndpointService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "index-endpoint-service")]
impl<T> IndexEndpointService<T>
where
    T: super::stub::IndexEndpointService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "index-endpoint-service")]
impl<T> super::stub::IndexEndpointService for IndexEndpointService<T>
where
    T: super::stub::IndexEndpointService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_index_endpoint(
        &self,
        req: crate::model::CreateIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_index_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_index_endpoint(
        &self,
        req: crate::model::GetIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IndexEndpoint>> {
        self.inner.get_index_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_index_endpoints(
        &self,
        req: crate::model::ListIndexEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIndexEndpointsResponse>> {
        self.inner.list_index_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_index_endpoint(
        &self,
        req: crate::model::UpdateIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IndexEndpoint>> {
        self.inner.update_index_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_index_endpoint(
        &self,
        req: crate::model::DeleteIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_index_endpoint(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deploy_index(
        &self,
        req: crate::model::DeployIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn undeploy_index(
        &self,
        req: crate::model::UndeployIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.undeploy_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn mutate_deployed_index(
        &self,
        req: crate::model::MutateDeployedIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.mutate_deployed_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [IndexService](super::stub::IndexService) decorator for logging and tracing.
#[cfg(feature = "index-service")]
#[derive(Clone, Debug)]
pub struct IndexService<T>
where
    T: super::stub::IndexService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "index-service")]
impl<T> IndexService<T>
where
    T: super::stub::IndexService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "index-service")]
impl<T> super::stub::IndexService for IndexService<T>
where
    T: super::stub::IndexService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_index(
        &self,
        req: crate::model::CreateIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_index(
        &self,
        req: crate::model::GetIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Index>> {
        self.inner.get_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_indexes(
        &self,
        req: crate::model::ListIndexesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIndexesResponse>> {
        self.inner.list_indexes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_index(
        &self,
        req: crate::model::UpdateIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_index(
        &self,
        req: crate::model::DeleteIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_index(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn upsert_datapoints(
        &self,
        req: crate::model::UpsertDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UpsertDatapointsResponse>> {
        self.inner.upsert_datapoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_datapoints(
        &self,
        req: crate::model::RemoveDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RemoveDatapointsResponse>> {
        self.inner.remove_datapoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [JobService](super::stub::JobService) decorator for logging and tracing.
#[cfg(feature = "job-service")]
#[derive(Clone, Debug)]
pub struct JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "job-service")]
impl<T> JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "job-service")]
impl<T> super::stub::JobService for JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_custom_job(
        &self,
        req: crate::model::CreateCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CustomJob>> {
        self.inner.create_custom_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_custom_job(
        &self,
        req: crate::model::GetCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CustomJob>> {
        self.inner.get_custom_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_custom_jobs(
        &self,
        req: crate::model::ListCustomJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCustomJobsResponse>> {
        self.inner.list_custom_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_custom_job(
        &self,
        req: crate::model::DeleteCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_custom_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_custom_job(
        &self,
        req: crate::model::CancelCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_custom_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_data_labeling_job(
        &self,
        req: crate::model::CreateDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataLabelingJob>> {
        self.inner.create_data_labeling_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_data_labeling_job(
        &self,
        req: crate::model::GetDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataLabelingJob>> {
        self.inner.get_data_labeling_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_data_labeling_jobs(
        &self,
        req: crate::model::ListDataLabelingJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataLabelingJobsResponse>> {
        self.inner.list_data_labeling_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_data_labeling_job(
        &self,
        req: crate::model::DeleteDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_data_labeling_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_data_labeling_job(
        &self,
        req: crate::model::CancelDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_data_labeling_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_hyperparameter_tuning_job(
        &self,
        req: crate::model::CreateHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HyperparameterTuningJob>> {
        self.inner
            .create_hyperparameter_tuning_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_hyperparameter_tuning_job(
        &self,
        req: crate::model::GetHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HyperparameterTuningJob>> {
        self.inner.get_hyperparameter_tuning_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_hyperparameter_tuning_jobs(
        &self,
        req: crate::model::ListHyperparameterTuningJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHyperparameterTuningJobsResponse>> {
        self.inner
            .list_hyperparameter_tuning_jobs(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn delete_hyperparameter_tuning_job(
        &self,
        req: crate::model::DeleteHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_hyperparameter_tuning_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn cancel_hyperparameter_tuning_job(
        &self,
        req: crate::model::CancelHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .cancel_hyperparameter_tuning_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn create_nas_job(
        &self,
        req: crate::model::CreateNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasJob>> {
        self.inner.create_nas_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_nas_job(
        &self,
        req: crate::model::GetNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasJob>> {
        self.inner.get_nas_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_nas_jobs(
        &self,
        req: crate::model::ListNasJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNasJobsResponse>> {
        self.inner.list_nas_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_nas_job(
        &self,
        req: crate::model::DeleteNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_nas_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_nas_job(
        &self,
        req: crate::model::CancelNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_nas_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_nas_trial_detail(
        &self,
        req: crate::model::GetNasTrialDetailRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasTrialDetail>> {
        self.inner.get_nas_trial_detail(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_nas_trial_details(
        &self,
        req: crate::model::ListNasTrialDetailsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNasTrialDetailsResponse>> {
        self.inner.list_nas_trial_details(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_batch_prediction_job(
        &self,
        req: crate::model::CreateBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchPredictionJob>> {
        self.inner.create_batch_prediction_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_batch_prediction_job(
        &self,
        req: crate::model::GetBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchPredictionJob>> {
        self.inner.get_batch_prediction_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_batch_prediction_jobs(
        &self,
        req: crate::model::ListBatchPredictionJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBatchPredictionJobsResponse>> {
        self.inner.list_batch_prediction_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_batch_prediction_job(
        &self,
        req: crate::model::DeleteBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_batch_prediction_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_batch_prediction_job(
        &self,
        req: crate::model::CancelBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_batch_prediction_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_model_deployment_monitoring_job(
        &self,
        req: crate::model::CreateModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelDeploymentMonitoringJob>> {
        self.inner
            .create_model_deployment_monitoring_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn search_model_deployment_monitoring_stats_anomalies(
        &self,
        req: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse,
        >,
    > {
        self.inner
            .search_model_deployment_monitoring_stats_anomalies(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_model_deployment_monitoring_job(
        &self,
        req: crate::model::GetModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelDeploymentMonitoringJob>> {
        self.inner
            .get_model_deployment_monitoring_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_model_deployment_monitoring_jobs(
        &self,
        req: crate::model::ListModelDeploymentMonitoringJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelDeploymentMonitoringJobsResponse>>
    {
        self.inner
            .list_model_deployment_monitoring_jobs(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn update_model_deployment_monitoring_job(
        &self,
        req: crate::model::UpdateModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .update_model_deployment_monitoring_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn delete_model_deployment_monitoring_job(
        &self,
        req: crate::model::DeleteModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_model_deployment_monitoring_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn pause_model_deployment_monitoring_job(
        &self,
        req: crate::model::PauseModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .pause_model_deployment_monitoring_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn resume_model_deployment_monitoring_job(
        &self,
        req: crate::model::ResumeModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .resume_model_deployment_monitoring_job(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [LlmUtilityService](super::stub::LlmUtilityService) decorator for logging and tracing.
#[cfg(feature = "llm-utility-service")]
#[derive(Clone, Debug)]
pub struct LlmUtilityService<T>
where
    T: super::stub::LlmUtilityService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "llm-utility-service")]
impl<T> LlmUtilityService<T>
where
    T: super::stub::LlmUtilityService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "llm-utility-service")]
impl<T> super::stub::LlmUtilityService for LlmUtilityService<T>
where
    T: super::stub::LlmUtilityService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn count_tokens(
        &self,
        req: crate::model::CountTokensRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CountTokensResponse>> {
        self.inner.count_tokens(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn compute_tokens(
        &self,
        req: crate::model::ComputeTokensRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ComputeTokensResponse>> {
        self.inner.compute_tokens(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [MatchService](super::stub::MatchService) decorator for logging and tracing.
#[cfg(feature = "match-service")]
#[derive(Clone, Debug)]
pub struct MatchService<T>
where
    T: super::stub::MatchService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "match-service")]
impl<T> MatchService<T>
where
    T: super::stub::MatchService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "match-service")]
impl<T> super::stub::MatchService for MatchService<T>
where
    T: super::stub::MatchService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn find_neighbors(
        &self,
        req: crate::model::FindNeighborsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FindNeighborsResponse>> {
        self.inner.find_neighbors(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn read_index_datapoints(
        &self,
        req: crate::model::ReadIndexDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadIndexDatapointsResponse>> {
        self.inner.read_index_datapoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [MetadataService](super::stub::MetadataService) decorator for logging and tracing.
#[cfg(feature = "metadata-service")]
#[derive(Clone, Debug)]
pub struct MetadataService<T>
where
    T: super::stub::MetadataService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "metadata-service")]
impl<T> MetadataService<T>
where
    T: super::stub::MetadataService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "metadata-service")]
impl<T> super::stub::MetadataService for MetadataService<T>
where
    T: super::stub::MetadataService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_metadata_store(
        &self,
        req: crate::model::CreateMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_metadata_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_metadata_store(
        &self,
        req: crate::model::GetMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataStore>> {
        self.inner.get_metadata_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_metadata_stores(
        &self,
        req: crate::model::ListMetadataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataStoresResponse>> {
        self.inner.list_metadata_stores(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_metadata_store(
        &self,
        req: crate::model::DeleteMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_metadata_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_artifact(
        &self,
        req: crate::model::CreateArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        self.inner.create_artifact(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_artifact(
        &self,
        req: crate::model::GetArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        self.inner.get_artifact(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_artifacts(
        &self,
        req: crate::model::ListArtifactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListArtifactsResponse>> {
        self.inner.list_artifacts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_artifact(
        &self,
        req: crate::model::UpdateArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        self.inner.update_artifact(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_artifact(
        &self,
        req: crate::model::DeleteArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_artifact(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_artifacts(
        &self,
        req: crate::model::PurgeArtifactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_artifacts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_context(
        &self,
        req: crate::model::CreateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.create_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_context(
        &self,
        req: crate::model::GetContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.get_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_contexts(
        &self,
        req: crate::model::ListContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContextsResponse>> {
        self.inner.list_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_context(
        &self,
        req: crate::model::UpdateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.update_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_context(
        &self,
        req: crate::model::DeleteContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_contexts(
        &self,
        req: crate::model::PurgeContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_context_artifacts_and_executions(
        &self,
        req: crate::model::AddContextArtifactsAndExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddContextArtifactsAndExecutionsResponse>>
    {
        self.inner
            .add_context_artifacts_and_executions(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn add_context_children(
        &self,
        req: crate::model::AddContextChildrenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddContextChildrenResponse>> {
        self.inner.add_context_children(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_context_children(
        &self,
        req: crate::model::RemoveContextChildrenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RemoveContextChildrenResponse>> {
        self.inner.remove_context_children(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn query_context_lineage_subgraph(
        &self,
        req: crate::model::QueryContextLineageSubgraphRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        self.inner
            .query_context_lineage_subgraph(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn create_execution(
        &self,
        req: crate::model::CreateExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        self.inner.create_execution(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_execution(
        &self,
        req: crate::model::GetExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        self.inner.get_execution(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_executions(
        &self,
        req: crate::model::ListExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListExecutionsResponse>> {
        self.inner.list_executions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_execution(
        &self,
        req: crate::model::UpdateExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        self.inner.update_execution(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_execution(
        &self,
        req: crate::model::DeleteExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_execution(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_executions(
        &self,
        req: crate::model::PurgeExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_executions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_execution_events(
        &self,
        req: crate::model::AddExecutionEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddExecutionEventsResponse>> {
        self.inner.add_execution_events(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn query_execution_inputs_and_outputs(
        &self,
        req: crate::model::QueryExecutionInputsAndOutputsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        self.inner
            .query_execution_inputs_and_outputs(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn create_metadata_schema(
        &self,
        req: crate::model::CreateMetadataSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataSchema>> {
        self.inner.create_metadata_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_metadata_schema(
        &self,
        req: crate::model::GetMetadataSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataSchema>> {
        self.inner.get_metadata_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_metadata_schemas(
        &self,
        req: crate::model::ListMetadataSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataSchemasResponse>> {
        self.inner.list_metadata_schemas(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn query_artifact_lineage_subgraph(
        &self,
        req: crate::model::QueryArtifactLineageSubgraphRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        self.inner
            .query_artifact_lineage_subgraph(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [MigrationService](super::stub::MigrationService) decorator for logging and tracing.
#[cfg(feature = "migration-service")]
#[derive(Clone, Debug)]
pub struct MigrationService<T>
where
    T: super::stub::MigrationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "migration-service")]
impl<T> MigrationService<T>
where
    T: super::stub::MigrationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "migration-service")]
impl<T> super::stub::MigrationService for MigrationService<T>
where
    T: super::stub::MigrationService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn search_migratable_resources(
        &self,
        req: crate::model::SearchMigratableResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchMigratableResourcesResponse>> {
        self.inner.search_migratable_resources(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_migrate_resources(
        &self,
        req: crate::model::BatchMigrateResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_migrate_resources(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ModelGardenService](super::stub::ModelGardenService) decorator for logging and tracing.
#[cfg(feature = "model-garden-service")]
#[derive(Clone, Debug)]
pub struct ModelGardenService<T>
where
    T: super::stub::ModelGardenService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "model-garden-service")]
impl<T> ModelGardenService<T>
where
    T: super::stub::ModelGardenService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "model-garden-service")]
impl<T> super::stub::ModelGardenService for ModelGardenService<T>
where
    T: super::stub::ModelGardenService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_publisher_model(
        &self,
        req: crate::model::GetPublisherModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublisherModel>> {
        self.inner.get_publisher_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deploy(
        &self,
        req: crate::model::DeployRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ModelService](super::stub::ModelService) decorator for logging and tracing.
#[cfg(feature = "model-service")]
#[derive(Clone, Debug)]
pub struct ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "model-service")]
impl<T> ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "model-service")]
impl<T> super::stub::ModelService for ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn upload_model(
        &self,
        req: crate::model::UploadModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.upload_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.get_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        self.inner.list_models(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_model_versions(
        &self,
        req: crate::model::ListModelVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelVersionsResponse>> {
        self.inner.list_model_versions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_model_version_checkpoints(
        &self,
        req: crate::model::ListModelVersionCheckpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelVersionCheckpointsResponse>> {
        self.inner
            .list_model_version_checkpoints(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn update_model(
        &self,
        req: crate::model::UpdateModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.update_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_explanation_dataset(
        &self,
        req: crate::model::UpdateExplanationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_explanation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_model_version(
        &self,
        req: crate::model::DeleteModelVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_model_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn merge_version_aliases(
        &self,
        req: crate::model::MergeVersionAliasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.merge_version_aliases(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_model(
        &self,
        req: crate::model::ExportModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn copy_model(
        &self,
        req: crate::model::CopyModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.copy_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_model_evaluation(
        &self,
        req: crate::model::ImportModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluation>> {
        self.inner.import_model_evaluation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_import_model_evaluation_slices(
        &self,
        req: crate::model::BatchImportModelEvaluationSlicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchImportModelEvaluationSlicesResponse>>
    {
        self.inner
            .batch_import_model_evaluation_slices(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn batch_import_evaluated_annotations(
        &self,
        req: crate::model::BatchImportEvaluatedAnnotationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchImportEvaluatedAnnotationsResponse>>
    {
        self.inner
            .batch_import_evaluated_annotations(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_model_evaluation(
        &self,
        req: crate::model::GetModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluation>> {
        self.inner.get_model_evaluation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_model_evaluations(
        &self,
        req: crate::model::ListModelEvaluationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelEvaluationsResponse>> {
        self.inner.list_model_evaluations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_model_evaluation_slice(
        &self,
        req: crate::model::GetModelEvaluationSliceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluationSlice>> {
        self.inner.get_model_evaluation_slice(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_model_evaluation_slices(
        &self,
        req: crate::model::ListModelEvaluationSlicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelEvaluationSlicesResponse>> {
        self.inner.list_model_evaluation_slices(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NotebookService](super::stub::NotebookService) decorator for logging and tracing.
#[cfg(feature = "notebook-service")]
#[derive(Clone, Debug)]
pub struct NotebookService<T>
where
    T: super::stub::NotebookService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "notebook-service")]
impl<T> NotebookService<T>
where
    T: super::stub::NotebookService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "notebook-service")]
impl<T> super::stub::NotebookService for NotebookService<T>
where
    T: super::stub::NotebookService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_notebook_runtime_template(
        &self,
        req: crate::model::CreateNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .create_notebook_runtime_template(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_notebook_runtime_template(
        &self,
        req: crate::model::GetNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntimeTemplate>> {
        self.inner.get_notebook_runtime_template(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_notebook_runtime_templates(
        &self,
        req: crate::model::ListNotebookRuntimeTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookRuntimeTemplatesResponse>> {
        self.inner
            .list_notebook_runtime_templates(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn delete_notebook_runtime_template(
        &self,
        req: crate::model::DeleteNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_notebook_runtime_template(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn update_notebook_runtime_template(
        &self,
        req: crate::model::UpdateNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntimeTemplate>> {
        self.inner
            .update_notebook_runtime_template(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn assign_notebook_runtime(
        &self,
        req: crate::model::AssignNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.assign_notebook_runtime(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_notebook_runtime(
        &self,
        req: crate::model::GetNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntime>> {
        self.inner.get_notebook_runtime(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_notebook_runtimes(
        &self,
        req: crate::model::ListNotebookRuntimesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookRuntimesResponse>> {
        self.inner.list_notebook_runtimes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_notebook_runtime(
        &self,
        req: crate::model::DeleteNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_notebook_runtime(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn upgrade_notebook_runtime(
        &self,
        req: crate::model::UpgradeNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.upgrade_notebook_runtime(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_notebook_runtime(
        &self,
        req: crate::model::StartNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.start_notebook_runtime(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_notebook_runtime(
        &self,
        req: crate::model::StopNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.stop_notebook_runtime(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_notebook_execution_job(
        &self,
        req: crate::model::CreateNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_notebook_execution_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_notebook_execution_job(
        &self,
        req: crate::model::GetNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookExecutionJob>> {
        self.inner.get_notebook_execution_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_notebook_execution_jobs(
        &self,
        req: crate::model::ListNotebookExecutionJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookExecutionJobsResponse>> {
        self.inner.list_notebook_execution_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_notebook_execution_job(
        &self,
        req: crate::model::DeleteNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_notebook_execution_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PersistentResourceService](super::stub::PersistentResourceService) decorator for logging and tracing.
#[cfg(feature = "persistent-resource-service")]
#[derive(Clone, Debug)]
pub struct PersistentResourceService<T>
where
    T: super::stub::PersistentResourceService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "persistent-resource-service")]
impl<T> PersistentResourceService<T>
where
    T: super::stub::PersistentResourceService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "persistent-resource-service")]
impl<T> super::stub::PersistentResourceService for PersistentResourceService<T>
where
    T: super::stub::PersistentResourceService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_persistent_resource(
        &self,
        req: crate::model::CreatePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_persistent_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_persistent_resource(
        &self,
        req: crate::model::GetPersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PersistentResource>> {
        self.inner.get_persistent_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_persistent_resources(
        &self,
        req: crate::model::ListPersistentResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPersistentResourcesResponse>> {
        self.inner.list_persistent_resources(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_persistent_resource(
        &self,
        req: crate::model::DeletePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_persistent_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_persistent_resource(
        &self,
        req: crate::model::UpdatePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_persistent_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn reboot_persistent_resource(
        &self,
        req: crate::model::RebootPersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.reboot_persistent_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PipelineService](super::stub::PipelineService) decorator for logging and tracing.
#[cfg(feature = "pipeline-service")]
#[derive(Clone, Debug)]
pub struct PipelineService<T>
where
    T: super::stub::PipelineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "pipeline-service")]
impl<T> PipelineService<T>
where
    T: super::stub::PipelineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "pipeline-service")]
impl<T> super::stub::PipelineService for PipelineService<T>
where
    T: super::stub::PipelineService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_training_pipeline(
        &self,
        req: crate::model::CreateTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TrainingPipeline>> {
        self.inner.create_training_pipeline(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_training_pipeline(
        &self,
        req: crate::model::GetTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TrainingPipeline>> {
        self.inner.get_training_pipeline(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_training_pipelines(
        &self,
        req: crate::model::ListTrainingPipelinesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTrainingPipelinesResponse>> {
        self.inner.list_training_pipelines(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_training_pipeline(
        &self,
        req: crate::model::DeleteTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_training_pipeline(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_training_pipeline(
        &self,
        req: crate::model::CancelTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_training_pipeline(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_pipeline_job(
        &self,
        req: crate::model::CreatePipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PipelineJob>> {
        self.inner.create_pipeline_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_pipeline_job(
        &self,
        req: crate::model::GetPipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PipelineJob>> {
        self.inner.get_pipeline_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_pipeline_jobs(
        &self,
        req: crate::model::ListPipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPipelineJobsResponse>> {
        self.inner.list_pipeline_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_pipeline_job(
        &self,
        req: crate::model::DeletePipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_pipeline_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_pipeline_jobs(
        &self,
        req: crate::model::BatchDeletePipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_delete_pipeline_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_pipeline_job(
        &self,
        req: crate::model::CancelPipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_pipeline_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_cancel_pipeline_jobs(
        &self,
        req: crate::model::BatchCancelPipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_cancel_pipeline_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PredictionService](super::stub::PredictionService) decorator for logging and tracing.
#[cfg(feature = "prediction-service")]
#[derive(Clone, Debug)]
pub struct PredictionService<T>
where
    T: super::stub::PredictionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "prediction-service")]
impl<T> PredictionService<T>
where
    T: super::stub::PredictionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "prediction-service")]
impl<T> super::stub::PredictionService for PredictionService<T>
where
    T: super::stub::PredictionService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn predict(
        &self,
        req: crate::model::PredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PredictResponse>> {
        self.inner.predict(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn raw_predict(
        &self,
        req: crate::model::RawPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        self.inner.raw_predict(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn direct_predict(
        &self,
        req: crate::model::DirectPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DirectPredictResponse>> {
        self.inner.direct_predict(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn direct_raw_predict(
        &self,
        req: crate::model::DirectRawPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DirectRawPredictResponse>> {
        self.inner.direct_raw_predict(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn explain(
        &self,
        req: crate::model::ExplainRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExplainResponse>> {
        self.inner.explain(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_content(
        &self,
        req: crate::model::GenerateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateContentResponse>> {
        self.inner.generate_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [ReasoningEngineExecutionService](super::stub::ReasoningEngineExecutionService) decorator for logging and tracing.
#[cfg(feature = "reasoning-engine-execution-service")]
#[derive(Clone, Debug)]
pub struct ReasoningEngineExecutionService<T>
where
    T: super::stub::ReasoningEngineExecutionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reasoning-engine-execution-service")]
impl<T> ReasoningEngineExecutionService<T>
where
    T: super::stub::ReasoningEngineExecutionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reasoning-engine-execution-service")]
impl<T> super::stub::ReasoningEngineExecutionService for ReasoningEngineExecutionService<T>
where
    T: super::stub::ReasoningEngineExecutionService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn query_reasoning_engine(
        &self,
        req: crate::model::QueryReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryReasoningEngineResponse>> {
        self.inner.query_reasoning_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [ReasoningEngineService](super::stub::ReasoningEngineService) decorator for logging and tracing.
#[cfg(feature = "reasoning-engine-service")]
#[derive(Clone, Debug)]
pub struct ReasoningEngineService<T>
where
    T: super::stub::ReasoningEngineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reasoning-engine-service")]
impl<T> ReasoningEngineService<T>
where
    T: super::stub::ReasoningEngineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reasoning-engine-service")]
impl<T> super::stub::ReasoningEngineService for ReasoningEngineService<T>
where
    T: super::stub::ReasoningEngineService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_reasoning_engine(
        &self,
        req: crate::model::CreateReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_reasoning_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_reasoning_engine(
        &self,
        req: crate::model::GetReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReasoningEngine>> {
        self.inner.get_reasoning_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_reasoning_engines(
        &self,
        req: crate::model::ListReasoningEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListReasoningEnginesResponse>> {
        self.inner.list_reasoning_engines(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_reasoning_engine(
        &self,
        req: crate::model::UpdateReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_reasoning_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_reasoning_engine(
        &self,
        req: crate::model::DeleteReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_reasoning_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ScheduleService](super::stub::ScheduleService) decorator for logging and tracing.
#[cfg(feature = "schedule-service")]
#[derive(Clone, Debug)]
pub struct ScheduleService<T>
where
    T: super::stub::ScheduleService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "schedule-service")]
impl<T> ScheduleService<T>
where
    T: super::stub::ScheduleService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "schedule-service")]
impl<T> super::stub::ScheduleService for ScheduleService<T>
where
    T: super::stub::ScheduleService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_schedule(
        &self,
        req: crate::model::CreateScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        self.inner.create_schedule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_schedule(
        &self,
        req: crate::model::DeleteScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_schedule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_schedule(
        &self,
        req: crate::model::GetScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        self.inner.get_schedule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_schedules(
        &self,
        req: crate::model::ListSchedulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchedulesResponse>> {
        self.inner.list_schedules(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn pause_schedule(
        &self,
        req: crate::model::PauseScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.pause_schedule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume_schedule(
        &self,
        req: crate::model::ResumeScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.resume_schedule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_schedule(
        &self,
        req: crate::model::UpdateScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        self.inner.update_schedule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SpecialistPoolService](super::stub::SpecialistPoolService) decorator for logging and tracing.
#[cfg(feature = "specialist-pool-service")]
#[derive(Clone, Debug)]
pub struct SpecialistPoolService<T>
where
    T: super::stub::SpecialistPoolService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "specialist-pool-service")]
impl<T> SpecialistPoolService<T>
where
    T: super::stub::SpecialistPoolService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "specialist-pool-service")]
impl<T> super::stub::SpecialistPoolService for SpecialistPoolService<T>
where
    T: super::stub::SpecialistPoolService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_specialist_pool(
        &self,
        req: crate::model::CreateSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_specialist_pool(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_specialist_pool(
        &self,
        req: crate::model::GetSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SpecialistPool>> {
        self.inner.get_specialist_pool(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_specialist_pools(
        &self,
        req: crate::model::ListSpecialistPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSpecialistPoolsResponse>> {
        self.inner.list_specialist_pools(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_specialist_pool(
        &self,
        req: crate::model::DeleteSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_specialist_pool(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_specialist_pool(
        &self,
        req: crate::model::UpdateSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_specialist_pool(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TensorboardService](super::stub::TensorboardService) decorator for logging and tracing.
#[cfg(feature = "tensorboard-service")]
#[derive(Clone, Debug)]
pub struct TensorboardService<T>
where
    T: super::stub::TensorboardService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "tensorboard-service")]
impl<T> TensorboardService<T>
where
    T: super::stub::TensorboardService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "tensorboard-service")]
impl<T> super::stub::TensorboardService for TensorboardService<T>
where
    T: super::stub::TensorboardService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_tensorboard(
        &self,
        req: crate::model::CreateTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_tensorboard(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_tensorboard(
        &self,
        req: crate::model::GetTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tensorboard>> {
        self.inner.get_tensorboard(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_tensorboard(
        &self,
        req: crate::model::UpdateTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_tensorboard(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_tensorboards(
        &self,
        req: crate::model::ListTensorboardsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardsResponse>> {
        self.inner.list_tensorboards(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_tensorboard(
        &self,
        req: crate::model::DeleteTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_tensorboard(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn read_tensorboard_usage(
        &self,
        req: crate::model::ReadTensorboardUsageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardUsageResponse>> {
        self.inner.read_tensorboard_usage(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn read_tensorboard_size(
        &self,
        req: crate::model::ReadTensorboardSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardSizeResponse>> {
        self.inner.read_tensorboard_size(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_tensorboard_experiment(
        &self,
        req: crate::model::CreateTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        self.inner.create_tensorboard_experiment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_tensorboard_experiment(
        &self,
        req: crate::model::GetTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        self.inner.get_tensorboard_experiment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_tensorboard_experiment(
        &self,
        req: crate::model::UpdateTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        self.inner.update_tensorboard_experiment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_tensorboard_experiments(
        &self,
        req: crate::model::ListTensorboardExperimentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardExperimentsResponse>> {
        self.inner.list_tensorboard_experiments(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_tensorboard_experiment(
        &self,
        req: crate::model::DeleteTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_tensorboard_experiment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_tensorboard_run(
        &self,
        req: crate::model::CreateTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        self.inner.create_tensorboard_run(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_tensorboard_runs(
        &self,
        req: crate::model::BatchCreateTensorboardRunsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchCreateTensorboardRunsResponse>> {
        self.inner.batch_create_tensorboard_runs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_tensorboard_run(
        &self,
        req: crate::model::GetTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        self.inner.get_tensorboard_run(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_tensorboard_run(
        &self,
        req: crate::model::UpdateTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        self.inner.update_tensorboard_run(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_tensorboard_runs(
        &self,
        req: crate::model::ListTensorboardRunsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardRunsResponse>> {
        self.inner.list_tensorboard_runs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_tensorboard_run(
        &self,
        req: crate::model::DeleteTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_tensorboard_run(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_tensorboard_time_series(
        &self,
        req: crate::model::BatchCreateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchCreateTensorboardTimeSeriesResponse>>
    {
        self.inner
            .batch_create_tensorboard_time_series(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn create_tensorboard_time_series(
        &self,
        req: crate::model::CreateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        self.inner
            .create_tensorboard_time_series(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_tensorboard_time_series(
        &self,
        req: crate::model::GetTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        self.inner.get_tensorboard_time_series(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_tensorboard_time_series(
        &self,
        req: crate::model::UpdateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        self.inner
            .update_tensorboard_time_series(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_tensorboard_time_series(
        &self,
        req: crate::model::ListTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardTimeSeriesResponse>> {
        self.inner.list_tensorboard_time_series(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_tensorboard_time_series(
        &self,
        req: crate::model::DeleteTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_tensorboard_time_series(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn batch_read_tensorboard_time_series_data(
        &self,
        req: crate::model::BatchReadTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchReadTensorboardTimeSeriesDataResponse>>
    {
        self.inner
            .batch_read_tensorboard_time_series_data(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn read_tensorboard_time_series_data(
        &self,
        req: crate::model::ReadTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardTimeSeriesDataResponse>> {
        self.inner
            .read_tensorboard_time_series_data(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn write_tensorboard_experiment_data(
        &self,
        req: crate::model::WriteTensorboardExperimentDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteTensorboardExperimentDataResponse>> {
        self.inner
            .write_tensorboard_experiment_data(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn write_tensorboard_run_data(
        &self,
        req: crate::model::WriteTensorboardRunDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteTensorboardRunDataResponse>> {
        self.inner.write_tensorboard_run_data(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_tensorboard_time_series_data(
        &self,
        req: crate::model::ExportTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExportTensorboardTimeSeriesDataResponse>>
    {
        self.inner
            .export_tensorboard_time_series_data(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [VertexRagDataService](super::stub::VertexRagDataService) decorator for logging and tracing.
#[cfg(feature = "vertex-rag-data-service")]
#[derive(Clone, Debug)]
pub struct VertexRagDataService<T>
where
    T: super::stub::VertexRagDataService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vertex-rag-data-service")]
impl<T> VertexRagDataService<T>
where
    T: super::stub::VertexRagDataService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vertex-rag-data-service")]
impl<T> super::stub::VertexRagDataService for VertexRagDataService<T>
where
    T: super::stub::VertexRagDataService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_rag_corpus(
        &self,
        req: crate::model::CreateRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_rag_corpus(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_rag_corpus(
        &self,
        req: crate::model::UpdateRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_rag_corpus(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rag_corpus(
        &self,
        req: crate::model::GetRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagCorpus>> {
        self.inner.get_rag_corpus(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_rag_corpora(
        &self,
        req: crate::model::ListRagCorporaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRagCorporaResponse>> {
        self.inner.list_rag_corpora(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_rag_corpus(
        &self,
        req: crate::model::DeleteRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_rag_corpus(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn upload_rag_file(
        &self,
        req: crate::model::UploadRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UploadRagFileResponse>> {
        self.inner.upload_rag_file(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_rag_files(
        &self,
        req: crate::model::ImportRagFilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_rag_files(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rag_file(
        &self,
        req: crate::model::GetRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagFile>> {
        self.inner.get_rag_file(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_rag_files(
        &self,
        req: crate::model::ListRagFilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRagFilesResponse>> {
        self.inner.list_rag_files(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_rag_file(
        &self,
        req: crate::model::DeleteRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_rag_file(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_rag_engine_config(
        &self,
        req: crate::model::UpdateRagEngineConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_rag_engine_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rag_engine_config(
        &self,
        req: crate::model::GetRagEngineConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagEngineConfig>> {
        self.inner.get_rag_engine_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [VertexRagService](super::stub::VertexRagService) decorator for logging and tracing.
#[cfg(feature = "vertex-rag-service")]
#[derive(Clone, Debug)]
pub struct VertexRagService<T>
where
    T: super::stub::VertexRagService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vertex-rag-service")]
impl<T> VertexRagService<T>
where
    T: super::stub::VertexRagService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vertex-rag-service")]
impl<T> super::stub::VertexRagService for VertexRagService<T>
where
    T: super::stub::VertexRagService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn retrieve_contexts(
        &self,
        req: crate::model::RetrieveContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RetrieveContextsResponse>> {
        self.inner.retrieve_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn augment_prompt(
        &self,
        req: crate::model::AugmentPromptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AugmentPromptResponse>> {
        self.inner.augment_prompt(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn corroborate_content(
        &self,
        req: crate::model::CorroborateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CorroborateContentResponse>> {
        self.inner.corroborate_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [VizierService](super::stub::VizierService) decorator for logging and tracing.
#[cfg(feature = "vizier-service")]
#[derive(Clone, Debug)]
pub struct VizierService<T>
where
    T: super::stub::VizierService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vizier-service")]
impl<T> VizierService<T>
where
    T: super::stub::VizierService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vizier-service")]
impl<T> super::stub::VizierService for VizierService<T>
where
    T: super::stub::VizierService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_study(
        &self,
        req: crate::model::CreateStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        self.inner.create_study(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_study(
        &self,
        req: crate::model::GetStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        self.inner.get_study(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_studies(
        &self,
        req: crate::model::ListStudiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListStudiesResponse>> {
        self.inner.list_studies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_study(
        &self,
        req: crate::model::DeleteStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_study(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn lookup_study(
        &self,
        req: crate::model::LookupStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        self.inner.lookup_study(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_trials(
        &self,
        req: crate::model::SuggestTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.suggest_trials(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_trial(
        &self,
        req: crate::model::CreateTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.create_trial(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_trial(
        &self,
        req: crate::model::GetTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.get_trial(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_trials(
        &self,
        req: crate::model::ListTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTrialsResponse>> {
        self.inner.list_trials(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_trial_measurement(
        &self,
        req: crate::model::AddTrialMeasurementRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.add_trial_measurement(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn complete_trial(
        &self,
        req: crate::model::CompleteTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.complete_trial(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_trial(
        &self,
        req: crate::model::DeleteTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_trial(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn check_trial_early_stopping_state(
        &self,
        req: crate::model::CheckTrialEarlyStoppingStateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .check_trial_early_stopping_state(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn stop_trial(
        &self,
        req: crate::model::StopTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.stop_trial(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_optimal_trials(
        &self,
        req: crate::model::ListOptimalTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListOptimalTrialsResponse>> {
        self.inner.list_optimal_trials(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
