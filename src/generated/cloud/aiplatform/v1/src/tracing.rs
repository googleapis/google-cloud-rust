// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(
    feature = "data-foundry-service",
    feature = "dataset-service",
    feature = "deployment-resource-pool-service",
    feature = "endpoint-service",
    feature = "evaluation-service",
    feature = "feature-online-store-admin-service",
    feature = "feature-online-store-service",
    feature = "feature-registry-service",
    feature = "featurestore-online-serving-service",
    feature = "featurestore-service",
    feature = "gen-ai-cache-service",
    feature = "gen-ai-tuning-service",
    feature = "index-endpoint-service",
    feature = "index-service",
    feature = "job-service",
    feature = "llm-utility-service",
    feature = "match-service",
    feature = "metadata-service",
    feature = "migration-service",
    feature = "model-garden-service",
    feature = "model-service",
    feature = "notebook-service",
    feature = "persistent-resource-service",
    feature = "pipeline-service",
    feature = "prediction-service",
    feature = "reasoning-engine-execution-service",
    feature = "reasoning-engine-service",
    feature = "schedule-service",
    feature = "specialist-pool-service",
    feature = "tensorboard-service",
    feature = "vertex-rag-data-service",
    feature = "vertex-rag-service",
    feature = "vizier-service",
))]
use crate::Result;

/// Implements a [DataFoundryService](super::stub::DataFoundryService) decorator for logging and tracing.
#[cfg(feature = "data-foundry-service")]
#[derive(Clone, Debug)]
pub struct DataFoundryService<T>
where
    T: super::stub::DataFoundryService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "data-foundry-service")]
impl<T> DataFoundryService<T>
where
    T: super::stub::DataFoundryService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "data-foundry-service")]
impl<T> super::stub::DataFoundryService for DataFoundryService<T>
where
    T: super::stub::DataFoundryService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn generate_synthetic_data(
        &self,
        req: crate::model::GenerateSyntheticDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateSyntheticDataResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::generate_synthetic_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "generate_synthetic_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .generate_synthetic_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn generate_synthetic_data(
        &self,
        req: crate::model::GenerateSyntheticDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateSyntheticDataResponse>> {
        self.inner.generate_synthetic_data(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataFoundryService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [DatasetService](super::stub::DatasetService) decorator for logging and tracing.
#[cfg(feature = "dataset-service")]
#[derive(Clone, Debug)]
pub struct DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "dataset-service")]
impl<T> DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "dataset-service")]
impl<T> super::stub::DatasetService for DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_dataset(
        &self,
        req: crate::model::CreateDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::create_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_dataset(
        &self,
        req: crate::model::CreateDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_dataset(
        &self,
        req: crate::model::GetDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_dataset(
        &self,
        req: crate::model::GetDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.get_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_dataset(
        &self,
        req: crate::model::UpdateDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::update_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_dataset(
        &self,
        req: crate::model::UpdateDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.update_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_datasets(
        &self,
        req: crate::model::ListDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDatasetsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_datasets"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_datasets",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_datasets(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_datasets(
        &self,
        req: crate::model::ListDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDatasetsResponse>> {
        self.inner.list_datasets(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_dataset(
        &self,
        req: crate::model::DeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::delete_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_dataset(
        &self,
        req: crate::model::DeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_data(
        &self,
        req: crate::model::ImportDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::import_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_data(
        &self,
        req: crate::model::ImportDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_data(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_data(
        &self,
        req: crate::model::ExportDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::export_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_data(
        &self,
        req: crate::model::ExportDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_data(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_dataset_version(
        &self,
        req: crate::model::CreateDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::create_dataset_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_dataset_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_dataset_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_dataset_version(
        &self,
        req: crate::model::CreateDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_dataset_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_dataset_version(
        &self,
        req: crate::model::UpdateDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetVersion>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::update_dataset_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_dataset_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_dataset_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_dataset_version(
        &self,
        req: crate::model::UpdateDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetVersion>> {
        self.inner.update_dataset_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_dataset_version(
        &self,
        req: crate::model::DeleteDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::delete_dataset_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_dataset_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_dataset_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_dataset_version(
        &self,
        req: crate::model::DeleteDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_dataset_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_dataset_version(
        &self,
        req: crate::model::GetDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetVersion>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_dataset_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_dataset_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_dataset_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_dataset_version(
        &self,
        req: crate::model::GetDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetVersion>> {
        self.inner.get_dataset_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_dataset_versions(
        &self,
        req: crate::model::ListDatasetVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDatasetVersionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_dataset_versions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_dataset_versions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_dataset_versions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_dataset_versions(
        &self,
        req: crate::model::ListDatasetVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDatasetVersionsResponse>> {
        self.inner.list_dataset_versions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn restore_dataset_version(
        &self,
        req: crate::model::RestoreDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::restore_dataset_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "restore_dataset_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .restore_dataset_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn restore_dataset_version(
        &self,
        req: crate::model::RestoreDatasetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.restore_dataset_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_data_items(
        &self,
        req: crate::model::ListDataItemsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataItemsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_data_items"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_data_items",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_data_items(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_data_items(
        &self,
        req: crate::model::ListDataItemsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataItemsResponse>> {
        self.inner.list_data_items(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_data_items(
        &self,
        req: crate::model::SearchDataItemsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchDataItemsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::search_data_items"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_data_items",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .search_data_items(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_data_items(
        &self,
        req: crate::model::SearchDataItemsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchDataItemsResponse>> {
        self.inner.search_data_items(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_saved_queries(
        &self,
        req: crate::model::ListSavedQueriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSavedQueriesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_saved_queries"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_saved_queries",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_saved_queries(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_saved_queries(
        &self,
        req: crate::model::ListSavedQueriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSavedQueriesResponse>> {
        self.inner.list_saved_queries(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_saved_query(
        &self,
        req: crate::model::DeleteSavedQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::delete_saved_query"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_saved_query",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_saved_query(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_saved_query(
        &self,
        req: crate::model::DeleteSavedQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_saved_query(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_annotation_spec(
        &self,
        req: crate::model::GetAnnotationSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnnotationSpec>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_annotation_spec"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_annotation_spec",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_annotation_spec(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_annotation_spec(
        &self,
        req: crate::model::GetAnnotationSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnnotationSpec>> {
        self.inner.get_annotation_spec(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_annotations(
        &self,
        req: crate::model::ListAnnotationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAnnotationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_annotations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_annotations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_annotations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_annotations(
        &self,
        req: crate::model::ListAnnotationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAnnotationsResponse>> {
        self.inner.list_annotations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [DeploymentResourcePoolService](super::stub::DeploymentResourcePoolService) decorator for logging and tracing.
#[cfg(feature = "deployment-resource-pool-service")]
#[derive(Clone, Debug)]
pub struct DeploymentResourcePoolService<T>
where
    T: super::stub::DeploymentResourcePoolService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "deployment-resource-pool-service")]
impl<T> DeploymentResourcePoolService<T>
where
    T: super::stub::DeploymentResourcePoolService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "deployment-resource-pool-service")]
impl<T> super::stub::DeploymentResourcePoolService for DeploymentResourcePoolService<T>
where
    T: super::stub::DeploymentResourcePoolService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_deployment_resource_pool(
        &self,
        req: crate::model::CreateDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::create_deployment_resource_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_deployment_resource_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_deployment_resource_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_deployment_resource_pool(
        &self,
        req: crate::model::CreateDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .create_deployment_resource_pool(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_deployment_resource_pool(
        &self,
        req: crate::model::GetDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DeploymentResourcePool>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::get_deployment_resource_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_deployment_resource_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_deployment_resource_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_deployment_resource_pool(
        &self,
        req: crate::model::GetDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DeploymentResourcePool>> {
        self.inner.get_deployment_resource_pool(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_deployment_resource_pools(
        &self,
        req: crate::model::ListDeploymentResourcePoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDeploymentResourcePoolsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::list_deployment_resource_pools"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_deployment_resource_pools",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_deployment_resource_pools(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_deployment_resource_pools(
        &self,
        req: crate::model::ListDeploymentResourcePoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDeploymentResourcePoolsResponse>> {
        self.inner
            .list_deployment_resource_pools(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_deployment_resource_pool(
        &self,
        req: crate::model::UpdateDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::update_deployment_resource_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_deployment_resource_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_deployment_resource_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_deployment_resource_pool(
        &self,
        req: crate::model::UpdateDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .update_deployment_resource_pool(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_deployment_resource_pool(
        &self,
        req: crate::model::DeleteDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::delete_deployment_resource_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_deployment_resource_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_deployment_resource_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_deployment_resource_pool(
        &self,
        req: crate::model::DeleteDeploymentResourcePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_deployment_resource_pool(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn query_deployed_models(
        &self,
        req: crate::model::QueryDeployedModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryDeployedModelsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::query_deployed_models"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "query_deployed_models",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .query_deployed_models(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn query_deployed_models(
        &self,
        req: crate::model::QueryDeployedModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryDeployedModelsResponse>> {
        self.inner.query_deployed_models(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DeploymentResourcePoolService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EndpointService](super::stub::EndpointService) decorator for logging and tracing.
#[cfg(feature = "endpoint-service")]
#[derive(Clone, Debug)]
pub struct EndpointService<T>
where
    T: super::stub::EndpointService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "endpoint-service")]
impl<T> EndpointService<T>
where
    T: super::stub::EndpointService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "endpoint-service")]
impl<T> super::stub::EndpointService for EndpointService<T>
where
    T: super::stub::EndpointService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_endpoint(
        &self,
        req: crate::model::CreateEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::create_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_endpoint(
        &self,
        req: crate::model::CreateEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_endpoint(
        &self,
        req: crate::model::GetEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Endpoint>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::get_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_endpoint(
        &self,
        req: crate::model::GetEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Endpoint>> {
        self.inner.get_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_endpoints(
        &self,
        req: crate::model::ListEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEndpointsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::list_endpoints"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_endpoints",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_endpoints(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_endpoints(
        &self,
        req: crate::model::ListEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEndpointsResponse>> {
        self.inner.list_endpoints(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_endpoint(
        &self,
        req: crate::model::UpdateEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Endpoint>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::update_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_endpoint(
        &self,
        req: crate::model::UpdateEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Endpoint>> {
        self.inner.update_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_endpoint_long_running(
        &self,
        req: crate::model::UpdateEndpointLongRunningRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::update_endpoint_long_running"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_endpoint_long_running",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_endpoint_long_running(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_endpoint_long_running(
        &self,
        req: crate::model::UpdateEndpointLongRunningRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_endpoint_long_running(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_endpoint(
        &self,
        req: crate::model::DeleteEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::delete_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_endpoint(
        &self,
        req: crate::model::DeleteEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn deploy_model(
        &self,
        req: crate::model::DeployModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::deploy_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "deploy_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .deploy_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn deploy_model(
        &self,
        req: crate::model::DeployModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn undeploy_model(
        &self,
        req: crate::model::UndeployModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::undeploy_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "undeploy_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .undeploy_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn undeploy_model(
        &self,
        req: crate::model::UndeployModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.undeploy_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn mutate_deployed_model(
        &self,
        req: crate::model::MutateDeployedModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::mutate_deployed_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "mutate_deployed_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .mutate_deployed_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn mutate_deployed_model(
        &self,
        req: crate::model::MutateDeployedModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.mutate_deployed_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EndpointService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EvaluationService](super::stub::EvaluationService) decorator for logging and tracing.
#[cfg(feature = "evaluation-service")]
#[derive(Clone, Debug)]
pub struct EvaluationService<T>
where
    T: super::stub::EvaluationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "evaluation-service")]
impl<T> EvaluationService<T>
where
    T: super::stub::EvaluationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "evaluation-service")]
impl<T> super::stub::EvaluationService for EvaluationService<T>
where
    T: super::stub::EvaluationService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn evaluate_instances(
        &self,
        req: crate::model::EvaluateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EvaluateInstancesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::evaluate_instances"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "evaluate_instances",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .evaluate_instances(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn evaluate_instances(
        &self,
        req: crate::model::EvaluateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EvaluateInstancesResponse>> {
        self.inner.evaluate_instances(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EvaluationService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [FeatureOnlineStoreAdminService](super::stub::FeatureOnlineStoreAdminService) decorator for logging and tracing.
#[cfg(feature = "feature-online-store-admin-service")]
#[derive(Clone, Debug)]
pub struct FeatureOnlineStoreAdminService<T>
where
    T: super::stub::FeatureOnlineStoreAdminService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "feature-online-store-admin-service")]
impl<T> FeatureOnlineStoreAdminService<T>
where
    T: super::stub::FeatureOnlineStoreAdminService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "feature-online-store-admin-service")]
impl<T> super::stub::FeatureOnlineStoreAdminService for FeatureOnlineStoreAdminService<T>
where
    T: super::stub::FeatureOnlineStoreAdminService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_feature_online_store(
        &self,
        req: crate::model::CreateFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::create_feature_online_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_feature_online_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_feature_online_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_feature_online_store(
        &self,
        req: crate::model::CreateFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature_online_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_feature_online_store(
        &self,
        req: crate::model::GetFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureOnlineStore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::get_feature_online_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_feature_online_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_feature_online_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_feature_online_store(
        &self,
        req: crate::model::GetFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureOnlineStore>> {
        self.inner.get_feature_online_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_feature_online_stores(
        &self,
        req: crate::model::ListFeatureOnlineStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureOnlineStoresResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::list_feature_online_stores"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_feature_online_stores",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_feature_online_stores(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_feature_online_stores(
        &self,
        req: crate::model::ListFeatureOnlineStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureOnlineStoresResponse>> {
        self.inner.list_feature_online_stores(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_feature_online_store(
        &self,
        req: crate::model::UpdateFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::update_feature_online_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_feature_online_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_feature_online_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_feature_online_store(
        &self,
        req: crate::model::UpdateFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature_online_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_feature_online_store(
        &self,
        req: crate::model::DeleteFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::delete_feature_online_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_feature_online_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_feature_online_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_feature_online_store(
        &self,
        req: crate::model::DeleteFeatureOnlineStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_online_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_feature_view(
        &self,
        req: crate::model::CreateFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::create_feature_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_feature_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_feature_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_feature_view(
        &self,
        req: crate::model::CreateFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_feature_view(
        &self,
        req: crate::model::GetFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureView>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::get_feature_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_feature_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_feature_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_feature_view(
        &self,
        req: crate::model::GetFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureView>> {
        self.inner.get_feature_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_feature_views(
        &self,
        req: crate::model::ListFeatureViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureViewsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::list_feature_views"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_feature_views",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_feature_views(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_feature_views(
        &self,
        req: crate::model::ListFeatureViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureViewsResponse>> {
        self.inner.list_feature_views(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_feature_view(
        &self,
        req: crate::model::UpdateFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::update_feature_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_feature_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_feature_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_feature_view(
        &self,
        req: crate::model::UpdateFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_feature_view(
        &self,
        req: crate::model::DeleteFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::delete_feature_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_feature_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_feature_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_feature_view(
        &self,
        req: crate::model::DeleteFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn sync_feature_view(
        &self,
        req: crate::model::SyncFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SyncFeatureViewResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::sync_feature_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "sync_feature_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .sync_feature_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn sync_feature_view(
        &self,
        req: crate::model::SyncFeatureViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SyncFeatureViewResponse>> {
        self.inner.sync_feature_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_feature_view_sync(
        &self,
        req: crate::model::GetFeatureViewSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureViewSync>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::get_feature_view_sync"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_feature_view_sync",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_feature_view_sync(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_feature_view_sync(
        &self,
        req: crate::model::GetFeatureViewSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureViewSync>> {
        self.inner.get_feature_view_sync(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_feature_view_syncs(
        &self,
        req: crate::model::ListFeatureViewSyncsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureViewSyncsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::list_feature_view_syncs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_feature_view_syncs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_feature_view_syncs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_feature_view_syncs(
        &self,
        req: crate::model::ListFeatureViewSyncsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureViewSyncsResponse>> {
        self.inner.list_feature_view_syncs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreAdminService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [FeatureOnlineStoreService](super::stub::FeatureOnlineStoreService) decorator for logging and tracing.
#[cfg(feature = "feature-online-store-service")]
#[derive(Clone, Debug)]
pub struct FeatureOnlineStoreService<T>
where
    T: super::stub::FeatureOnlineStoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "feature-online-store-service")]
impl<T> FeatureOnlineStoreService<T>
where
    T: super::stub::FeatureOnlineStoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "feature-online-store-service")]
impl<T> super::stub::FeatureOnlineStoreService for FeatureOnlineStoreService<T>
where
    T: super::stub::FeatureOnlineStoreService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn fetch_feature_values(
        &self,
        req: crate::model::FetchFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchFeatureValuesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::fetch_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "fetch_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .fetch_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn fetch_feature_values(
        &self,
        req: crate::model::FetchFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchFeatureValuesResponse>> {
        self.inner.fetch_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_nearest_entities(
        &self,
        req: crate::model::SearchNearestEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchNearestEntitiesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::search_nearest_entities"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_nearest_entities",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .search_nearest_entities(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_nearest_entities(
        &self,
        req: crate::model::SearchNearestEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchNearestEntitiesResponse>> {
        self.inner.search_nearest_entities(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn generate_fetch_access_token(
        &self,
        req: crate::model::GenerateFetchAccessTokenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateFetchAccessTokenResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::generate_fetch_access_token"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "generate_fetch_access_token",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .generate_fetch_access_token(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn generate_fetch_access_token(
        &self,
        req: crate::model::GenerateFetchAccessTokenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateFetchAccessTokenResponse>> {
        self.inner.generate_fetch_access_token(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureOnlineStoreService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [FeatureRegistryService](super::stub::FeatureRegistryService) decorator for logging and tracing.
#[cfg(feature = "feature-registry-service")]
#[derive(Clone, Debug)]
pub struct FeatureRegistryService<T>
where
    T: super::stub::FeatureRegistryService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "feature-registry-service")]
impl<T> FeatureRegistryService<T>
where
    T: super::stub::FeatureRegistryService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "feature-registry-service")]
impl<T> super::stub::FeatureRegistryService for FeatureRegistryService<T>
where
    T: super::stub::FeatureRegistryService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_feature_group(
        &self,
        req: crate::model::CreateFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::create_feature_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_feature_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_feature_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_feature_group(
        &self,
        req: crate::model::CreateFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_feature_group(
        &self,
        req: crate::model::GetFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::get_feature_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_feature_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_feature_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_feature_group(
        &self,
        req: crate::model::GetFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FeatureGroup>> {
        self.inner.get_feature_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_feature_groups(
        &self,
        req: crate::model::ListFeatureGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureGroupsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::list_feature_groups"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_feature_groups",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_feature_groups(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_feature_groups(
        &self,
        req: crate::model::ListFeatureGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeatureGroupsResponse>> {
        self.inner.list_feature_groups(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_feature_group(
        &self,
        req: crate::model::UpdateFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::update_feature_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_feature_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_feature_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_feature_group(
        &self,
        req: crate::model::UpdateFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_feature_group(
        &self,
        req: crate::model::DeleteFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::delete_feature_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_feature_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_feature_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_feature_group(
        &self,
        req: crate::model::DeleteFeatureGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_feature(
        &self,
        req: crate::model::CreateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::create_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_feature(
        &self,
        req: crate::model::CreateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_create_features(
        &self,
        req: crate::model::BatchCreateFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::batch_create_features"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_create_features",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_create_features(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_create_features(
        &self,
        req: crate::model::BatchCreateFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_features(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_feature(
        &self,
        req: crate::model::GetFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::get_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_feature(
        &self,
        req: crate::model::GetFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        self.inner.get_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_features(
        &self,
        req: crate::model::ListFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::list_features"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_features",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_features(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_features(
        &self,
        req: crate::model::ListFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturesResponse>> {
        self.inner.list_features(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_feature(
        &self,
        req: crate::model::UpdateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::update_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_feature(
        &self,
        req: crate::model::UpdateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_feature(
        &self,
        req: crate::model::DeleteFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::delete_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_feature(
        &self,
        req: crate::model::DeleteFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeatureRegistryService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [FeaturestoreOnlineServingService](super::stub::FeaturestoreOnlineServingService) decorator for logging and tracing.
#[cfg(feature = "featurestore-online-serving-service")]
#[derive(Clone, Debug)]
pub struct FeaturestoreOnlineServingService<T>
where
    T: super::stub::FeaturestoreOnlineServingService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "featurestore-online-serving-service")]
impl<T> FeaturestoreOnlineServingService<T>
where
    T: super::stub::FeaturestoreOnlineServingService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "featurestore-online-serving-service")]
impl<T> super::stub::FeaturestoreOnlineServingService for FeaturestoreOnlineServingService<T>
where
    T: super::stub::FeaturestoreOnlineServingService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn read_feature_values(
        &self,
        req: crate::model::ReadFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadFeatureValuesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::read_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "read_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .read_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn read_feature_values(
        &self,
        req: crate::model::ReadFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadFeatureValuesResponse>> {
        self.inner.read_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn write_feature_values(
        &self,
        req: crate::model::WriteFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteFeatureValuesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::write_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "write_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .write_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn write_feature_values(
        &self,
        req: crate::model::WriteFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteFeatureValuesResponse>> {
        self.inner.write_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreOnlineServingService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [FeaturestoreService](super::stub::FeaturestoreService) decorator for logging and tracing.
#[cfg(feature = "featurestore-service")]
#[derive(Clone, Debug)]
pub struct FeaturestoreService<T>
where
    T: super::stub::FeaturestoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "featurestore-service")]
impl<T> FeaturestoreService<T>
where
    T: super::stub::FeaturestoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "featurestore-service")]
impl<T> super::stub::FeaturestoreService for FeaturestoreService<T>
where
    T: super::stub::FeaturestoreService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_featurestore(
        &self,
        req: crate::model::CreateFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::create_featurestore"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_featurestore",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_featurestore(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_featurestore(
        &self,
        req: crate::model::CreateFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_featurestore(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_featurestore(
        &self,
        req: crate::model::GetFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Featurestore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::get_featurestore"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_featurestore",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_featurestore(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_featurestore(
        &self,
        req: crate::model::GetFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Featurestore>> {
        self.inner.get_featurestore(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_featurestores(
        &self,
        req: crate::model::ListFeaturestoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturestoresResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::list_featurestores"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_featurestores",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_featurestores(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_featurestores(
        &self,
        req: crate::model::ListFeaturestoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturestoresResponse>> {
        self.inner.list_featurestores(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_featurestore(
        &self,
        req: crate::model::UpdateFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::update_featurestore"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_featurestore",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_featurestore(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_featurestore(
        &self,
        req: crate::model::UpdateFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_featurestore(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_featurestore(
        &self,
        req: crate::model::DeleteFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::delete_featurestore"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_featurestore",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_featurestore(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_featurestore(
        &self,
        req: crate::model::DeleteFeaturestoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_featurestore(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::create_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::get_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.get_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::list_entity_types"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_entity_types",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_entity_types(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        self.inner.list_entity_types(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::update_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.update_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::delete_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_feature(
        &self,
        req: crate::model::CreateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::create_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_feature(
        &self,
        req: crate::model::CreateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_create_features(
        &self,
        req: crate::model::BatchCreateFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::batch_create_features"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_create_features",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_create_features(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_create_features(
        &self,
        req: crate::model::BatchCreateFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_features(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_feature(
        &self,
        req: crate::model::GetFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::get_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_feature(
        &self,
        req: crate::model::GetFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        self.inner.get_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_features(
        &self,
        req: crate::model::ListFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::list_features"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_features",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_features(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_features(
        &self,
        req: crate::model::ListFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFeaturesResponse>> {
        self.inner.list_features(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_feature(
        &self,
        req: crate::model::UpdateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::update_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_feature(
        &self,
        req: crate::model::UpdateFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Feature>> {
        self.inner.update_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_feature(
        &self,
        req: crate::model::DeleteFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::delete_feature"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_feature",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_feature(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_feature(
        &self,
        req: crate::model::DeleteFeatureRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_feature_values(
        &self,
        req: crate::model::ImportFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::import_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_feature_values(
        &self,
        req: crate::model::ImportFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_read_feature_values(
        &self,
        req: crate::model::BatchReadFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::batch_read_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_read_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_read_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_read_feature_values(
        &self,
        req: crate::model::BatchReadFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_read_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_feature_values(
        &self,
        req: crate::model::ExportFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::export_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_feature_values(
        &self,
        req: crate::model::ExportFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_feature_values(
        &self,
        req: crate::model::DeleteFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::delete_feature_values"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_feature_values",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_feature_values(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_feature_values(
        &self,
        req: crate::model::DeleteFeatureValuesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_feature_values(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_features(
        &self,
        req: crate::model::SearchFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchFeaturesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::search_features"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_features",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .search_features(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_features(
        &self,
        req: crate::model::SearchFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchFeaturesResponse>> {
        self.inner.search_features(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "FeaturestoreService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GenAiCacheService](super::stub::GenAiCacheService) decorator for logging and tracing.
#[cfg(feature = "gen-ai-cache-service")]
#[derive(Clone, Debug)]
pub struct GenAiCacheService<T>
where
    T: super::stub::GenAiCacheService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "gen-ai-cache-service")]
impl<T> GenAiCacheService<T>
where
    T: super::stub::GenAiCacheService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "gen-ai-cache-service")]
impl<T> super::stub::GenAiCacheService for GenAiCacheService<T>
where
    T: super::stub::GenAiCacheService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_cached_content(
        &self,
        req: crate::model::CreateCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::create_cached_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_cached_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_cached_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_cached_content(
        &self,
        req: crate::model::CreateCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        self.inner.create_cached_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_cached_content(
        &self,
        req: crate::model::GetCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::get_cached_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_cached_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_cached_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_cached_content(
        &self,
        req: crate::model::GetCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        self.inner.get_cached_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_cached_content(
        &self,
        req: crate::model::UpdateCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::update_cached_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_cached_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_cached_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_cached_content(
        &self,
        req: crate::model::UpdateCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CachedContent>> {
        self.inner.update_cached_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_cached_content(
        &self,
        req: crate::model::DeleteCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::delete_cached_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_cached_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_cached_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_cached_content(
        &self,
        req: crate::model::DeleteCachedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_cached_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_cached_contents(
        &self,
        req: crate::model::ListCachedContentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCachedContentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::list_cached_contents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_cached_contents",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_cached_contents(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_cached_contents(
        &self,
        req: crate::model::ListCachedContentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCachedContentsResponse>> {
        self.inner.list_cached_contents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiCacheService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [GenAiTuningService](super::stub::GenAiTuningService) decorator for logging and tracing.
#[cfg(feature = "gen-ai-tuning-service")]
#[derive(Clone, Debug)]
pub struct GenAiTuningService<T>
where
    T: super::stub::GenAiTuningService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "gen-ai-tuning-service")]
impl<T> GenAiTuningService<T>
where
    T: super::stub::GenAiTuningService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "gen-ai-tuning-service")]
impl<T> super::stub::GenAiTuningService for GenAiTuningService<T>
where
    T: super::stub::GenAiTuningService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tuning_job(
        &self,
        req: crate::model::CreateTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TuningJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::create_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tuning_job(
        &self,
        req: crate::model::CreateTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TuningJob>> {
        self.inner.create_tuning_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_tuning_job(
        &self,
        req: crate::model::GetTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TuningJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::get_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_tuning_job(
        &self,
        req: crate::model::GetTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TuningJob>> {
        self.inner.get_tuning_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tuning_jobs(
        &self,
        req: crate::model::ListTuningJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTuningJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::list_tuning_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tuning_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tuning_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tuning_jobs(
        &self,
        req: crate::model::ListTuningJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTuningJobsResponse>> {
        self.inner.list_tuning_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_tuning_job(
        &self,
        req: crate::model::CancelTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::cancel_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_tuning_job(
        &self,
        req: crate::model::CancelTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_tuning_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn rebase_tuned_model(
        &self,
        req: crate::model::RebaseTunedModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::rebase_tuned_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "rebase_tuned_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .rebase_tuned_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn rebase_tuned_model(
        &self,
        req: crate::model::RebaseTunedModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.rebase_tuned_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GenAiTuningService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [IndexEndpointService](super::stub::IndexEndpointService) decorator for logging and tracing.
#[cfg(feature = "index-endpoint-service")]
#[derive(Clone, Debug)]
pub struct IndexEndpointService<T>
where
    T: super::stub::IndexEndpointService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "index-endpoint-service")]
impl<T> IndexEndpointService<T>
where
    T: super::stub::IndexEndpointService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "index-endpoint-service")]
impl<T> super::stub::IndexEndpointService for IndexEndpointService<T>
where
    T: super::stub::IndexEndpointService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_index_endpoint(
        &self,
        req: crate::model::CreateIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::create_index_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_index_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_index_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_index_endpoint(
        &self,
        req: crate::model::CreateIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_index_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_index_endpoint(
        &self,
        req: crate::model::GetIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IndexEndpoint>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::get_index_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_index_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_index_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_index_endpoint(
        &self,
        req: crate::model::GetIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IndexEndpoint>> {
        self.inner.get_index_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_index_endpoints(
        &self,
        req: crate::model::ListIndexEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIndexEndpointsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::list_index_endpoints"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_index_endpoints",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_index_endpoints(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_index_endpoints(
        &self,
        req: crate::model::ListIndexEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIndexEndpointsResponse>> {
        self.inner.list_index_endpoints(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_index_endpoint(
        &self,
        req: crate::model::UpdateIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IndexEndpoint>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::update_index_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_index_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_index_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_index_endpoint(
        &self,
        req: crate::model::UpdateIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IndexEndpoint>> {
        self.inner.update_index_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_index_endpoint(
        &self,
        req: crate::model::DeleteIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::delete_index_endpoint"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_index_endpoint",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_index_endpoint(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_index_endpoint(
        &self,
        req: crate::model::DeleteIndexEndpointRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_index_endpoint(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn deploy_index(
        &self,
        req: crate::model::DeployIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::deploy_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "deploy_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .deploy_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn deploy_index(
        &self,
        req: crate::model::DeployIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn undeploy_index(
        &self,
        req: crate::model::UndeployIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::undeploy_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "undeploy_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .undeploy_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn undeploy_index(
        &self,
        req: crate::model::UndeployIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.undeploy_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn mutate_deployed_index(
        &self,
        req: crate::model::MutateDeployedIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::mutate_deployed_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "mutate_deployed_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .mutate_deployed_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn mutate_deployed_index(
        &self,
        req: crate::model::MutateDeployedIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.mutate_deployed_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexEndpointService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [IndexService](super::stub::IndexService) decorator for logging and tracing.
#[cfg(feature = "index-service")]
#[derive(Clone, Debug)]
pub struct IndexService<T>
where
    T: super::stub::IndexService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "index-service")]
impl<T> IndexService<T>
where
    T: super::stub::IndexService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "index-service")]
impl<T> super::stub::IndexService for IndexService<T>
where
    T: super::stub::IndexService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_index(
        &self,
        req: crate::model::CreateIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::create_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_index(
        &self,
        req: crate::model::CreateIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_index(
        &self,
        req: crate::model::GetIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Index>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::get_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_index(
        &self,
        req: crate::model::GetIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Index>> {
        self.inner.get_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_indexes(
        &self,
        req: crate::model::ListIndexesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIndexesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::list_indexes"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_indexes",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_indexes(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_indexes(
        &self,
        req: crate::model::ListIndexesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIndexesResponse>> {
        self.inner.list_indexes(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_index(
        &self,
        req: crate::model::UpdateIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::update_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_index(
        &self,
        req: crate::model::UpdateIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_index(
        &self,
        req: crate::model::DeleteIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::delete_index"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_index",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_index(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_index(
        &self,
        req: crate::model::DeleteIndexRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_index(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn upsert_datapoints(
        &self,
        req: crate::model::UpsertDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UpsertDatapointsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::upsert_datapoints"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "upsert_datapoints",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .upsert_datapoints(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn upsert_datapoints(
        &self,
        req: crate::model::UpsertDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UpsertDatapointsResponse>> {
        self.inner.upsert_datapoints(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn remove_datapoints(
        &self,
        req: crate::model::RemoveDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RemoveDatapointsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::remove_datapoints"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "remove_datapoints",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .remove_datapoints(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn remove_datapoints(
        &self,
        req: crate::model::RemoveDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RemoveDatapointsResponse>> {
        self.inner.remove_datapoints(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IndexService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [JobService](super::stub::JobService) decorator for logging and tracing.
#[cfg(feature = "job-service")]
#[derive(Clone, Debug)]
pub struct JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "job-service")]
impl<T> JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "job-service")]
impl<T> super::stub::JobService for JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_custom_job(
        &self,
        req: crate::model::CreateCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CustomJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::create_custom_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_custom_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_custom_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_custom_job(
        &self,
        req: crate::model::CreateCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CustomJob>> {
        self.inner.create_custom_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_custom_job(
        &self,
        req: crate::model::GetCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CustomJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_custom_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_custom_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_custom_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_custom_job(
        &self,
        req: crate::model::GetCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CustomJob>> {
        self.inner.get_custom_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_custom_jobs(
        &self,
        req: crate::model::ListCustomJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCustomJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_custom_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_custom_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_custom_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_custom_jobs(
        &self,
        req: crate::model::ListCustomJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCustomJobsResponse>> {
        self.inner.list_custom_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_custom_job(
        &self,
        req: crate::model::DeleteCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_custom_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_custom_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_custom_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_custom_job(
        &self,
        req: crate::model::DeleteCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_custom_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_custom_job(
        &self,
        req: crate::model::CancelCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_custom_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_custom_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_custom_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_custom_job(
        &self,
        req: crate::model::CancelCustomJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_custom_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_data_labeling_job(
        &self,
        req: crate::model::CreateDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataLabelingJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::create_data_labeling_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_data_labeling_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_data_labeling_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_data_labeling_job(
        &self,
        req: crate::model::CreateDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataLabelingJob>> {
        self.inner.create_data_labeling_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_data_labeling_job(
        &self,
        req: crate::model::GetDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataLabelingJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_data_labeling_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_data_labeling_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_data_labeling_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_data_labeling_job(
        &self,
        req: crate::model::GetDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataLabelingJob>> {
        self.inner.get_data_labeling_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_data_labeling_jobs(
        &self,
        req: crate::model::ListDataLabelingJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataLabelingJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_data_labeling_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_data_labeling_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_data_labeling_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_data_labeling_jobs(
        &self,
        req: crate::model::ListDataLabelingJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataLabelingJobsResponse>> {
        self.inner.list_data_labeling_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_data_labeling_job(
        &self,
        req: crate::model::DeleteDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_data_labeling_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_data_labeling_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_data_labeling_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_data_labeling_job(
        &self,
        req: crate::model::DeleteDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_data_labeling_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_data_labeling_job(
        &self,
        req: crate::model::CancelDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_data_labeling_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_data_labeling_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_data_labeling_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_data_labeling_job(
        &self,
        req: crate::model::CancelDataLabelingJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_data_labeling_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_hyperparameter_tuning_job(
        &self,
        req: crate::model::CreateHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HyperparameterTuningJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::create_hyperparameter_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_hyperparameter_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_hyperparameter_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_hyperparameter_tuning_job(
        &self,
        req: crate::model::CreateHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HyperparameterTuningJob>> {
        self.inner
            .create_hyperparameter_tuning_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_hyperparameter_tuning_job(
        &self,
        req: crate::model::GetHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HyperparameterTuningJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_hyperparameter_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_hyperparameter_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_hyperparameter_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_hyperparameter_tuning_job(
        &self,
        req: crate::model::GetHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HyperparameterTuningJob>> {
        self.inner.get_hyperparameter_tuning_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_hyperparameter_tuning_jobs(
        &self,
        req: crate::model::ListHyperparameterTuningJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHyperparameterTuningJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_hyperparameter_tuning_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_hyperparameter_tuning_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_hyperparameter_tuning_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_hyperparameter_tuning_jobs(
        &self,
        req: crate::model::ListHyperparameterTuningJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHyperparameterTuningJobsResponse>> {
        self.inner
            .list_hyperparameter_tuning_jobs(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_hyperparameter_tuning_job(
        &self,
        req: crate::model::DeleteHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_hyperparameter_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_hyperparameter_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_hyperparameter_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_hyperparameter_tuning_job(
        &self,
        req: crate::model::DeleteHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_hyperparameter_tuning_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_hyperparameter_tuning_job(
        &self,
        req: crate::model::CancelHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_hyperparameter_tuning_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_hyperparameter_tuning_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_hyperparameter_tuning_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_hyperparameter_tuning_job(
        &self,
        req: crate::model::CancelHyperparameterTuningJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .cancel_hyperparameter_tuning_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_nas_job(
        &self,
        req: crate::model::CreateNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::create_nas_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_nas_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_nas_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_nas_job(
        &self,
        req: crate::model::CreateNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasJob>> {
        self.inner.create_nas_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_nas_job(
        &self,
        req: crate::model::GetNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_nas_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_nas_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_nas_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_nas_job(
        &self,
        req: crate::model::GetNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasJob>> {
        self.inner.get_nas_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_nas_jobs(
        &self,
        req: crate::model::ListNasJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNasJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_nas_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_nas_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_nas_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_nas_jobs(
        &self,
        req: crate::model::ListNasJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNasJobsResponse>> {
        self.inner.list_nas_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_nas_job(
        &self,
        req: crate::model::DeleteNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_nas_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_nas_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_nas_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_nas_job(
        &self,
        req: crate::model::DeleteNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_nas_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_nas_job(
        &self,
        req: crate::model::CancelNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_nas_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_nas_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_nas_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_nas_job(
        &self,
        req: crate::model::CancelNasJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_nas_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_nas_trial_detail(
        &self,
        req: crate::model::GetNasTrialDetailRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasTrialDetail>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_nas_trial_detail"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_nas_trial_detail",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_nas_trial_detail(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_nas_trial_detail(
        &self,
        req: crate::model::GetNasTrialDetailRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NasTrialDetail>> {
        self.inner.get_nas_trial_detail(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_nas_trial_details(
        &self,
        req: crate::model::ListNasTrialDetailsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNasTrialDetailsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_nas_trial_details"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_nas_trial_details",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_nas_trial_details(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_nas_trial_details(
        &self,
        req: crate::model::ListNasTrialDetailsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNasTrialDetailsResponse>> {
        self.inner.list_nas_trial_details(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_batch_prediction_job(
        &self,
        req: crate::model::CreateBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchPredictionJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::create_batch_prediction_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_batch_prediction_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_batch_prediction_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_batch_prediction_job(
        &self,
        req: crate::model::CreateBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchPredictionJob>> {
        self.inner.create_batch_prediction_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_batch_prediction_job(
        &self,
        req: crate::model::GetBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchPredictionJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_batch_prediction_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_batch_prediction_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_batch_prediction_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_batch_prediction_job(
        &self,
        req: crate::model::GetBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchPredictionJob>> {
        self.inner.get_batch_prediction_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_batch_prediction_jobs(
        &self,
        req: crate::model::ListBatchPredictionJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBatchPredictionJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_batch_prediction_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_batch_prediction_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_batch_prediction_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_batch_prediction_jobs(
        &self,
        req: crate::model::ListBatchPredictionJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBatchPredictionJobsResponse>> {
        self.inner.list_batch_prediction_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_batch_prediction_job(
        &self,
        req: crate::model::DeleteBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_batch_prediction_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_batch_prediction_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_batch_prediction_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_batch_prediction_job(
        &self,
        req: crate::model::DeleteBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_batch_prediction_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_batch_prediction_job(
        &self,
        req: crate::model::CancelBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_batch_prediction_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_batch_prediction_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_batch_prediction_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_batch_prediction_job(
        &self,
        req: crate::model::CancelBatchPredictionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_batch_prediction_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_model_deployment_monitoring_job(
        &self,
        req: crate::model::CreateModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelDeploymentMonitoringJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::create_model_deployment_monitoring_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_model_deployment_monitoring_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_model_deployment_monitoring_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_model_deployment_monitoring_job(
        &self,
        req: crate::model::CreateModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelDeploymentMonitoringJob>> {
        self.inner
            .create_model_deployment_monitoring_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_model_deployment_monitoring_stats_anomalies(
        &self,
        req: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse,
        >,
    > {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::search_model_deployment_monitoring_stats_anomalies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_model_deployment_monitoring_stats_anomalies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .search_model_deployment_monitoring_stats_anomalies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_model_deployment_monitoring_stats_anomalies(
        &self,
        req: crate::model::SearchModelDeploymentMonitoringStatsAnomaliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SearchModelDeploymentMonitoringStatsAnomaliesResponse,
        >,
    > {
        self.inner
            .search_model_deployment_monitoring_stats_anomalies(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_model_deployment_monitoring_job(
        &self,
        req: crate::model::GetModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelDeploymentMonitoringJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_model_deployment_monitoring_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_model_deployment_monitoring_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_model_deployment_monitoring_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_model_deployment_monitoring_job(
        &self,
        req: crate::model::GetModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelDeploymentMonitoringJob>> {
        self.inner
            .get_model_deployment_monitoring_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_model_deployment_monitoring_jobs(
        &self,
        req: crate::model::ListModelDeploymentMonitoringJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelDeploymentMonitoringJobsResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_model_deployment_monitoring_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_model_deployment_monitoring_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_model_deployment_monitoring_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_model_deployment_monitoring_jobs(
        &self,
        req: crate::model::ListModelDeploymentMonitoringJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelDeploymentMonitoringJobsResponse>>
    {
        self.inner
            .list_model_deployment_monitoring_jobs(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_model_deployment_monitoring_job(
        &self,
        req: crate::model::UpdateModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::update_model_deployment_monitoring_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_model_deployment_monitoring_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_model_deployment_monitoring_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_model_deployment_monitoring_job(
        &self,
        req: crate::model::UpdateModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .update_model_deployment_monitoring_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_model_deployment_monitoring_job(
        &self,
        req: crate::model::DeleteModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_model_deployment_monitoring_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_model_deployment_monitoring_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_model_deployment_monitoring_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_model_deployment_monitoring_job(
        &self,
        req: crate::model::DeleteModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_model_deployment_monitoring_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn pause_model_deployment_monitoring_job(
        &self,
        req: crate::model::PauseModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::pause_model_deployment_monitoring_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "pause_model_deployment_monitoring_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .pause_model_deployment_monitoring_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn pause_model_deployment_monitoring_job(
        &self,
        req: crate::model::PauseModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .pause_model_deployment_monitoring_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn resume_model_deployment_monitoring_job(
        &self,
        req: crate::model::ResumeModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::resume_model_deployment_monitoring_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "resume_model_deployment_monitoring_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .resume_model_deployment_monitoring_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn resume_model_deployment_monitoring_job(
        &self,
        req: crate::model::ResumeModelDeploymentMonitoringJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .resume_model_deployment_monitoring_job(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [LlmUtilityService](super::stub::LlmUtilityService) decorator for logging and tracing.
#[cfg(feature = "llm-utility-service")]
#[derive(Clone, Debug)]
pub struct LlmUtilityService<T>
where
    T: super::stub::LlmUtilityService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "llm-utility-service")]
impl<T> LlmUtilityService<T>
where
    T: super::stub::LlmUtilityService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "llm-utility-service")]
impl<T> super::stub::LlmUtilityService for LlmUtilityService<T>
where
    T: super::stub::LlmUtilityService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn count_tokens(
        &self,
        req: crate::model::CountTokensRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CountTokensResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::count_tokens"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "count_tokens",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .count_tokens(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn count_tokens(
        &self,
        req: crate::model::CountTokensRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CountTokensResponse>> {
        self.inner.count_tokens(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn compute_tokens(
        &self,
        req: crate::model::ComputeTokensRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ComputeTokensResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::compute_tokens"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "compute_tokens",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .compute_tokens(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn compute_tokens(
        &self,
        req: crate::model::ComputeTokensRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ComputeTokensResponse>> {
        self.inner.compute_tokens(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "LlmUtilityService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [MatchService](super::stub::MatchService) decorator for logging and tracing.
#[cfg(feature = "match-service")]
#[derive(Clone, Debug)]
pub struct MatchService<T>
where
    T: super::stub::MatchService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "match-service")]
impl<T> MatchService<T>
where
    T: super::stub::MatchService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "match-service")]
impl<T> super::stub::MatchService for MatchService<T>
where
    T: super::stub::MatchService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn find_neighbors(
        &self,
        req: crate::model::FindNeighborsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FindNeighborsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::find_neighbors"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "find_neighbors",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .find_neighbors(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn find_neighbors(
        &self,
        req: crate::model::FindNeighborsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FindNeighborsResponse>> {
        self.inner.find_neighbors(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn read_index_datapoints(
        &self,
        req: crate::model::ReadIndexDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadIndexDatapointsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::read_index_datapoints"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "read_index_datapoints",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .read_index_datapoints(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn read_index_datapoints(
        &self,
        req: crate::model::ReadIndexDatapointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadIndexDatapointsResponse>> {
        self.inner.read_index_datapoints(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MatchService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [MetadataService](super::stub::MetadataService) decorator for logging and tracing.
#[cfg(feature = "metadata-service")]
#[derive(Clone, Debug)]
pub struct MetadataService<T>
where
    T: super::stub::MetadataService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "metadata-service")]
impl<T> MetadataService<T>
where
    T: super::stub::MetadataService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "metadata-service")]
impl<T> super::stub::MetadataService for MetadataService<T>
where
    T: super::stub::MetadataService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_metadata_store(
        &self,
        req: crate::model::CreateMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::create_metadata_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_metadata_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_metadata_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_metadata_store(
        &self,
        req: crate::model::CreateMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_metadata_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_metadata_store(
        &self,
        req: crate::model::GetMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataStore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_metadata_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_metadata_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_metadata_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_metadata_store(
        &self,
        req: crate::model::GetMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataStore>> {
        self.inner.get_metadata_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_metadata_stores(
        &self,
        req: crate::model::ListMetadataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataStoresResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_metadata_stores"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_metadata_stores",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_metadata_stores(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_metadata_stores(
        &self,
        req: crate::model::ListMetadataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataStoresResponse>> {
        self.inner.list_metadata_stores(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_metadata_store(
        &self,
        req: crate::model::DeleteMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::delete_metadata_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_metadata_store",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_metadata_store(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_metadata_store(
        &self,
        req: crate::model::DeleteMetadataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_metadata_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_artifact(
        &self,
        req: crate::model::CreateArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::create_artifact"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_artifact",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_artifact(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_artifact(
        &self,
        req: crate::model::CreateArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        self.inner.create_artifact(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_artifact(
        &self,
        req: crate::model::GetArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_artifact"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_artifact",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_artifact(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_artifact(
        &self,
        req: crate::model::GetArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        self.inner.get_artifact(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_artifacts(
        &self,
        req: crate::model::ListArtifactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListArtifactsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_artifacts"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_artifacts",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_artifacts(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_artifacts(
        &self,
        req: crate::model::ListArtifactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListArtifactsResponse>> {
        self.inner.list_artifacts(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_artifact(
        &self,
        req: crate::model::UpdateArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::update_artifact"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_artifact",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_artifact(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_artifact(
        &self,
        req: crate::model::UpdateArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Artifact>> {
        self.inner.update_artifact(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_artifact(
        &self,
        req: crate::model::DeleteArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::delete_artifact"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_artifact",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_artifact(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_artifact(
        &self,
        req: crate::model::DeleteArtifactRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_artifact(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_artifacts(
        &self,
        req: crate::model::PurgeArtifactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::purge_artifacts"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_artifacts",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .purge_artifacts(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_artifacts(
        &self,
        req: crate::model::PurgeArtifactsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_artifacts(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_context(
        &self,
        req: crate::model::CreateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::create_context"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_context",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_context(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_context(
        &self,
        req: crate::model::CreateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.create_context(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_context(
        &self,
        req: crate::model::GetContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_context"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_context",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_context(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_context(
        &self,
        req: crate::model::GetContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.get_context(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_contexts(
        &self,
        req: crate::model::ListContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContextsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_contexts"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_contexts",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_contexts(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_contexts(
        &self,
        req: crate::model::ListContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContextsResponse>> {
        self.inner.list_contexts(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_context(
        &self,
        req: crate::model::UpdateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::update_context"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_context",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_context(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_context(
        &self,
        req: crate::model::UpdateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.update_context(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_context(
        &self,
        req: crate::model::DeleteContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::delete_context"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_context",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_context(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_context(
        &self,
        req: crate::model::DeleteContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_context(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_contexts(
        &self,
        req: crate::model::PurgeContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::purge_contexts"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_contexts",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .purge_contexts(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_contexts(
        &self,
        req: crate::model::PurgeContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_contexts(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn add_context_artifacts_and_executions(
        &self,
        req: crate::model::AddContextArtifactsAndExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddContextArtifactsAndExecutionsResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::add_context_artifacts_and_executions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "add_context_artifacts_and_executions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .add_context_artifacts_and_executions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn add_context_artifacts_and_executions(
        &self,
        req: crate::model::AddContextArtifactsAndExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddContextArtifactsAndExecutionsResponse>>
    {
        self.inner
            .add_context_artifacts_and_executions(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn add_context_children(
        &self,
        req: crate::model::AddContextChildrenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddContextChildrenResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::add_context_children"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "add_context_children",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .add_context_children(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn add_context_children(
        &self,
        req: crate::model::AddContextChildrenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddContextChildrenResponse>> {
        self.inner.add_context_children(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn remove_context_children(
        &self,
        req: crate::model::RemoveContextChildrenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RemoveContextChildrenResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::remove_context_children"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "remove_context_children",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .remove_context_children(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn remove_context_children(
        &self,
        req: crate::model::RemoveContextChildrenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RemoveContextChildrenResponse>> {
        self.inner.remove_context_children(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn query_context_lineage_subgraph(
        &self,
        req: crate::model::QueryContextLineageSubgraphRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::query_context_lineage_subgraph"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "query_context_lineage_subgraph",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .query_context_lineage_subgraph(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn query_context_lineage_subgraph(
        &self,
        req: crate::model::QueryContextLineageSubgraphRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        self.inner
            .query_context_lineage_subgraph(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_execution(
        &self,
        req: crate::model::CreateExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::create_execution"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_execution",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_execution(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_execution(
        &self,
        req: crate::model::CreateExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        self.inner.create_execution(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_execution(
        &self,
        req: crate::model::GetExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_execution"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_execution",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_execution(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_execution(
        &self,
        req: crate::model::GetExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        self.inner.get_execution(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_executions(
        &self,
        req: crate::model::ListExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListExecutionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_executions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_executions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_executions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_executions(
        &self,
        req: crate::model::ListExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListExecutionsResponse>> {
        self.inner.list_executions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_execution(
        &self,
        req: crate::model::UpdateExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::update_execution"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_execution",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_execution(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_execution(
        &self,
        req: crate::model::UpdateExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Execution>> {
        self.inner.update_execution(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_execution(
        &self,
        req: crate::model::DeleteExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::delete_execution"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_execution",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_execution(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_execution(
        &self,
        req: crate::model::DeleteExecutionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_execution(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_executions(
        &self,
        req: crate::model::PurgeExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::purge_executions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_executions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .purge_executions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_executions(
        &self,
        req: crate::model::PurgeExecutionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_executions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn add_execution_events(
        &self,
        req: crate::model::AddExecutionEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddExecutionEventsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::add_execution_events"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "add_execution_events",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .add_execution_events(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn add_execution_events(
        &self,
        req: crate::model::AddExecutionEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddExecutionEventsResponse>> {
        self.inner.add_execution_events(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn query_execution_inputs_and_outputs(
        &self,
        req: crate::model::QueryExecutionInputsAndOutputsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::query_execution_inputs_and_outputs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "query_execution_inputs_and_outputs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .query_execution_inputs_and_outputs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn query_execution_inputs_and_outputs(
        &self,
        req: crate::model::QueryExecutionInputsAndOutputsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        self.inner
            .query_execution_inputs_and_outputs(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_metadata_schema(
        &self,
        req: crate::model::CreateMetadataSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataSchema>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::create_metadata_schema"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_metadata_schema",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_metadata_schema(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_metadata_schema(
        &self,
        req: crate::model::CreateMetadataSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataSchema>> {
        self.inner.create_metadata_schema(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_metadata_schema(
        &self,
        req: crate::model::GetMetadataSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataSchema>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_metadata_schema"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_metadata_schema",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_metadata_schema(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_metadata_schema(
        &self,
        req: crate::model::GetMetadataSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataSchema>> {
        self.inner.get_metadata_schema(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_metadata_schemas(
        &self,
        req: crate::model::ListMetadataSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataSchemasResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_metadata_schemas"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_metadata_schemas",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_metadata_schemas(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_metadata_schemas(
        &self,
        req: crate::model::ListMetadataSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataSchemasResponse>> {
        self.inner.list_metadata_schemas(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn query_artifact_lineage_subgraph(
        &self,
        req: crate::model::QueryArtifactLineageSubgraphRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::query_artifact_lineage_subgraph"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "query_artifact_lineage_subgraph",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .query_artifact_lineage_subgraph(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn query_artifact_lineage_subgraph(
        &self,
        req: crate::model::QueryArtifactLineageSubgraphRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LineageSubgraph>> {
        self.inner
            .query_artifact_lineage_subgraph(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MetadataService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [MigrationService](super::stub::MigrationService) decorator for logging and tracing.
#[cfg(feature = "migration-service")]
#[derive(Clone, Debug)]
pub struct MigrationService<T>
where
    T: super::stub::MigrationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "migration-service")]
impl<T> MigrationService<T>
where
    T: super::stub::MigrationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "migration-service")]
impl<T> super::stub::MigrationService for MigrationService<T>
where
    T: super::stub::MigrationService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_migratable_resources(
        &self,
        req: crate::model::SearchMigratableResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchMigratableResourcesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::search_migratable_resources"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_migratable_resources",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .search_migratable_resources(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_migratable_resources(
        &self,
        req: crate::model::SearchMigratableResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchMigratableResourcesResponse>> {
        self.inner.search_migratable_resources(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_migrate_resources(
        &self,
        req: crate::model::BatchMigrateResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::batch_migrate_resources"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_migrate_resources",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_migrate_resources(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_migrate_resources(
        &self,
        req: crate::model::BatchMigrateResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_migrate_resources(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "MigrationService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ModelGardenService](super::stub::ModelGardenService) decorator for logging and tracing.
#[cfg(feature = "model-garden-service")]
#[derive(Clone, Debug)]
pub struct ModelGardenService<T>
where
    T: super::stub::ModelGardenService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "model-garden-service")]
impl<T> ModelGardenService<T>
where
    T: super::stub::ModelGardenService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "model-garden-service")]
impl<T> super::stub::ModelGardenService for ModelGardenService<T>
where
    T: super::stub::ModelGardenService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_publisher_model(
        &self,
        req: crate::model::GetPublisherModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublisherModel>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::get_publisher_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_publisher_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_publisher_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_publisher_model(
        &self,
        req: crate::model::GetPublisherModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublisherModel>> {
        self.inner.get_publisher_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn deploy(
        &self,
        req: crate::model::DeployRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::deploy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "deploy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .deploy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn deploy(
        &self,
        req: crate::model::DeployRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelGardenService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ModelService](super::stub::ModelService) decorator for logging and tracing.
#[cfg(feature = "model-service")]
#[derive(Clone, Debug)]
pub struct ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "model-service")]
impl<T> ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "model-service")]
impl<T> super::stub::ModelService for ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn upload_model(
        &self,
        req: crate::model::UploadModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::upload_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "upload_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .upload_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn upload_model(
        &self,
        req: crate::model::UploadModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.upload_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.get_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_models"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_models",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_models(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        self.inner.list_models(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_model_versions(
        &self,
        req: crate::model::ListModelVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelVersionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_model_versions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_model_versions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_model_versions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_model_versions(
        &self,
        req: crate::model::ListModelVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelVersionsResponse>> {
        self.inner.list_model_versions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_model_version_checkpoints(
        &self,
        req: crate::model::ListModelVersionCheckpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelVersionCheckpointsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_model_version_checkpoints"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_model_version_checkpoints",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_model_version_checkpoints(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_model_version_checkpoints(
        &self,
        req: crate::model::ListModelVersionCheckpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelVersionCheckpointsResponse>> {
        self.inner
            .list_model_version_checkpoints(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_model(
        &self,
        req: crate::model::UpdateModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::update_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_model(
        &self,
        req: crate::model::UpdateModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.update_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_explanation_dataset(
        &self,
        req: crate::model::UpdateExplanationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::update_explanation_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_explanation_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_explanation_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_explanation_dataset(
        &self,
        req: crate::model::UpdateExplanationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_explanation_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::delete_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_model_version(
        &self,
        req: crate::model::DeleteModelVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::delete_model_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_model_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_model_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_model_version(
        &self,
        req: crate::model::DeleteModelVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_model_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn merge_version_aliases(
        &self,
        req: crate::model::MergeVersionAliasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::merge_version_aliases"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "merge_version_aliases",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .merge_version_aliases(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn merge_version_aliases(
        &self,
        req: crate::model::MergeVersionAliasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.merge_version_aliases(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_model(
        &self,
        req: crate::model::ExportModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::export_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_model(
        &self,
        req: crate::model::ExportModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn copy_model(
        &self,
        req: crate::model::CopyModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::copy_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "copy_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .copy_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn copy_model(
        &self,
        req: crate::model::CopyModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.copy_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_model_evaluation(
        &self,
        req: crate::model::ImportModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::import_model_evaluation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_model_evaluation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_model_evaluation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_model_evaluation(
        &self,
        req: crate::model::ImportModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluation>> {
        self.inner.import_model_evaluation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_import_model_evaluation_slices(
        &self,
        req: crate::model::BatchImportModelEvaluationSlicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchImportModelEvaluationSlicesResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::batch_import_model_evaluation_slices"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_import_model_evaluation_slices",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_import_model_evaluation_slices(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_import_model_evaluation_slices(
        &self,
        req: crate::model::BatchImportModelEvaluationSlicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchImportModelEvaluationSlicesResponse>>
    {
        self.inner
            .batch_import_model_evaluation_slices(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_import_evaluated_annotations(
        &self,
        req: crate::model::BatchImportEvaluatedAnnotationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchImportEvaluatedAnnotationsResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::batch_import_evaluated_annotations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_import_evaluated_annotations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_import_evaluated_annotations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_import_evaluated_annotations(
        &self,
        req: crate::model::BatchImportEvaluatedAnnotationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchImportEvaluatedAnnotationsResponse>>
    {
        self.inner
            .batch_import_evaluated_annotations(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_model_evaluation(
        &self,
        req: crate::model::GetModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_model_evaluation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_model_evaluation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_model_evaluation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_model_evaluation(
        &self,
        req: crate::model::GetModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluation>> {
        self.inner.get_model_evaluation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_model_evaluations(
        &self,
        req: crate::model::ListModelEvaluationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelEvaluationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_model_evaluations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_model_evaluations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_model_evaluations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_model_evaluations(
        &self,
        req: crate::model::ListModelEvaluationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelEvaluationsResponse>> {
        self.inner.list_model_evaluations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_model_evaluation_slice(
        &self,
        req: crate::model::GetModelEvaluationSliceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluationSlice>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_model_evaluation_slice"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_model_evaluation_slice",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_model_evaluation_slice(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_model_evaluation_slice(
        &self,
        req: crate::model::GetModelEvaluationSliceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ModelEvaluationSlice>> {
        self.inner.get_model_evaluation_slice(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_model_evaluation_slices(
        &self,
        req: crate::model::ListModelEvaluationSlicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelEvaluationSlicesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_model_evaluation_slices"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_model_evaluation_slices",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_model_evaluation_slices(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_model_evaluation_slices(
        &self,
        req: crate::model::ListModelEvaluationSlicesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelEvaluationSlicesResponse>> {
        self.inner.list_model_evaluation_slices(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NotebookService](super::stub::NotebookService) decorator for logging and tracing.
#[cfg(feature = "notebook-service")]
#[derive(Clone, Debug)]
pub struct NotebookService<T>
where
    T: super::stub::NotebookService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "notebook-service")]
impl<T> NotebookService<T>
where
    T: super::stub::NotebookService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "notebook-service")]
impl<T> super::stub::NotebookService for NotebookService<T>
where
    T: super::stub::NotebookService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_notebook_runtime_template(
        &self,
        req: crate::model::CreateNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::create_notebook_runtime_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_notebook_runtime_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_notebook_runtime_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_notebook_runtime_template(
        &self,
        req: crate::model::CreateNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .create_notebook_runtime_template(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_notebook_runtime_template(
        &self,
        req: crate::model::GetNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntimeTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::get_notebook_runtime_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_notebook_runtime_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_notebook_runtime_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_notebook_runtime_template(
        &self,
        req: crate::model::GetNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntimeTemplate>> {
        self.inner.get_notebook_runtime_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_notebook_runtime_templates(
        &self,
        req: crate::model::ListNotebookRuntimeTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookRuntimeTemplatesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::list_notebook_runtime_templates"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_notebook_runtime_templates",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_notebook_runtime_templates(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_notebook_runtime_templates(
        &self,
        req: crate::model::ListNotebookRuntimeTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookRuntimeTemplatesResponse>> {
        self.inner
            .list_notebook_runtime_templates(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_notebook_runtime_template(
        &self,
        req: crate::model::DeleteNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::delete_notebook_runtime_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_notebook_runtime_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_notebook_runtime_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_notebook_runtime_template(
        &self,
        req: crate::model::DeleteNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_notebook_runtime_template(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_notebook_runtime_template(
        &self,
        req: crate::model::UpdateNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntimeTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::update_notebook_runtime_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_notebook_runtime_template",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_notebook_runtime_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_notebook_runtime_template(
        &self,
        req: crate::model::UpdateNotebookRuntimeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntimeTemplate>> {
        self.inner
            .update_notebook_runtime_template(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn assign_notebook_runtime(
        &self,
        req: crate::model::AssignNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::assign_notebook_runtime"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "assign_notebook_runtime",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .assign_notebook_runtime(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn assign_notebook_runtime(
        &self,
        req: crate::model::AssignNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.assign_notebook_runtime(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_notebook_runtime(
        &self,
        req: crate::model::GetNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntime>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::get_notebook_runtime"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_notebook_runtime",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_notebook_runtime(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_notebook_runtime(
        &self,
        req: crate::model::GetNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookRuntime>> {
        self.inner.get_notebook_runtime(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_notebook_runtimes(
        &self,
        req: crate::model::ListNotebookRuntimesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookRuntimesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::list_notebook_runtimes"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_notebook_runtimes",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_notebook_runtimes(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_notebook_runtimes(
        &self,
        req: crate::model::ListNotebookRuntimesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookRuntimesResponse>> {
        self.inner.list_notebook_runtimes(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_notebook_runtime(
        &self,
        req: crate::model::DeleteNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::delete_notebook_runtime"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_notebook_runtime",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_notebook_runtime(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_notebook_runtime(
        &self,
        req: crate::model::DeleteNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_notebook_runtime(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn upgrade_notebook_runtime(
        &self,
        req: crate::model::UpgradeNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::upgrade_notebook_runtime"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "upgrade_notebook_runtime",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .upgrade_notebook_runtime(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn upgrade_notebook_runtime(
        &self,
        req: crate::model::UpgradeNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.upgrade_notebook_runtime(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn start_notebook_runtime(
        &self,
        req: crate::model::StartNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::start_notebook_runtime"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "start_notebook_runtime",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .start_notebook_runtime(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn start_notebook_runtime(
        &self,
        req: crate::model::StartNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.start_notebook_runtime(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn stop_notebook_runtime(
        &self,
        req: crate::model::StopNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::stop_notebook_runtime"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "stop_notebook_runtime",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .stop_notebook_runtime(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn stop_notebook_runtime(
        &self,
        req: crate::model::StopNotebookRuntimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.stop_notebook_runtime(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_notebook_execution_job(
        &self,
        req: crate::model::CreateNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::create_notebook_execution_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_notebook_execution_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_notebook_execution_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_notebook_execution_job(
        &self,
        req: crate::model::CreateNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_notebook_execution_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_notebook_execution_job(
        &self,
        req: crate::model::GetNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookExecutionJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::get_notebook_execution_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_notebook_execution_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_notebook_execution_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_notebook_execution_job(
        &self,
        req: crate::model::GetNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotebookExecutionJob>> {
        self.inner.get_notebook_execution_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_notebook_execution_jobs(
        &self,
        req: crate::model::ListNotebookExecutionJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookExecutionJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::list_notebook_execution_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_notebook_execution_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_notebook_execution_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_notebook_execution_jobs(
        &self,
        req: crate::model::ListNotebookExecutionJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNotebookExecutionJobsResponse>> {
        self.inner.list_notebook_execution_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_notebook_execution_job(
        &self,
        req: crate::model::DeleteNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::delete_notebook_execution_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_notebook_execution_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_notebook_execution_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_notebook_execution_job(
        &self,
        req: crate::model::DeleteNotebookExecutionJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_notebook_execution_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NotebookService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PersistentResourceService](super::stub::PersistentResourceService) decorator for logging and tracing.
#[cfg(feature = "persistent-resource-service")]
#[derive(Clone, Debug)]
pub struct PersistentResourceService<T>
where
    T: super::stub::PersistentResourceService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "persistent-resource-service")]
impl<T> PersistentResourceService<T>
where
    T: super::stub::PersistentResourceService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "persistent-resource-service")]
impl<T> super::stub::PersistentResourceService for PersistentResourceService<T>
where
    T: super::stub::PersistentResourceService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_persistent_resource(
        &self,
        req: crate::model::CreatePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::create_persistent_resource"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_persistent_resource",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_persistent_resource(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_persistent_resource(
        &self,
        req: crate::model::CreatePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_persistent_resource(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_persistent_resource(
        &self,
        req: crate::model::GetPersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PersistentResource>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::get_persistent_resource"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_persistent_resource",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_persistent_resource(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_persistent_resource(
        &self,
        req: crate::model::GetPersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PersistentResource>> {
        self.inner.get_persistent_resource(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_persistent_resources(
        &self,
        req: crate::model::ListPersistentResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPersistentResourcesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::list_persistent_resources"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_persistent_resources",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_persistent_resources(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_persistent_resources(
        &self,
        req: crate::model::ListPersistentResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPersistentResourcesResponse>> {
        self.inner.list_persistent_resources(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_persistent_resource(
        &self,
        req: crate::model::DeletePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::delete_persistent_resource"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_persistent_resource",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_persistent_resource(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_persistent_resource(
        &self,
        req: crate::model::DeletePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_persistent_resource(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_persistent_resource(
        &self,
        req: crate::model::UpdatePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::update_persistent_resource"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_persistent_resource",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_persistent_resource(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_persistent_resource(
        &self,
        req: crate::model::UpdatePersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_persistent_resource(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn reboot_persistent_resource(
        &self,
        req: crate::model::RebootPersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::reboot_persistent_resource"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "reboot_persistent_resource",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .reboot_persistent_resource(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn reboot_persistent_resource(
        &self,
        req: crate::model::RebootPersistentResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.reboot_persistent_resource(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PersistentResourceService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PipelineService](super::stub::PipelineService) decorator for logging and tracing.
#[cfg(feature = "pipeline-service")]
#[derive(Clone, Debug)]
pub struct PipelineService<T>
where
    T: super::stub::PipelineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "pipeline-service")]
impl<T> PipelineService<T>
where
    T: super::stub::PipelineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "pipeline-service")]
impl<T> super::stub::PipelineService for PipelineService<T>
where
    T: super::stub::PipelineService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_training_pipeline(
        &self,
        req: crate::model::CreateTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TrainingPipeline>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::create_training_pipeline"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_training_pipeline",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_training_pipeline(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_training_pipeline(
        &self,
        req: crate::model::CreateTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TrainingPipeline>> {
        self.inner.create_training_pipeline(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_training_pipeline(
        &self,
        req: crate::model::GetTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TrainingPipeline>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::get_training_pipeline"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_training_pipeline",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_training_pipeline(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_training_pipeline(
        &self,
        req: crate::model::GetTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TrainingPipeline>> {
        self.inner.get_training_pipeline(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_training_pipelines(
        &self,
        req: crate::model::ListTrainingPipelinesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTrainingPipelinesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::list_training_pipelines"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_training_pipelines",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_training_pipelines(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_training_pipelines(
        &self,
        req: crate::model::ListTrainingPipelinesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTrainingPipelinesResponse>> {
        self.inner.list_training_pipelines(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_training_pipeline(
        &self,
        req: crate::model::DeleteTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::delete_training_pipeline"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_training_pipeline",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_training_pipeline(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_training_pipeline(
        &self,
        req: crate::model::DeleteTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_training_pipeline(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_training_pipeline(
        &self,
        req: crate::model::CancelTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::cancel_training_pipeline"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_training_pipeline",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_training_pipeline(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_training_pipeline(
        &self,
        req: crate::model::CancelTrainingPipelineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_training_pipeline(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_pipeline_job(
        &self,
        req: crate::model::CreatePipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PipelineJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::create_pipeline_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_pipeline_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_pipeline_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_pipeline_job(
        &self,
        req: crate::model::CreatePipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PipelineJob>> {
        self.inner.create_pipeline_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_pipeline_job(
        &self,
        req: crate::model::GetPipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PipelineJob>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::get_pipeline_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_pipeline_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_pipeline_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_pipeline_job(
        &self,
        req: crate::model::GetPipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PipelineJob>> {
        self.inner.get_pipeline_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_pipeline_jobs(
        &self,
        req: crate::model::ListPipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPipelineJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::list_pipeline_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_pipeline_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_pipeline_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_pipeline_jobs(
        &self,
        req: crate::model::ListPipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPipelineJobsResponse>> {
        self.inner.list_pipeline_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_pipeline_job(
        &self,
        req: crate::model::DeletePipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::delete_pipeline_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_pipeline_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_pipeline_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_pipeline_job(
        &self,
        req: crate::model::DeletePipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_pipeline_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_delete_pipeline_jobs(
        &self,
        req: crate::model::BatchDeletePipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::batch_delete_pipeline_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_delete_pipeline_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_delete_pipeline_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_delete_pipeline_jobs(
        &self,
        req: crate::model::BatchDeletePipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_delete_pipeline_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_pipeline_job(
        &self,
        req: crate::model::CancelPipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::cancel_pipeline_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_pipeline_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_pipeline_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_pipeline_job(
        &self,
        req: crate::model::CancelPipelineJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_pipeline_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_cancel_pipeline_jobs(
        &self,
        req: crate::model::BatchCancelPipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::batch_cancel_pipeline_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_cancel_pipeline_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_cancel_pipeline_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_cancel_pipeline_jobs(
        &self,
        req: crate::model::BatchCancelPipelineJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_cancel_pipeline_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PipelineService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PredictionService](super::stub::PredictionService) decorator for logging and tracing.
#[cfg(feature = "prediction-service")]
#[derive(Clone, Debug)]
pub struct PredictionService<T>
where
    T: super::stub::PredictionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "prediction-service")]
impl<T> PredictionService<T>
where
    T: super::stub::PredictionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "prediction-service")]
impl<T> super::stub::PredictionService for PredictionService<T>
where
    T: super::stub::PredictionService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn predict(
        &self,
        req: crate::model::PredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PredictResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::predict"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "predict",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .predict(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn predict(
        &self,
        req: crate::model::PredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PredictResponse>> {
        self.inner.predict(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn raw_predict(
        &self,
        req: crate::model::RawPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::raw_predict"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "raw_predict",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .raw_predict(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn raw_predict(
        &self,
        req: crate::model::RawPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        self.inner.raw_predict(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn direct_predict(
        &self,
        req: crate::model::DirectPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DirectPredictResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::direct_predict"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "direct_predict",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .direct_predict(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn direct_predict(
        &self,
        req: crate::model::DirectPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DirectPredictResponse>> {
        self.inner.direct_predict(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn direct_raw_predict(
        &self,
        req: crate::model::DirectRawPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DirectRawPredictResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::direct_raw_predict"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "direct_raw_predict",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .direct_raw_predict(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn direct_raw_predict(
        &self,
        req: crate::model::DirectRawPredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DirectRawPredictResponse>> {
        self.inner.direct_raw_predict(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn explain(
        &self,
        req: crate::model::ExplainRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExplainResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::explain"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "explain",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .explain(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn explain(
        &self,
        req: crate::model::ExplainRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExplainResponse>> {
        self.inner.explain(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn generate_content(
        &self,
        req: crate::model::GenerateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateContentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::generate_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "generate_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .generate_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn generate_content(
        &self,
        req: crate::model::GenerateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateContentResponse>> {
        self.inner.generate_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn embed_content(
        &self,
        req: crate::model::EmbedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EmbedContentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::embed_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "embed_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .embed_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn embed_content(
        &self,
        req: crate::model::EmbedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EmbedContentResponse>> {
        self.inner.embed_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "PredictionService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [ReasoningEngineExecutionService](super::stub::ReasoningEngineExecutionService) decorator for logging and tracing.
#[cfg(feature = "reasoning-engine-execution-service")]
#[derive(Clone, Debug)]
pub struct ReasoningEngineExecutionService<T>
where
    T: super::stub::ReasoningEngineExecutionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reasoning-engine-execution-service")]
impl<T> ReasoningEngineExecutionService<T>
where
    T: super::stub::ReasoningEngineExecutionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reasoning-engine-execution-service")]
impl<T> super::stub::ReasoningEngineExecutionService for ReasoningEngineExecutionService<T>
where
    T: super::stub::ReasoningEngineExecutionService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn query_reasoning_engine(
        &self,
        req: crate::model::QueryReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryReasoningEngineResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::query_reasoning_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "query_reasoning_engine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .query_reasoning_engine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn query_reasoning_engine(
        &self,
        req: crate::model::QueryReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryReasoningEngineResponse>> {
        self.inner.query_reasoning_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineExecutionService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [ReasoningEngineService](super::stub::ReasoningEngineService) decorator for logging and tracing.
#[cfg(feature = "reasoning-engine-service")]
#[derive(Clone, Debug)]
pub struct ReasoningEngineService<T>
where
    T: super::stub::ReasoningEngineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reasoning-engine-service")]
impl<T> ReasoningEngineService<T>
where
    T: super::stub::ReasoningEngineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reasoning-engine-service")]
impl<T> super::stub::ReasoningEngineService for ReasoningEngineService<T>
where
    T: super::stub::ReasoningEngineService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_reasoning_engine(
        &self,
        req: crate::model::CreateReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::create_reasoning_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_reasoning_engine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_reasoning_engine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_reasoning_engine(
        &self,
        req: crate::model::CreateReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_reasoning_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_reasoning_engine(
        &self,
        req: crate::model::GetReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReasoningEngine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::get_reasoning_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_reasoning_engine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_reasoning_engine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_reasoning_engine(
        &self,
        req: crate::model::GetReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReasoningEngine>> {
        self.inner.get_reasoning_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_reasoning_engines(
        &self,
        req: crate::model::ListReasoningEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListReasoningEnginesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::list_reasoning_engines"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_reasoning_engines",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_reasoning_engines(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_reasoning_engines(
        &self,
        req: crate::model::ListReasoningEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListReasoningEnginesResponse>> {
        self.inner.list_reasoning_engines(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_reasoning_engine(
        &self,
        req: crate::model::UpdateReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::update_reasoning_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_reasoning_engine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_reasoning_engine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_reasoning_engine(
        &self,
        req: crate::model::UpdateReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_reasoning_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_reasoning_engine(
        &self,
        req: crate::model::DeleteReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::delete_reasoning_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_reasoning_engine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_reasoning_engine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_reasoning_engine(
        &self,
        req: crate::model::DeleteReasoningEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_reasoning_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ReasoningEngineService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ScheduleService](super::stub::ScheduleService) decorator for logging and tracing.
#[cfg(feature = "schedule-service")]
#[derive(Clone, Debug)]
pub struct ScheduleService<T>
where
    T: super::stub::ScheduleService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "schedule-service")]
impl<T> ScheduleService<T>
where
    T: super::stub::ScheduleService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "schedule-service")]
impl<T> super::stub::ScheduleService for ScheduleService<T>
where
    T: super::stub::ScheduleService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_schedule(
        &self,
        req: crate::model::CreateScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::create_schedule"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_schedule",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_schedule(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_schedule(
        &self,
        req: crate::model::CreateScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        self.inner.create_schedule(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_schedule(
        &self,
        req: crate::model::DeleteScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::delete_schedule"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_schedule",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_schedule(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_schedule(
        &self,
        req: crate::model::DeleteScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_schedule(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_schedule(
        &self,
        req: crate::model::GetScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::get_schedule"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_schedule",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_schedule(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_schedule(
        &self,
        req: crate::model::GetScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        self.inner.get_schedule(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_schedules(
        &self,
        req: crate::model::ListSchedulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchedulesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::list_schedules"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_schedules",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_schedules(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_schedules(
        &self,
        req: crate::model::ListSchedulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchedulesResponse>> {
        self.inner.list_schedules(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn pause_schedule(
        &self,
        req: crate::model::PauseScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::pause_schedule"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "pause_schedule",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .pause_schedule(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn pause_schedule(
        &self,
        req: crate::model::PauseScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.pause_schedule(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn resume_schedule(
        &self,
        req: crate::model::ResumeScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::resume_schedule"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "resume_schedule",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .resume_schedule(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn resume_schedule(
        &self,
        req: crate::model::ResumeScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.resume_schedule(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_schedule(
        &self,
        req: crate::model::UpdateScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::update_schedule"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_schedule",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_schedule(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_schedule(
        &self,
        req: crate::model::UpdateScheduleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schedule>> {
        self.inner.update_schedule(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ScheduleService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SpecialistPoolService](super::stub::SpecialistPoolService) decorator for logging and tracing.
#[cfg(feature = "specialist-pool-service")]
#[derive(Clone, Debug)]
pub struct SpecialistPoolService<T>
where
    T: super::stub::SpecialistPoolService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "specialist-pool-service")]
impl<T> SpecialistPoolService<T>
where
    T: super::stub::SpecialistPoolService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "specialist-pool-service")]
impl<T> super::stub::SpecialistPoolService for SpecialistPoolService<T>
where
    T: super::stub::SpecialistPoolService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_specialist_pool(
        &self,
        req: crate::model::CreateSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::create_specialist_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_specialist_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_specialist_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_specialist_pool(
        &self,
        req: crate::model::CreateSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_specialist_pool(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_specialist_pool(
        &self,
        req: crate::model::GetSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SpecialistPool>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::get_specialist_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_specialist_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_specialist_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_specialist_pool(
        &self,
        req: crate::model::GetSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SpecialistPool>> {
        self.inner.get_specialist_pool(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_specialist_pools(
        &self,
        req: crate::model::ListSpecialistPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSpecialistPoolsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::list_specialist_pools"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_specialist_pools",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_specialist_pools(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_specialist_pools(
        &self,
        req: crate::model::ListSpecialistPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSpecialistPoolsResponse>> {
        self.inner.list_specialist_pools(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_specialist_pool(
        &self,
        req: crate::model::DeleteSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::delete_specialist_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_specialist_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_specialist_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_specialist_pool(
        &self,
        req: crate::model::DeleteSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_specialist_pool(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_specialist_pool(
        &self,
        req: crate::model::UpdateSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::update_specialist_pool"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_specialist_pool",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_specialist_pool(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_specialist_pool(
        &self,
        req: crate::model::UpdateSpecialistPoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_specialist_pool(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SpecialistPoolService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TensorboardService](super::stub::TensorboardService) decorator for logging and tracing.
#[cfg(feature = "tensorboard-service")]
#[derive(Clone, Debug)]
pub struct TensorboardService<T>
where
    T: super::stub::TensorboardService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "tensorboard-service")]
impl<T> TensorboardService<T>
where
    T: super::stub::TensorboardService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "tensorboard-service")]
impl<T> super::stub::TensorboardService for TensorboardService<T>
where
    T: super::stub::TensorboardService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tensorboard(
        &self,
        req: crate::model::CreateTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::create_tensorboard"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tensorboard",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tensorboard(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tensorboard(
        &self,
        req: crate::model::CreateTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_tensorboard(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_tensorboard(
        &self,
        req: crate::model::GetTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tensorboard>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_tensorboard"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_tensorboard",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_tensorboard(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_tensorboard(
        &self,
        req: crate::model::GetTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Tensorboard>> {
        self.inner.get_tensorboard(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tensorboard(
        &self,
        req: crate::model::UpdateTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::update_tensorboard"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tensorboard",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tensorboard(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tensorboard(
        &self,
        req: crate::model::UpdateTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_tensorboard(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tensorboards(
        &self,
        req: crate::model::ListTensorboardsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::list_tensorboards"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tensorboards",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tensorboards(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tensorboards(
        &self,
        req: crate::model::ListTensorboardsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardsResponse>> {
        self.inner.list_tensorboards(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tensorboard(
        &self,
        req: crate::model::DeleteTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::delete_tensorboard"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tensorboard",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tensorboard(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tensorboard(
        &self,
        req: crate::model::DeleteTensorboardRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_tensorboard(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn read_tensorboard_usage(
        &self,
        req: crate::model::ReadTensorboardUsageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardUsageResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::read_tensorboard_usage"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "read_tensorboard_usage",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .read_tensorboard_usage(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn read_tensorboard_usage(
        &self,
        req: crate::model::ReadTensorboardUsageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardUsageResponse>> {
        self.inner.read_tensorboard_usage(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn read_tensorboard_size(
        &self,
        req: crate::model::ReadTensorboardSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardSizeResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::read_tensorboard_size"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "read_tensorboard_size",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .read_tensorboard_size(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn read_tensorboard_size(
        &self,
        req: crate::model::ReadTensorboardSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardSizeResponse>> {
        self.inner.read_tensorboard_size(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tensorboard_experiment(
        &self,
        req: crate::model::CreateTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::create_tensorboard_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tensorboard_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tensorboard_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tensorboard_experiment(
        &self,
        req: crate::model::CreateTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        self.inner.create_tensorboard_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_tensorboard_experiment(
        &self,
        req: crate::model::GetTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_tensorboard_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_tensorboard_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_tensorboard_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_tensorboard_experiment(
        &self,
        req: crate::model::GetTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        self.inner.get_tensorboard_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tensorboard_experiment(
        &self,
        req: crate::model::UpdateTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::update_tensorboard_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tensorboard_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tensorboard_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tensorboard_experiment(
        &self,
        req: crate::model::UpdateTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardExperiment>> {
        self.inner.update_tensorboard_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tensorboard_experiments(
        &self,
        req: crate::model::ListTensorboardExperimentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardExperimentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::list_tensorboard_experiments"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tensorboard_experiments",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tensorboard_experiments(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tensorboard_experiments(
        &self,
        req: crate::model::ListTensorboardExperimentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardExperimentsResponse>> {
        self.inner.list_tensorboard_experiments(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tensorboard_experiment(
        &self,
        req: crate::model::DeleteTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::delete_tensorboard_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tensorboard_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tensorboard_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tensorboard_experiment(
        &self,
        req: crate::model::DeleteTensorboardExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_tensorboard_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tensorboard_run(
        &self,
        req: crate::model::CreateTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::create_tensorboard_run"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tensorboard_run",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tensorboard_run(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tensorboard_run(
        &self,
        req: crate::model::CreateTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        self.inner.create_tensorboard_run(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_create_tensorboard_runs(
        &self,
        req: crate::model::BatchCreateTensorboardRunsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchCreateTensorboardRunsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::batch_create_tensorboard_runs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_create_tensorboard_runs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_create_tensorboard_runs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_create_tensorboard_runs(
        &self,
        req: crate::model::BatchCreateTensorboardRunsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchCreateTensorboardRunsResponse>> {
        self.inner.batch_create_tensorboard_runs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_tensorboard_run(
        &self,
        req: crate::model::GetTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_tensorboard_run"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_tensorboard_run",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_tensorboard_run(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_tensorboard_run(
        &self,
        req: crate::model::GetTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        self.inner.get_tensorboard_run(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tensorboard_run(
        &self,
        req: crate::model::UpdateTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::update_tensorboard_run"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tensorboard_run",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tensorboard_run(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tensorboard_run(
        &self,
        req: crate::model::UpdateTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardRun>> {
        self.inner.update_tensorboard_run(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tensorboard_runs(
        &self,
        req: crate::model::ListTensorboardRunsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardRunsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::list_tensorboard_runs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tensorboard_runs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tensorboard_runs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tensorboard_runs(
        &self,
        req: crate::model::ListTensorboardRunsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardRunsResponse>> {
        self.inner.list_tensorboard_runs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tensorboard_run(
        &self,
        req: crate::model::DeleteTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::delete_tensorboard_run"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tensorboard_run",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tensorboard_run(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tensorboard_run(
        &self,
        req: crate::model::DeleteTensorboardRunRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_tensorboard_run(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_create_tensorboard_time_series(
        &self,
        req: crate::model::BatchCreateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchCreateTensorboardTimeSeriesResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::batch_create_tensorboard_time_series"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_create_tensorboard_time_series",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_create_tensorboard_time_series(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_create_tensorboard_time_series(
        &self,
        req: crate::model::BatchCreateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchCreateTensorboardTimeSeriesResponse>>
    {
        self.inner
            .batch_create_tensorboard_time_series(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_tensorboard_time_series(
        &self,
        req: crate::model::CreateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::create_tensorboard_time_series"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_tensorboard_time_series",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_tensorboard_time_series(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_tensorboard_time_series(
        &self,
        req: crate::model::CreateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        self.inner
            .create_tensorboard_time_series(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_tensorboard_time_series(
        &self,
        req: crate::model::GetTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_tensorboard_time_series"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_tensorboard_time_series",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_tensorboard_time_series(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_tensorboard_time_series(
        &self,
        req: crate::model::GetTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        self.inner.get_tensorboard_time_series(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_tensorboard_time_series(
        &self,
        req: crate::model::UpdateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::update_tensorboard_time_series"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_tensorboard_time_series",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_tensorboard_time_series(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_tensorboard_time_series(
        &self,
        req: crate::model::UpdateTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TensorboardTimeSeries>> {
        self.inner
            .update_tensorboard_time_series(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tensorboard_time_series(
        &self,
        req: crate::model::ListTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardTimeSeriesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::list_tensorboard_time_series"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tensorboard_time_series",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tensorboard_time_series(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tensorboard_time_series(
        &self,
        req: crate::model::ListTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTensorboardTimeSeriesResponse>> {
        self.inner.list_tensorboard_time_series(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_tensorboard_time_series(
        &self,
        req: crate::model::DeleteTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::delete_tensorboard_time_series"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_tensorboard_time_series",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_tensorboard_time_series(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_tensorboard_time_series(
        &self,
        req: crate::model::DeleteTensorboardTimeSeriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .delete_tensorboard_time_series(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_read_tensorboard_time_series_data(
        &self,
        req: crate::model::BatchReadTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchReadTensorboardTimeSeriesDataResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::batch_read_tensorboard_time_series_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_read_tensorboard_time_series_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_read_tensorboard_time_series_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_read_tensorboard_time_series_data(
        &self,
        req: crate::model::BatchReadTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchReadTensorboardTimeSeriesDataResponse>>
    {
        self.inner
            .batch_read_tensorboard_time_series_data(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn read_tensorboard_time_series_data(
        &self,
        req: crate::model::ReadTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardTimeSeriesDataResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::read_tensorboard_time_series_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "read_tensorboard_time_series_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .read_tensorboard_time_series_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn read_tensorboard_time_series_data(
        &self,
        req: crate::model::ReadTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReadTensorboardTimeSeriesDataResponse>> {
        self.inner
            .read_tensorboard_time_series_data(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn write_tensorboard_experiment_data(
        &self,
        req: crate::model::WriteTensorboardExperimentDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteTensorboardExperimentDataResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::write_tensorboard_experiment_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "write_tensorboard_experiment_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .write_tensorboard_experiment_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn write_tensorboard_experiment_data(
        &self,
        req: crate::model::WriteTensorboardExperimentDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteTensorboardExperimentDataResponse>> {
        self.inner
            .write_tensorboard_experiment_data(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn write_tensorboard_run_data(
        &self,
        req: crate::model::WriteTensorboardRunDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteTensorboardRunDataResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::write_tensorboard_run_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "write_tensorboard_run_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .write_tensorboard_run_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn write_tensorboard_run_data(
        &self,
        req: crate::model::WriteTensorboardRunDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WriteTensorboardRunDataResponse>> {
        self.inner.write_tensorboard_run_data(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_tensorboard_time_series_data(
        &self,
        req: crate::model::ExportTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExportTensorboardTimeSeriesDataResponse>>
    {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::export_tensorboard_time_series_data"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_tensorboard_time_series_data",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_tensorboard_time_series_data(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_tensorboard_time_series_data(
        &self,
        req: crate::model::ExportTensorboardTimeSeriesDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExportTensorboardTimeSeriesDataResponse>>
    {
        self.inner
            .export_tensorboard_time_series_data(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TensorboardService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [VertexRagDataService](super::stub::VertexRagDataService) decorator for logging and tracing.
#[cfg(feature = "vertex-rag-data-service")]
#[derive(Clone, Debug)]
pub struct VertexRagDataService<T>
where
    T: super::stub::VertexRagDataService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vertex-rag-data-service")]
impl<T> VertexRagDataService<T>
where
    T: super::stub::VertexRagDataService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vertex-rag-data-service")]
impl<T> super::stub::VertexRagDataService for VertexRagDataService<T>
where
    T: super::stub::VertexRagDataService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_rag_corpus(
        &self,
        req: crate::model::CreateRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::create_rag_corpus"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_rag_corpus",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_rag_corpus(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_rag_corpus(
        &self,
        req: crate::model::CreateRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_rag_corpus(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_rag_corpus(
        &self,
        req: crate::model::UpdateRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::update_rag_corpus"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_rag_corpus",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_rag_corpus(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_rag_corpus(
        &self,
        req: crate::model::UpdateRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_rag_corpus(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_rag_corpus(
        &self,
        req: crate::model::GetRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagCorpus>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::get_rag_corpus"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_rag_corpus",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_rag_corpus(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_rag_corpus(
        &self,
        req: crate::model::GetRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagCorpus>> {
        self.inner.get_rag_corpus(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_rag_corpora(
        &self,
        req: crate::model::ListRagCorporaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRagCorporaResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::list_rag_corpora"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_rag_corpora",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_rag_corpora(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_rag_corpora(
        &self,
        req: crate::model::ListRagCorporaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRagCorporaResponse>> {
        self.inner.list_rag_corpora(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_rag_corpus(
        &self,
        req: crate::model::DeleteRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::delete_rag_corpus"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_rag_corpus",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_rag_corpus(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_rag_corpus(
        &self,
        req: crate::model::DeleteRagCorpusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_rag_corpus(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn upload_rag_file(
        &self,
        req: crate::model::UploadRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UploadRagFileResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::upload_rag_file"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "upload_rag_file",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .upload_rag_file(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn upload_rag_file(
        &self,
        req: crate::model::UploadRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UploadRagFileResponse>> {
        self.inner.upload_rag_file(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_rag_files(
        &self,
        req: crate::model::ImportRagFilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::import_rag_files"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_rag_files",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_rag_files(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_rag_files(
        &self,
        req: crate::model::ImportRagFilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_rag_files(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_rag_file(
        &self,
        req: crate::model::GetRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagFile>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::get_rag_file"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_rag_file",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_rag_file(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_rag_file(
        &self,
        req: crate::model::GetRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagFile>> {
        self.inner.get_rag_file(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_rag_files(
        &self,
        req: crate::model::ListRagFilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRagFilesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::list_rag_files"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_rag_files",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_rag_files(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_rag_files(
        &self,
        req: crate::model::ListRagFilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRagFilesResponse>> {
        self.inner.list_rag_files(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_rag_file(
        &self,
        req: crate::model::DeleteRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::delete_rag_file"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_rag_file",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_rag_file(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_rag_file(
        &self,
        req: crate::model::DeleteRagFileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_rag_file(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_rag_engine_config(
        &self,
        req: crate::model::UpdateRagEngineConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::update_rag_engine_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_rag_engine_config",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_rag_engine_config(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_rag_engine_config(
        &self,
        req: crate::model::UpdateRagEngineConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_rag_engine_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_rag_engine_config(
        &self,
        req: crate::model::GetRagEngineConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagEngineConfig>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::get_rag_engine_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_rag_engine_config",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_rag_engine_config(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_rag_engine_config(
        &self,
        req: crate::model::GetRagEngineConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RagEngineConfig>> {
        self.inner.get_rag_engine_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagDataService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [VertexRagService](super::stub::VertexRagService) decorator for logging and tracing.
#[cfg(feature = "vertex-rag-service")]
#[derive(Clone, Debug)]
pub struct VertexRagService<T>
where
    T: super::stub::VertexRagService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vertex-rag-service")]
impl<T> VertexRagService<T>
where
    T: super::stub::VertexRagService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vertex-rag-service")]
impl<T> super::stub::VertexRagService for VertexRagService<T>
where
    T: super::stub::VertexRagService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn retrieve_contexts(
        &self,
        req: crate::model::RetrieveContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RetrieveContextsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::retrieve_contexts"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "retrieve_contexts",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .retrieve_contexts(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn retrieve_contexts(
        &self,
        req: crate::model::RetrieveContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RetrieveContextsResponse>> {
        self.inner.retrieve_contexts(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn augment_prompt(
        &self,
        req: crate::model::AugmentPromptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AugmentPromptResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::augment_prompt"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "augment_prompt",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .augment_prompt(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn augment_prompt(
        &self,
        req: crate::model::AugmentPromptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AugmentPromptResponse>> {
        self.inner.augment_prompt(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn corroborate_content(
        &self,
        req: crate::model::CorroborateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CorroborateContentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::corroborate_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "corroborate_content",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .corroborate_content(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn corroborate_content(
        &self,
        req: crate::model::CorroborateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CorroborateContentResponse>> {
        self.inner.corroborate_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VertexRagService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }
}

/// Implements a [VizierService](super::stub::VizierService) decorator for logging and tracing.
#[cfg(feature = "vizier-service")]
#[derive(Clone, Debug)]
pub struct VizierService<T>
where
    T: super::stub::VizierService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vizier-service")]
impl<T> VizierService<T>
where
    T: super::stub::VizierService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vizier-service")]
impl<T> super::stub::VizierService for VizierService<T>
where
    T: super::stub::VizierService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_study(
        &self,
        req: crate::model::CreateStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::create_study"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_study",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_study(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_study(
        &self,
        req: crate::model::CreateStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        self.inner.create_study(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_study(
        &self,
        req: crate::model::GetStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::get_study"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_study",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_study(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_study(
        &self,
        req: crate::model::GetStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        self.inner.get_study(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_studies(
        &self,
        req: crate::model::ListStudiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListStudiesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::list_studies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_studies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_studies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_studies(
        &self,
        req: crate::model::ListStudiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListStudiesResponse>> {
        self.inner.list_studies(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_study(
        &self,
        req: crate::model::DeleteStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::delete_study"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_study",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_study(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_study(
        &self,
        req: crate::model::DeleteStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_study(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn lookup_study(
        &self,
        req: crate::model::LookupStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::lookup_study"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "lookup_study",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .lookup_study(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn lookup_study(
        &self,
        req: crate::model::LookupStudyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Study>> {
        self.inner.lookup_study(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn suggest_trials(
        &self,
        req: crate::model::SuggestTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::suggest_trials"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "suggest_trials",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .suggest_trials(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn suggest_trials(
        &self,
        req: crate::model::SuggestTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.suggest_trials(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_trial(
        &self,
        req: crate::model::CreateTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::create_trial"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_trial",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_trial(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_trial(
        &self,
        req: crate::model::CreateTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.create_trial(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_trial(
        &self,
        req: crate::model::GetTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::get_trial"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_trial",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_trial(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_trial(
        &self,
        req: crate::model::GetTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.get_trial(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_trials(
        &self,
        req: crate::model::ListTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTrialsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::list_trials"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_trials",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_trials(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_trials(
        &self,
        req: crate::model::ListTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTrialsResponse>> {
        self.inner.list_trials(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn add_trial_measurement(
        &self,
        req: crate::model::AddTrialMeasurementRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::add_trial_measurement"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "add_trial_measurement",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .add_trial_measurement(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn add_trial_measurement(
        &self,
        req: crate::model::AddTrialMeasurementRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.add_trial_measurement(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn complete_trial(
        &self,
        req: crate::model::CompleteTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::complete_trial"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "complete_trial",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .complete_trial(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn complete_trial(
        &self,
        req: crate::model::CompleteTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.complete_trial(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_trial(
        &self,
        req: crate::model::DeleteTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::delete_trial"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_trial",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_trial(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_trial(
        &self,
        req: crate::model::DeleteTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_trial(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn check_trial_early_stopping_state(
        &self,
        req: crate::model::CheckTrialEarlyStoppingStateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::check_trial_early_stopping_state"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "check_trial_early_stopping_state",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .check_trial_early_stopping_state(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn check_trial_early_stopping_state(
        &self,
        req: crate::model::CheckTrialEarlyStoppingStateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .check_trial_early_stopping_state(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn stop_trial(
        &self,
        req: crate::model::StopTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::stop_trial"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "stop_trial",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .stop_trial(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn stop_trial(
        &self,
        req: crate::model::StopTrialRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Trial>> {
        self.inner.stop_trial(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_optimal_trials(
        &self,
        req: crate::model::ListOptimalTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListOptimalTrialsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::list_optimal_trials"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_optimal_trials",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_optimal_trials(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_optimal_trials(
        &self,
        req: crate::model::ListOptimalTrialsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListOptimalTrialsResponse>> {
        self.inner.list_optimal_trials(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "VizierService",
            "::wait_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "wait_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .wait_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn wait_operation(
        &self,
        req: longrunning::model::WaitOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.wait_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
