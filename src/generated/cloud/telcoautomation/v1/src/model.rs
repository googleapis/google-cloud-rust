// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Orchestration cluster represents a GKE cluster with config controller and
/// TNA specific components installed on it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OrchestrationCluster {
    /// Name of the orchestration cluster. The name of orchestration cluster cannot
    /// be more than 24 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Management configuration of the underlying GKE cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_config: std::option::Option<crate::model::ManagementConfig>,

    /// Output only. [Output only] Create time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Provides the TNA version installed on the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tna_version: std::string::String,

    /// Output only. State of the Orchestration Cluster.
    pub state: crate::model::orchestration_cluster::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrchestrationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OrchestrationCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [management_config][crate::model::OrchestrationCluster::management_config].
    pub fn set_management_config<
        T: std::convert::Into<std::option::Option<crate::model::ManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OrchestrationCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::OrchestrationCluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::OrchestrationCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tna_version][crate::model::OrchestrationCluster::tna_version].
    pub fn set_tna_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tna_version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::OrchestrationCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::orchestration_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for OrchestrationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.OrchestrationCluster"
    }
}

/// Defines additional types related to [OrchestrationCluster].
pub mod orchestration_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states that the Orchestration Cluster can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// OrchestrationCluster is being created.
        Creating,
        /// OrchestrationCluster has been created and is ready for use.
        Active,
        /// OrchestrationCluster is being deleted.
        Deleting,
        /// OrchestrationCluster encountered an error and is in an indeterministic
        /// state. User can still initiate a delete operation on this state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.telcoautomation.v1.OrchestrationCluster.State",
            ))
        }
    }
}

/// EdgeSlm represents an SLM instance which manages the lifecycle of edge
/// components installed on Workload clusters managed by an Orchestration
/// Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EdgeSlm {
    /// Name of the EdgeSlm resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. Reference to the orchestration cluster on which templates for
    /// this resources will be applied. This should be of format
    /// projects/{project}/locations/{location}/orchestrationClusters/{orchestration_cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub orchestration_cluster: std::string::String,

    /// Output only. [Output only] Create time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs. The key and value should contain
    /// characters which are UTF-8 compliant and less than 50 characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Provides the active TNA version for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tna_version: std::string::String,

    /// Output only. State of the EdgeSlm resource.
    pub state: crate::model::edge_slm::State,

    /// Optional. Type of workload cluster for which an EdgeSLM resource is
    /// created.
    pub workload_cluster_type: crate::model::edge_slm::WorkloadClusterType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EdgeSlm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EdgeSlm::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [orchestration_cluster][crate::model::EdgeSlm::orchestration_cluster].
    pub fn set_orchestration_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.orchestration_cluster = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EdgeSlm::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EdgeSlm::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EdgeSlm::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tna_version][crate::model::EdgeSlm::tna_version].
    pub fn set_tna_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tna_version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::EdgeSlm::state].
    pub fn set_state<T: std::convert::Into<crate::model::edge_slm::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [workload_cluster_type][crate::model::EdgeSlm::workload_cluster_type].
    pub fn set_workload_cluster_type<
        T: std::convert::Into<crate::model::edge_slm::WorkloadClusterType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_cluster_type = v.into();
        self
    }
}

impl wkt::message::Message for EdgeSlm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.EdgeSlm"
    }
}

/// Defines additional types related to [EdgeSlm].
pub mod edge_slm {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// EdgeSlm is being created.
        Creating,
        /// EdgeSlm has been created and is ready for use.
        Active,
        /// EdgeSlm is being deleted.
        Deleting,
        /// EdgeSlm encountered an error and is in an indeterministic
        /// state. User can still initiate a delete operation on this state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.telcoautomation.v1.EdgeSlm.State",
            ))
        }
    }

    /// Workload clusters supported by TNA. New values will be added to the enum
    /// list as TNA adds supports for new workload clusters in future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WorkloadClusterType {
        /// Unspecified workload cluster.
        Unspecified,
        /// Workload cluster is a GDCE cluster.
        Gdce,
        /// Workload cluster is a GKE cluster.
        Gke,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WorkloadClusterType::value] or
        /// [WorkloadClusterType::name].
        UnknownValue(workload_cluster_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod workload_cluster_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WorkloadClusterType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gdce => std::option::Option::Some(1),
                Self::Gke => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WORKLOAD_CLUSTER_TYPE_UNSPECIFIED"),
                Self::Gdce => std::option::Option::Some("GDCE"),
                Self::Gke => std::option::Option::Some("GKE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WorkloadClusterType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WorkloadClusterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WorkloadClusterType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gdce,
                2 => Self::Gke,
                _ => Self::UnknownValue(workload_cluster_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WorkloadClusterType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GDCE" => Self::Gdce,
                "GKE" => Self::Gke,
                _ => Self::UnknownValue(workload_cluster_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WorkloadClusterType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gdce => serializer.serialize_i32(1),
                Self::Gke => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WorkloadClusterType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WorkloadClusterType>::new(
                ".google.cloud.telcoautomation.v1.EdgeSlm.WorkloadClusterType",
            ))
        }
    }
}

/// A Blueprint contains a collection of kubernetes resources in the form of
/// YAML files. The file contents of a blueprint are collectively known as
/// package. A blueprint can be
/// a) imported from TNA's public catalog
/// b) modified as per a user's need
/// c) proposed and approved.
/// On approval, a revision of blueprint is created which can be used to
/// create a deployment on Orchestration or Workload Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Blueprint {
    /// The name of the blueprint. If unspecified, the name will be autogenerated
    /// from server side. Name of the blueprint must not contain `@` character.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The revision ID of the blueprint.
    /// A new revision is committed whenever a blueprint is approved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Required. Immutable. The public blueprint ID from which this blueprint was
    /// created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_blueprint: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Approval state of the blueprint (DRAFT, PROPOSED, APPROVED)
    pub approval_state: crate::model::blueprint::ApprovalState,

    /// Optional. Human readable name of a Blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Name of the repository where the blueprint files are stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Optional. Files present in a blueprint.
    /// When invoking UpdateBlueprint API, only the modified files should be
    /// included in this. Files that are not included in the update of a blueprint
    /// will not be changed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// Optional. Labels are key-value attributes that can be set on a blueprint
    /// resource by the user.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Blueprint creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the blueprint was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Source provider is the author of a public blueprint, from
    /// which this blueprint is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_provider: std::string::String,

    /// Output only. DeploymentLevel of a blueprint signifies where the blueprint
    /// will be applied. e.g. [HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT]
    pub deployment_level: crate::model::DeploymentLevel,

    /// Output only. Indicates if the deployment created from this blueprint can be
    /// rolled back.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rollback_support: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Blueprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Blueprint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::Blueprint::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [source_blueprint][crate::model::Blueprint::source_blueprint].
    pub fn set_source_blueprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_blueprint = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::Blueprint::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [approval_state][crate::model::Blueprint::approval_state].
    pub fn set_approval_state<T: std::convert::Into<crate::model::blueprint::ApprovalState>>(
        mut self,
        v: T,
    ) -> Self {
        self.approval_state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Blueprint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::Blueprint::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [files][crate::model::Blueprint::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Blueprint::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Blueprint::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Blueprint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [source_provider][crate::model::Blueprint::source_provider].
    pub fn set_source_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_provider = v.into();
        self
    }

    /// Sets the value of [deployment_level][crate::model::Blueprint::deployment_level].
    pub fn set_deployment_level<T: std::convert::Into<crate::model::DeploymentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_level = v.into();
        self
    }

    /// Sets the value of [rollback_support][crate::model::Blueprint::rollback_support].
    pub fn set_rollback_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rollback_support = v.into();
        self
    }
}

impl wkt::message::Message for Blueprint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.Blueprint"
    }
}

/// Defines additional types related to [Blueprint].
pub mod blueprint {
    #[allow(unused_imports)]
    use super::*;

    /// Approval state indicates the state of a Blueprint in its approval
    /// lifecycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApprovalState {
        /// Unspecified state.
        Unspecified,
        /// A blueprint starts in DRAFT state once it is created. All edits are made
        /// to the blueprint in DRAFT state.
        Draft,
        /// When the edits are ready for review, blueprint can be proposed and moves
        /// to PROPOSED state. Edits cannot be made to a blueprint in PROPOSED state.
        Proposed,
        /// When a proposed blueprint is approved, it moves to APPROVED state. A new
        /// revision is committed. The latest committed revision can be used to
        /// create a deployment on Orchestration or Workload Cluster. Edits to an
        /// APPROVED blueprint changes its state back to DRAFT. The last committed
        /// revision of a blueprint represents its latest APPROVED state.
        Approved,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApprovalState::value] or
        /// [ApprovalState::name].
        UnknownValue(approval_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod approval_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApprovalState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Proposed => std::option::Option::Some(2),
                Self::Approved => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("APPROVAL_STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Proposed => std::option::Option::Some("PROPOSED"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApprovalState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApprovalState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApprovalState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Proposed,
                3 => Self::Approved,
                _ => Self::UnknownValue(approval_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApprovalState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "PROPOSED" => Self::Proposed,
                "APPROVED" => Self::Approved,
                _ => Self::UnknownValue(approval_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApprovalState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Proposed => serializer.serialize_i32(2),
                Self::Approved => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApprovalState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApprovalState>::new(
                ".google.cloud.telcoautomation.v1.Blueprint.ApprovalState",
            ))
        }
    }
}

/// A Blueprint contains a collection of kubernetes resources in the form of
/// YAML files. The file contents of a blueprint are collectively known as
/// package.
/// Public blueprint is a TNA provided blueprint that in present in TNA's public
/// catalog. A user can copy the public blueprint to their private catalog for
/// further modifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PublicBlueprint {
    /// Name of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// DeploymentLevel of a blueprint signifies where the blueprint will be
    /// applied. e.g. [HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT]
    pub deployment_level: crate::model::DeploymentLevel,

    /// Source provider is the author of a public blueprint. e.g. Google, vendors
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_provider: std::string::String,

    /// Output only. Indicates if the deployment created from this blueprint can be
    /// rolled back.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rollback_support: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PublicBlueprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PublicBlueprint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PublicBlueprint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PublicBlueprint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [deployment_level][crate::model::PublicBlueprint::deployment_level].
    pub fn set_deployment_level<T: std::convert::Into<crate::model::DeploymentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_level = v.into();
        self
    }

    /// Sets the value of [source_provider][crate::model::PublicBlueprint::source_provider].
    pub fn set_source_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_provider = v.into();
        self
    }

    /// Sets the value of [rollback_support][crate::model::PublicBlueprint::rollback_support].
    pub fn set_rollback_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rollback_support = v.into();
        self
    }
}

impl wkt::message::Message for PublicBlueprint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.PublicBlueprint"
    }
}

/// Deployment contains a collection of YAML files (This collection is also known
/// as package) that can to applied on an orchestration cluster (GKE cluster with
/// TNA addons) or a workload cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Deployment {
    /// The name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The revision ID of the deployment.
    /// A new revision is committed whenever a change in deployment is applied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Required. The blueprint revision from which this deployment was created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_blueprint_revision: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the deployment (DRAFT, APPLIED, DELETING).
    pub state: crate::model::deployment::State,

    /// Optional. Human readable name of a Deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Name of the repository where the deployment package files are
    /// stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Optional. Files present in a deployment.
    /// When invoking UpdateDeployment API, only the modified files should be
    /// included in this. Files that are not included in the update of a deployment
    /// will not be changed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// Optional. Labels are key-value attributes that can be set on a deployment
    /// resource by the user.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Deployment creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the deployment was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Source provider is the author of a public blueprint, from
    /// which this deployment is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_provider: std::string::String,

    /// Optional. Immutable. The WorkloadCluster on which to create the Deployment.
    /// This field should only be passed when the deployment_level of the source
    /// blueprint specifies deployments on workload clusters e.g.
    /// WORKLOAD_CLUSTER_DEPLOYMENT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_cluster: std::string::String,

    /// Output only. Attributes to where the deployment can inflict changes. The
    /// value can only be [SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT].
    pub deployment_level: crate::model::DeploymentLevel,

    /// Output only. Indicates if the deployment can be rolled back, exported from
    /// public blueprint.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rollback_support: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Deployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::Deployment::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [source_blueprint_revision][crate::model::Deployment::source_blueprint_revision].
    pub fn set_source_blueprint_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_blueprint_revision = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::Deployment::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Deployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Deployment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::Deployment::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [files][crate::model::Deployment::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Deployment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Deployment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Deployment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [source_provider][crate::model::Deployment::source_provider].
    pub fn set_source_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_provider = v.into();
        self
    }

    /// Sets the value of [workload_cluster][crate::model::Deployment::workload_cluster].
    pub fn set_workload_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_cluster = v.into();
        self
    }

    /// Sets the value of [deployment_level][crate::model::Deployment::deployment_level].
    pub fn set_deployment_level<T: std::convert::Into<crate::model::DeploymentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_level = v.into();
        self
    }

    /// Sets the value of [rollback_support][crate::model::Deployment::rollback_support].
    pub fn set_rollback_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rollback_support = v.into();
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.Deployment"
    }
}

/// Defines additional types related to [Deployment].
pub mod deployment {
    #[allow(unused_imports)]
    use super::*;

    /// State defines which state the current deployment is in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// A deployment starts in DRAFT state. All edits are made in DRAFT state. A
        /// deployment opened for editing after applying will be in draft state,
        /// while its prevision revision will be its current applied version.
        Draft,
        /// This state means that the contents (YAML files containing kubernetes
        /// resources) of the deployment have been applied to an Orchestration or
        /// Workload Cluster. A revision is created when a deployment is applied.
        /// This revision will represent the latest view of what is applied on the
        /// cluster until the deployment is modified and applied again, which will
        /// create a new revision.
        Applied,
        /// A deployment in DELETING state has been marked for deletion. Its
        /// deletion status can be queried using `ComputeDeploymentStatus` API. No
        /// updates are allowed to a deployment in DELETING state.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Applied => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Applied => std::option::Option::Some("APPLIED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Applied,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "APPLIED" => Self::Applied,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Applied => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.telcoautomation.v1.Deployment.State",
            ))
        }
    }
}

/// A collection of kubernetes yaml files which are deployed on a Workload
/// Cluster. Hydrated Deployments are created by TNA intent based automation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HydratedDeployment {
    /// Output only. The name of the hydrated deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. State of the hydrated deployment (DRAFT, APPLIED).
    pub state: crate::model::hydrated_deployment::State,

    /// Optional. File contents of a hydrated deployment.
    /// When invoking UpdateHydratedBlueprint API, only the modified files should
    /// be included in this. Files that are not included in the update of a
    /// hydrated deployment will not be changed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// Output only. WorkloadCluster identifies which workload cluster will the
    /// hydrated deployment will be deployed on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_cluster: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HydratedDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HydratedDeployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::HydratedDeployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::hydrated_deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [files][crate::model::HydratedDeployment::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [workload_cluster][crate::model::HydratedDeployment::workload_cluster].
    pub fn set_workload_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_cluster = v.into();
        self
    }
}

impl wkt::message::Message for HydratedDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.HydratedDeployment"
    }
}

/// Defines additional types related to [HydratedDeployment].
pub mod hydrated_deployment {
    #[allow(unused_imports)]
    use super::*;

    /// State defines which state the current hydrated deployment is in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// A hydrated deployment starts in DRAFT state. All edits are made in DRAFT
        /// state.
        Draft,
        /// When the edit is applied, the hydrated deployment moves to APPLIED
        /// state. No changes can be made once a hydrated deployment is applied.
        Applied,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Applied => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Applied => std::option::Option::Some("APPLIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Applied,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "APPLIED" => Self::Applied,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Applied => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.telcoautomation.v1.HydratedDeployment.State",
            ))
        }
    }
}

/// Message for requesting list of OrchestrationClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrchestrationClustersRequest {
    /// Required. Parent value for ListOrchestrationClustersRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrchestrationClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOrchestrationClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOrchestrationClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOrchestrationClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOrchestrationClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListOrchestrationClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListOrchestrationClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListOrchestrationClustersRequest"
    }
}

/// Message for response to listing OrchestrationClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrchestrationClustersResponse {
    /// The list of OrchestrationCluster
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub orchestration_clusters: std::vec::Vec<crate::model::OrchestrationCluster>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrchestrationClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [orchestration_clusters][crate::model::ListOrchestrationClustersResponse::orchestration_clusters].
    pub fn set_orchestration_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrchestrationCluster>,
    {
        use std::iter::Iterator;
        self.orchestration_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOrchestrationClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListOrchestrationClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOrchestrationClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListOrchestrationClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOrchestrationClustersResponse {
    type PageItem = crate::model::OrchestrationCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.orchestration_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a OrchestrationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOrchestrationClusterRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOrchestrationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOrchestrationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOrchestrationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetOrchestrationClusterRequest"
    }
}

/// Message for creating a OrchestrationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateOrchestrationClusterRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// orchestration_cluster_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub orchestration_cluster_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub orchestration_cluster: std::option::Option<crate::model::OrchestrationCluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOrchestrationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOrchestrationClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [orchestration_cluster_id][crate::model::CreateOrchestrationClusterRequest::orchestration_cluster_id].
    pub fn set_orchestration_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.orchestration_cluster_id = v.into();
        self
    }

    /// Sets the value of [orchestration_cluster][crate::model::CreateOrchestrationClusterRequest::orchestration_cluster].
    pub fn set_orchestration_cluster<
        T: std::convert::Into<std::option::Option<crate::model::OrchestrationCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.orchestration_cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateOrchestrationClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateOrchestrationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateOrchestrationClusterRequest"
    }
}

/// Message for deleting a OrchestrationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteOrchestrationClusterRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOrchestrationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOrchestrationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteOrchestrationClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOrchestrationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DeleteOrchestrationClusterRequest"
    }
}

/// Message for requesting list of EdgeSlms
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEdgeSlmsRequest {
    /// Required. Parent value for ListEdgeSlmsRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEdgeSlmsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEdgeSlmsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEdgeSlmsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEdgeSlmsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEdgeSlmsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEdgeSlmsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEdgeSlmsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListEdgeSlmsRequest"
    }
}

/// Message for response to listing EdgeSlms.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEdgeSlmsResponse {
    /// The list of EdgeSlm
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub edge_slms: std::vec::Vec<crate::model::EdgeSlm>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEdgeSlmsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [edge_slms][crate::model::ListEdgeSlmsResponse::edge_slms].
    pub fn set_edge_slms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EdgeSlm>,
    {
        use std::iter::Iterator;
        self.edge_slms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEdgeSlmsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEdgeSlmsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEdgeSlmsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListEdgeSlmsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEdgeSlmsResponse {
    type PageItem = crate::model::EdgeSlm;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.edge_slms
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a EdgeSlm.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEdgeSlmRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEdgeSlmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEdgeSlmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEdgeSlmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetEdgeSlmRequest"
    }
}

/// Message for creating a EdgeSlm.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEdgeSlmRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// edge_slm_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub edge_slm_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub edge_slm: std::option::Option<crate::model::EdgeSlm>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEdgeSlmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEdgeSlmRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [edge_slm_id][crate::model::CreateEdgeSlmRequest::edge_slm_id].
    pub fn set_edge_slm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.edge_slm_id = v.into();
        self
    }

    /// Sets the value of [edge_slm][crate::model::CreateEdgeSlmRequest::edge_slm].
    pub fn set_edge_slm<T: std::convert::Into<std::option::Option<crate::model::EdgeSlm>>>(
        mut self,
        v: T,
    ) -> Self {
        self.edge_slm = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateEdgeSlmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEdgeSlmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateEdgeSlmRequest"
    }
}

/// Message for deleting a EdgeSlm.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEdgeSlmRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEdgeSlmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEdgeSlmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteEdgeSlmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEdgeSlmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DeleteEdgeSlmRequest"
    }
}

/// Request object for `CreateBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBlueprintRequest {
    /// Required. The name of parent resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The name of the blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub blueprint_id: std::string::String,

    /// Required. The `Blueprint` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blueprint: std::option::Option<crate::model::Blueprint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBlueprintRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [blueprint_id][crate::model::CreateBlueprintRequest::blueprint_id].
    pub fn set_blueprint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.blueprint_id = v.into();
        self
    }

    /// Sets the value of [blueprint][crate::model::CreateBlueprintRequest::blueprint].
    pub fn set_blueprint<T: std::convert::Into<std::option::Option<crate::model::Blueprint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blueprint = v.into();
        self
    }
}

impl wkt::message::Message for CreateBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateBlueprintRequest"
    }
}

/// Request object for `UpdateBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBlueprintRequest {
    /// Required. The `blueprint` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blueprint: std::option::Option<crate::model::Blueprint>,

    /// Required. Update mask is used to specify the fields to be overwritten in
    /// the `blueprint` resource by the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blueprint][crate::model::UpdateBlueprintRequest::blueprint].
    pub fn set_blueprint<T: std::convert::Into<std::option::Option<crate::model::Blueprint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blueprint = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBlueprintRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.UpdateBlueprintRequest"
    }
}

/// Request object for `GetBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBlueprintRequest {
    /// Required. The name of the blueprint.
    /// Case 1: If the name provided in the request is
    /// {blueprint_id}@{revision_id}, then the revision with revision_id will be
    /// returned. Case 2: If the name provided in the request is {blueprint}, then
    /// the current state of the blueprint is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Defines the type of view of the blueprint.
    /// When field is not present BLUEPRINT_VIEW_BASIC is considered as default.
    pub view: crate::model::BlueprintView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetBlueprintRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BlueprintView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetBlueprintRequest"
    }
}

/// Request object for `DeleteBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBlueprintRequest {
    /// Required. The name of blueprint to delete.
    /// Blueprint name should be in the format {blueprint_id}, if
    /// {blueprint_id}@{revision_id} is passed then the API throws invalid
    /// argument.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DeleteBlueprintRequest"
    }
}

/// Request object for `ListBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Filtering only supports equality on blueprint state.
    /// It should be in the form: "state = DRAFT". `OR` operator can be used to
    /// get response for multiple states. e.g. "state = DRAFT OR state = PROPOSED".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of blueprints to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListBlueprints call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlueprintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBlueprintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBlueprintsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBlueprintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBlueprintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlueprintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintsRequest"
    }
}

/// Response object for `ListBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintsResponse {
    /// The list of requested blueprints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::Blueprint>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlueprintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blueprints][crate::model::ListBlueprintsResponse::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBlueprintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlueprintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBlueprintsResponse {
    type PageItem = crate::model::Blueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `ApproveBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveBlueprintRequest {
    /// Required. The name of the blueprint to approve. The blueprint must be in
    /// Proposed state. A new revision is committed on approval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ApproveBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ApproveBlueprintRequest"
    }
}

/// Request object for `ProposeBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProposeBlueprintRequest {
    /// Required. The name of the blueprint being proposed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProposeBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProposeBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ProposeBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ProposeBlueprintRequest"
    }
}

/// Request object for `RejectBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RejectBlueprintRequest {
    /// Required. The name of the blueprint being rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RejectBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RejectBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RejectBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.RejectBlueprintRequest"
    }
}

/// Request object for `ListBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintRevisionsRequest {
    /// Required. The name of the blueprint to list revisions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The maximum number of revisions to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The page token, received from a previous ListBlueprintRevisions call
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlueprintRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListBlueprintRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBlueprintRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBlueprintRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlueprintRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintRevisionsRequest"
    }
}

/// Response object for `ListBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintRevisionsResponse {
    /// The revisions of the blueprint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::Blueprint>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlueprintRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blueprints][crate::model::ListBlueprintRevisionsResponse::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBlueprintRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlueprintRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBlueprintRevisionsResponse {
    type PageItem = crate::model::Blueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `SearchBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlueprintRevisionsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Supported queries:
    ///
    /// . ""                       : Lists all revisions across all blueprints.
    /// . "latest=true"            : Lists latest revisions across all blueprints.
    /// . "name={name}"            : Lists all revisions of blueprint with name
    ///   {name}.
    /// . "name={name} latest=true": Lists latest revision of blueprint with name
    ///   {name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. The maximum number of blueprints revisions to return per page.
    /// max page size = 100, default page size = 20.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, received from a previous search call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlueprintRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchBlueprintRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchBlueprintRevisionsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchBlueprintRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchBlueprintRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlueprintRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchBlueprintRevisionsRequest"
    }
}

/// Response object for `SearchBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlueprintRevisionsResponse {
    /// The list of requested blueprint revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::Blueprint>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlueprintRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blueprints][crate::model::SearchBlueprintRevisionsResponse::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchBlueprintRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlueprintRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchBlueprintRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchBlueprintRevisionsResponse {
    type PageItem = crate::model::Blueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `DiscardBlueprintChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardBlueprintChangesRequest {
    /// Required. The name of the blueprint of which changes are being discarded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscardBlueprintChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscardBlueprintChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DiscardBlueprintChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardBlueprintChangesRequest"
    }
}

/// Response object for `DiscardBlueprintChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardBlueprintChangesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscardBlueprintChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DiscardBlueprintChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardBlueprintChangesResponse"
    }
}

/// Request object for `ListPublicBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPublicBlueprintsRequest {
    /// Required. Parent value of public blueprint.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPublicBlueprintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPublicBlueprintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPublicBlueprintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPublicBlueprintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPublicBlueprintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListPublicBlueprintsRequest"
    }
}

/// Response object for `ListPublicBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPublicBlueprintsResponse {
    /// The list of public blueprints to return.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub public_blueprints: std::vec::Vec<crate::model::PublicBlueprint>,

    /// Output only. A token identifying a page of results the server should
    /// return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPublicBlueprintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_blueprints][crate::model::ListPublicBlueprintsResponse::public_blueprints].
    pub fn set_public_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PublicBlueprint>,
    {
        use std::iter::Iterator;
        self.public_blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPublicBlueprintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPublicBlueprintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListPublicBlueprintsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPublicBlueprintsResponse {
    type PageItem = crate::model::PublicBlueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.public_blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `GetPublicBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPublicBlueprintRequest {
    /// Required. The name of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPublicBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPublicBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPublicBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetPublicBlueprintRequest"
    }
}

/// Request object for `CreateDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeploymentRequest {
    /// Required. The name of parent resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_id: std::string::String,

    /// Required. The `Deployment` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeploymentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deployment_id][crate::model::CreateDeploymentRequest::deployment_id].
    pub fn set_deployment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deployment_id = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::CreateDeploymentRequest::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateDeploymentRequest"
    }
}

/// Request object for `UpdateDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeploymentRequest {
    /// Required. The `deployment` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Required. Update mask is used to specify the fields to be overwritten in
    /// the `deployment` resource by the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment][crate::model::UpdateDeploymentRequest::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeploymentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.UpdateDeploymentRequest"
    }
}

/// Request object for `GetDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeploymentRequest {
    /// Required. The name of the deployment.
    /// Case 1: If the name provided in the request is
    /// {deployment_id}@{revision_id}, then the revision with revision_id will be
    /// returned.
    /// Case 2: If the name provided in the request is {deployment}, then
    /// the current state of the deployment is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Defines the type of view of the deployment.
    /// When field is not present VIEW_BASIC is considered as default.
    pub view: crate::model::DeploymentView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetDeploymentRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::DeploymentView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetDeploymentRequest"
    }
}

/// Request object for `RemoveDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveDeploymentRequest {
    /// Required. The name of deployment to initiate delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RemoveDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.RemoveDeploymentRequest"
    }
}

/// Request object for `ListDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Filtering only supports equality on deployment state.
    /// It should be in the form: "state = DRAFT". `OR` operator can be used to
    /// get response for multiple states. e.g. "state = DRAFT OR state = APPLIED".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of deployments to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListDeployments call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeploymentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentsRequest"
    }
}

/// Response object for `ListDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentsResponse {
    /// The list of requested deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployments][crate::model::ListDeploymentsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeploymentsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for listing all revisions of a deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentRevisionsRequest {
    /// Required. The name of the deployment to list revisions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The maximum number of revisions to return per page.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListDeploymentRevisions
    /// call Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeploymentRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListDeploymentRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentRevisionsRequest"
    }
}

/// List of deployment revisions for a given deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentRevisionsResponse {
    /// The revisions of the deployment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeploymentRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployments][crate::model::ListDeploymentRevisionsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeploymentRevisionsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `SearchDeploymentRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDeploymentRevisionsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Supported queries:
    ///
    /// . ""                       : Lists all revisions across all deployments.
    /// . "latest=true"            : Lists latest revisions across all
    ///   deployments.
    /// . "name={name}"            : Lists all revisions of deployment with name
    ///   {name}.
    /// . "name={name} latest=true": Lists latest revision of deployment with name
    ///   {name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. The maximum number of deployment revisions to return per page.
    /// max page size = 100, default page size = 20.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, received from a previous search call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchDeploymentRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchDeploymentRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchDeploymentRevisionsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchDeploymentRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchDeploymentRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchDeploymentRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchDeploymentRevisionsRequest"
    }
}

/// Response object for `SearchDeploymentRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDeploymentRevisionsResponse {
    /// The list of requested deployment revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchDeploymentRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployments][crate::model::SearchDeploymentRevisionsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchDeploymentRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchDeploymentRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchDeploymentRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchDeploymentRevisionsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `DiscardDeploymentChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardDeploymentChangesRequest {
    /// Required. The name of the deployment of which changes are being discarded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscardDeploymentChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscardDeploymentChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DiscardDeploymentChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardDeploymentChangesRequest"
    }
}

/// Response object for `DiscardDeploymentChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardDeploymentChangesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscardDeploymentChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DiscardDeploymentChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardDeploymentChangesResponse"
    }
}

/// Request object for `ApplyDeployment`. The resources in given deployment
/// gets applied to Orchestration Cluster. A new revision is created when a
/// deployment is applied.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyDeploymentRequest {
    /// Required. The name of the deployment to apply to orchestration cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplyDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ApplyDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ApplyDeploymentRequest"
    }
}

/// Request object for `ComputeDeploymentStatus`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeDeploymentStatusRequest {
    /// Required. The name of the deployment without revisionID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeDeploymentStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeDeploymentStatusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ComputeDeploymentStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ComputeDeploymentStatusRequest"
    }
}

/// Response object for `ComputeDeploymentStatus`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeDeploymentStatusResponse {
    /// The name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Aggregated status of a deployment.
    pub aggregated_status: crate::model::Status,

    /// Output only. Resource level status details in deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_statuses: std::vec::Vec<crate::model::ResourceStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeDeploymentStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeDeploymentStatusResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [aggregated_status][crate::model::ComputeDeploymentStatusResponse::aggregated_status].
    pub fn set_aggregated_status<T: std::convert::Into<crate::model::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.aggregated_status = v.into();
        self
    }

    /// Sets the value of [resource_statuses][crate::model::ComputeDeploymentStatusResponse::resource_statuses].
    pub fn set_resource_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceStatus>,
    {
        use std::iter::Iterator;
        self.resource_statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeDeploymentStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ComputeDeploymentStatusResponse"
    }
}

/// Request object for `RollbackDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackDeploymentRequest {
    /// Required. Name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The revision id of deployment to roll back to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::RollbackDeploymentRequest::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.RollbackDeploymentRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.OperationMetadata"
    }
}

/// Request object for `GetHydratedDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetHydratedDeploymentRequest {
    /// Required. Name of the hydrated deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetHydratedDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetHydratedDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetHydratedDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetHydratedDeploymentRequest"
    }
}

/// Request object for `ListHydratedDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHydratedDeploymentsRequest {
    /// Required. The deployment managing the hydrated deployments.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of hydrated deployments to return. The service
    /// may return fewer than this value. If unspecified, at most 50 hydrated
    /// deployments will be returned. The maximum value is 1000. Values above 1000
    /// will be set to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListHydratedDeployments
    /// call. Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHydratedDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHydratedDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHydratedDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHydratedDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHydratedDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListHydratedDeploymentsRequest"
    }
}

/// Response object for `ListHydratedDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHydratedDeploymentsResponse {
    /// The list of hydrated deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hydrated_deployments: std::vec::Vec<crate::model::HydratedDeployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHydratedDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hydrated_deployments][crate::model::ListHydratedDeploymentsResponse::hydrated_deployments].
    pub fn set_hydrated_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HydratedDeployment>,
    {
        use std::iter::Iterator;
        self.hydrated_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListHydratedDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHydratedDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListHydratedDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListHydratedDeploymentsResponse {
    type PageItem = crate::model::HydratedDeployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hydrated_deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request object for `UpdateHydratedDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateHydratedDeploymentRequest {
    /// Required. The hydrated deployment to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hydrated_deployment: std::option::Option<crate::model::HydratedDeployment>,

    /// Required. The list of fields to update. Update mask supports a special
    /// value `*` which fully replaces (equivalent to PUT) the resource provided.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateHydratedDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hydrated_deployment][crate::model::UpdateHydratedDeploymentRequest::hydrated_deployment].
    pub fn set_hydrated_deployment<
        T: std::convert::Into<std::option::Option<crate::model::HydratedDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hydrated_deployment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateHydratedDeploymentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateHydratedDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.UpdateHydratedDeploymentRequest"
    }
}

/// Request for applying a hydrated deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyHydratedDeploymentRequest {
    /// Required. The name of the hydrated deployment to apply.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplyHydratedDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyHydratedDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ApplyHydratedDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ApplyHydratedDeploymentRequest"
    }
}

/// Configuration of the cluster management
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagementConfig {
    /// The configuration can be one of StandardManagementConfig
    /// and FullManagementConfig
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub oneof_config: std::option::Option<crate::model::management_config::OneofConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oneof_config][crate::model::ManagementConfig::oneof_config].
    ///
    /// Note that all the setters affecting `oneof_config` are mutually
    /// exclusive.
    pub fn set_oneof_config<
        T: std::convert::Into<std::option::Option<crate::model::management_config::OneofConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_config = v.into();
        self
    }

    /// The value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// if it holds a `StandardManagementConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_management_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardManagementConfig>> {
        #[allow(unreachable_patterns)]
        self.oneof_config.as_ref().and_then(|v| match v {
            crate::model::management_config::OneofConfig::StandardManagementConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// to hold a `StandardManagementConfig`.
    ///
    /// Note that all the setters affecting `oneof_config` are
    /// mutually exclusive.
    pub fn set_standard_management_config<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_config = std::option::Option::Some(
            crate::model::management_config::OneofConfig::StandardManagementConfig(v.into()),
        );
        self
    }

    /// The value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// if it holds a `FullManagementConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn full_management_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FullManagementConfig>> {
        #[allow(unreachable_patterns)]
        self.oneof_config.as_ref().and_then(|v| match v {
            crate::model::management_config::OneofConfig::FullManagementConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// to hold a `FullManagementConfig`.
    ///
    /// Note that all the setters affecting `oneof_config` are
    /// mutually exclusive.
    pub fn set_full_management_config<
        T: std::convert::Into<std::boxed::Box<crate::model::FullManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_config = std::option::Option::Some(
            crate::model::management_config::OneofConfig::FullManagementConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ManagementConfig"
    }
}

/// Defines additional types related to [ManagementConfig].
pub mod management_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration can be one of StandardManagementConfig
    /// and FullManagementConfig
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OneofConfig {
        /// Configuration of the standard (GKE) cluster management
        StandardManagementConfig(std::boxed::Box<crate::model::StandardManagementConfig>),
        /// Configuration of the full (Autopilot) cluster management. Full cluster
        /// management is a preview feature.
        FullManagementConfig(std::boxed::Box<crate::model::FullManagementConfig>),
    }
}

/// Configuration of the standard (GKE) cluster management.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardManagementConfig {
    /// Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
    /// VPC will be created if it doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Specifies the subnet that the interface will be part of. Network
    /// key must be specified and the subnet must be a subnetwork of the specified
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    /// Optional. The /28 network that the masters will use. It should be free
    /// within the network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster pod IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation
    /// (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster service IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
    /// 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_cidr_block: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
    /// can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_named_range: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for service ClusterIPs. Alternatively,
    /// services_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_named_range: std::string::String,

    /// Optional. Master Authorized Network that supports multiple CIDR blocks.
    /// Allows access to the k8s master from multiple blocks. It cannot be set at
    /// the same time with the field man_block.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::StandardManagementConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::StandardManagementConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::StandardManagementConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_cidr_block][crate::model::StandardManagementConfig::cluster_cidr_block].
    pub fn set_cluster_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_cidr_block][crate::model::StandardManagementConfig::services_cidr_block].
    pub fn set_services_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_named_range][crate::model::StandardManagementConfig::cluster_named_range].
    pub fn set_cluster_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_named_range = v.into();
        self
    }

    /// Sets the value of [services_named_range][crate::model::StandardManagementConfig::services_named_range].
    pub fn set_services_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_named_range = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::StandardManagementConfig::master_authorized_networks_config].
    pub fn set_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_authorized_networks_config = v.into();
        self
    }
}

impl wkt::message::Message for StandardManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.StandardManagementConfig"
    }
}

/// Configuration of the full (Autopilot) cluster management
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FullManagementConfig {
    /// Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
    /// VPC will be created if it doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Specifies the subnet that the interface will be part of. Network
    /// key must be specified and the subnet must be a subnetwork of the specified
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    /// Optional. The /28 network that the masters will use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster pod IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation
    /// (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster service IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
    /// 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_cidr_block: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
    /// can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_named_range: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for service ClusterIPs. Alternatively,
    /// services_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_named_range: std::string::String,

    /// Optional. Master Authorized Network that supports multiple CIDR blocks.
    /// Allows access to the k8s master from multiple blocks. It cannot be set at
    /// the same time with the field man_block.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FullManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::FullManagementConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::FullManagementConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::FullManagementConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_cidr_block][crate::model::FullManagementConfig::cluster_cidr_block].
    pub fn set_cluster_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_cidr_block][crate::model::FullManagementConfig::services_cidr_block].
    pub fn set_services_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_named_range][crate::model::FullManagementConfig::cluster_named_range].
    pub fn set_cluster_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_named_range = v.into();
        self
    }

    /// Sets the value of [services_named_range][crate::model::FullManagementConfig::services_named_range].
    pub fn set_services_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_named_range = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::FullManagementConfig::master_authorized_networks_config].
    pub fn set_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_authorized_networks_config = v.into();
        self
    }
}

impl wkt::message::Message for FullManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.FullManagementConfig"
    }
}

/// Configuration of the Master Authorized Network that support multiple CIDRs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MasterAuthorizedNetworksConfig {
    /// Optional. cidr_blocks define up to 50 external networks that could access
    /// Kubernetes master through HTTPS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cidr_blocks: std::vec::Vec<crate::model::master_authorized_networks_config::CidrBlock>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cidr_blocks][crate::model::MasterAuthorizedNetworksConfig::cidr_blocks].
    pub fn set_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::master_authorized_networks_config::CidrBlock>,
    {
        use std::iter::Iterator;
        self.cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MasterAuthorizedNetworksConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.MasterAuthorizedNetworksConfig"
    }
}

/// Defines additional types related to [MasterAuthorizedNetworksConfig].
pub mod master_authorized_networks_config {
    #[allow(unused_imports)]
    use super::*;

    /// CidrBlock contains an optional name and one CIDR block.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CidrBlock {
        /// Optional. display_name is an optional field for users to identify CIDR
        /// blocks.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// Optional. cidr_block must be specified in CIDR notation when using
        /// master_authorized_networks_config. Currently, the user could still use
        /// the deprecated man_block field, so this field is currently optional, but
        /// will be required in the future.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cidr_block: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CidrBlock {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::master_authorized_networks_config::CidrBlock::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [cidr_block][crate::model::master_authorized_networks_config::CidrBlock::cidr_block].
        pub fn set_cidr_block<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cidr_block = v.into();
            self
        }
    }

    impl wkt::message::Message for CidrBlock {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.telcoautomation.v1.MasterAuthorizedNetworksConfig.CidrBlock"
        }
    }
}

/// File represents a yaml file present in a blueprint's package.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct File {
    /// Required. Path of the file in package.
    /// e.g. `gdce/v1/cluster.yaml`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Optional. The contents of a file in string format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// Optional. Signifies whether a file is marked for deletion.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub deleted: bool,

    /// Optional. Indicates whether changes are allowed to a file. If the field is
    /// not set, the file cannot be edited.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub editable: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl File {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::File::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [content][crate::model::File::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::File::deleted].
    pub fn set_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deleted = v.into();
        self
    }

    /// Sets the value of [editable][crate::model::File::editable].
    pub fn set_editable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.editable = v.into();
        self
    }
}

impl wkt::message::Message for File {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.File"
    }
}

/// Status of a deployment resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceStatus {
    /// Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Namespace of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_namespace: std::string::String,

    /// Group to which the resource belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// Version of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Kind of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Output only. Resource type.
    pub resource_type: crate::model::ResourceType,

    /// Output only. Status of the resource.
    pub status: crate::model::Status,

    /// Output only. Detailed status of NFDeploy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nf_deploy_status: std::option::Option<crate::model::NFDeployStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceStatus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_namespace][crate::model::ResourceStatus::resource_namespace].
    pub fn set_resource_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_namespace = v.into();
        self
    }

    /// Sets the value of [group][crate::model::ResourceStatus::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ResourceStatus::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ResourceStatus::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::ResourceStatus::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::ResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ResourceStatus::status].
    pub fn set_status<T: std::convert::Into<crate::model::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [nf_deploy_status][crate::model::ResourceStatus::nf_deploy_status].
    pub fn set_nf_deploy_status<
        T: std::convert::Into<std::option::Option<crate::model::NFDeployStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nf_deploy_status = v.into();
        self
    }
}

impl wkt::message::Message for ResourceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ResourceStatus"
    }
}

/// Deployment status of NFDeploy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NFDeployStatus {
    /// Output only. Total number of NFs targeted by this deployment
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub targeted_nfs: i32,

    /// Output only. Total number of NFs targeted by this deployment with a Ready
    /// Condition set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ready_nfs: i32,

    /// Output only. Per-Site Status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sites: std::vec::Vec<crate::model::NFDeploySiteStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NFDeployStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targeted_nfs][crate::model::NFDeployStatus::targeted_nfs].
    pub fn set_targeted_nfs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.targeted_nfs = v.into();
        self
    }

    /// Sets the value of [ready_nfs][crate::model::NFDeployStatus::ready_nfs].
    pub fn set_ready_nfs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ready_nfs = v.into();
        self
    }

    /// Sets the value of [sites][crate::model::NFDeployStatus::sites].
    pub fn set_sites<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NFDeploySiteStatus>,
    {
        use std::iter::Iterator;
        self.sites = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NFDeployStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.NFDeployStatus"
    }
}

/// Per-Site Status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NFDeploySiteStatus {
    /// Output only. Site id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site: std::string::String,

    /// Output only. If true, the Site Deletion is in progress.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub pending_deletion: bool,

    /// Output only. Hydration status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hydration: std::option::Option<crate::model::HydrationStatus>,

    /// Output only. Workload status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload: std::option::Option<crate::model::WorkloadStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NFDeploySiteStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site][crate::model::NFDeploySiteStatus::site].
    pub fn set_site<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site = v.into();
        self
    }

    /// Sets the value of [pending_deletion][crate::model::NFDeploySiteStatus::pending_deletion].
    pub fn set_pending_deletion<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.pending_deletion = v.into();
        self
    }

    /// Sets the value of [hydration][crate::model::NFDeploySiteStatus::hydration].
    pub fn set_hydration<
        T: std::convert::Into<std::option::Option<crate::model::HydrationStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hydration = v.into();
        self
    }

    /// Sets the value of [workload][crate::model::NFDeploySiteStatus::workload].
    pub fn set_workload<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload = v.into();
        self
    }
}

impl wkt::message::Message for NFDeploySiteStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.NFDeploySiteStatus"
    }
}

/// Hydration status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HydrationStatus {
    /// Output only. SiteVersion Hydration is targeting.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub site_version: std::option::Option<crate::model::SiteVersion>,

    /// Output only. Status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HydrationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_version][crate::model::HydrationStatus::site_version].
    pub fn set_site_version<
        T: std::convert::Into<std::option::Option<crate::model::SiteVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.site_version = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HydrationStatus::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for HydrationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.HydrationStatus"
    }
}

/// SiteVersion Hydration is targeting.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SiteVersion {
    /// Output only. NF vendor.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nf_vendor: std::string::String,

    /// Output only. NF vendor type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nf_type: std::string::String,

    /// Output only. NF version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nf_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SiteVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nf_vendor][crate::model::SiteVersion::nf_vendor].
    pub fn set_nf_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nf_vendor = v.into();
        self
    }

    /// Sets the value of [nf_type][crate::model::SiteVersion::nf_type].
    pub fn set_nf_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nf_type = v.into();
        self
    }

    /// Sets the value of [nf_version][crate::model::SiteVersion::nf_version].
    pub fn set_nf_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nf_version = v.into();
        self
    }
}

impl wkt::message::Message for SiteVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SiteVersion"
    }
}

/// Workload status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadStatus {
    /// Output only. SiteVersion running in the workload cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub site_version: std::option::Option<crate::model::SiteVersion>,

    /// Output only. Status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_version][crate::model::WorkloadStatus::site_version].
    pub fn set_site_version<
        T: std::convert::Into<std::option::Option<crate::model::SiteVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.site_version = v.into();
        self
    }

    /// Sets the value of [status][crate::model::WorkloadStatus::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.WorkloadStatus"
    }
}

/// BlueprintView defines the type of view of the blueprint.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BlueprintView {
    /// Unspecified enum value.
    Unspecified,
    /// View which only contains metadata.
    Basic,
    /// View which contains metadata and files it encapsulates.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BlueprintView::value] or
    /// [BlueprintView::name].
    UnknownValue(blueprint_view::UnknownValue),
}

#[doc(hidden)]
pub mod blueprint_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BlueprintView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BLUEPRINT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BLUEPRINT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("BLUEPRINT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BlueprintView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BlueprintView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BlueprintView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(blueprint_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BlueprintView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BLUEPRINT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BLUEPRINT_VIEW_BASIC" => Self::Basic,
            "BLUEPRINT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(blueprint_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BlueprintView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BlueprintView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BlueprintView>::new(
            ".google.cloud.telcoautomation.v1.BlueprintView",
        ))
    }
}

/// DeploymentView defines the type of view of the deployment.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DeploymentView {
    /// Unspecified enum value.
    Unspecified,
    /// View which only contains metadata.
    Basic,
    /// View which contains metadata and files it encapsulates.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DeploymentView::value] or
    /// [DeploymentView::name].
    UnknownValue(deployment_view::UnknownValue),
}

#[doc(hidden)]
pub mod deployment_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DeploymentView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DEPLOYMENT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("DEPLOYMENT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("DEPLOYMENT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DeploymentView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DeploymentView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DeploymentView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(deployment_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DeploymentView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DEPLOYMENT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "DEPLOYMENT_VIEW_BASIC" => Self::Basic,
            "DEPLOYMENT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(deployment_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DeploymentView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DeploymentView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeploymentView>::new(
            ".google.cloud.telcoautomation.v1.DeploymentView",
        ))
    }
}

/// Represent type of CR.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ResourceType {
    /// Unspecified resource type.
    Unspecified,
    /// User specified NF Deploy CR.
    NfDeployResource,
    /// CRs that are part of a blueprint.
    DeploymentResource,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ResourceType::value] or
    /// [ResourceType::name].
    UnknownValue(resource_type::UnknownValue),
}

#[doc(hidden)]
pub mod resource_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ResourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NfDeployResource => std::option::Option::Some(1),
            Self::DeploymentResource => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESOURCE_TYPE_UNSPECIFIED"),
            Self::NfDeployResource => std::option::Option::Some("NF_DEPLOY_RESOURCE"),
            Self::DeploymentResource => std::option::Option::Some("DEPLOYMENT_RESOURCE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ResourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ResourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NfDeployResource,
            2 => Self::DeploymentResource,
            _ => Self::UnknownValue(resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ResourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NF_DEPLOY_RESOURCE" => Self::NfDeployResource,
            "DEPLOYMENT_RESOURCE" => Self::DeploymentResource,
            _ => Self::UnknownValue(resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ResourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NfDeployResource => serializer.serialize_i32(1),
            Self::DeploymentResource => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceType>::new(
            ".google.cloud.telcoautomation.v1.ResourceType",
        ))
    }
}

/// Status of an entity (resource, deployment).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Status {
    /// Unknown state.
    Unspecified,
    /// Under progress.
    InProgress,
    /// Running and ready to serve traffic.
    Active,
    /// Failed or stalled.
    Failed,
    /// Delete in progress.
    Deleting,
    /// Deleted deployment.
    Deleted,
    /// NFDeploy specific status. Peering in progress.
    Peering,
    /// K8s objects such as NetworkAttachmentDefinition don't have a defined
    /// status.
    NotApplicable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Status::value] or
    /// [Status::name].
    UnknownValue(status::UnknownValue),
}

#[doc(hidden)]
pub mod status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Status {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::InProgress => std::option::Option::Some(1),
            Self::Active => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::Deleting => std::option::Option::Some(4),
            Self::Deleted => std::option::Option::Some(5),
            Self::Peering => std::option::Option::Some(10),
            Self::NotApplicable => std::option::Option::Some(11),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
            Self::InProgress => std::option::Option::Some("STATUS_IN_PROGRESS"),
            Self::Active => std::option::Option::Some("STATUS_ACTIVE"),
            Self::Failed => std::option::Option::Some("STATUS_FAILED"),
            Self::Deleting => std::option::Option::Some("STATUS_DELETING"),
            Self::Deleted => std::option::Option::Some("STATUS_DELETED"),
            Self::Peering => std::option::Option::Some("STATUS_PEERING"),
            Self::NotApplicable => std::option::Option::Some("STATUS_NOT_APPLICABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Status {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Status {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Status {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::InProgress,
            2 => Self::Active,
            3 => Self::Failed,
            4 => Self::Deleting,
            5 => Self::Deleted,
            10 => Self::Peering,
            11 => Self::NotApplicable,
            _ => Self::UnknownValue(status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Status {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATUS_UNSPECIFIED" => Self::Unspecified,
            "STATUS_IN_PROGRESS" => Self::InProgress,
            "STATUS_ACTIVE" => Self::Active,
            "STATUS_FAILED" => Self::Failed,
            "STATUS_DELETING" => Self::Deleting,
            "STATUS_DELETED" => Self::Deleted,
            "STATUS_PEERING" => Self::Peering,
            "STATUS_NOT_APPLICABLE" => Self::NotApplicable,
            _ => Self::UnknownValue(status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Status {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::InProgress => serializer.serialize_i32(1),
            Self::Active => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::Deleting => serializer.serialize_i32(4),
            Self::Deleted => serializer.serialize_i32(5),
            Self::Peering => serializer.serialize_i32(10),
            Self::NotApplicable => serializer.serialize_i32(11),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Status {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
            ".google.cloud.telcoautomation.v1.Status",
        ))
    }
}

/// DeploymentLevel of a blueprint signifies where the blueprint will be
/// applied.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DeploymentLevel {
    /// Default unspecified deployment level.
    Unspecified,
    /// Blueprints at HYDRATION level cannot be used to create a Deployment
    /// (A user cannot manually initate deployment of these blueprints on
    /// orchestration or workload cluster).
    /// These blueprints stay in a user's private catalog and are configured and
    /// deployed by TNA automation.
    Hydration,
    /// Blueprints at SINGLE_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on orchestration cluster by the user, once
    /// approved.
    SingleDeployment,
    /// Blueprints at MULTI_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on orchestration cluster which will create
    /// further hydrated deployments.
    MultiDeployment,
    /// Blueprints at WORKLOAD_CLUSTER_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on workload cluster by the user, once
    /// approved.
    WorkloadClusterDeployment,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DeploymentLevel::value] or
    /// [DeploymentLevel::name].
    UnknownValue(deployment_level::UnknownValue),
}

#[doc(hidden)]
pub mod deployment_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DeploymentLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Hydration => std::option::Option::Some(1),
            Self::SingleDeployment => std::option::Option::Some(2),
            Self::MultiDeployment => std::option::Option::Some(3),
            Self::WorkloadClusterDeployment => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DEPLOYMENT_LEVEL_UNSPECIFIED"),
            Self::Hydration => std::option::Option::Some("HYDRATION"),
            Self::SingleDeployment => std::option::Option::Some("SINGLE_DEPLOYMENT"),
            Self::MultiDeployment => std::option::Option::Some("MULTI_DEPLOYMENT"),
            Self::WorkloadClusterDeployment => {
                std::option::Option::Some("WORKLOAD_CLUSTER_DEPLOYMENT")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DeploymentLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DeploymentLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DeploymentLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Hydration,
            2 => Self::SingleDeployment,
            3 => Self::MultiDeployment,
            4 => Self::WorkloadClusterDeployment,
            _ => Self::UnknownValue(deployment_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DeploymentLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DEPLOYMENT_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "HYDRATION" => Self::Hydration,
            "SINGLE_DEPLOYMENT" => Self::SingleDeployment,
            "MULTI_DEPLOYMENT" => Self::MultiDeployment,
            "WORKLOAD_CLUSTER_DEPLOYMENT" => Self::WorkloadClusterDeployment,
            _ => Self::UnknownValue(deployment_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DeploymentLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Hydration => serializer.serialize_i32(1),
            Self::SingleDeployment => serializer.serialize_i32(2),
            Self::MultiDeployment => serializer.serialize_i32(3),
            Self::WorkloadClusterDeployment => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DeploymentLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeploymentLevel>::new(
            ".google.cloud.telcoautomation.v1.DeploymentLevel",
        ))
    }
}
