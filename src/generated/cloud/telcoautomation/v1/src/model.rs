// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Orchestration cluster represents a GKE cluster with config controller and
/// TNA specific components installed on it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OrchestrationCluster {
    /// Name of the orchestration cluster. The name of orchestration cluster cannot
    /// be more than 24 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Management configuration of the underlying GKE cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_config: std::option::Option<crate::model::ManagementConfig>,

    /// Output only. [Output only] Create time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Provides the TNA version installed on the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tna_version: std::string::String,

    /// Output only. State of the Orchestration Cluster.
    pub state: crate::model::orchestration_cluster::State,
}

impl OrchestrationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OrchestrationCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [management_config][crate::model::OrchestrationCluster::management_config].
    pub fn set_management_config<
        T: std::convert::Into<std::option::Option<crate::model::ManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OrchestrationCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::OrchestrationCluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [tna_version][crate::model::OrchestrationCluster::tna_version].
    pub fn set_tna_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tna_version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::OrchestrationCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::orchestration_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::OrchestrationCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for OrchestrationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.OrchestrationCluster"
    }
}

/// Defines additional types related to OrchestrationCluster
pub mod orchestration_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states that the Orchestration Cluster can be in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// OrchestrationCluster is being created.
        pub const CREATING: State = State::new("CREATING");

        /// OrchestrationCluster has been created and is ready for use.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// OrchestrationCluster is being deleted.
        pub const DELETING: State = State::new("DELETING");

        /// OrchestrationCluster encountered an error and is in an indeterministic
        /// state. User can still initiate a delete operation on this state.
        pub const FAILED: State = State::new("FAILED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }
}

/// EdgeSlm represents an SLM instance which manages the lifecycle of edge
/// components installed on Workload clusters managed by an Orchestration
/// Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EdgeSlm {
    /// Name of the EdgeSlm resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. Reference to the orchestration cluster on which templates for
    /// this resources will be applied. This should be of format
    /// projects/{project}/locations/{location}/orchestrationClusters/{orchestration_cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub orchestration_cluster: std::string::String,

    /// Output only. [Output only] Create time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs. The key and value should contain
    /// characters which are UTF-8 compliant and less than 50 characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Provides the active TNA version for this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tna_version: std::string::String,

    /// Output only. State of the EdgeSlm resource.
    pub state: crate::model::edge_slm::State,

    /// Optional. Type of workload cluster for which an EdgeSLM resource is
    /// created.
    pub workload_cluster_type: crate::model::edge_slm::WorkloadClusterType,
}

impl EdgeSlm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EdgeSlm::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [orchestration_cluster][crate::model::EdgeSlm::orchestration_cluster].
    pub fn set_orchestration_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.orchestration_cluster = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EdgeSlm::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EdgeSlm::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [tna_version][crate::model::EdgeSlm::tna_version].
    pub fn set_tna_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tna_version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::EdgeSlm::state].
    pub fn set_state<T: std::convert::Into<crate::model::edge_slm::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [workload_cluster_type][crate::model::EdgeSlm::workload_cluster_type].
    pub fn set_workload_cluster_type<
        T: std::convert::Into<crate::model::edge_slm::WorkloadClusterType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_cluster_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EdgeSlm::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for EdgeSlm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.EdgeSlm"
    }
}

/// Defines additional types related to EdgeSlm
pub mod edge_slm {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// EdgeSlm is being created.
        pub const CREATING: State = State::new("CREATING");

        /// EdgeSlm has been created and is ready for use.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// EdgeSlm is being deleted.
        pub const DELETING: State = State::new("DELETING");

        /// EdgeSlm encountered an error and is in an indeterministic
        /// state. User can still initiate a delete operation on this state.
        pub const FAILED: State = State::new("FAILED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }

    /// Workload clusters supported by TNA. New values will be added to the enum
    /// list as TNA adds supports for new workload clusters in future.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct WorkloadClusterType(std::borrow::Cow<'static, str>);

    impl WorkloadClusterType {
        /// Creates a new WorkloadClusterType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [WorkloadClusterType](WorkloadClusterType)
    pub mod workload_cluster_type {
        use super::WorkloadClusterType;

        /// Unspecified workload cluster.
        pub const WORKLOAD_CLUSTER_TYPE_UNSPECIFIED: WorkloadClusterType =
            WorkloadClusterType::new("WORKLOAD_CLUSTER_TYPE_UNSPECIFIED");

        /// Workload cluster is a GDCE cluster.
        pub const GDCE: WorkloadClusterType = WorkloadClusterType::new("GDCE");

        /// Workload cluster is a GKE cluster.
        pub const GKE: WorkloadClusterType = WorkloadClusterType::new("GKE");
    }

    impl std::convert::From<std::string::String> for WorkloadClusterType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for WorkloadClusterType {
        fn default() -> Self {
            workload_cluster_type::WORKLOAD_CLUSTER_TYPE_UNSPECIFIED
        }
    }
}

/// A Blueprint contains a collection of kubernetes resources in the form of
/// YAML files. The file contents of a blueprint are collectively known as
/// package. A blueprint can be
/// a) imported from TNA's public catalog
/// b) modified as per a user's need
/// c) proposed and approved.
/// On approval, a revision of blueprint is created which can be used to
/// create a deployment on Orchestration or Workload Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Blueprint {
    /// The name of the blueprint. If unspecified, the name will be autogenerated
    /// from server side. Name of the blueprint must not contain `@` character.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The revision ID of the blueprint.
    /// A new revision is committed whenever a blueprint is approved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Required. Immutable. The public blueprint ID from which this blueprint was
    /// created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_blueprint: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Approval state of the blueprint (DRAFT, PROPOSED, APPROVED)
    pub approval_state: crate::model::blueprint::ApprovalState,

    /// Optional. Human readable name of a Blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Name of the repository where the blueprint files are stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Optional. Files present in a blueprint.
    /// When invoking UpdateBlueprint API, only the modified files should be
    /// included in this. Files that are not included in the update of a blueprint
    /// will not be changed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// Optional. Labels are key-value attributes that can be set on a blueprint
    /// resource by the user.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Blueprint creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the blueprint was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Source provider is the author of a public blueprint, from
    /// which this blueprint is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_provider: std::string::String,

    /// Output only. DeploymentLevel of a blueprint signifies where the blueprint
    /// will be applied. e.g. [HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT]
    pub deployment_level: crate::model::DeploymentLevel,

    /// Output only. Indicates if the deployment created from this blueprint can be
    /// rolled back.
    pub rollback_support: bool,
}

impl Blueprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Blueprint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::Blueprint::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [source_blueprint][crate::model::Blueprint::source_blueprint].
    pub fn set_source_blueprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_blueprint = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::Blueprint::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [approval_state][crate::model::Blueprint::approval_state].
    pub fn set_approval_state<T: std::convert::Into<crate::model::blueprint::ApprovalState>>(
        mut self,
        v: T,
    ) -> Self {
        self.approval_state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Blueprint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::Blueprint::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Blueprint::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Blueprint::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [source_provider][crate::model::Blueprint::source_provider].
    pub fn set_source_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_provider = v.into();
        self
    }

    /// Sets the value of [deployment_level][crate::model::Blueprint::deployment_level].
    pub fn set_deployment_level<T: std::convert::Into<crate::model::DeploymentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_level = v.into();
        self
    }

    /// Sets the value of [rollback_support][crate::model::Blueprint::rollback_support].
    pub fn set_rollback_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rollback_support = v.into();
        self
    }

    /// Sets the value of [files][crate::model::Blueprint::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Blueprint::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Blueprint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.Blueprint"
    }
}

/// Defines additional types related to Blueprint
pub mod blueprint {
    #[allow(unused_imports)]
    use super::*;

    /// Approval state indicates the state of a Blueprint in its approval
    /// lifecycle.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ApprovalState(std::borrow::Cow<'static, str>);

    impl ApprovalState {
        /// Creates a new ApprovalState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ApprovalState](ApprovalState)
    pub mod approval_state {
        use super::ApprovalState;

        /// Unspecified state.
        pub const APPROVAL_STATE_UNSPECIFIED: ApprovalState =
            ApprovalState::new("APPROVAL_STATE_UNSPECIFIED");

        /// A blueprint starts in DRAFT state once it is created. All edits are made
        /// to the blueprint in DRAFT state.
        pub const DRAFT: ApprovalState = ApprovalState::new("DRAFT");

        /// When the edits are ready for review, blueprint can be proposed and moves
        /// to PROPOSED state. Edits cannot be made to a blueprint in PROPOSED state.
        pub const PROPOSED: ApprovalState = ApprovalState::new("PROPOSED");

        /// When a proposed blueprint is approved, it moves to APPROVED state. A new
        /// revision is committed. The latest committed revision can be used to
        /// create a deployment on Orchestration or Workload Cluster. Edits to an
        /// APPROVED blueprint changes its state back to DRAFT. The last committed
        /// revision of a blueprint represents its latest APPROVED state.
        pub const APPROVED: ApprovalState = ApprovalState::new("APPROVED");
    }

    impl std::convert::From<std::string::String> for ApprovalState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for ApprovalState {
        fn default() -> Self {
            approval_state::APPROVAL_STATE_UNSPECIFIED
        }
    }
}

/// A Blueprint contains a collection of kubernetes resources in the form of
/// YAML files. The file contents of a blueprint are collectively known as
/// package.
/// Public blueprint is a TNA provided blueprint that in present in TNA's public
/// catalog. A user can copy the public blueprint to their private catalog for
/// further modifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PublicBlueprint {
    /// Name of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// DeploymentLevel of a blueprint signifies where the blueprint will be
    /// applied. e.g. [HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT]
    pub deployment_level: crate::model::DeploymentLevel,

    /// Source provider is the author of a public blueprint. e.g. Google, vendors
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_provider: std::string::String,

    /// Output only. Indicates if the deployment created from this blueprint can be
    /// rolled back.
    pub rollback_support: bool,
}

impl PublicBlueprint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PublicBlueprint::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PublicBlueprint::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PublicBlueprint::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [deployment_level][crate::model::PublicBlueprint::deployment_level].
    pub fn set_deployment_level<T: std::convert::Into<crate::model::DeploymentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_level = v.into();
        self
    }

    /// Sets the value of [source_provider][crate::model::PublicBlueprint::source_provider].
    pub fn set_source_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_provider = v.into();
        self
    }

    /// Sets the value of [rollback_support][crate::model::PublicBlueprint::rollback_support].
    pub fn set_rollback_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rollback_support = v.into();
        self
    }
}

impl wkt::message::Message for PublicBlueprint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.PublicBlueprint"
    }
}

/// Deployment contains a collection of YAML files (This collection is also known
/// as package) that can to applied on an orchestration cluster (GKE cluster with
/// TNA addons) or a workload cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Deployment {
    /// The name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The revision ID of the deployment.
    /// A new revision is committed whenever a change in deployment is applied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Required. The blueprint revision from which this deployment was created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_blueprint_revision: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the deployment (DRAFT, APPLIED, DELETING).
    pub state: crate::model::deployment::State,

    /// Optional. Human readable name of a Deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Name of the repository where the deployment package files are
    /// stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Optional. Files present in a deployment.
    /// When invoking UpdateDeployment API, only the modified files should be
    /// included in this. Files that are not included in the update of a deployment
    /// will not be changed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// Optional. Labels are key-value attributes that can be set on a deployment
    /// resource by the user.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Deployment creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the deployment was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Source provider is the author of a public blueprint, from
    /// which this deployment is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_provider: std::string::String,

    /// Optional. Immutable. The WorkloadCluster on which to create the Deployment.
    /// This field should only be passed when the deployment_level of the source
    /// blueprint specifies deployments on workload clusters e.g.
    /// WORKLOAD_CLUSTER_DEPLOYMENT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_cluster: std::string::String,

    /// Output only. Attributes to where the deployment can inflict changes. The
    /// value can only be [SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT].
    pub deployment_level: crate::model::DeploymentLevel,

    /// Output only. Indicates if the deployment can be rolled back, exported from
    /// public blueprint.
    pub rollback_support: bool,
}

impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Deployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::Deployment::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [source_blueprint_revision][crate::model::Deployment::source_blueprint_revision].
    pub fn set_source_blueprint_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_blueprint_revision = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::Deployment::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Deployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Deployment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::Deployment::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Deployment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Deployment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [source_provider][crate::model::Deployment::source_provider].
    pub fn set_source_provider<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_provider = v.into();
        self
    }

    /// Sets the value of [workload_cluster][crate::model::Deployment::workload_cluster].
    pub fn set_workload_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_cluster = v.into();
        self
    }

    /// Sets the value of [deployment_level][crate::model::Deployment::deployment_level].
    pub fn set_deployment_level<T: std::convert::Into<crate::model::DeploymentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_level = v.into();
        self
    }

    /// Sets the value of [rollback_support][crate::model::Deployment::rollback_support].
    pub fn set_rollback_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rollback_support = v.into();
        self
    }

    /// Sets the value of [files][crate::model::Deployment::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Deployment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.Deployment"
    }
}

/// Defines additional types related to Deployment
pub mod deployment {
    #[allow(unused_imports)]
    use super::*;

    /// State defines which state the current deployment is in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// A deployment starts in DRAFT state. All edits are made in DRAFT state. A
        /// deployment opened for editing after applying will be in draft state,
        /// while its prevision revision will be its current applied version.
        pub const DRAFT: State = State::new("DRAFT");

        /// This state means that the contents (YAML files containing kubernetes
        /// resources) of the deployment have been applied to an Orchestration or
        /// Workload Cluster. A revision is created when a deployment is applied.
        /// This revision will represent the latest view of what is applied on the
        /// cluster until the deployment is modified and applied again, which will
        /// create a new revision.
        pub const APPLIED: State = State::new("APPLIED");

        /// A deployment in DELETING state has been marked for deletion. Its
        /// deletion status can be queried using `ComputeDeploymentStatus` API. No
        /// updates are allowed to a deployment in DELETING state.
        pub const DELETING: State = State::new("DELETING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }
}

/// A collection of kubernetes yaml files which are deployed on a Workload
/// Cluster. Hydrated Deployments are created by TNA intent based automation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HydratedDeployment {
    /// Output only. The name of the hydrated deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. State of the hydrated deployment (DRAFT, APPLIED).
    pub state: crate::model::hydrated_deployment::State,

    /// Optional. File contents of a hydrated deployment.
    /// When invoking UpdateHydratedBlueprint API, only the modified files should
    /// be included in this. Files that are not included in the update of a
    /// hydrated deployment will not be changed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::File>,

    /// Output only. WorkloadCluster identifies which workload cluster will the
    /// hydrated deployment will be deployed on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_cluster: std::string::String,
}

impl HydratedDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HydratedDeployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::HydratedDeployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::hydrated_deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [workload_cluster][crate::model::HydratedDeployment::workload_cluster].
    pub fn set_workload_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_cluster = v.into();
        self
    }

    /// Sets the value of [files][crate::model::HydratedDeployment::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HydratedDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.HydratedDeployment"
    }
}

/// Defines additional types related to HydratedDeployment
pub mod hydrated_deployment {
    #[allow(unused_imports)]
    use super::*;

    /// State defines which state the current hydrated deployment is in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// A hydrated deployment starts in DRAFT state. All edits are made in DRAFT
        /// state.
        pub const DRAFT: State = State::new("DRAFT");

        /// When the edit is applied, the hydrated deployment moves to APPLIED
        /// state. No changes can be made once a hydrated deployment is applied.
        pub const APPLIED: State = State::new("APPLIED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }
}

/// Message for requesting list of OrchestrationClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrchestrationClustersRequest {
    /// Required. Parent value for ListOrchestrationClustersRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListOrchestrationClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOrchestrationClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOrchestrationClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOrchestrationClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOrchestrationClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListOrchestrationClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListOrchestrationClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListOrchestrationClustersRequest"
    }
}

/// Message for response to listing OrchestrationClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrchestrationClustersResponse {
    /// The list of OrchestrationCluster
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub orchestration_clusters: std::vec::Vec<crate::model::OrchestrationCluster>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListOrchestrationClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListOrchestrationClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [orchestration_clusters][crate::model::ListOrchestrationClustersResponse::orchestration_clusters].
    pub fn set_orchestration_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrchestrationCluster>,
    {
        use std::iter::Iterator;
        self.orchestration_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListOrchestrationClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOrchestrationClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListOrchestrationClustersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListOrchestrationClustersResponse {
    type PageItem = crate::model::OrchestrationCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.orchestration_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting a OrchestrationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOrchestrationClusterRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetOrchestrationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOrchestrationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOrchestrationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetOrchestrationClusterRequest"
    }
}

/// Message for creating a OrchestrationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateOrchestrationClusterRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// orchestration_cluster_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub orchestration_cluster_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub orchestration_cluster: std::option::Option<crate::model::OrchestrationCluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateOrchestrationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOrchestrationClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [orchestration_cluster_id][crate::model::CreateOrchestrationClusterRequest::orchestration_cluster_id].
    pub fn set_orchestration_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.orchestration_cluster_id = v.into();
        self
    }

    /// Sets the value of [orchestration_cluster][crate::model::CreateOrchestrationClusterRequest::orchestration_cluster].
    pub fn set_orchestration_cluster<
        T: std::convert::Into<std::option::Option<crate::model::OrchestrationCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.orchestration_cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateOrchestrationClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateOrchestrationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateOrchestrationClusterRequest"
    }
}

/// Message for deleting a OrchestrationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteOrchestrationClusterRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteOrchestrationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOrchestrationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteOrchestrationClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOrchestrationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DeleteOrchestrationClusterRequest"
    }
}

/// Message for requesting list of EdgeSlms
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEdgeSlmsRequest {
    /// Required. Parent value for ListEdgeSlmsRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListEdgeSlmsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEdgeSlmsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEdgeSlmsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEdgeSlmsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEdgeSlmsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEdgeSlmsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEdgeSlmsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListEdgeSlmsRequest"
    }
}

/// Message for response to listing EdgeSlms.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEdgeSlmsResponse {
    /// The list of EdgeSlm
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub edge_slms: std::vec::Vec<crate::model::EdgeSlm>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListEdgeSlmsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEdgeSlmsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [edge_slms][crate::model::ListEdgeSlmsResponse::edge_slms].
    pub fn set_edge_slms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EdgeSlm>,
    {
        use std::iter::Iterator;
        self.edge_slms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEdgeSlmsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEdgeSlmsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListEdgeSlmsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEdgeSlmsResponse {
    type PageItem = crate::model::EdgeSlm;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.edge_slms
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting a EdgeSlm.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEdgeSlmRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEdgeSlmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEdgeSlmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEdgeSlmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetEdgeSlmRequest"
    }
}

/// Message for creating a EdgeSlm.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEdgeSlmRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// edge_slm_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub edge_slm_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub edge_slm: std::option::Option<crate::model::EdgeSlm>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateEdgeSlmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEdgeSlmRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [edge_slm_id][crate::model::CreateEdgeSlmRequest::edge_slm_id].
    pub fn set_edge_slm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.edge_slm_id = v.into();
        self
    }

    /// Sets the value of [edge_slm][crate::model::CreateEdgeSlmRequest::edge_slm].
    pub fn set_edge_slm<T: std::convert::Into<std::option::Option<crate::model::EdgeSlm>>>(
        mut self,
        v: T,
    ) -> Self {
        self.edge_slm = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateEdgeSlmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEdgeSlmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateEdgeSlmRequest"
    }
}

/// Message for deleting a EdgeSlm.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEdgeSlmRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteEdgeSlmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEdgeSlmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteEdgeSlmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEdgeSlmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DeleteEdgeSlmRequest"
    }
}

/// Request object for `CreateBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBlueprintRequest {
    /// Required. The name of parent resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The name of the blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub blueprint_id: std::string::String,

    /// Required. The `Blueprint` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blueprint: std::option::Option<crate::model::Blueprint>,
}

impl CreateBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBlueprintRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [blueprint_id][crate::model::CreateBlueprintRequest::blueprint_id].
    pub fn set_blueprint_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.blueprint_id = v.into();
        self
    }

    /// Sets the value of [blueprint][crate::model::CreateBlueprintRequest::blueprint].
    pub fn set_blueprint<T: std::convert::Into<std::option::Option<crate::model::Blueprint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blueprint = v.into();
        self
    }
}

impl wkt::message::Message for CreateBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateBlueprintRequest"
    }
}

/// Request object for `UpdateBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBlueprintRequest {
    /// Required. The `blueprint` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blueprint: std::option::Option<crate::model::Blueprint>,

    /// Required. Update mask is used to specify the fields to be overwritten in
    /// the `blueprint` resource by the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blueprint][crate::model::UpdateBlueprintRequest::blueprint].
    pub fn set_blueprint<T: std::convert::Into<std::option::Option<crate::model::Blueprint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blueprint = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBlueprintRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.UpdateBlueprintRequest"
    }
}

/// Request object for `GetBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBlueprintRequest {
    /// Required. The name of the blueprint.
    /// Case 1: If the name provided in the request is
    /// {blueprint_id}@{revision_id}, then the revision with revision_id will be
    /// returned. Case 2: If the name provided in the request is {blueprint}, then
    /// the current state of the blueprint is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Defines the type of view of the blueprint.
    /// When field is not present BLUEPRINT_VIEW_BASIC is considered as default.
    pub view: crate::model::BlueprintView,
}

impl GetBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetBlueprintRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BlueprintView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetBlueprintRequest"
    }
}

/// Request object for `DeleteBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBlueprintRequest {
    /// Required. The name of blueprint to delete.
    /// Blueprint name should be in the format {blueprint_id}, if
    /// {blueprint_id}@{revision_id} is passed then the API throws invalid
    /// argument.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DeleteBlueprintRequest"
    }
}

/// Request object for `ListBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Filtering only supports equality on blueprint state.
    /// It should be in the form: "state = DRAFT". `OR` operator can be used to
    /// get response for multiple states. e.g. "state = DRAFT OR state = PROPOSED".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of blueprints to return per page.
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListBlueprints call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListBlueprintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBlueprintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBlueprintsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBlueprintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBlueprintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlueprintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintsRequest"
    }
}

/// Response object for `ListBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintsResponse {
    /// The list of requested blueprints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::Blueprint>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListBlueprintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBlueprintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [blueprints][crate::model::ListBlueprintsResponse::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBlueprintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBlueprintsResponse {
    type PageItem = crate::model::Blueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `ApproveBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveBlueprintRequest {
    /// Required. The name of the blueprint to approve. The blueprint must be in
    /// Proposed state. A new revision is committed on approval.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ApproveBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ApproveBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ApproveBlueprintRequest"
    }
}

/// Request object for `ProposeBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProposeBlueprintRequest {
    /// Required. The name of the blueprint being proposed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ProposeBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProposeBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ProposeBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ProposeBlueprintRequest"
    }
}

/// Request object for `RejectBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RejectBlueprintRequest {
    /// Required. The name of the blueprint being rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RejectBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RejectBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RejectBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.RejectBlueprintRequest"
    }
}

/// Request object for `ListBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintRevisionsRequest {
    /// Required. The name of the blueprint to list revisions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The maximum number of revisions to return per page.
    pub page_size: i32,

    /// The page token, received from a previous ListBlueprintRevisions call
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListBlueprintRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListBlueprintRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBlueprintRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBlueprintRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlueprintRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintRevisionsRequest"
    }
}

/// Response object for `ListBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlueprintRevisionsResponse {
    /// The revisions of the blueprint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::Blueprint>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListBlueprintRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBlueprintRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [blueprints][crate::model::ListBlueprintRevisionsResponse::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBlueprintRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListBlueprintRevisionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBlueprintRevisionsResponse {
    type PageItem = crate::model::Blueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `SearchBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlueprintRevisionsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Supported queries:
    ///
    /// . ""                       : Lists all revisions across all blueprints.
    /// . "latest=true"            : Lists latest revisions across all blueprints.
    /// . "name={name}"            : Lists all revisions of blueprint with name
    ///   {name}.
    /// . "name={name} latest=true": Lists latest revision of blueprint with name
    ///   {name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. The maximum number of blueprints revisions to return per page.
    /// max page size = 100, default page size = 20.
    pub page_size: i32,

    /// Optional. The page token, received from a previous search call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl SearchBlueprintRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchBlueprintRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchBlueprintRevisionsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchBlueprintRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchBlueprintRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlueprintRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchBlueprintRevisionsRequest"
    }
}

/// Response object for `SearchBlueprintRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlueprintRevisionsResponse {
    /// The list of requested blueprint revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::Blueprint>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchBlueprintRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchBlueprintRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [blueprints][crate::model::SearchBlueprintRevisionsResponse::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchBlueprintRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchBlueprintRevisionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchBlueprintRevisionsResponse {
    type PageItem = crate::model::Blueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `DiscardBlueprintChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardBlueprintChangesRequest {
    /// Required. The name of the blueprint of which changes are being discarded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DiscardBlueprintChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscardBlueprintChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DiscardBlueprintChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardBlueprintChangesRequest"
    }
}

/// Response object for `DiscardBlueprintChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardBlueprintChangesResponse {}

impl DiscardBlueprintChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DiscardBlueprintChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardBlueprintChangesResponse"
    }
}

/// Request object for `ListPublicBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPublicBlueprintsRequest {
    /// Required. Parent value of public blueprint.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListPublicBlueprintsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPublicBlueprintsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPublicBlueprintsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPublicBlueprintsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPublicBlueprintsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListPublicBlueprintsRequest"
    }
}

/// Response object for `ListPublicBlueprints`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPublicBlueprintsResponse {
    /// The list of public blueprints to return.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub public_blueprints: std::vec::Vec<crate::model::PublicBlueprint>,

    /// Output only. A token identifying a page of results the server should
    /// return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListPublicBlueprintsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPublicBlueprintsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [public_blueprints][crate::model::ListPublicBlueprintsResponse::public_blueprints].
    pub fn set_public_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PublicBlueprint>,
    {
        use std::iter::Iterator;
        self.public_blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPublicBlueprintsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListPublicBlueprintsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPublicBlueprintsResponse {
    type PageItem = crate::model::PublicBlueprint;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.public_blueprints
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `GetPublicBlueprint`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPublicBlueprintRequest {
    /// Required. The name of the public blueprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPublicBlueprintRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPublicBlueprintRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPublicBlueprintRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetPublicBlueprintRequest"
    }
}

/// Request object for `CreateDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeploymentRequest {
    /// Required. The name of parent resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deployment_id: std::string::String,

    /// Required. The `Deployment` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,
}

impl CreateDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeploymentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deployment_id][crate::model::CreateDeploymentRequest::deployment_id].
    pub fn set_deployment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deployment_id = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::CreateDeploymentRequest::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.CreateDeploymentRequest"
    }
}

/// Request object for `UpdateDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeploymentRequest {
    /// Required. The `deployment` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment: std::option::Option<crate::model::Deployment>,

    /// Required. Update mask is used to specify the fields to be overwritten in
    /// the `deployment` resource by the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment][crate::model::UpdateDeploymentRequest::deployment].
    pub fn set_deployment<T: std::convert::Into<std::option::Option<crate::model::Deployment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeploymentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.UpdateDeploymentRequest"
    }
}

/// Request object for `GetDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeploymentRequest {
    /// Required. The name of the deployment.
    /// Case 1: If the name provided in the request is
    /// {deployment_id}@{revision_id}, then the revision with revision_id will be
    /// returned.
    /// Case 2: If the name provided in the request is {deployment}, then
    /// the current state of the deployment is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Defines the type of view of the deployment.
    /// When field is not present VIEW_BASIC is considered as default.
    pub view: crate::model::DeploymentView,
}

impl GetDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetDeploymentRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::DeploymentView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetDeploymentRequest"
    }
}

/// Request object for `RemoveDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveDeploymentRequest {
    /// Required. The name of deployment to initiate delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RemoveDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RemoveDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.RemoveDeploymentRequest"
    }
}

/// Request object for `ListDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Filtering only supports equality on deployment state.
    /// It should be in the form: "state = DRAFT". `OR` operator can be used to
    /// get response for multiple states. e.g. "state = DRAFT OR state = APPLIED".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of deployments to return per page.
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListDeployments call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeploymentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentsRequest"
    }
}

/// Response object for `ListDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentsResponse {
    /// The list of requested deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [deployments][crate::model::ListDeploymentsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDeploymentsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for listing all revisions of a deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentRevisionsRequest {
    /// Required. The name of the deployment to list revisions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The maximum number of revisions to return per page.
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListDeploymentRevisions
    /// call Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDeploymentRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListDeploymentRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeploymentRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentRevisionsRequest"
    }
}

/// List of deployment revisions for a given deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeploymentRevisionsResponse {
    /// The revisions of the deployment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDeploymentRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [deployments][crate::model::ListDeploymentRevisionsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeploymentRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListDeploymentRevisionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListDeploymentRevisionsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `SearchDeploymentRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDeploymentRevisionsRequest {
    /// Required. The name of parent orchestration cluster resource.
    /// Format should be -
    /// "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Supported queries:
    ///
    /// . ""                       : Lists all revisions across all deployments.
    /// . "latest=true"            : Lists latest revisions across all
    ///   deployments.
    /// . "name={name}"            : Lists all revisions of deployment with name
    ///   {name}.
    /// . "name={name} latest=true": Lists latest revision of deployment with name
    ///   {name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. The maximum number of deployment revisions to return per page.
    /// max page size = 100, default page size = 20.
    pub page_size: i32,

    /// Optional. The page token, received from a previous search call.
    /// It can be provided to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl SearchDeploymentRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchDeploymentRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchDeploymentRevisionsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchDeploymentRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchDeploymentRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchDeploymentRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchDeploymentRevisionsRequest"
    }
}

/// Response object for `SearchDeploymentRevisions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchDeploymentRevisionsResponse {
    /// The list of requested deployment revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchDeploymentRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchDeploymentRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [deployments][crate::model::SearchDeploymentRevisionsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchDeploymentRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SearchDeploymentRevisionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchDeploymentRevisionsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `DiscardDeploymentChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardDeploymentChangesRequest {
    /// Required. The name of the deployment of which changes are being discarded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DiscardDeploymentChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiscardDeploymentChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DiscardDeploymentChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardDeploymentChangesRequest"
    }
}

/// Response object for `DiscardDeploymentChanges`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscardDeploymentChangesResponse {}

impl DiscardDeploymentChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DiscardDeploymentChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.DiscardDeploymentChangesResponse"
    }
}

/// Request object for `ApplyDeployment`. The resources in given deployment
/// gets applied to Orchestration Cluster. A new revision is created when a
/// deployment is applied.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyDeploymentRequest {
    /// Required. The name of the deployment to apply to orchestration cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ApplyDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ApplyDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ApplyDeploymentRequest"
    }
}

/// Request object for `ComputeDeploymentStatus`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeDeploymentStatusRequest {
    /// Required. The name of the deployment without revisionID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ComputeDeploymentStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeDeploymentStatusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ComputeDeploymentStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ComputeDeploymentStatusRequest"
    }
}

/// Response object for `ComputeDeploymentStatus`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeDeploymentStatusResponse {
    /// The name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Aggregated status of a deployment.
    pub aggregated_status: crate::model::Status,

    /// Output only. Resource level status details in deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_statuses: std::vec::Vec<crate::model::ResourceStatus>,
}

impl ComputeDeploymentStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeDeploymentStatusResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [aggregated_status][crate::model::ComputeDeploymentStatusResponse::aggregated_status].
    pub fn set_aggregated_status<T: std::convert::Into<crate::model::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.aggregated_status = v.into();
        self
    }

    /// Sets the value of [resource_statuses][crate::model::ComputeDeploymentStatusResponse::resource_statuses].
    pub fn set_resource_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceStatus>,
    {
        use std::iter::Iterator;
        self.resource_statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeDeploymentStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ComputeDeploymentStatusResponse"
    }
}

/// Request object for `RollbackDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackDeploymentRequest {
    /// Required. Name of the deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The revision id of deployment to roll back to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,
}

impl RollbackDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::RollbackDeploymentRequest::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.RollbackDeploymentRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.OperationMetadata"
    }
}

/// Request object for `GetHydratedDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetHydratedDeploymentRequest {
    /// Required. Name of the hydrated deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetHydratedDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetHydratedDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetHydratedDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.GetHydratedDeploymentRequest"
    }
}

/// Request object for `ListHydratedDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHydratedDeploymentsRequest {
    /// Required. The deployment managing the hydrated deployments.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of hydrated deployments to return. The service
    /// may return fewer than this value. If unspecified, at most 50 hydrated
    /// deployments will be returned. The maximum value is 1000. Values above 1000
    /// will be set to 1000.
    pub page_size: i32,

    /// Optional. The page token, received from a previous ListHydratedDeployments
    /// call. Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListHydratedDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHydratedDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHydratedDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHydratedDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHydratedDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListHydratedDeploymentsRequest"
    }
}

/// Response object for `ListHydratedDeployments`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHydratedDeploymentsResponse {
    /// The list of hydrated deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hydrated_deployments: std::vec::Vec<crate::model::HydratedDeployment>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListHydratedDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListHydratedDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [hydrated_deployments][crate::model::ListHydratedDeploymentsResponse::hydrated_deployments].
    pub fn set_hydrated_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HydratedDeployment>,
    {
        use std::iter::Iterator;
        self.hydrated_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListHydratedDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ListHydratedDeploymentsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListHydratedDeploymentsResponse {
    type PageItem = crate::model::HydratedDeployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hydrated_deployments
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request object for `UpdateHydratedDeployment`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateHydratedDeploymentRequest {
    /// Required. The hydrated deployment to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hydrated_deployment: std::option::Option<crate::model::HydratedDeployment>,

    /// Required. The list of fields to update. Update mask supports a special
    /// value `*` which fully replaces (equivalent to PUT) the resource provided.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateHydratedDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hydrated_deployment][crate::model::UpdateHydratedDeploymentRequest::hydrated_deployment].
    pub fn set_hydrated_deployment<
        T: std::convert::Into<std::option::Option<crate::model::HydratedDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hydrated_deployment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateHydratedDeploymentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateHydratedDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.UpdateHydratedDeploymentRequest"
    }
}

/// Request for applying a hydrated deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyHydratedDeploymentRequest {
    /// Required. The name of the hydrated deployment to apply.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ApplyHydratedDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyHydratedDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ApplyHydratedDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ApplyHydratedDeploymentRequest"
    }
}

/// Configuration of the cluster management
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagementConfig {
    /// The configuration can be one of StandardManagementConfig
    /// and FullManagementConfig
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub oneof_config: std::option::Option<crate::model::management_config::OneofConfig>,
}

impl ManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `oneof_config`.
    pub fn set_oneof_config<
        T: std::convert::Into<std::option::Option<crate::model::management_config::OneofConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_config = v.into();
        self
    }

    /// The value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// if it holds a `StandardManagementConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_standard_management_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardManagementConfig>> {
        #[allow(unreachable_patterns)]
        self.oneof_config.as_ref().and_then(|v| match v {
            crate::model::management_config::OneofConfig::StandardManagementConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// if it holds a `FullManagementConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_full_management_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FullManagementConfig>> {
        #[allow(unreachable_patterns)]
        self.oneof_config.as_ref().and_then(|v| match v {
            crate::model::management_config::OneofConfig::FullManagementConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// to hold a `StandardManagementConfig`.
    ///
    /// Note that all the setters affecting `oneof_config` are
    /// mutually exclusive.
    pub fn set_standard_management_config<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_config = std::option::Option::Some(
            crate::model::management_config::OneofConfig::StandardManagementConfig(v.into()),
        );
        self
    }

    /// Sets the value of [oneof_config][crate::model::ManagementConfig::oneof_config]
    /// to hold a `FullManagementConfig`.
    ///
    /// Note that all the setters affecting `oneof_config` are
    /// mutually exclusive.
    pub fn set_full_management_config<
        T: std::convert::Into<std::boxed::Box<crate::model::FullManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_config = std::option::Option::Some(
            crate::model::management_config::OneofConfig::FullManagementConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ManagementConfig"
    }
}

/// Defines additional types related to ManagementConfig
pub mod management_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration can be one of StandardManagementConfig
    /// and FullManagementConfig
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OneofConfig {
        /// Configuration of the standard (GKE) cluster management
        StandardManagementConfig(std::boxed::Box<crate::model::StandardManagementConfig>),
        /// Configuration of the full (Autopilot) cluster management. Full cluster
        /// management is a preview feature.
        FullManagementConfig(std::boxed::Box<crate::model::FullManagementConfig>),
    }
}

/// Configuration of the standard (GKE) cluster management.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardManagementConfig {
    /// Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
    /// VPC will be created if it doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Specifies the subnet that the interface will be part of. Network
    /// key must be specified and the subnet must be a subnetwork of the specified
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    /// Optional. The /28 network that the masters will use. It should be free
    /// within the network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster pod IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation
    /// (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster service IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
    /// 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_cidr_block: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
    /// can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_named_range: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for service ClusterIPs. Alternatively,
    /// services_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_named_range: std::string::String,

    /// Optional. Master Authorized Network that supports multiple CIDR blocks.
    /// Allows access to the k8s master from multiple blocks. It cannot be set at
    /// the same time with the field man_block.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,
}

impl StandardManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::StandardManagementConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::StandardManagementConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::StandardManagementConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_cidr_block][crate::model::StandardManagementConfig::cluster_cidr_block].
    pub fn set_cluster_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_cidr_block][crate::model::StandardManagementConfig::services_cidr_block].
    pub fn set_services_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_named_range][crate::model::StandardManagementConfig::cluster_named_range].
    pub fn set_cluster_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_named_range = v.into();
        self
    }

    /// Sets the value of [services_named_range][crate::model::StandardManagementConfig::services_named_range].
    pub fn set_services_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_named_range = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::StandardManagementConfig::master_authorized_networks_config].
    pub fn set_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_authorized_networks_config = v.into();
        self
    }
}

impl wkt::message::Message for StandardManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.StandardManagementConfig"
    }
}

/// Configuration of the full (Autopilot) cluster management
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FullManagementConfig {
    /// Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
    /// VPC will be created if it doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Specifies the subnet that the interface will be part of. Network
    /// key must be specified and the subnet must be a subnetwork of the specified
    /// network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    /// Optional. The /28 network that the masters will use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster pod IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation
    /// (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_cidr_block: std::string::String,

    /// Optional. The IP address range for the cluster service IPs. Set to blank to
    /// have a range chosen with the default size. Set to /netmask (e.g. /14) to
    /// have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
    /// 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
    /// 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_cidr_block: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
    /// can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_named_range: std::string::String,

    /// Optional. The name of the existing secondary range in the cluster's
    /// subnetwork to use for service ClusterIPs. Alternatively,
    /// services_cidr_block can be used to automatically create a GKE-managed one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_named_range: std::string::String,

    /// Optional. Master Authorized Network that supports multiple CIDR blocks.
    /// Allows access to the k8s master from multiple blocks. It cannot be set at
    /// the same time with the field man_block.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,
}

impl FullManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::FullManagementConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::FullManagementConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::FullManagementConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_cidr_block][crate::model::FullManagementConfig::cluster_cidr_block].
    pub fn set_cluster_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_cidr_block][crate::model::FullManagementConfig::services_cidr_block].
    pub fn set_services_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_cidr_block = v.into();
        self
    }

    /// Sets the value of [cluster_named_range][crate::model::FullManagementConfig::cluster_named_range].
    pub fn set_cluster_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_named_range = v.into();
        self
    }

    /// Sets the value of [services_named_range][crate::model::FullManagementConfig::services_named_range].
    pub fn set_services_named_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_named_range = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::FullManagementConfig::master_authorized_networks_config].
    pub fn set_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_authorized_networks_config = v.into();
        self
    }
}

impl wkt::message::Message for FullManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.FullManagementConfig"
    }
}

/// Configuration of the Master Authorized Network that support multiple CIDRs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MasterAuthorizedNetworksConfig {
    /// Optional. cidr_blocks define up to 50 external networks that could access
    /// Kubernetes master through HTTPS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cidr_blocks: std::vec::Vec<crate::model::master_authorized_networks_config::CidrBlock>,
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cidr_blocks][crate::model::MasterAuthorizedNetworksConfig::cidr_blocks].
    pub fn set_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::master_authorized_networks_config::CidrBlock>,
    {
        use std::iter::Iterator;
        self.cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MasterAuthorizedNetworksConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.MasterAuthorizedNetworksConfig"
    }
}

/// Defines additional types related to MasterAuthorizedNetworksConfig
pub mod master_authorized_networks_config {
    #[allow(unused_imports)]
    use super::*;

    /// CidrBlock contains an optional name and one CIDR block.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CidrBlock {
        /// Optional. display_name is an optional field for users to identify CIDR
        /// blocks.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// Optional. cidr_block must be specified in CIDR notation when using
        /// master_authorized_networks_config. Currently, the user could still use
        /// the deprecated man_block field, so this field is currently optional, but
        /// will be required in the future.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cidr_block: std::string::String,
    }

    impl CidrBlock {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::master_authorized_networks_config::CidrBlock::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [cidr_block][crate::model::master_authorized_networks_config::CidrBlock::cidr_block].
        pub fn set_cidr_block<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cidr_block = v.into();
            self
        }
    }

    impl wkt::message::Message for CidrBlock {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.telcoautomation.v1.MasterAuthorizedNetworksConfig.CidrBlock"
        }
    }
}

/// File represents a yaml file present in a blueprint's package.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct File {
    /// Required. Path of the file in package.
    /// e.g. `gdce/v1/cluster.yaml`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Optional. The contents of a file in string format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// Optional. Signifies whether a file is marked for deletion.
    pub deleted: bool,

    /// Optional. Indicates whether changes are allowed to a file. If the field is
    /// not set, the file cannot be edited.
    pub editable: bool,
}

impl File {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::File::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [content][crate::model::File::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::File::deleted].
    pub fn set_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deleted = v.into();
        self
    }

    /// Sets the value of [editable][crate::model::File::editable].
    pub fn set_editable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.editable = v.into();
        self
    }
}

impl wkt::message::Message for File {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.File"
    }
}

/// Status of a deployment resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceStatus {
    /// Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Namespace of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_namespace: std::string::String,

    /// Group to which the resource belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// Version of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Kind of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Output only. Resource type.
    pub resource_type: crate::model::ResourceType,

    /// Output only. Status of the resource.
    pub status: crate::model::Status,

    /// Output only. Detailed status of NFDeploy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nf_deploy_status: std::option::Option<crate::model::NFDeployStatus>,
}

impl ResourceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceStatus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_namespace][crate::model::ResourceStatus::resource_namespace].
    pub fn set_resource_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_namespace = v.into();
        self
    }

    /// Sets the value of [group][crate::model::ResourceStatus::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [version][crate::model::ResourceStatus::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ResourceStatus::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::ResourceStatus::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::ResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ResourceStatus::status].
    pub fn set_status<T: std::convert::Into<crate::model::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [nf_deploy_status][crate::model::ResourceStatus::nf_deploy_status].
    pub fn set_nf_deploy_status<
        T: std::convert::Into<std::option::Option<crate::model::NFDeployStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nf_deploy_status = v.into();
        self
    }
}

impl wkt::message::Message for ResourceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.ResourceStatus"
    }
}

/// Deployment status of NFDeploy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NFDeployStatus {
    /// Output only. Total number of NFs targeted by this deployment
    pub targeted_nfs: i32,

    /// Output only. Total number of NFs targeted by this deployment with a Ready
    /// Condition set.
    pub ready_nfs: i32,

    /// Output only. Per-Site Status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sites: std::vec::Vec<crate::model::NFDeploySiteStatus>,
}

impl NFDeployStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targeted_nfs][crate::model::NFDeployStatus::targeted_nfs].
    pub fn set_targeted_nfs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.targeted_nfs = v.into();
        self
    }

    /// Sets the value of [ready_nfs][crate::model::NFDeployStatus::ready_nfs].
    pub fn set_ready_nfs<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ready_nfs = v.into();
        self
    }

    /// Sets the value of [sites][crate::model::NFDeployStatus::sites].
    pub fn set_sites<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NFDeploySiteStatus>,
    {
        use std::iter::Iterator;
        self.sites = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NFDeployStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.NFDeployStatus"
    }
}

/// Per-Site Status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NFDeploySiteStatus {
    /// Output only. Site id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site: std::string::String,

    /// Output only. If true, the Site Deletion is in progress.
    pub pending_deletion: bool,

    /// Output only. Hydration status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hydration: std::option::Option<crate::model::HydrationStatus>,

    /// Output only. Workload status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload: std::option::Option<crate::model::WorkloadStatus>,
}

impl NFDeploySiteStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site][crate::model::NFDeploySiteStatus::site].
    pub fn set_site<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site = v.into();
        self
    }

    /// Sets the value of [pending_deletion][crate::model::NFDeploySiteStatus::pending_deletion].
    pub fn set_pending_deletion<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.pending_deletion = v.into();
        self
    }

    /// Sets the value of [hydration][crate::model::NFDeploySiteStatus::hydration].
    pub fn set_hydration<
        T: std::convert::Into<std::option::Option<crate::model::HydrationStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hydration = v.into();
        self
    }

    /// Sets the value of [workload][crate::model::NFDeploySiteStatus::workload].
    pub fn set_workload<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload = v.into();
        self
    }
}

impl wkt::message::Message for NFDeploySiteStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.NFDeploySiteStatus"
    }
}

/// Hydration status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HydrationStatus {
    /// Output only. SiteVersion Hydration is targeting.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub site_version: std::option::Option<crate::model::SiteVersion>,

    /// Output only. Status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,
}

impl HydrationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_version][crate::model::HydrationStatus::site_version].
    pub fn set_site_version<
        T: std::convert::Into<std::option::Option<crate::model::SiteVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.site_version = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HydrationStatus::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for HydrationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.HydrationStatus"
    }
}

/// SiteVersion Hydration is targeting.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SiteVersion {
    /// Output only. NF vendor.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nf_vendor: std::string::String,

    /// Output only. NF vendor type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nf_type: std::string::String,

    /// Output only. NF version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nf_version: std::string::String,
}

impl SiteVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nf_vendor][crate::model::SiteVersion::nf_vendor].
    pub fn set_nf_vendor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nf_vendor = v.into();
        self
    }

    /// Sets the value of [nf_type][crate::model::SiteVersion::nf_type].
    pub fn set_nf_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nf_type = v.into();
        self
    }

    /// Sets the value of [nf_version][crate::model::SiteVersion::nf_version].
    pub fn set_nf_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nf_version = v.into();
        self
    }
}

impl wkt::message::Message for SiteVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.SiteVersion"
    }
}

/// Workload status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadStatus {
    /// Output only. SiteVersion running in the workload cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub site_version: std::option::Option<crate::model::SiteVersion>,

    /// Output only. Status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,
}

impl WorkloadStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_version][crate::model::WorkloadStatus::site_version].
    pub fn set_site_version<
        T: std::convert::Into<std::option::Option<crate::model::SiteVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.site_version = v.into();
        self
    }

    /// Sets the value of [status][crate::model::WorkloadStatus::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.telcoautomation.v1.WorkloadStatus"
    }
}

/// BlueprintView defines the type of view of the blueprint.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct BlueprintView(std::borrow::Cow<'static, str>);

impl BlueprintView {
    /// Creates a new BlueprintView instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [BlueprintView](BlueprintView)
pub mod blueprint_view {
    use super::BlueprintView;

    /// Unspecified enum value.
    pub const BLUEPRINT_VIEW_UNSPECIFIED: BlueprintView =
        BlueprintView::new("BLUEPRINT_VIEW_UNSPECIFIED");

    /// View which only contains metadata.
    pub const BLUEPRINT_VIEW_BASIC: BlueprintView = BlueprintView::new("BLUEPRINT_VIEW_BASIC");

    /// View which contains metadata and files it encapsulates.
    pub const BLUEPRINT_VIEW_FULL: BlueprintView = BlueprintView::new("BLUEPRINT_VIEW_FULL");
}

impl std::convert::From<std::string::String> for BlueprintView {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for BlueprintView {
    fn default() -> Self {
        blueprint_view::BLUEPRINT_VIEW_UNSPECIFIED
    }
}

/// DeploymentView defines the type of view of the deployment.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DeploymentView(std::borrow::Cow<'static, str>);

impl DeploymentView {
    /// Creates a new DeploymentView instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [DeploymentView](DeploymentView)
pub mod deployment_view {
    use super::DeploymentView;

    /// Unspecified enum value.
    pub const DEPLOYMENT_VIEW_UNSPECIFIED: DeploymentView =
        DeploymentView::new("DEPLOYMENT_VIEW_UNSPECIFIED");

    /// View which only contains metadata.
    pub const DEPLOYMENT_VIEW_BASIC: DeploymentView = DeploymentView::new("DEPLOYMENT_VIEW_BASIC");

    /// View which contains metadata and files it encapsulates.
    pub const DEPLOYMENT_VIEW_FULL: DeploymentView = DeploymentView::new("DEPLOYMENT_VIEW_FULL");
}

impl std::convert::From<std::string::String> for DeploymentView {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for DeploymentView {
    fn default() -> Self {
        deployment_view::DEPLOYMENT_VIEW_UNSPECIFIED
    }
}

/// Represent type of CR.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ResourceType(std::borrow::Cow<'static, str>);

impl ResourceType {
    /// Creates a new ResourceType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ResourceType](ResourceType)
pub mod resource_type {
    use super::ResourceType;

    /// Unspecified resource type.
    pub const RESOURCE_TYPE_UNSPECIFIED: ResourceType =
        ResourceType::new("RESOURCE_TYPE_UNSPECIFIED");

    /// User specified NF Deploy CR.
    pub const NF_DEPLOY_RESOURCE: ResourceType = ResourceType::new("NF_DEPLOY_RESOURCE");

    /// CRs that are part of a blueprint.
    pub const DEPLOYMENT_RESOURCE: ResourceType = ResourceType::new("DEPLOYMENT_RESOURCE");
}

impl std::convert::From<std::string::String> for ResourceType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for ResourceType {
    fn default() -> Self {
        resource_type::RESOURCE_TYPE_UNSPECIFIED
    }
}

/// Status of an entity (resource, deployment).
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Status(std::borrow::Cow<'static, str>);

impl Status {
    /// Creates a new Status instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [Status](Status)
pub mod status {
    use super::Status;

    /// Unknown state.
    pub const STATUS_UNSPECIFIED: Status = Status::new("STATUS_UNSPECIFIED");

    /// Under progress.
    pub const STATUS_IN_PROGRESS: Status = Status::new("STATUS_IN_PROGRESS");

    /// Running and ready to serve traffic.
    pub const STATUS_ACTIVE: Status = Status::new("STATUS_ACTIVE");

    /// Failed or stalled.
    pub const STATUS_FAILED: Status = Status::new("STATUS_FAILED");

    /// Delete in progress.
    pub const STATUS_DELETING: Status = Status::new("STATUS_DELETING");

    /// Deleted deployment.
    pub const STATUS_DELETED: Status = Status::new("STATUS_DELETED");

    /// NFDeploy specific status. Peering in progress.
    pub const STATUS_PEERING: Status = Status::new("STATUS_PEERING");

    /// K8s objects such as NetworkAttachmentDefinition don't have a defined
    /// status.
    pub const STATUS_NOT_APPLICABLE: Status = Status::new("STATUS_NOT_APPLICABLE");
}

impl std::convert::From<std::string::String> for Status {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for Status {
    fn default() -> Self {
        status::STATUS_UNSPECIFIED
    }
}

/// DeploymentLevel of a blueprint signifies where the blueprint will be
/// applied.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DeploymentLevel(std::borrow::Cow<'static, str>);

impl DeploymentLevel {
    /// Creates a new DeploymentLevel instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [DeploymentLevel](DeploymentLevel)
pub mod deployment_level {
    use super::DeploymentLevel;

    /// Default unspecified deployment level.
    pub const DEPLOYMENT_LEVEL_UNSPECIFIED: DeploymentLevel =
        DeploymentLevel::new("DEPLOYMENT_LEVEL_UNSPECIFIED");

    /// Blueprints at HYDRATION level cannot be used to create a Deployment
    /// (A user cannot manually initate deployment of these blueprints on
    /// orchestration or workload cluster).
    /// These blueprints stay in a user's private catalog and are configured and
    /// deployed by TNA automation.
    pub const HYDRATION: DeploymentLevel = DeploymentLevel::new("HYDRATION");

    /// Blueprints at SINGLE_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on orchestration cluster by the user, once
    /// approved.
    pub const SINGLE_DEPLOYMENT: DeploymentLevel = DeploymentLevel::new("SINGLE_DEPLOYMENT");

    /// Blueprints at MULTI_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on orchestration cluster which will create
    /// further hydrated deployments.
    pub const MULTI_DEPLOYMENT: DeploymentLevel = DeploymentLevel::new("MULTI_DEPLOYMENT");

    /// Blueprints at WORKLOAD_CLUSTER_DEPLOYMENT level can be
    /// a) Modified in private catalog.
    /// b) Used to create a deployment on workload cluster by the user, once
    /// approved.
    pub const WORKLOAD_CLUSTER_DEPLOYMENT: DeploymentLevel =
        DeploymentLevel::new("WORKLOAD_CLUSTER_DEPLOYMENT");
}

impl std::convert::From<std::string::String> for DeploymentLevel {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for DeploymentLevel {
    fn default() -> Self {
        deployment_level::DEPLOYMENT_LEVEL_UNSPECIFIED
    }
}
