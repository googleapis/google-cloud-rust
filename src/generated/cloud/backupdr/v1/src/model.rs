// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Network configuration for ManagementServer instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Optional. The resource name of the Google Compute Engine VPC network to
    /// which the ManagementServer instance is connected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. The network connect mode of the ManagementServer instance. For
    /// this version, only PRIVATE_SERVICE_ACCESS is supported.
    pub peering_mode: crate::model::network_config::PeeringMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [peering_mode][crate::model::NetworkConfig::peering_mode].
    pub fn set_peering_mode<T: std::convert::Into<crate::model::network_config::PeeringMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.peering_mode = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.NetworkConfig"
    }
}

/// Defines additional types related to [NetworkConfig].
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// VPC peering modes supported by Cloud BackupDR.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PeeringMode {
        /// Peering mode not set.
        Unspecified,
        /// Connect using Private Service Access to the Management Server. Private
        /// services access provides an IP address range for multiple Google Cloud
        /// services, including Cloud BackupDR.
        PrivateServiceAccess,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PeeringMode::value] or
        /// [PeeringMode::name].
        UnknownValue(peering_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod peering_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PeeringMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PrivateServiceAccess => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PEERING_MODE_UNSPECIFIED"),
                Self::PrivateServiceAccess => std::option::Option::Some("PRIVATE_SERVICE_ACCESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PeeringMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PeeringMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PeeringMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PrivateServiceAccess,
                _ => Self::UnknownValue(peering_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PeeringMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PEERING_MODE_UNSPECIFIED" => Self::Unspecified,
                "PRIVATE_SERVICE_ACCESS" => Self::PrivateServiceAccess,
                _ => Self::UnknownValue(peering_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PeeringMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PrivateServiceAccess => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PeeringMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PeeringMode>::new(
                ".google.cloud.backupdr.v1.NetworkConfig.PeeringMode",
            ))
        }
    }
}

/// ManagementURI for the Management Server resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagementURI {
    /// Output only. The ManagementServer AGM/RD WebUI URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub web_ui: std::string::String,

    /// Output only. The ManagementServer AGM/RD API URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagementURI {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [web_ui][crate::model::ManagementURI::web_ui].
    pub fn set_web_ui<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.web_ui = v.into();
        self
    }

    /// Sets the value of [api][crate::model::ManagementURI::api].
    pub fn set_api<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api = v.into();
        self
    }
}

impl wkt::message::Message for ManagementURI {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ManagementURI"
    }
}

/// ManagementURI depending on the Workforce Identity i.e. either 1p or 3p.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkforceIdentityBasedManagementURI {
    /// Output only. First party Management URI for Google Identities.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub first_party_management_uri: std::string::String,

    /// Output only. Third party Management URI for External Identity Providers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub third_party_management_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkforceIdentityBasedManagementURI {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_party_management_uri][crate::model::WorkforceIdentityBasedManagementURI::first_party_management_uri].
    pub fn set_first_party_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_party_management_uri = v.into();
        self
    }

    /// Sets the value of [third_party_management_uri][crate::model::WorkforceIdentityBasedManagementURI::third_party_management_uri].
    pub fn set_third_party_management_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.third_party_management_uri = v.into();
        self
    }
}

impl wkt::message::Message for WorkforceIdentityBasedManagementURI {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.WorkforceIdentityBasedManagementURI"
    }
}

/// OAuth Client ID depending on the Workforce Identity i.e. either 1p or 3p,
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkforceIdentityBasedOAuth2ClientID {
    /// Output only. First party OAuth Client ID for Google Identities.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub first_party_oauth2_client_id: std::string::String,

    /// Output only. Third party OAuth Client ID for External Identity Providers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub third_party_oauth2_client_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkforceIdentityBasedOAuth2ClientID {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first_party_oauth2_client_id][crate::model::WorkforceIdentityBasedOAuth2ClientID::first_party_oauth2_client_id].
    pub fn set_first_party_oauth2_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_party_oauth2_client_id = v.into();
        self
    }

    /// Sets the value of [third_party_oauth2_client_id][crate::model::WorkforceIdentityBasedOAuth2ClientID::third_party_oauth2_client_id].
    pub fn set_third_party_oauth2_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.third_party_oauth2_client_id = v.into();
        self
    }
}

impl wkt::message::Message for WorkforceIdentityBasedOAuth2ClientID {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.WorkforceIdentityBasedOAuth2ClientID"
    }
}

/// ManagementServer describes a single BackupDR ManagementServer instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagementServer {
    /// Output only. Identifier. The resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The description of the ManagementServer instance (2048 characters
    /// or less).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Resource labels to represent user provided metadata.
    /// Labels currently defined:
    ///
    /// . migrate_from_go=<false|true>
    ///   If set to true, the MS is created in migration ready mode.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The type of the ManagementServer resource.
    #[serde(rename = "type")]
    pub r#type: crate::model::management_server::InstanceType,

    /// Output only. The hostname or ip address of the exposed AGM endpoints, used
    /// by clients to connect to AGM/RD graphical user interface and APIs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_uri: std::option::Option<crate::model::ManagementURI>,

    /// Output only. The hostnames of the exposed AGM endpoints for both types of
    /// user i.e. 1p and 3p, used to connect AGM/RM UI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workforce_identity_based_management_uri:
        std::option::Option<crate::model::WorkforceIdentityBasedManagementURI>,

    /// Output only. The ManagementServer state.
    pub state: crate::model::management_server::InstanceState,

    /// Optional. VPC networks to which the ManagementServer instance is connected.
    /// For this version, only a single network is supported. This field is
    /// optional if MS is created without PSA
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Optional. Server specified ETag for the ManagementServer resource to
    /// prevent simultaneous updates from overwiting each other.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The OAuth 2.0 client id is required to make API calls to the
    /// BackupDR instance API of this ManagementServer. This is the value that
    /// should be provided in the 'aud' field of the OIDC ID Token (see openid
    /// specification
    /// <https://openid.net/specs/openid-connect-core-1_0.html#IDToken>).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oauth2_client_id: std::string::String,

    /// Output only. The OAuth client IDs for both types of user i.e. 1p and 3p.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workforce_identity_based_oauth2_client_id:
        std::option::Option<crate::model::WorkforceIdentityBasedOAuth2ClientID>,

    /// Output only. The hostname or ip address of the exposed AGM endpoints, used
    /// by BAs to connect to BA proxy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ba_proxy_uri: std::vec::Vec<std::string::String>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagementServer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ManagementServer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ManagementServer::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ManagementServer::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::ManagementServer::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ManagementServer::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ManagementServer::type].
    pub fn set_type<T: std::convert::Into<crate::model::management_server::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [management_uri][crate::model::ManagementServer::management_uri].
    pub fn set_management_uri<
        T: std::convert::Into<std::option::Option<crate::model::ManagementURI>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management_uri = v.into();
        self
    }

    /// Sets the value of [workforce_identity_based_management_uri][crate::model::ManagementServer::workforce_identity_based_management_uri].
    pub fn set_workforce_identity_based_management_uri<
        T: std::convert::Into<std::option::Option<crate::model::WorkforceIdentityBasedManagementURI>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workforce_identity_based_management_uri = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ManagementServer::state].
    pub fn set_state<T: std::convert::Into<crate::model::management_server::InstanceState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [networks][crate::model::ManagementServer::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::ManagementServer::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [oauth2_client_id][crate::model::ManagementServer::oauth2_client_id].
    pub fn set_oauth2_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth2_client_id = v.into();
        self
    }

    /// Sets the value of [workforce_identity_based_oauth2_client_id][crate::model::ManagementServer::workforce_identity_based_oauth2_client_id].
    pub fn set_workforce_identity_based_oauth2_client_id<
        T: std::convert::Into<std::option::Option<crate::model::WorkforceIdentityBasedOAuth2ClientID>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workforce_identity_based_oauth2_client_id = v.into();
        self
    }

    /// Sets the value of [ba_proxy_uri][crate::model::ManagementServer::ba_proxy_uri].
    pub fn set_ba_proxy_uri<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ba_proxy_uri = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ManagementServer::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ManagementServer::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for ManagementServer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ManagementServer"
    }
}

/// Defines additional types related to [ManagementServer].
pub mod management_server {
    #[allow(unused_imports)]
    use super::*;

    /// Type of backup service resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceType {
        /// Instance type is not mentioned.
        Unspecified,
        /// Instance for backup and restore management (i.e., AGM).
        BackupRestore,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceType::value] or
        /// [InstanceType::name].
        UnknownValue(instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BackupRestore => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_TYPE_UNSPECIFIED"),
                Self::BackupRestore => std::option::Option::Some("BACKUP_RESTORE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BackupRestore,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BACKUP_RESTORE" => Self::BackupRestore,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BackupRestore => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceType>::new(
                ".google.cloud.backupdr.v1.ManagementServer.InstanceType",
            ))
        }
    }

    /// State of Management server instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceState {
        /// State not set.
        Unspecified,
        /// The instance is being created.
        Creating,
        /// The instance has been created and is fully usable.
        Ready,
        /// The instance configuration is being updated. Certain kinds of updates
        /// may cause the instance to become unusable while the update is in
        /// progress.
        Updating,
        /// The instance is being deleted.
        Deleting,
        /// The instance is being repaired and may be unstable.
        Repairing,
        /// Maintenance is being performed on this instance.
        Maintenance,
        /// The instance is experiencing an issue and might be unusable. You can get
        /// further details from the statusMessage field of Instance resource.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceState::value] or
        /// [InstanceState::name].
        UnknownValue(instance_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Repairing => std::option::Option::Some(5),
                Self::Maintenance => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Repairing,
                6 => Self::Maintenance,
                7 => Self::Error,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "REPAIRING" => Self::Repairing,
                "MAINTENANCE" => Self::Maintenance,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Repairing => serializer.serialize_i32(5),
                Self::Maintenance => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceState>::new(
                ".google.cloud.backupdr.v1.ManagementServer.InstanceState",
            ))
        }
    }
}

/// Request message for listing management servers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListManagementServersRequest {
    /// Required. The project and location for which to retrieve management servers
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud BackupDR, locations map to Google Cloud regions, for example
    /// **us-central1**. To retrieve management servers for all locations, use "-"
    /// for the
    /// '{location}' value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<std::string::String>,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub order_by: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListManagementServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListManagementServersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListManagementServersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListManagementServersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListManagementServersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListManagementServersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListManagementServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListManagementServersRequest"
    }
}

/// Response message for listing management servers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListManagementServersResponse {
    /// The list of ManagementServer instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return management servers in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub management_servers: std::vec::Vec<crate::model::ManagementServer>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListManagementServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [management_servers][crate::model::ListManagementServersResponse::management_servers].
    pub fn set_management_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagementServer>,
    {
        use std::iter::Iterator;
        self.management_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListManagementServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListManagementServersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListManagementServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListManagementServersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListManagementServersResponse {
    type PageItem = crate::model::ManagementServer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.management_servers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a management server instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetManagementServerRequest {
    /// Required. Name of the management server resource name, in the format
    /// 'projects/{project_id}/locations/{location}/managementServers/{resource_name}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetManagementServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetManagementServerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetManagementServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetManagementServerRequest"
    }
}

/// Request message for creating a management server instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateManagementServerRequest {
    /// Required. The management server project and location in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR
    /// locations map to Google Cloud regions, for example **us-central1**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the management server to create. The name must be
    /// unique for the specified project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub management_server_id: std::string::String,

    /// Required. A [management server
    /// resource][google.cloud.backupdr.v1.ManagementServer]
    ///
    /// [google.cloud.backupdr.v1.ManagementServer]: crate::model::ManagementServer
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management_server: std::option::Option<crate::model::ManagementServer>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateManagementServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateManagementServerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [management_server_id][crate::model::CreateManagementServerRequest::management_server_id].
    pub fn set_management_server_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.management_server_id = v.into();
        self
    }

    /// Sets the value of [management_server][crate::model::CreateManagementServerRequest::management_server].
    pub fn set_management_server<
        T: std::convert::Into<std::option::Option<crate::model::ManagementServer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management_server = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateManagementServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateManagementServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateManagementServerRequest"
    }
}

/// Request message for deleting a management server instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteManagementServerRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteManagementServerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteManagementServerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteManagementServerRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteManagementServerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteManagementServerRequest"
    }
}

/// Request message for initializing the service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InitializeServiceRequest {
    /// Required. The resource name of the serviceConfig used to initialize the
    /// service. Format:
    /// `projects/{project_id}/locations/{location}/serviceConfig`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The resource type to which the default service config will be
    /// applied. Examples include, "compute.googleapis.com/Instance" and
    /// "storage.googleapis.com/Bucket".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_type: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InitializeServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::InitializeServiceRequest::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InitializeServiceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for InitializeServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.InitializeServiceRequest"
    }
}

/// Response message for initializing the service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InitializeServiceResponse {
    /// The resource name of the default `BackupVault` created.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_vault_name: std::string::String,

    /// The resource name of the default `BackupPlan` created.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupPlans/{backup_plan_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vault_name][crate::model::InitializeServiceResponse::backup_vault_name].
    pub fn set_backup_vault_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault_name = v.into();
        self
    }

    /// Sets the value of [backup_plan_name][crate::model::InitializeServiceResponse::backup_plan_name].
    pub fn set_backup_plan_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_name = v.into();
        self
    }
}

impl wkt::message::Message for InitializeServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.InitializeServiceResponse"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to 'Code.CANCELLED'.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// Output only. AdditionalInfo contains additional Info related to backup plan
    /// association resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub additional_info: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [additional_info][crate::model::OperationMetadata::additional_info].
    pub fn set_additional_info<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_info = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.OperationMetadata"
    }
}

/// A `BackupPlan` specifies some common fields, such as `description` as well
/// as one or more `BackupRule` messages. Each `BackupRule` has a retention
/// policy and defines a schedule by which the system is to perform backup
/// workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupPlan {
    /// Output only. Identifier. The resource name of the `BackupPlan`.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The description of the `BackupPlan` resource.
    ///
    /// The description allows for additional details about `BackupPlan` and its
    /// use cases to be provided. An example description is the following:  "This
    /// is a backup plan that performs a daily backup at 6pm and retains data for 3
    /// months". The description must be at most 2048 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. This collection of key/value pairs allows for custom labels to be
    /// supplied by the user.  Example, {"tag": "Weekly"}.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. When the `BackupPlan` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. When the `BackupPlan` was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The backup rules for this `BackupPlan`. There must be at least
    /// one `BackupRule` message.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_rules: std::vec::Vec<crate::model::BackupRule>,

    /// Output only. The `State` for the `BackupPlan`.
    pub state: crate::model::backup_plan::State,

    /// Required. The resource type to which the `BackupPlan` will be applied.
    /// Examples include, "compute.googleapis.com/Instance",
    /// "sqladmin.googleapis.com/Instance", or "alloydb.googleapis.com/Cluster".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_type: std::string::String,

    /// Optional. `etag` is returned from the service in the response. As a user of
    /// the service, you may provide an etag value in this field to prevent stale
    /// resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Required. Resource name of backup vault which will be used as storage
    /// location for backups. Format:
    /// projects/{project}/locations/{location}/backupVaults/{backupvault}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_vault: std::string::String,

    /// Output only. The Google Cloud Platform Service Account to be used by the
    /// BackupVault for taking backups. Specify the email address of the Backup
    /// Vault Service Account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_vault_service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPlan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPlan::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupPlan::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BackupPlan::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPlan::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BackupPlan::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [backup_rules][crate::model::BackupPlan::backup_rules].
    pub fn set_backup_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupRule>,
    {
        use std::iter::Iterator;
        self.backup_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::BackupPlan::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_plan::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::BackupPlan::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::BackupPlan::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::BackupPlan::backup_vault].
    pub fn set_backup_vault<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault = v.into();
        self
    }

    /// Sets the value of [backup_vault_service_account][crate::model::BackupPlan::backup_vault_service_account].
    pub fn set_backup_vault_service_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault_service_account = v.into();
        self
    }
}

impl wkt::message::Message for BackupPlan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupPlan"
    }
}

/// Defines additional types related to [BackupPlan].
pub mod backup_plan {
    #[allow(unused_imports)]
    use super::*;

    /// `State` enumerates the possible states for a `BackupPlan`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The resource is being created.
        Creating,
        /// The resource has been created and is fully usable.
        Active,
        /// The resource is being deleted.
        Deleting,
        /// The resource has been created but is not usable.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Inactive => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Inactive => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.BackupPlan.State",
            ))
        }
    }
}

/// `BackupRule` binds the backup schedule to a retention policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRule {
    /// Required. Immutable. The unique id of this `BackupRule`. The `rule_id` is
    /// unique per `BackupPlan`.The `rule_id` must start with a lowercase letter
    /// followed by up to 62 lowercase letters, numbers, or hyphens. Pattern,
    /// /[a-z][a-z0-9-]{,62}/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_id: std::string::String,

    /// Required. Configures the duration for which backup data will be kept. It is
    /// defined in “days”. The value should be greater than or equal to minimum
    /// enforced retention of the backup vault.
    ///
    /// Minimum value is 1 and maximum value is 90 for hourly backups.
    /// Minimum value is 1 and maximum value is 90 for daily backups.
    /// Minimum value is 7 and maximum value is 186 for weekly backups.
    /// Minimum value is 30 and maximum value is 732 for monthly backups.
    /// Minimum value is 365 and maximum value is 36159 for yearly backups.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub backup_retention_days: i32,

    /// The schedule that defines the automated backup workloads for this
    /// `BackupRule`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub backup_schedule_oneof: std::option::Option<crate::model::backup_rule::BackupScheduleOneof>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::BackupRule::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [backup_retention_days][crate::model::BackupRule::backup_retention_days].
    pub fn set_backup_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backup_retention_days = v.into();
        self
    }

    /// Sets the value of [backup_schedule_oneof][crate::model::BackupRule::backup_schedule_oneof].
    ///
    /// Note that all the setters affecting `backup_schedule_oneof` are mutually
    /// exclusive.
    pub fn set_backup_schedule_oneof<
        T: std::convert::Into<std::option::Option<crate::model::backup_rule::BackupScheduleOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule_oneof = v.into();
        self
    }

    /// The value of [backup_schedule_oneof][crate::model::BackupRule::backup_schedule_oneof]
    /// if it holds a `StandardSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSchedule>> {
        #[allow(unreachable_patterns)]
        self.backup_schedule_oneof.as_ref().and_then(|v| match v {
            crate::model::backup_rule::BackupScheduleOneof::StandardSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_schedule_oneof][crate::model::BackupRule::backup_schedule_oneof]
    /// to hold a `StandardSchedule`.
    ///
    /// Note that all the setters affecting `backup_schedule_oneof` are
    /// mutually exclusive.
    pub fn set_standard_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_schedule_oneof = std::option::Option::Some(
            crate::model::backup_rule::BackupScheduleOneof::StandardSchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupRule"
    }
}

/// Defines additional types related to [BackupRule].
pub mod backup_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The schedule that defines the automated backup workloads for this
    /// `BackupRule`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BackupScheduleOneof {
        /// Required. Defines a schedule that runs within the confines of a defined
        /// window of time.
        StandardSchedule(std::boxed::Box<crate::model::StandardSchedule>),
    }
}

/// `StandardSchedule` defines a schedule that run within the confines of a
/// defined window of days. We can define recurrence type for schedule as
/// HOURLY, DAILY, WEEKLY, MONTHLY or YEARLY.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSchedule {
    /// Required. Specifies the `RecurrenceType` for the schedule.
    pub recurrence_type: crate::model::standard_schedule::RecurrenceType,

    /// Optional. Specifies frequency for hourly backups. A hourly frequency of 2
    /// means jobs will run every 2 hours from start time till end time defined.
    ///
    /// This is required for `recurrence_type`, `HOURLY` and is not applicable
    /// otherwise. A validation error will occur if a value is supplied and
    /// `recurrence_type` is not `HOURLY`.
    ///
    /// Value of hourly frequency should be between 6 and 23.
    ///
    /// Reason for limit : We found that there is bandwidth limitation of 3GB/S for
    /// GMI while taking a backup and 5GB/S while doing a restore. Given the amount
    /// of parallel backups and restore we are targeting, this will potentially
    /// take the backup time to mins and hours (in worst case scenario).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub hourly_frequency: i32,

    /// Optional. Specifies days of week like, MONDAY or TUESDAY, on which jobs
    /// will run.
    ///
    /// This is required for `recurrence_type`, `WEEKLY` and is not applicable
    /// otherwise. A validation error will occur if a value is supplied and
    /// `recurrence_type` is not `WEEKLY`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. Specifies days of months like 1, 5, or 14 on which jobs will run.
    ///
    /// Values for `days_of_month` are only applicable for `recurrence_type`,
    /// `MONTHLY` and `YEARLY`. A validation error will occur if other values are
    /// supplied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub days_of_month: std::vec::Vec<i32>,

    /// Optional. Specifies a week day of the month like, FIRST SUNDAY or LAST
    /// MONDAY, on which jobs will run. This will be specified by two fields in
    /// `WeekDayOfMonth`, one for the day, e.g. `MONDAY`, and one for the week,
    /// e.g. `LAST`.
    ///
    /// This field is only applicable for `recurrence_type`, `MONTHLY` and
    /// `YEARLY`. A validation error will occur if other values are supplied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub week_day_of_month: std::option::Option<crate::model::WeekDayOfMonth>,

    /// Optional. Specifies the months of year, like `FEBRUARY` and/or `MAY`, on
    /// which jobs will run.
    ///
    /// This field is only applicable when `recurrence_type` is `YEARLY`. A
    /// validation error will occur if other values are supplied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub months: std::vec::Vec<gtype::model::Month>,

    /// Required. A BackupWindow defines the window of day during which backup jobs
    /// will run. Jobs are queued at the beginning of the window and will be marked
    /// as `NOT_RUN` if they do not start by the end of the window.
    ///
    /// Note: running jobs will not be cancelled at the end of the window.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_window: std::option::Option<crate::model::BackupWindow>,

    /// Required. The time zone to be used when interpreting the schedule.
    /// The value of this field must be a time zone name from the IANA tz database.
    /// See <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones> for the
    /// list of valid timezone names. For e.g., Europe/Paris.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recurrence_type][crate::model::StandardSchedule::recurrence_type].
    pub fn set_recurrence_type<
        T: std::convert::Into<crate::model::standard_schedule::RecurrenceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence_type = v.into();
        self
    }

    /// Sets the value of [hourly_frequency][crate::model::StandardSchedule::hourly_frequency].
    pub fn set_hourly_frequency<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.hourly_frequency = v.into();
        self
    }

    /// Sets the value of [days_of_week][crate::model::StandardSchedule::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [days_of_month][crate::model::StandardSchedule::days_of_month].
    pub fn set_days_of_month<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.days_of_month = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [week_day_of_month][crate::model::StandardSchedule::week_day_of_month].
    pub fn set_week_day_of_month<
        T: std::convert::Into<std::option::Option<crate::model::WeekDayOfMonth>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.week_day_of_month = v.into();
        self
    }

    /// Sets the value of [months][crate::model::StandardSchedule::months].
    pub fn set_months<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::Month>,
    {
        use std::iter::Iterator;
        self.months = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_window][crate::model::StandardSchedule::backup_window].
    pub fn set_backup_window<
        T: std::convert::Into<std::option::Option<crate::model::BackupWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_window = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::StandardSchedule::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for StandardSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.StandardSchedule"
    }
}

/// Defines additional types related to [StandardSchedule].
pub mod standard_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// `RecurrenceTypes` enumerates the applicable periodicity for the schedule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RecurrenceType {
        /// recurrence type not set
        Unspecified,
        /// The `BackupRule` is to be applied hourly.
        Hourly,
        /// The `BackupRule` is to be applied daily.
        Daily,
        /// The `BackupRule` is to be applied weekly.
        Weekly,
        /// The `BackupRule` is to be applied monthly.
        Monthly,
        /// The `BackupRule` is to be applied yearly.
        Yearly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RecurrenceType::value] or
        /// [RecurrenceType::name].
        UnknownValue(recurrence_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod recurrence_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RecurrenceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hourly => std::option::Option::Some(1),
                Self::Daily => std::option::Option::Some(2),
                Self::Weekly => std::option::Option::Some(3),
                Self::Monthly => std::option::Option::Some(4),
                Self::Yearly => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECURRENCE_TYPE_UNSPECIFIED"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Yearly => std::option::Option::Some("YEARLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RecurrenceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RecurrenceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RecurrenceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hourly,
                2 => Self::Daily,
                3 => Self::Weekly,
                4 => Self::Monthly,
                5 => Self::Yearly,
                _ => Self::UnknownValue(recurrence_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RecurrenceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECURRENCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "YEARLY" => Self::Yearly,
                _ => Self::UnknownValue(recurrence_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RecurrenceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hourly => serializer.serialize_i32(1),
                Self::Daily => serializer.serialize_i32(2),
                Self::Weekly => serializer.serialize_i32(3),
                Self::Monthly => serializer.serialize_i32(4),
                Self::Yearly => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RecurrenceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RecurrenceType>::new(
                ".google.cloud.backupdr.v1.StandardSchedule.RecurrenceType",
            ))
        }
    }
}

/// `BackupWindow` defines a window of the day during which backup jobs will run.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupWindow {
    /// Required. The hour of day (0-23) when the window starts for e.g. if value
    /// of start hour of day is 6 that mean backup window start at 6:00.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub start_hour_of_day: i32,

    /// Required. The hour of day (1-24) when the window end for e.g. if value of
    /// end hour of day is 10 that mean backup window end time is 10:00.
    ///
    /// End hour of day should be greater than start hour of day.
    /// 0 <= start_hour_of_day < end_hour_of_day <= 24
    ///
    /// End hour of day is not include in backup window that mean if
    /// end_hour_of_day= 10 jobs should start before 10:00.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub end_hour_of_day: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_hour_of_day][crate::model::BackupWindow::start_hour_of_day].
    pub fn set_start_hour_of_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.start_hour_of_day = v.into();
        self
    }

    /// Sets the value of [end_hour_of_day][crate::model::BackupWindow::end_hour_of_day].
    pub fn set_end_hour_of_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.end_hour_of_day = v.into();
        self
    }
}

impl wkt::message::Message for BackupWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupWindow"
    }
}

/// `WeekDayOfMonth` defines the week day of the month on which the backups will
/// run. The message combines a `WeekOfMonth` and `DayOfWeek` to produce values
/// like `FIRST`/`MONDAY` or `LAST`/`FRIDAY`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeekDayOfMonth {
    /// Required. Specifies the week of the month.
    pub week_of_month: crate::model::week_day_of_month::WeekOfMonth,

    /// Required. Specifies the day of the week.
    pub day_of_week: gtype::model::DayOfWeek,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeekDayOfMonth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [week_of_month][crate::model::WeekDayOfMonth::week_of_month].
    pub fn set_week_of_month<
        T: std::convert::Into<crate::model::week_day_of_month::WeekOfMonth>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.week_of_month = v.into();
        self
    }

    /// Sets the value of [day_of_week][crate::model::WeekDayOfMonth::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }
}

impl wkt::message::Message for WeekDayOfMonth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.WeekDayOfMonth"
    }
}

/// Defines additional types related to [WeekDayOfMonth].
pub mod week_day_of_month {
    #[allow(unused_imports)]
    use super::*;

    /// `WeekOfMonth` enumerates possible weeks in the month, e.g. the first,
    /// third, or last week of the month.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WeekOfMonth {
        /// The zero value. Do not use.
        Unspecified,
        /// The first week of the month.
        First,
        /// The second week of the month.
        Second,
        /// The third week of the month.
        Third,
        /// The fourth  week of the month.
        Fourth,
        /// The last  week of the month.
        Last,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WeekOfMonth::value] or
        /// [WeekOfMonth::name].
        UnknownValue(week_of_month::UnknownValue),
    }

    #[doc(hidden)]
    pub mod week_of_month {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WeekOfMonth {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::First => std::option::Option::Some(1),
                Self::Second => std::option::Option::Some(2),
                Self::Third => std::option::Option::Some(3),
                Self::Fourth => std::option::Option::Some(4),
                Self::Last => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WEEK_OF_MONTH_UNSPECIFIED"),
                Self::First => std::option::Option::Some("FIRST"),
                Self::Second => std::option::Option::Some("SECOND"),
                Self::Third => std::option::Option::Some("THIRD"),
                Self::Fourth => std::option::Option::Some("FOURTH"),
                Self::Last => std::option::Option::Some("LAST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WeekOfMonth {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WeekOfMonth {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WeekOfMonth {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::First,
                2 => Self::Second,
                3 => Self::Third,
                4 => Self::Fourth,
                5 => Self::Last,
                _ => Self::UnknownValue(week_of_month::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WeekOfMonth {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WEEK_OF_MONTH_UNSPECIFIED" => Self::Unspecified,
                "FIRST" => Self::First,
                "SECOND" => Self::Second,
                "THIRD" => Self::Third,
                "FOURTH" => Self::Fourth,
                "LAST" => Self::Last,
                _ => Self::UnknownValue(week_of_month::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WeekOfMonth {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::First => serializer.serialize_i32(1),
                Self::Second => serializer.serialize_i32(2),
                Self::Third => serializer.serialize_i32(3),
                Self::Fourth => serializer.serialize_i32(4),
                Self::Last => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WeekOfMonth {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WeekOfMonth>::new(
                ".google.cloud.backupdr.v1.WeekDayOfMonth.WeekOfMonth",
            ))
        }
    }
}

/// The request message for creating a `BackupPlan`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupPlanRequest {
    /// Required. The `BackupPlan` project and location in the format
    /// `projects/{project}/locations/{location}`. In Cloud BackupDR locations
    /// map to GCP regions, for example **us-central1**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the `BackupPlan` to create. The name must be unique
    /// for the specified project and location.The name must start with a lowercase
    /// letter followed by up to 62 lowercase letters, numbers, or hyphens.
    /// Pattern, /[a-z][a-z0-9-]{,62}/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan_id: std::string::String,

    /// Required. The `BackupPlan` resource object to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_plan: std::option::Option<crate::model::BackupPlan>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPlanRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_plan_id][crate::model::CreateBackupPlanRequest::backup_plan_id].
    pub fn set_backup_plan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan_id = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::CreateBackupPlanRequest::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::option::Option<crate::model::BackupPlan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupPlanRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateBackupPlanRequest"
    }
}

/// The request message for getting a list `BackupPlan`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupPlansRequest {
    /// Required. The project and location for which to retrieve `BackupPlans`
    /// information. Format: `projects/{project}/locations/{location}`. In Cloud
    /// BackupDR, locations map to GCP regions, for e.g. **us-central1**. To
    /// retrieve backup plans for all locations, use "-" for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of `BackupPlans` to return in a single
    /// response. If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]: crate::model::ListBackupPlansResponse::next_page_token
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
    /// received from a previous `ListBackupPlans` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackupPlans` must match the call that provided the page token.
    ///
    /// [google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]: crate::model::ListBackupPlansResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPlansRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPlansRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPlansRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPlansRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupPlansRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPlansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlansRequest"
    }
}

/// The response message for getting a list of `BackupPlan`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupPlansResponse {
    /// The list of `BackupPlans` in the project for the specified
    /// location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of resources from all locations. In case any location is unreachable,
    /// the response will only return backup plans in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    /// BackupPlan
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_plans: std::vec::Vec<crate::model::BackupPlan>,

    /// A token which may be sent as
    /// [page_token][google.cloud.backupdr.v1.ListBackupPlansRequest.page_token] in
    /// a subsequent `ListBackupPlans` call to retrieve the next page of results.
    /// If this field is omitted or empty, then there are no more results to
    /// return.
    ///
    /// [google.cloud.backupdr.v1.ListBackupPlansRequest.page_token]: crate::model::ListBackupPlansRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlansResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plans][crate::model::ListBackupPlansResponse::backup_plans].
    pub fn set_backup_plans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPlan>,
    {
        use std::iter::Iterator;
        self.backup_plans = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPlansResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPlansResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPlansResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlansResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPlansResponse {
    type PageItem = crate::model::BackupPlan;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_plans
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for getting a `BackupPlan`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupPlanRequest {
    /// Required. The resource name of the `BackupPlan` to retrieve.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupPlanRequest"
    }
}

/// The request message for deleting a `BackupPlan`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupPlanRequest {
    /// Required. The resource name of the `BackupPlan` to delete.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupPlanRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupPlanRequest"
    }
}

/// A BackupPlanAssociation represents a single BackupPlanAssociation which
/// contains details like workload, backup plan etc
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupPlanAssociation {
    /// Output only. Identifier. The resource name of BackupPlanAssociation in
    /// below format Format :
    /// projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Immutable. Resource type of workload on which backupplan is
    /// applied
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_type: std::string::String,

    /// Required. Immutable. Resource name of workload on which backupplan is
    /// applied
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// Required. Resource name of backup plan which needs to be applied on
    /// workload. Format:
    /// projects/{project}/locations/{location}/backupPlans/{backupPlanId}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan: std::string::String,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The BackupPlanAssociation resource state.
    pub state: crate::model::backup_plan_association::State,

    /// Output only. The config info related to backup rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules_config_info: std::vec::Vec<crate::model::RuleConfigInfo>,

    /// Output only. Resource name of data source which will be used as storage
    /// location for backups taken. Format :
    /// projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPlanAssociation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPlanAssociation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::BackupPlanAssociation::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::BackupPlanAssociation::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::BackupPlanAssociation::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPlanAssociation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BackupPlanAssociation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BackupPlanAssociation::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_plan_association::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [rules_config_info][crate::model::BackupPlanAssociation::rules_config_info].
    pub fn set_rules_config_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuleConfigInfo>,
    {
        use std::iter::Iterator;
        self.rules_config_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_source][crate::model::BackupPlanAssociation::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }
}

impl wkt::message::Message for BackupPlanAssociation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupPlanAssociation"
    }
}

/// Defines additional types related to [BackupPlanAssociation].
pub mod backup_plan_association {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for State of BackupPlan Association
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The resource is being created.
        Creating,
        /// The resource has been created and is fully usable.
        Active,
        /// The resource is being deleted.
        Deleting,
        /// The resource has been created but is not usable.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Inactive => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Inactive => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.BackupPlanAssociation.State",
            ))
        }
    }
}

/// Message for rules config info.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuleConfigInfo {
    /// Output only. Backup Rule id fetched from backup plan.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_id: std::string::String,

    /// Output only. The last backup state for rule.
    pub last_backup_state: crate::model::rule_config_info::LastBackupState,

    /// Output only. google.rpc.Status object to store the last backup error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_backup_error: std::option::Option<rpc::model::Status>,

    /// Output only. The point in time when the last successful backup was captured
    /// from the source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_successful_backup_consistency_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuleConfigInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::RuleConfigInfo::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [last_backup_state][crate::model::RuleConfigInfo::last_backup_state].
    pub fn set_last_backup_state<
        T: std::convert::Into<crate::model::rule_config_info::LastBackupState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_backup_state = v.into();
        self
    }

    /// Sets the value of [last_backup_error][crate::model::RuleConfigInfo::last_backup_error].
    pub fn set_last_backup_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_backup_error = v.into();
        self
    }

    /// Sets the value of [last_successful_backup_consistency_time][crate::model::RuleConfigInfo::last_successful_backup_consistency_time].
    pub fn set_last_successful_backup_consistency_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_successful_backup_consistency_time = v.into();
        self
    }
}

impl wkt::message::Message for RuleConfigInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.RuleConfigInfo"
    }
}

/// Defines additional types related to [RuleConfigInfo].
pub mod rule_config_info {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for LastBackupState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LastBackupState {
        /// State not set.
        Unspecified,
        /// The first backup is pending.
        FirstBackupPending,
        /// The most recent backup could not be run/failed because of the lack of
        /// permissions.
        PermissionDenied,
        /// The last backup operation succeeded.
        Succeeded,
        /// The last backup operation failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LastBackupState::value] or
        /// [LastBackupState::name].
        UnknownValue(last_backup_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod last_backup_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LastBackupState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirstBackupPending => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LAST_BACKUP_STATE_UNSPECIFIED"),
                Self::FirstBackupPending => std::option::Option::Some("FIRST_BACKUP_PENDING"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LastBackupState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LastBackupState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LastBackupState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirstBackupPending,
                2 => Self::PermissionDenied,
                3 => Self::Succeeded,
                4 => Self::Failed,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LastBackupState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LAST_BACKUP_STATE_UNSPECIFIED" => Self::Unspecified,
                "FIRST_BACKUP_PENDING" => Self::FirstBackupPending,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LastBackupState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirstBackupPending => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LastBackupState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LastBackupState>::new(
                ".google.cloud.backupdr.v1.RuleConfigInfo.LastBackupState",
            ))
        }
    }
}

/// Request message for creating a backup plan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupPlanAssociationRequest {
    /// Required. The backup plan association project and location in the format
    /// `projects/{project_id}/locations/{location}`. In Cloud BackupDR locations
    /// map to GCP regions, for example **us-central1**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name of the backup plan association to create. The name must
    /// be unique for the specified project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan_association_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_plan_association: std::option::Option<crate::model::BackupPlanAssociation>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPlanAssociationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPlanAssociationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_plan_association_id][crate::model::CreateBackupPlanAssociationRequest::backup_plan_association_id].
    pub fn set_backup_plan_association_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_association_id = v.into();
        self
    }

    /// Sets the value of [backup_plan_association][crate::model::CreateBackupPlanAssociationRequest::backup_plan_association].
    pub fn set_backup_plan_association<
        T: std::convert::Into<std::option::Option<crate::model::BackupPlanAssociation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_association = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupPlanAssociationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPlanAssociationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateBackupPlanAssociationRequest"
    }
}

/// Request message for List BackupPlanAssociation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupPlanAssociationsRequest {
    /// Required. The project and location for which to retrieve backup Plan
    /// Associations information, in the format
    /// `projects/{project_id}/locations/{location}`. In Cloud BackupDR, locations
    /// map to GCP regions, for example **us-central1**. To retrieve backup plan
    /// associations for all locations, use "-" for the
    /// `{location}` value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlanAssociationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPlanAssociationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPlanAssociationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPlanAssociationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPlanAssociationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPlanAssociationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlanAssociationsRequest"
    }
}

/// Response message for List BackupPlanAssociation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupPlanAssociationsResponse {
    /// The list of Backup Plan Associations in the project for the specified
    /// location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup plan associations in reachable
    /// locations and the 'unreachable' field will be populated with a list of
    /// unreachable locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_plan_associations: std::vec::Vec<crate::model::BackupPlanAssociation>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlanAssociationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plan_associations][crate::model::ListBackupPlanAssociationsResponse::backup_plan_associations].
    pub fn set_backup_plan_associations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPlanAssociation>,
    {
        use std::iter::Iterator;
        self.backup_plan_associations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPlanAssociationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPlanAssociationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPlanAssociationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupPlanAssociationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPlanAssociationsResponse {
    type PageItem = crate::model::BackupPlanAssociation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_plan_associations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a BackupPlanAssociation resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupPlanAssociationRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPlanAssociationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPlanAssociationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPlanAssociationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupPlanAssociationRequest"
    }
}

/// Request message for deleting a backup plan association.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupPlanAssociationRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPlanAssociationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPlanAssociationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupPlanAssociationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPlanAssociationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupPlanAssociationRequest"
    }
}

/// Request message for triggering a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TriggerBackupRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. backup rule_id for which a backup needs to be triggered.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_id: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TriggerBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TriggerBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::TriggerBackupRequest::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::TriggerBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for TriggerBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.TriggerBackupRequest"
    }
}

/// Message describing a BackupVault object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupVault {
    /// Output only. Identifier. Name of the backup vault to create. It must have
    /// the
    /// format`"projects/{project}/locations/{location}/backupVaults/{backupvault}"`.
    /// `{backupvault}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The description of the BackupVault instance (2048 characters or
    /// less).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined:
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The default and minimum enforced retention for each backup within
    /// the backup vault.  The enforced retention for each backup can be extended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_minimum_enforced_retention_duration: std::option::Option<wkt::Duration>,

    /// Output only. Set to true when there are no backups nested under this
    /// resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletable: std::option::Option<bool>,

    /// Optional. Server specified ETag for the backup vault resource to
    /// prevent simultaneous updates from overwiting each other.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// Output only. The BackupVault resource instance state.
    pub state: crate::model::backup_vault::State,

    /// Optional. Time after which the BackupVault resource is locked.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub effective_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The number of backups in this backup vault.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_count: i64,

    /// Output only. Service account used by the BackupVault Service for this
    /// BackupVault.  The user should grant this account permissions in their
    /// workload project to enable the service to run backups and restores there.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Output only. Total size of the storage used by all backup resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_stored_bytes: i64,

    /// Output only. Immutable after resource creation until resource deletion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. User annotations. See <https://google.aip.dev/128#annotations>
    /// Stores small amounts of arbitrary data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Note: This field is added for future use case and will not be
    /// supported in the current release.
    ///
    /// Access restriction for the backup vault.
    /// Default value is WITHIN_ORGANIZATION if not provided during creation.
    pub access_restriction: crate::model::backup_vault::AccessRestriction,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupVault {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupVault::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupVault::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BackupVault::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupVault::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BackupVault::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [backup_minimum_enforced_retention_duration][crate::model::BackupVault::backup_minimum_enforced_retention_duration].
    pub fn set_backup_minimum_enforced_retention_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_minimum_enforced_retention_duration = v.into();
        self
    }

    /// Sets the value of [deletable][crate::model::BackupVault::deletable].
    pub fn set_deletable<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.deletable = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::BackupVault::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BackupVault::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_vault::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [effective_time][crate::model::BackupVault::effective_time].
    pub fn set_effective_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.effective_time = v.into();
        self
    }

    /// Sets the value of [backup_count][crate::model::BackupVault::backup_count].
    pub fn set_backup_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_count = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BackupVault::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [total_stored_bytes][crate::model::BackupVault::total_stored_bytes].
    pub fn set_total_stored_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_stored_bytes = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupVault::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::BackupVault::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [access_restriction][crate::model::BackupVault::access_restriction].
    pub fn set_access_restriction<
        T: std::convert::Into<crate::model::backup_vault::AccessRestriction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_restriction = v.into();
        self
    }
}

impl wkt::message::Message for BackupVault {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupVault"
    }
}

/// Defines additional types related to [BackupVault].
pub mod backup_vault {
    #[allow(unused_imports)]
    use super::*;

    /// Holds the state of the backup vault resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The backup vault is being created.
        Creating,
        /// The backup vault has been created and is fully usable.
        Active,
        /// The backup vault is being deleted.
        Deleting,
        /// The backup vault is experiencing an issue and might be unusable.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.BackupVault.State",
            ))
        }
    }

    /// Holds the access restriction for the backup vault.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessRestriction {
        /// Access restriction not set. If user does not provide any value or pass
        /// this value, it will be changed to WITHIN_ORGANIZATION.
        Unspecified,
        /// Access to or from resources outside your current project will be denied.
        WithinProject,
        /// Access to or from resources outside your current organization will be
        /// denied.
        WithinOrganization,
        /// No access restriction.
        Unrestricted,
        /// Access to or from resources outside your current organization will be
        /// denied except for backup appliance.
        WithinOrgButUnrestrictedForBa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccessRestriction::value] or
        /// [AccessRestriction::name].
        UnknownValue(access_restriction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod access_restriction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccessRestriction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::WithinProject => std::option::Option::Some(1),
                Self::WithinOrganization => std::option::Option::Some(2),
                Self::Unrestricted => std::option::Option::Some(3),
                Self::WithinOrgButUnrestrictedForBa => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCESS_RESTRICTION_UNSPECIFIED"),
                Self::WithinProject => std::option::Option::Some("WITHIN_PROJECT"),
                Self::WithinOrganization => std::option::Option::Some("WITHIN_ORGANIZATION"),
                Self::Unrestricted => std::option::Option::Some("UNRESTRICTED"),
                Self::WithinOrgButUnrestrictedForBa => {
                    std::option::Option::Some("WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccessRestriction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccessRestriction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccessRestriction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::WithinProject,
                2 => Self::WithinOrganization,
                3 => Self::Unrestricted,
                4 => Self::WithinOrgButUnrestrictedForBa,
                _ => Self::UnknownValue(access_restriction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccessRestriction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCESS_RESTRICTION_UNSPECIFIED" => Self::Unspecified,
                "WITHIN_PROJECT" => Self::WithinProject,
                "WITHIN_ORGANIZATION" => Self::WithinOrganization,
                "UNRESTRICTED" => Self::Unrestricted,
                "WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA" => Self::WithinOrgButUnrestrictedForBa,
                _ => Self::UnknownValue(access_restriction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccessRestriction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::WithinProject => serializer.serialize_i32(1),
                Self::WithinOrganization => serializer.serialize_i32(2),
                Self::Unrestricted => serializer.serialize_i32(3),
                Self::WithinOrgButUnrestrictedForBa => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessRestriction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessRestriction>::new(
                ".google.cloud.backupdr.v1.BackupVault.AccessRestriction",
            ))
        }
    }
}

/// Message describing a DataSource object.
/// Datasource object used to represent Datasource details for both admin and
/// basic view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSource {
    /// Output only. Identifier. Name of the datasource to create.
    /// It must have the
    /// format`"projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}"`.
    /// `{datasource}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the backup vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The DataSource resource instance state.
    pub state: crate::model::data_source::State,

    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined:
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Number of backups in the data source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub backup_count: std::option::Option<i64>,

    /// Server specified ETag for the ManagementServer resource to prevent
    /// simultaneous updates from overwiting each other.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// The number of bytes (metadata and data) stored in this datasource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_stored_bytes: std::option::Option<i64>,

    /// Output only. The backup configuration state.
    pub config_state: crate::model::BackupConfigState,

    /// Output only. Details of how the resource is configured for backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_config_info: std::option::Option<crate::model::BackupConfigInfo>,

    /// The source resource that is represented by this DataSource. It can be a
    /// Google Cloud resource, or one backed up by a Backup Appliance.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_resource: std::option::Option<crate::model::data_source::SourceResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataSource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataSource::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_source::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataSource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DataSource::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataSource::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [backup_count][crate::model::DataSource::backup_count].
    pub fn set_backup_count<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataSource::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [total_stored_bytes][crate::model::DataSource::total_stored_bytes].
    pub fn set_total_stored_bytes<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_stored_bytes = v.into();
        self
    }

    /// Sets the value of [config_state][crate::model::DataSource::config_state].
    pub fn set_config_state<T: std::convert::Into<crate::model::BackupConfigState>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_state = v.into();
        self
    }

    /// Sets the value of [backup_config_info][crate::model::DataSource::backup_config_info].
    pub fn set_backup_config_info<
        T: std::convert::Into<std::option::Option<crate::model::BackupConfigInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config_info = v.into();
        self
    }

    /// Sets the value of [source_resource][crate::model::DataSource::source_resource].
    ///
    /// Note that all the setters affecting `source_resource` are mutually
    /// exclusive.
    pub fn set_source_resource<
        T: std::convert::Into<std::option::Option<crate::model::data_source::SourceResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource = v.into();
        self
    }

    /// The value of [source_resource][crate::model::DataSource::source_resource]
    /// if it holds a `DataSourceGcpResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_source_gcp_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceGcpResource>> {
        #[allow(unreachable_patterns)]
        self.source_resource.as_ref().and_then(|v| match v {
            crate::model::data_source::SourceResource::DataSourceGcpResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_resource][crate::model::DataSource::source_resource]
    /// to hold a `DataSourceGcpResource`.
    ///
    /// Note that all the setters affecting `source_resource` are
    /// mutually exclusive.
    pub fn set_data_source_gcp_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::DataSourceGcpResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource = std::option::Option::Some(
            crate::model::data_source::SourceResource::DataSourceGcpResource(v.into()),
        );
        self
    }

    /// The value of [source_resource][crate::model::DataSource::source_resource]
    /// if it holds a `DataSourceBackupApplianceApplication`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_source_backup_appliance_application(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>>
    {
        #[allow(unreachable_patterns)]
        self.source_resource.as_ref().and_then(|v| match v {
            crate::model::data_source::SourceResource::DataSourceBackupApplianceApplication(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_resource][crate::model::DataSource::source_resource]
    /// to hold a `DataSourceBackupApplianceApplication`.
    ///
    /// Note that all the setters affecting `source_resource` are
    /// mutually exclusive.
    pub fn set_data_source_backup_appliance_application<
        T: std::convert::Into<std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_resource = std::option::Option::Some(
            crate::model::data_source::SourceResource::DataSourceBackupApplianceApplication(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DataSource"
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// Holds the state of the data source resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The data source is being created.
        Creating,
        /// The data source has been created and is fully usable.
        Active,
        /// The data source is being deleted.
        Deleting,
        /// The data source is experiencing an issue and might be unusable.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.DataSource.State",
            ))
        }
    }

    /// The source resource that is represented by this DataSource. It can be a
    /// Google Cloud resource, or one backed up by a Backup Appliance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceResource {
        /// The backed up resource is a Google Cloud resource.
        /// The word 'DataSource' was included in the names to indicate that this is
        /// the representation of the Google Cloud resource used within the
        /// DataSource object.
        DataSourceGcpResource(std::boxed::Box<crate::model::DataSourceGcpResource>),
        /// The backed up resource is a backup appliance application.
        DataSourceBackupApplianceApplication(
            std::boxed::Box<crate::model::DataSourceBackupApplianceApplication>,
        ),
    }
}

/// BackupConfigInfo has information about how the resource is configured
/// for Backup and about the most recent backup to this vault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupConfigInfo {
    /// Output only. The status of the last backup to this BackupVault
    pub last_backup_state: crate::model::backup_config_info::LastBackupState,

    /// Output only. If the last backup were successful, this field has the
    /// consistency date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_successful_backup_consistency_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If the last backup failed, this field has the error message.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_backup_error: std::option::Option<rpc::model::Status>,

    /// Configuration Info has the resource format-specific configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub backup_config: std::option::Option<crate::model::backup_config_info::BackupConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupConfigInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_backup_state][crate::model::BackupConfigInfo::last_backup_state].
    pub fn set_last_backup_state<
        T: std::convert::Into<crate::model::backup_config_info::LastBackupState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_backup_state = v.into();
        self
    }

    /// Sets the value of [last_successful_backup_consistency_time][crate::model::BackupConfigInfo::last_successful_backup_consistency_time].
    pub fn set_last_successful_backup_consistency_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_successful_backup_consistency_time = v.into();
        self
    }

    /// Sets the value of [last_backup_error][crate::model::BackupConfigInfo::last_backup_error].
    pub fn set_last_backup_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_backup_error = v.into();
        self
    }

    /// Sets the value of [backup_config][crate::model::BackupConfigInfo::backup_config].
    ///
    /// Note that all the setters affecting `backup_config` are mutually
    /// exclusive.
    pub fn set_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::backup_config_info::BackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = v.into();
        self
    }

    /// The value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// if it holds a `GcpBackupConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_backup_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcpBackupConfig>> {
        #[allow(unreachable_patterns)]
        self.backup_config.as_ref().and_then(|v| match v {
            crate::model::backup_config_info::BackupConfig::GcpBackupConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// to hold a `GcpBackupConfig`.
    ///
    /// Note that all the setters affecting `backup_config` are
    /// mutually exclusive.
    pub fn set_gcp_backup_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GcpBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = std::option::Option::Some(
            crate::model::backup_config_info::BackupConfig::GcpBackupConfig(v.into()),
        );
        self
    }

    /// The value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// if it holds a `BackupApplianceBackupConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_appliance_backup_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupApplianceBackupConfig>> {
        #[allow(unreachable_patterns)]
        self.backup_config.as_ref().and_then(|v| match v {
            crate::model::backup_config_info::BackupConfig::BackupApplianceBackupConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_config][crate::model::BackupConfigInfo::backup_config]
    /// to hold a `BackupApplianceBackupConfig`.
    ///
    /// Note that all the setters affecting `backup_config` are
    /// mutually exclusive.
    pub fn set_backup_appliance_backup_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BackupApplianceBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = std::option::Option::Some(
            crate::model::backup_config_info::BackupConfig::BackupApplianceBackupConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupConfigInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupConfigInfo"
    }
}

/// Defines additional types related to [BackupConfigInfo].
pub mod backup_config_info {
    #[allow(unused_imports)]
    use super::*;

    /// LastBackupstate tracks whether the last backup was not yet started,
    /// successful, failed, or could not be run because of the lack of permissions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LastBackupState {
        /// Status not set.
        Unspecified,
        /// The first backup has not yet completed
        FirstBackupPending,
        /// The most recent backup was successful
        Succeeded,
        /// The most recent backup failed
        Failed,
        /// The most recent backup could not be run/failed because of the lack of
        /// permissions
        PermissionDenied,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LastBackupState::value] or
        /// [LastBackupState::name].
        UnknownValue(last_backup_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod last_backup_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LastBackupState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirstBackupPending => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::PermissionDenied => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LAST_BACKUP_STATE_UNSPECIFIED"),
                Self::FirstBackupPending => std::option::Option::Some("FIRST_BACKUP_PENDING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LastBackupState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LastBackupState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LastBackupState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirstBackupPending,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::PermissionDenied,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LastBackupState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LAST_BACKUP_STATE_UNSPECIFIED" => Self::Unspecified,
                "FIRST_BACKUP_PENDING" => Self::FirstBackupPending,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                _ => Self::UnknownValue(last_backup_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LastBackupState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirstBackupPending => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::PermissionDenied => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LastBackupState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LastBackupState>::new(
                ".google.cloud.backupdr.v1.BackupConfigInfo.LastBackupState",
            ))
        }
    }

    /// Configuration Info has the resource format-specific configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BackupConfig {
        /// Configuration for a Google Cloud resource.
        GcpBackupConfig(std::boxed::Box<crate::model::GcpBackupConfig>),
        /// Configuration for an application backed up by a Backup Appliance.
        BackupApplianceBackupConfig(std::boxed::Box<crate::model::BackupApplianceBackupConfig>),
    }
}

/// GcpBackupConfig captures the Backup configuration details for Google Cloud
/// resources. All Google Cloud resources regardless of type are protected with
/// backup plan associations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcpBackupConfig {
    /// The name of the backup plan.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan: std::string::String,

    /// The description of the backup plan.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan_description: std::string::String,

    /// The name of the backup plan association.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_plan_association: std::string::String,

    /// The names of the backup plan rules which point to this backupvault
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_plan_rules: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plan][crate::model::GcpBackupConfig::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [backup_plan_description][crate::model::GcpBackupConfig::backup_plan_description].
    pub fn set_backup_plan_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_description = v.into();
        self
    }

    /// Sets the value of [backup_plan_association][crate::model::GcpBackupConfig::backup_plan_association].
    pub fn set_backup_plan_association<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_plan_association = v.into();
        self
    }

    /// Sets the value of [backup_plan_rules][crate::model::GcpBackupConfig::backup_plan_rules].
    pub fn set_backup_plan_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.backup_plan_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcpBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GcpBackupConfig"
    }
}

/// BackupApplianceBackupConfig captures the backup configuration for
/// applications that are protected by Backup Appliances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupApplianceBackupConfig {
    /// The name of the backup appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_appliance_name: std::string::String,

    /// The ID of the backup appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_appliance_id: i64,

    /// The ID of the SLA of this application.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sla_id: i64,

    /// The name of the application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub application_name: std::string::String,

    /// The name of the host where the application is running.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_name: std::string::String,

    /// The name of the SLT associated with the application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub slt_name: std::string::String,

    /// The name of the SLP associated with the application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub slp_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupApplianceBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_appliance_name][crate::model::BackupApplianceBackupConfig::backup_appliance_name].
    pub fn set_backup_appliance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_appliance_name = v.into();
        self
    }

    /// Sets the value of [backup_appliance_id][crate::model::BackupApplianceBackupConfig::backup_appliance_id].
    pub fn set_backup_appliance_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_appliance_id = v.into();
        self
    }

    /// Sets the value of [sla_id][crate::model::BackupApplianceBackupConfig::sla_id].
    pub fn set_sla_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sla_id = v.into();
        self
    }

    /// Sets the value of [application_name][crate::model::BackupApplianceBackupConfig::application_name].
    pub fn set_application_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_name = v.into();
        self
    }

    /// Sets the value of [host_name][crate::model::BackupApplianceBackupConfig::host_name].
    pub fn set_host_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_name = v.into();
        self
    }

    /// Sets the value of [slt_name][crate::model::BackupApplianceBackupConfig::slt_name].
    pub fn set_slt_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.slt_name = v.into();
        self
    }

    /// Sets the value of [slp_name][crate::model::BackupApplianceBackupConfig::slp_name].
    pub fn set_slp_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.slp_name = v.into();
        self
    }
}

impl wkt::message::Message for BackupApplianceBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupApplianceBackupConfig"
    }
}

/// DataSourceGcpResource is used for protected resources that are Google Cloud
/// Resources. This name is easeier to understand than GcpResourceDataSource or
/// GcpDataSourceResource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSourceGcpResource {
    /// Output only. Full resource pathname URL of the source Google Cloud
    /// resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_resourcename: std::string::String,

    /// Location of the resource: \<region\>/\<zone\>/"global"/"unspecified".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The type of the Google Cloud resource. Use the Unified Resource Type,
    /// eg. compute.googleapis.com/Instance.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// gcp_Properties has properties of the Google Cloud Resource.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub gcp_resource_properties:
        std::option::Option<crate::model::data_source_gcp_resource::GcpResourceProperties>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceGcpResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_resourcename][crate::model::DataSourceGcpResource::gcp_resourcename].
    pub fn set_gcp_resourcename<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resourcename = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DataSourceGcpResource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataSourceGcpResource::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [gcp_resource_properties][crate::model::DataSourceGcpResource::gcp_resource_properties].
    ///
    /// Note that all the setters affecting `gcp_resource_properties` are mutually
    /// exclusive.
    pub fn set_gcp_resource_properties<
        T: std::convert::Into<
                std::option::Option<crate::model::data_source_gcp_resource::GcpResourceProperties>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resource_properties = v.into();
        self
    }

    /// The value of [gcp_resource_properties][crate::model::DataSourceGcpResource::gcp_resource_properties]
    /// if it holds a `ComputeInstanceDatasourceProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_datasource_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>>
    {
        #[allow(unreachable_patterns)]
        self.gcp_resource_properties.as_ref().and_then(|v| match v {
            crate::model::data_source_gcp_resource::GcpResourceProperties::ComputeInstanceDatasourceProperties(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [gcp_resource_properties][crate::model::DataSourceGcpResource::gcp_resource_properties]
    /// to hold a `ComputeInstanceDatasourceProperties`.
    ///
    /// Note that all the setters affecting `gcp_resource_properties` are
    /// mutually exclusive.
    pub fn set_compute_instance_datasource_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resource_properties = std::option::Option::Some(
            crate::model::data_source_gcp_resource::GcpResourceProperties::ComputeInstanceDatasourceProperties(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for DataSourceGcpResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DataSourceGcpResource"
    }
}

/// Defines additional types related to [DataSourceGcpResource].
pub mod data_source_gcp_resource {
    #[allow(unused_imports)]
    use super::*;

    /// gcp_Properties has properties of the Google Cloud Resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum GcpResourceProperties {
        /// ComputeInstanceDataSourceProperties has a subset of Compute Instance
        /// properties that are useful at the Datasource level.
        ComputeInstanceDatasourceProperties(
            std::boxed::Box<crate::model::ComputeInstanceDataSourceProperties>,
        ),
    }
}

/// BackupApplianceApplication describes a Source Resource when it is an
/// application backed up by a BackupAppliance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSourceBackupApplianceApplication {
    /// The name of the Application as known to the Backup Appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub application_name: std::string::String,

    /// Appliance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_appliance: std::string::String,

    /// Appliance Id of the Backup Appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub appliance_id: i64,

    /// The type of the application. e.g. VMBackup
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// The appid field of the application within the Backup Appliance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub application_id: i64,

    /// Hostname of the host where the application is running.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Hostid of the application host.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub host_id: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceBackupApplianceApplication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application_name][crate::model::DataSourceBackupApplianceApplication::application_name].
    pub fn set_application_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.application_name = v.into();
        self
    }

    /// Sets the value of [backup_appliance][crate::model::DataSourceBackupApplianceApplication::backup_appliance].
    pub fn set_backup_appliance<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_appliance = v.into();
        self
    }

    /// Sets the value of [appliance_id][crate::model::DataSourceBackupApplianceApplication::appliance_id].
    pub fn set_appliance_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.appliance_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataSourceBackupApplianceApplication::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [application_id][crate::model::DataSourceBackupApplianceApplication::application_id].
    pub fn set_application_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.application_id = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::DataSourceBackupApplianceApplication::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [host_id][crate::model::DataSourceBackupApplianceApplication::host_id].
    pub fn set_host_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.host_id = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceBackupApplianceApplication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DataSourceBackupApplianceApplication"
    }
}

/// ServiceLockInfo represents the details of a lock taken by the service on a
/// Backup resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceLockInfo {
    /// Output only. The name of the operation that created this lock.
    /// The lock will automatically be released when the operation completes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceLockInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::ServiceLockInfo::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }
}

impl wkt::message::Message for ServiceLockInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ServiceLockInfo"
    }
}

/// BackupApplianceLockInfo contains metadata about the backupappliance that
/// created the lock.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupApplianceLockInfo {
    /// Required. The ID of the backup/recovery appliance that created this lock.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_appliance_id: i64,

    /// Required. The name of the backup/recovery appliance that created this lock.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_appliance_name: std::string::String,

    /// Required. The reason for the lock: e.g. MOUNT/RESTORE/BACKUP/etc.  The
    /// value of this string is only meaningful to the client and it is not
    /// interpreted by the BackupVault service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lock_reason: std::string::String,

    /// The information about this lock.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub lock_source: std::option::Option<crate::model::backup_appliance_lock_info::LockSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupApplianceLockInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_appliance_id][crate::model::BackupApplianceLockInfo::backup_appliance_id].
    pub fn set_backup_appliance_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_appliance_id = v.into();
        self
    }

    /// Sets the value of [backup_appliance_name][crate::model::BackupApplianceLockInfo::backup_appliance_name].
    pub fn set_backup_appliance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_appliance_name = v.into();
        self
    }

    /// Sets the value of [lock_reason][crate::model::BackupApplianceLockInfo::lock_reason].
    pub fn set_lock_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lock_reason = v.into();
        self
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source].
    ///
    /// Note that all the setters affecting `lock_source` are mutually
    /// exclusive.
    pub fn set_lock_source<
        T: std::convert::Into<
                std::option::Option<crate::model::backup_appliance_lock_info::LockSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lock_source = v.into();
        self
    }

    /// The value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// if it holds a `JobName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn job_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.lock_source.as_ref().and_then(|v| match v {
            crate::model::backup_appliance_lock_info::LockSource::JobName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// to hold a `JobName`.
    ///
    /// Note that all the setters affecting `lock_source` are
    /// mutually exclusive.
    pub fn set_job_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lock_source = std::option::Option::Some(
            crate::model::backup_appliance_lock_info::LockSource::JobName(v.into()),
        );
        self
    }

    /// The value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// if it holds a `BackupImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_image(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.lock_source.as_ref().and_then(|v| match v {
            crate::model::backup_appliance_lock_info::LockSource::BackupImage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// to hold a `BackupImage`.
    ///
    /// Note that all the setters affecting `lock_source` are
    /// mutually exclusive.
    pub fn set_backup_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lock_source = std::option::Option::Some(
            crate::model::backup_appliance_lock_info::LockSource::BackupImage(v.into()),
        );
        self
    }

    /// The value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// if it holds a `SlaId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sla_id(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.lock_source.as_ref().and_then(|v| match v {
            crate::model::backup_appliance_lock_info::LockSource::SlaId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [lock_source][crate::model::BackupApplianceLockInfo::lock_source]
    /// to hold a `SlaId`.
    ///
    /// Note that all the setters affecting `lock_source` are
    /// mutually exclusive.
    pub fn set_sla_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.lock_source = std::option::Option::Some(
            crate::model::backup_appliance_lock_info::LockSource::SlaId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupApplianceLockInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupApplianceLockInfo"
    }
}

/// Defines additional types related to [BackupApplianceLockInfo].
pub mod backup_appliance_lock_info {
    #[allow(unused_imports)]
    use super::*;

    /// The information about this lock.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LockSource {
        /// The job name on the backup/recovery appliance that created this lock.
        JobName(std::string::String),
        /// The image name that depends on this Backup.
        BackupImage(std::string::String),
        /// The SLA on the backup/recovery appliance that owns the lock.
        SlaId(i64),
    }
}

/// BackupLock represents a single lock on a Backup resource.  An unexpired
/// lock on a Backup prevents the Backup from being deleted.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupLock {
    /// Required. The time after which this lock is not considered valid and will
    /// no longer protect the Backup from deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lock_until_time: std::option::Option<wkt::Timestamp>,

    /// Metadata about the owner and reason for the lock.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub client_lock_info: std::option::Option<crate::model::backup_lock::ClientLockInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupLock {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lock_until_time][crate::model::BackupLock::lock_until_time].
    pub fn set_lock_until_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lock_until_time = v.into();
        self
    }

    /// Sets the value of [client_lock_info][crate::model::BackupLock::client_lock_info].
    ///
    /// Note that all the setters affecting `client_lock_info` are mutually
    /// exclusive.
    pub fn set_client_lock_info<
        T: std::convert::Into<std::option::Option<crate::model::backup_lock::ClientLockInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_lock_info = v.into();
        self
    }

    /// The value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// if it holds a `BackupApplianceLockInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_appliance_lock_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupApplianceLockInfo>> {
        #[allow(unreachable_patterns)]
        self.client_lock_info.as_ref().and_then(|v| match v {
            crate::model::backup_lock::ClientLockInfo::BackupApplianceLockInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// to hold a `BackupApplianceLockInfo`.
    ///
    /// Note that all the setters affecting `client_lock_info` are
    /// mutually exclusive.
    pub fn set_backup_appliance_lock_info<
        T: std::convert::Into<std::boxed::Box<crate::model::BackupApplianceLockInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_lock_info = std::option::Option::Some(
            crate::model::backup_lock::ClientLockInfo::BackupApplianceLockInfo(v.into()),
        );
        self
    }

    /// The value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// if it holds a `ServiceLockInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_lock_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ServiceLockInfo>> {
        #[allow(unreachable_patterns)]
        self.client_lock_info.as_ref().and_then(|v| match v {
            crate::model::backup_lock::ClientLockInfo::ServiceLockInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [client_lock_info][crate::model::BackupLock::client_lock_info]
    /// to hold a `ServiceLockInfo`.
    ///
    /// Note that all the setters affecting `client_lock_info` are
    /// mutually exclusive.
    pub fn set_service_lock_info<
        T: std::convert::Into<std::boxed::Box<crate::model::ServiceLockInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_lock_info = std::option::Option::Some(
            crate::model::backup_lock::ClientLockInfo::ServiceLockInfo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackupLock {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupLock"
    }
}

/// Defines additional types related to [BackupLock].
pub mod backup_lock {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata about the owner and reason for the lock.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ClientLockInfo {
        /// If the client is a backup and recovery appliance, this
        /// contains metadata about why the lock exists.
        BackupApplianceLockInfo(std::boxed::Box<crate::model::BackupApplianceLockInfo>),
        /// Output only. Contains metadata about the lock exist for Google Cloud
        /// native backups.
        ServiceLockInfo(std::boxed::Box<crate::model::ServiceLockInfo>),
    }
}

/// Message describing a Backup object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. Identifier. Name of the backup to create. It must have the
    /// format`"projects/<project>/locations/<location>/backupVaults/<backupvault>/dataSources/{datasource}/backups/{backup}"`.
    /// `{backup}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the datasource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The description of the Backup instance (2048 characters or
    /// less).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Output only. The time when the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the instance was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The backup can not be deleted before this time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enforced_retention_end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. When this backup is automatically expired.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The point in time when this backup was captured from the
    /// source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub consistency_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Server specified ETag to prevent updates from overwriting each
    /// other.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// Output only. The Backup resource instance state.
    pub state: crate::model::backup::State,

    /// Output only. The list of BackupLocks taken by the service to prevent the
    /// deletion of the backup.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_locks: std::vec::Vec<crate::model::BackupLock>,

    /// Optional. The list of BackupLocks taken by the accessor Backup Appliance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_appliance_locks: std::vec::Vec<crate::model::BackupLock>,

    /// Output only. Type of the backup, unspecified, scheduled or ondemand.
    pub backup_type: crate::model::backup::BackupType,

    /// Output only. source resource size in bytes at the time of the backup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub resource_size_bytes: i64,

    /// Workload specific backup properties.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub backup_properties: std::option::Option<crate::model::backup::BackupProperties>,

    /// Configuration Info has the resource format-specific configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub plan_info: std::option::Option<crate::model::backup::PlanInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Backup::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enforced_retention_end_time][crate::model::Backup::enforced_retention_end_time].
    pub fn set_enforced_retention_end_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enforced_retention_end_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [consistency_time][crate::model::Backup::consistency_time].
    pub fn set_consistency_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.consistency_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Backup::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [service_locks][crate::model::Backup::service_locks].
    pub fn set_service_locks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupLock>,
    {
        use std::iter::Iterator;
        self.service_locks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_appliance_locks][crate::model::Backup::backup_appliance_locks].
    pub fn set_backup_appliance_locks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupLock>,
    {
        use std::iter::Iterator;
        self.backup_appliance_locks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [resource_size_bytes][crate::model::Backup::resource_size_bytes].
    pub fn set_resource_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.resource_size_bytes = v.into();
        self
    }

    /// Sets the value of [backup_properties][crate::model::Backup::backup_properties].
    ///
    /// Note that all the setters affecting `backup_properties` are mutually
    /// exclusive.
    pub fn set_backup_properties<
        T: std::convert::Into<std::option::Option<crate::model::backup::BackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_properties = v.into();
        self
    }

    /// The value of [backup_properties][crate::model::Backup::backup_properties]
    /// if it holds a `ComputeInstanceBackupProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_backup_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceBackupProperties>> {
        #[allow(unreachable_patterns)]
        self.backup_properties.as_ref().and_then(|v| match v {
            crate::model::backup::BackupProperties::ComputeInstanceBackupProperties(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_properties][crate::model::Backup::backup_properties]
    /// to hold a `ComputeInstanceBackupProperties`.
    ///
    /// Note that all the setters affecting `backup_properties` are
    /// mutually exclusive.
    pub fn set_compute_instance_backup_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceBackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_properties = std::option::Option::Some(
            crate::model::backup::BackupProperties::ComputeInstanceBackupProperties(v.into()),
        );
        self
    }

    /// The value of [backup_properties][crate::model::Backup::backup_properties]
    /// if it holds a `BackupApplianceBackupProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_appliance_backup_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupApplianceBackupProperties>> {
        #[allow(unreachable_patterns)]
        self.backup_properties.as_ref().and_then(|v| match v {
            crate::model::backup::BackupProperties::BackupApplianceBackupProperties(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_properties][crate::model::Backup::backup_properties]
    /// to hold a `BackupApplianceBackupProperties`.
    ///
    /// Note that all the setters affecting `backup_properties` are
    /// mutually exclusive.
    pub fn set_backup_appliance_backup_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::BackupApplianceBackupProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_properties = std::option::Option::Some(
            crate::model::backup::BackupProperties::BackupApplianceBackupProperties(v.into()),
        );
        self
    }

    /// Sets the value of [plan_info][crate::model::Backup::plan_info].
    ///
    /// Note that all the setters affecting `plan_info` are mutually
    /// exclusive.
    pub fn set_plan_info<
        T: std::convert::Into<std::option::Option<crate::model::backup::PlanInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.plan_info = v.into();
        self
    }

    /// The value of [plan_info][crate::model::Backup::plan_info]
    /// if it holds a `GcpBackupPlanInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_backup_plan_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>> {
        #[allow(unreachable_patterns)]
        self.plan_info.as_ref().and_then(|v| match v {
            crate::model::backup::PlanInfo::GcpBackupPlanInfo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [plan_info][crate::model::Backup::plan_info]
    /// to hold a `GcpBackupPlanInfo`.
    ///
    /// Note that all the setters affecting `plan_info` are
    /// mutually exclusive.
    pub fn set_gcp_backup_plan_info<
        T: std::convert::Into<std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.plan_info =
            std::option::Option::Some(crate::model::backup::PlanInfo::GcpBackupPlanInfo(v.into()));
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Backup"
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// GCPBackupPlanInfo captures the plan configuration details of Google Cloud
    /// resources at the time of backup.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GCPBackupPlanInfo {
        /// Resource name of backup plan by which workload is protected at the time
        /// of the backup.
        /// Format:
        /// projects/{project}/locations/{location}/backupPlans/{backupPlanId}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub backup_plan: std::string::String,

        /// The rule id of the backup plan which triggered this backup in case of
        /// scheduled backup or used for
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub backup_plan_rule_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GCPBackupPlanInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup_plan][crate::model::backup::GCPBackupPlanInfo::backup_plan].
        pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.backup_plan = v.into();
            self
        }

        /// Sets the value of [backup_plan_rule_id][crate::model::backup::GCPBackupPlanInfo::backup_plan_rule_id].
        pub fn set_backup_plan_rule_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.backup_plan_rule_id = v.into();
            self
        }
    }

    impl wkt::message::Message for GCPBackupPlanInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.backupdr.v1.Backup.GCPBackupPlanInfo"
        }
    }

    /// Holds the state of the backup resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// The backup is being created.
        Creating,
        /// The backup has been created and is fully usable.
        Active,
        /// The backup is being deleted.
        Deleting,
        /// The backup is experiencing an issue and might be unusable.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.backupdr.v1.Backup.State",
            ))
        }
    }

    /// Type of the backup, scheduled or ondemand.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// Backup type is unspecified.
        Unspecified,
        /// Scheduled backup.
        Scheduled,
        /// On demand backup.
        OnDemand,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scheduled => std::option::Option::Some(1),
                Self::OnDemand => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scheduled,
                2 => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCHEDULED" => Self::Scheduled,
                "ON_DEMAND" => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scheduled => serializer.serialize_i32(1),
                Self::OnDemand => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.cloud.backupdr.v1.Backup.BackupType",
            ))
        }
    }

    /// Workload specific backup properties.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BackupProperties {
        /// Output only. Compute Engine specific backup properties.
        ComputeInstanceBackupProperties(
            std::boxed::Box<crate::model::ComputeInstanceBackupProperties>,
        ),
        /// Output only. Backup Appliance specific backup properties.
        BackupApplianceBackupProperties(
            std::boxed::Box<crate::model::BackupApplianceBackupProperties>,
        ),
    }

    /// Configuration Info has the resource format-specific configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PlanInfo {
        /// Output only. Configuration for a Google Cloud resource.
        GcpBackupPlanInfo(std::boxed::Box<crate::model::backup::GCPBackupPlanInfo>),
    }
}

/// Message for creating a BackupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupVaultRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object
    /// If auto-generating ID server-side, remove this field and
    /// backup_vault_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_vault_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupVaultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_vault_id][crate::model::CreateBackupVaultRequest::backup_vault_id].
    pub fn set_backup_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault_id = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::CreateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<
        T: std::convert::Into<std::option::Option<crate::model::BackupVault>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateBackupVaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CreateBackupVaultRequest"
    }
}

/// Request message for listing backupvault stores.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupVaultsRequest {
    /// Required. The project and location for which to retrieve backupvault stores
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud Backup and DR, locations map to Google Cloud regions, for example
    /// **us-central1**.
    /// To retrieve backupvault stores for all locations, use "-" for the
    /// '{location}' value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// Vault.
    pub view: crate::model::BackupVaultView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListBackupVaultsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupVaultView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupVaultsRequest"
    }
}

/// Response message for listing BackupVaults.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupVaultsResponse {
    /// The list of BackupVault instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup vaults in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_vaults: std::vec::Vec<crate::model::BackupVault>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vaults][crate::model::ListBackupVaultsResponse::backup_vaults].
    pub fn set_backup_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupVault>,
    {
        use std::iter::Iterator;
        self.backup_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupVaultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupVaultsResponse {
    type PageItem = crate::model::BackupVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for fetching usable BackupVaults.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchUsableBackupVaultsRequest {
    /// Required. The project and location for which to retrieve backupvault stores
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud Backup and DR, locations map to Google Cloud regions, for example
    /// **us-central1**.
    /// To retrieve backupvault stores for all locations, use "-" for the
    /// '{location}' value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchUsableBackupVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::FetchUsableBackupVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchUsableBackupVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchUsableBackupVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::FetchUsableBackupVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::FetchUsableBackupVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for FetchUsableBackupVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.FetchUsableBackupVaultsRequest"
    }
}

/// Response message for fetching usable BackupVaults.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchUsableBackupVaultsResponse {
    /// The list of BackupVault instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup vaults in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_vaults: std::vec::Vec<crate::model::BackupVault>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchUsableBackupVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vaults][crate::model::FetchUsableBackupVaultsResponse::backup_vaults].
    pub fn set_backup_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupVault>,
    {
        use std::iter::Iterator;
        self.backup_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchUsableBackupVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::FetchUsableBackupVaultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchUsableBackupVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.FetchUsableBackupVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchUsableBackupVaultsResponse {
    type PageItem = crate::model::BackupVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a BackupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupVaultRequest {
    /// Required. Name of the backupvault store resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// Vault
    pub view: crate::model::BackupVaultView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetBackupVaultRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupVaultView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupVaultRequest"
    }
}

/// Request message for updating a BackupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupVaultRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// BackupVault resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. If set to true, will not check plan duration against backup vault
    /// enforcement duration.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupVaultRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::UpdateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<
        T: std::convert::Into<std::option::Option<crate::model::BackupVault>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateBackupVaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::UpdateBackupVaultRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.UpdateBackupVaultRequest"
    }
}

/// Message for deleting a BackupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupVaultRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, any data source from this backup vault will also
    /// be deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    /// The current etag of the backup vault.
    /// If an etag is provided and does not match the current etag of the
    /// connection, deletion will be blocked.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. If true and the BackupVault is not found, the request will
    /// succeed but no action will be taken.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    /// Optional. If set to true, backupvault deletion will proceed even if there
    /// are backup plans referencing the backupvault. The default is 'false'.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ignore_backup_plan_references: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupVaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteBackupVaultRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupVaultRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteBackupVaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteBackupVaultRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_backup_plan_references][crate::model::DeleteBackupVaultRequest::ignore_backup_plan_references].
    pub fn set_ignore_backup_plan_references<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_backup_plan_references = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupVaultRequest"
    }
}

/// Request message for listing DataSources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataSourcesRequest {
    /// Required. The project and location for which to retrieve data
    /// sources information, in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
    /// locations map to Google Cloud regions, for example **us-central1**.
    /// To retrieve data sources for all locations, use "-" for the
    /// '{location}' value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListDataSourcesRequest"
    }
}

/// Response message for listing DataSources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataSourcesResponse {
    /// The list of DataSource instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return data sources in reachable locations
    /// and the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_sources: std::vec::Vec<crate::model::DataSource>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sources][crate::model::ListDataSourcesResponse::data_sources].
    pub fn set_data_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSource>,
    {
        use std::iter::Iterator;
        self.data_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDataSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListDataSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataSourcesResponse {
    type PageItem = crate::model::DataSource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a DataSource instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataSourceRequest {
    /// Required. Name of the data source resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}/dataSource/{resource_name}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetDataSourceRequest"
    }
}

/// Request message for updating a data source instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDataSourceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// DataSource resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::DataSource>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Enable upsert.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataSourceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::UpdateDataSourceRequest::data_source].
    pub fn set_data_source<T: std::convert::Into<std::option::Option<crate::model::DataSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDataSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDataSourceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.UpdateDataSourceRequest"
    }
}

/// Request message for listing Backups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The project and location for which to retrieve backup
    /// information, in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
    /// locations map to Google Cloud regions, for example **us-central1**.
    /// To retrieve data sources for all locations, use "-" for the
    /// '{location}' value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// resource.
    pub view: crate::model::BackupView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListBackupsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupsRequest"
    }
}

/// Response message for listing Backups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of Backup instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return data sources in reachable locations
    /// and the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for getting a Backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the data source resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{backupVault}/dataSources/{datasource}/backups/{backup}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// resource.
    pub view: crate::model::BackupView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetBackupRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::BackupView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GetBackupRequest"
    }
}

/// Request message for updating a Backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.UpdateBackupRequest"
    }
}

/// Message for deleting a Backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DeleteBackupRequest"
    }
}

/// Request message for restoring from a Backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreBackupRequest {
    /// Required. The resource name of the Backup instance, in the format
    /// 'projects/*/locations/*/backupVaults/*/dataSources/*/backups/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// The target environment for the restore operation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_environment:
        std::option::Option<crate::model::restore_backup_request::TargetEnvironment>,

    /// The property overrides for the instance being restored.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub instance_properties:
        std::option::Option<crate::model::restore_backup_request::InstanceProperties>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RestoreBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [target_environment][crate::model::RestoreBackupRequest::target_environment].
    ///
    /// Note that all the setters affecting `target_environment` are mutually
    /// exclusive.
    pub fn set_target_environment<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_backup_request::TargetEnvironment>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_environment = v.into();
        self
    }

    /// The value of [target_environment][crate::model::RestoreBackupRequest::target_environment]
    /// if it holds a `ComputeInstanceTargetEnvironment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_target_environment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>> {
        #[allow(unreachable_patterns)]
        self.target_environment.as_ref().and_then(|v| match v {
            crate::model::restore_backup_request::TargetEnvironment::ComputeInstanceTargetEnvironment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_environment][crate::model::RestoreBackupRequest::target_environment]
    /// to hold a `ComputeInstanceTargetEnvironment`.
    ///
    /// Note that all the setters affecting `target_environment` are
    /// mutually exclusive.
    pub fn set_compute_instance_target_environment<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_environment = std::option::Option::Some(
            crate::model::restore_backup_request::TargetEnvironment::ComputeInstanceTargetEnvironment(
                v.into()
            )
        );
        self
    }

    /// Sets the value of [instance_properties][crate::model::RestoreBackupRequest::instance_properties].
    ///
    /// Note that all the setters affecting `instance_properties` are mutually
    /// exclusive.
    pub fn set_instance_properties<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_backup_request::InstanceProperties>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_properties = v.into();
        self
    }

    /// The value of [instance_properties][crate::model::RestoreBackupRequest::instance_properties]
    /// if it holds a `ComputeInstanceRestoreProperties`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_instance_restore_properties(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>> {
        #[allow(unreachable_patterns)]
        self.instance_properties.as_ref().and_then(|v| match v {
            crate::model::restore_backup_request::InstanceProperties::ComputeInstanceRestoreProperties(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instance_properties][crate::model::RestoreBackupRequest::instance_properties]
    /// to hold a `ComputeInstanceRestoreProperties`.
    ///
    /// Note that all the setters affecting `instance_properties` are
    /// mutually exclusive.
    pub fn set_compute_instance_restore_properties<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_properties = std::option::Option::Some(
            crate::model::restore_backup_request::InstanceProperties::ComputeInstanceRestoreProperties(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for RestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.RestoreBackupRequest"
    }
}

/// Defines additional types related to [RestoreBackupRequest].
pub mod restore_backup_request {
    #[allow(unused_imports)]
    use super::*;

    /// The target environment for the restore operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetEnvironment {
        /// Compute Engine target environment to be used during restore.
        ComputeInstanceTargetEnvironment(
            std::boxed::Box<crate::model::ComputeInstanceTargetEnvironment>,
        ),
    }

    /// The property overrides for the instance being restored.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum InstanceProperties {
        /// Compute Engine instance properties to be overridden during restore.
        ComputeInstanceRestoreProperties(
            std::boxed::Box<crate::model::ComputeInstanceRestoreProperties>,
        ),
    }
}

/// Response message for restoring from a Backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreBackupResponse {
    /// Details of the target resource created/modified as part of restore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_resource: std::option::Option<crate::model::TargetResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreBackupResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_resource][crate::model::RestoreBackupResponse::target_resource].
    pub fn set_target_resource<
        T: std::convert::Into<std::option::Option<crate::model::TargetResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource = v.into();
        self
    }
}

impl wkt::message::Message for RestoreBackupResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.RestoreBackupResponse"
    }
}

/// Details of the target resource created/modified as part of restore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetResource {
    /// Minimum details to identify the restored resource.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_resource_info:
        std::option::Option<crate::model::target_resource::TargetResourceInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_resource_info][crate::model::TargetResource::target_resource_info].
    ///
    /// Note that all the setters affecting `target_resource_info` are mutually
    /// exclusive.
    pub fn set_target_resource_info<
        T: std::convert::Into<std::option::Option<crate::model::target_resource::TargetResourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_info = v.into();
        self
    }

    /// The value of [target_resource_info][crate::model::TargetResource::target_resource_info]
    /// if it holds a `GcpResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_resource(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcpResource>> {
        #[allow(unreachable_patterns)]
        self.target_resource_info.as_ref().and_then(|v| match v {
            crate::model::target_resource::TargetResourceInfo::GcpResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_resource_info][crate::model::TargetResource::target_resource_info]
    /// to hold a `GcpResource`.
    ///
    /// Note that all the setters affecting `target_resource_info` are
    /// mutually exclusive.
    pub fn set_gcp_resource<T: std::convert::Into<std::boxed::Box<crate::model::GcpResource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_info = std::option::Option::Some(
            crate::model::target_resource::TargetResourceInfo::GcpResource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TargetResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.TargetResource"
    }
}

/// Defines additional types related to [TargetResource].
pub mod target_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Minimum details to identify the restored resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetResourceInfo {
        /// Details of the native Google Cloud resource created as part of restore.
        GcpResource(std::boxed::Box<crate::model::GcpResource>),
    }
}

/// Minimum details to identify a Google Cloud resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcpResource {
    /// Name of the Google Cloud resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_resourcename: std::string::String,

    /// Location of the resource: \<region\>/\<zone\>/"global"/"unspecified".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Type of the resource. Use the Unified Resource Type,
    /// eg. compute.googleapis.com/Instance.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_resourcename][crate::model::GcpResource::gcp_resourcename].
    pub fn set_gcp_resourcename<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_resourcename = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GcpResource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::GcpResource::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for GcpResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GcpResource"
    }
}

/// BackupApplianceBackupProperties represents BackupDR backup appliance's
/// properties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupApplianceBackupProperties {
    /// Output only. The numeric generation ID of the backup (monotonically
    /// increasing).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generation_id: std::option::Option<i32>,

    /// Output only. The time when this backup object was finalized (if none,
    /// backup is not finalized).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finalize_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The earliest timestamp of data available in this Backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recovery_range_start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The latest timestamp of data available in this Backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recovery_range_end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupApplianceBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generation_id][crate::model::BackupApplianceBackupProperties::generation_id].
    pub fn set_generation_id<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.generation_id = v.into();
        self
    }

    /// Sets the value of [finalize_time][crate::model::BackupApplianceBackupProperties::finalize_time].
    pub fn set_finalize_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finalize_time = v.into();
        self
    }

    /// Sets the value of [recovery_range_start_time][crate::model::BackupApplianceBackupProperties::recovery_range_start_time].
    pub fn set_recovery_range_start_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recovery_range_start_time = v.into();
        self
    }

    /// Sets the value of [recovery_range_end_time][crate::model::BackupApplianceBackupProperties::recovery_range_end_time].
    pub fn set_recovery_range_end_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recovery_range_end_time = v.into();
        self
    }
}

impl wkt::message::Message for BackupApplianceBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.BackupApplianceBackupProperties"
    }
}

/// ComputeInstanceBackupProperties represents Compute Engine instance backup
/// properties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeInstanceBackupProperties {
    /// An optional text description for the instances that are created from these
    /// properties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// A list of tags to apply to the instances that are created from these
    /// properties. The tags identify valid sources or targets for network
    /// firewalls. The setTags method can modify this list of tags. Each tag within
    /// the list must comply with RFC1035 (<https://www.ietf.org/rfc/rfc1035.txt>).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tags: std::option::Option<crate::model::Tags>,

    /// The machine type to use for instances that are created from these
    /// properties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_type: std::option::Option<std::string::String>,

    /// Enables instances created based on these properties to send packets with
    /// source IP addresses other than their own and receive packets with
    /// destination IP addresses other than their own. If these instances will be
    /// used as an IP gateway or it will be set as the next-hop in a Route
    /// resource, specify `true`. If unsure, leave this set to `false`. See the
    /// <https://cloud.google.com/vpc/docs/using-routes#canipforward>
    /// documentation for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub can_ip_forward: std::option::Option<bool>,

    /// An array of network access configurations for this interface.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_interface: std::vec::Vec<crate::model::NetworkInterface>,

    /// An array of disks that are associated with the instances that are created
    /// from these properties.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub disk: std::vec::Vec<crate::model::AttachedDisk>,

    /// The metadata key/value pairs to assign to instances that are created from
    /// these properties. These pairs can consist of custom metadata or predefined
    /// keys. See <https://cloud.google.com/compute/docs/metadata/overview> for more
    /// information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// A list of service accounts with specified scopes. Access tokens for these
    /// service accounts are available to the instances that are created from
    /// these properties. Use metadata queries to obtain the access tokens for
    /// these instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_account: std::vec::Vec<crate::model::ServiceAccount>,

    /// Specifies the scheduling options for the instances that are created from
    /// these properties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// A list of guest accelerator cards' type and count to use for instances
    /// created from these properties.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub guest_accelerator: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Minimum cpu/platform to be used by instances. The instance may be
    /// scheduled on the specified or newer cpu/platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: Intel Haswell` or `minCpuPlatform: Intel Sandy Bridge`.
    /// For more information, read
    /// <https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// KeyRevocationActionType of the instance. Supported options are "STOP" and
    /// "NONE". The default value is "NONE" if it is not specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key_revocation_action_type: std::option::Option<crate::model::KeyRevocationActionType>,

    /// The source instance used to create this backup. This can be a partial or
    /// full URL to the resource. For example, the following are valid values:
    /// -<https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance>
    /// -projects/project/zones/zone/instances/instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_instance: std::option::Option<std::string::String>,

    /// Labels to apply to instances that are created from these properties.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceBackupProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::ComputeInstanceBackupProperties::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::ComputeInstanceBackupProperties::tags].
    pub fn set_tags<T: std::convert::Into<std::option::Option<crate::model::Tags>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tags = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeInstanceBackupProperties::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::ComputeInstanceBackupProperties::can_ip_forward].
    pub fn set_can_ip_forward<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.can_ip_forward = v.into();
        self
    }

    /// Sets the value of [network_interface][crate::model::ComputeInstanceBackupProperties::network_interface].
    pub fn set_network_interface<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interface = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk][crate::model::ComputeInstanceBackupProperties::disk].
    pub fn set_disk<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disk = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeInstanceBackupProperties::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<crate::model::Metadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeInstanceBackupProperties::service_account].
    pub fn set_service_account<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_account = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::ComputeInstanceBackupProperties::scheduling].
    pub fn set_scheduling<T: std::convert::Into<std::option::Option<crate::model::Scheduling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scheduling = v.into();
        self
    }

    /// Sets the value of [guest_accelerator][crate::model::ComputeInstanceBackupProperties::guest_accelerator].
    pub fn set_guest_accelerator<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerator = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::ComputeInstanceBackupProperties::min_cpu_platform].
    pub fn set_min_cpu_platform<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::ComputeInstanceBackupProperties::key_revocation_action_type].
    pub fn set_key_revocation_action_type<
        T: std::convert::Into<std::option::Option<crate::model::KeyRevocationActionType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_revocation_action_type = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::ComputeInstanceBackupProperties::source_instance].
    pub fn set_source_instance<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_instance = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeInstanceBackupProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ComputeInstanceBackupProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceBackupProperties"
    }
}

/// ComputeInstanceRestoreProperties represents Compute Engine instance
/// properties to be overridden during restore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeInstanceRestoreProperties {
    /// Required. Name of the compute instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// Optional. Controls for advanced machine-related behavior features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Optional. Allows this instance to send and receive packets with
    /// non-matching destination or source IPs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub can_ip_forward: std::option::Option<bool>,

    /// Optional. Controls Confidential compute options on the instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    /// Optional. Whether the resource should be protected against deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_protection: std::option::Option<bool>,

    /// Optional. An optional description of this resource. Provide this property
    /// when you create the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Optional. Array of disks associated with this instance. Persistent disks
    /// must be created before you can assign them.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub disks: std::vec::Vec<crate::model::AttachedDisk>,

    /// Optional. Enables display device for the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_device: std::option::Option<crate::model::DisplayDevice>,

    /// Optional. A list of the type and count of accelerator cards attached to the
    /// instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. Specifies the hostname of the instance. The specified hostname
    /// must be RFC1035 compliant. If hostname is not specified, the default
    /// hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global
    /// DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal
    /// DNS.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hostname: std::option::Option<std::string::String>,

    /// Optional. Encrypts suspended data for an instance with a
    /// customer-managed encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// Optional. KeyRevocationActionType of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key_revocation_action_type: std::option::Option<crate::model::KeyRevocationActionType>,

    /// Optional. Labels to apply to this instance.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Full or partial URL of the machine type resource to use for this
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_type: std::option::Option<std::string::String>,

    /// Optional. This includes custom metadata and predefined keys.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Optional. Minimum CPU platform to use for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// Optional. An array of network configurations for this instance. These
    /// specify how interfaces are configured to interact with other network
    /// services, such as connecting to the internet. Multiple interfaces are
    /// supported per instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Optional. Configure network performance such as egress bandwidth tier.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_performance_config: std::option::Option<crate::model::NetworkPerformanceConfig>,

    /// Input only. Additional params passed with the request, but not persisted
    /// as part of resource payload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub params: std::option::Option<crate::model::InstanceParams>,

    /// Optional. The private IPv6 google access type for the VM.
    /// If not specified, use INHERIT_FROM_SUBNETWORK as default.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_ipv6_google_access: std::option::Option<
        crate::model::compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess,
    >,

    /// Optional. Specifies the reservations that this instance can consume from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allocation_affinity: std::option::Option<crate::model::AllocationAffinity>,

    /// Optional. Resource policies applied to this instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// Optional. Sets the scheduling options for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// Optional. A list of service accounts, with their specified scopes,
    /// authorized for this instance. Only one service account per VM instance is
    /// supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    /// Optional. Tags to apply to this instance. Tags are used to identify valid
    /// sources or targets for network firewalls and are specified by the client
    /// during instance creation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tags: std::option::Option<crate::model::Tags>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceRestoreProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeInstanceRestoreProperties::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::ComputeInstanceRestoreProperties::advanced_machine_features].
    pub fn set_advanced_machine_features<
        T: std::convert::Into<std::option::Option<crate::model::AdvancedMachineFeatures>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.advanced_machine_features = v.into();
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::ComputeInstanceRestoreProperties::can_ip_forward].
    pub fn set_can_ip_forward<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.can_ip_forward = v.into();
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::ComputeInstanceRestoreProperties::confidential_instance_config].
    pub fn set_confidential_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::ConfidentialInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_instance_config = v.into();
        self
    }

    /// Sets the value of [deletion_protection][crate::model::ComputeInstanceRestoreProperties::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deletion_protection = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ComputeInstanceRestoreProperties::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::ComputeInstanceRestoreProperties::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_device][crate::model::ComputeInstanceRestoreProperties::display_device].
    pub fn set_display_device<
        T: std::convert::Into<std::option::Option<crate::model::DisplayDevice>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.display_device = v.into();
        self
    }

    /// Sets the value of [guest_accelerators][crate::model::ComputeInstanceRestoreProperties::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeInstanceRestoreProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [instance_encryption_key][crate::model::ComputeInstanceRestoreProperties::instance_encryption_key].
    pub fn set_instance_encryption_key<
        T: std::convert::Into<std::option::Option<crate::model::CustomerEncryptionKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_encryption_key = v.into();
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::ComputeInstanceRestoreProperties::key_revocation_action_type].
    pub fn set_key_revocation_action_type<
        T: std::convert::Into<std::option::Option<crate::model::KeyRevocationActionType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_revocation_action_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeInstanceRestoreProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeInstanceRestoreProperties::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeInstanceRestoreProperties::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<crate::model::Metadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::ComputeInstanceRestoreProperties::min_cpu_platform].
    pub fn set_min_cpu_platform<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeInstanceRestoreProperties::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::ComputeInstanceRestoreProperties::network_performance_config].
    pub fn set_network_performance_config<
        T: std::convert::Into<std::option::Option<crate::model::NetworkPerformanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_performance_config = v.into();
        self
    }

    /// Sets the value of [params][crate::model::ComputeInstanceRestoreProperties::params].
    pub fn set_params<T: std::convert::Into<std::option::Option<crate::model::InstanceParams>>>(
        mut self,
        v: T,
    ) -> Self {
        self.params = v.into();
        self
    }

    /// Sets the value of [private_ipv6_google_access][crate::model::ComputeInstanceRestoreProperties::private_ipv6_google_access].
    pub fn set_private_ipv6_google_access<T: std::convert::Into<std::option::Option<crate::model::compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess>>>(mut self, v: T) -> Self{
        self.private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [allocation_affinity][crate::model::ComputeInstanceRestoreProperties::allocation_affinity].
    pub fn set_allocation_affinity<
        T: std::convert::Into<std::option::Option<crate::model::AllocationAffinity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.allocation_affinity = v.into();
        self
    }

    /// Sets the value of [resource_policies][crate::model::ComputeInstanceRestoreProperties::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::ComputeInstanceRestoreProperties::scheduling].
    pub fn set_scheduling<T: std::convert::Into<std::option::Option<crate::model::Scheduling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scheduling = v.into();
        self
    }

    /// Sets the value of [service_accounts][crate::model::ComputeInstanceRestoreProperties::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::ComputeInstanceRestoreProperties::tags].
    pub fn set_tags<T: std::convert::Into<std::option::Option<crate::model::Tags>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tags = v.into();
        self
    }
}

impl wkt::message::Message for ComputeInstanceRestoreProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceRestoreProperties"
    }
}

/// Defines additional types related to [ComputeInstanceRestoreProperties].
pub mod compute_instance_restore_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The private IPv6 google access type for the VMs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstancePrivateIpv6GoogleAccess {
        /// Default value. This value is unused.
        Unspecified,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its
        /// subnetwork.
        InheritFromSubnetwork,
        /// Outbound private IPv6 access from VMs in this subnet to Google services.
        /// If specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        EnableOutboundVmAccessToGoogle,
        /// Bidirectional private IPv6 access to/from Google services. If
        /// specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        EnableBidirectionalAccessToGoogle,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstancePrivateIpv6GoogleAccess::value] or
        /// [InstancePrivateIpv6GoogleAccess::name].
        UnknownValue(instance_private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstancePrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InheritFromSubnetwork => std::option::Option::Some(1),
                Self::EnableOutboundVmAccessToGoogle => std::option::Option::Some(2),
                Self::EnableBidirectionalAccessToGoogle => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::EnableOutboundVmAccessToGoogle => {
                    std::option::Option::Some("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::EnableBidirectionalAccessToGoogle => {
                    std::option::Option::Some("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstancePrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstancePrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstancePrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InheritFromSubnetwork,
                2 => Self::EnableOutboundVmAccessToGoogle,
                3 => Self::EnableBidirectionalAccessToGoogle,
                _ => Self::UnknownValue(instance_private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstancePrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => Self::Unspecified,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => Self::EnableOutboundVmAccessToGoogle,
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => Self::EnableBidirectionalAccessToGoogle,
                _ => Self::UnknownValue(instance_private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstancePrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InheritFromSubnetwork => serializer.serialize_i32(1),
                Self::EnableOutboundVmAccessToGoogle => serializer.serialize_i32(2),
                Self::EnableBidirectionalAccessToGoogle => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstancePrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstancePrivateIpv6GoogleAccess>::new(
                ".google.cloud.backupdr.v1.ComputeInstanceRestoreProperties.InstancePrivateIpv6GoogleAccess"))
        }
    }
}

/// ComputeInstanceTargetEnvironment represents Compute Engine target
/// environment to be used during restore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeInstanceTargetEnvironment {
    /// Required. Target project for the Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Required. The zone of the Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceTargetEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ComputeInstanceTargetEnvironment::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeInstanceTargetEnvironment::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }
}

impl wkt::message::Message for ComputeInstanceTargetEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceTargetEnvironment"
    }
}

/// ComputeInstanceDataSourceProperties represents the properties of a
/// ComputeEngine resource that are stored in the DataSource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeInstanceDataSourceProperties {
    /// Name of the compute instance backed up by the datasource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The description of the Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The machine type of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// The total number of disks attached to the Instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_disk_count: i64,

    /// The sum of all the disk sizes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_disk_size_gb: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeInstanceDataSourceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeInstanceDataSourceProperties::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ComputeInstanceDataSourceProperties::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeInstanceDataSourceProperties::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [total_disk_count][crate::model::ComputeInstanceDataSourceProperties::total_disk_count].
    pub fn set_total_disk_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_disk_count = v.into();
        self
    }

    /// Sets the value of [total_disk_size_gb][crate::model::ComputeInstanceDataSourceProperties::total_disk_size_gb].
    pub fn set_total_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_disk_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for ComputeInstanceDataSourceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ComputeInstanceDataSourceProperties"
    }
}

/// Specifies options for controlling advanced machine features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// Optional. Whether to enable nested virtualization or not (default is
    /// false).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_nested_virtualization: std::option::Option<bool>,

    /// Optional. The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number
    /// of threads supported per core by the underlying processor is
    /// assumed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub threads_per_core: std::option::Option<i32>,

    /// Optional. The number of physical cores to expose to an instance. Multiply
    /// by the number of threads per core to compute the total number of virtual
    /// CPUs to expose to the instance. If unset, the number of cores is
    /// inferred from the instance's nominal CPU count and the underlying
    /// platform's SMT width.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub visible_core_count: std::option::Option<i32>,

    /// Optional. Whether to enable UEFI networking for instance creation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_uefi_networking: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_enable_nested_virtualization<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_nested_virtualization = v.into();
        self
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.threads_per_core = v.into();
        self
    }

    /// Sets the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_visible_core_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.visible_core_count = v.into();
        self
    }

    /// Sets the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_enable_uefi_networking<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_uefi_networking = v.into();
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AdvancedMachineFeatures"
    }
}

/// A set of Confidential Instance options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfidentialInstanceConfig {
    /// Optional. Defines whether the instance should have confidential compute
    /// enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_confidential_compute: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_confidential_compute = v.into();
        self
    }
}

impl wkt::message::Message for ConfidentialInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ConfidentialInstanceConfig"
    }
}

/// A set of Display Device options
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisplayDevice {
    /// Optional. Enables display for the Compute Engine VM
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_display: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisplayDevice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_enable_display<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_display = v.into();
        self
    }
}

impl wkt::message::Message for DisplayDevice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.DisplayDevice"
    }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// Optional. Full or partial URL of the accelerator type resource to attach to
    /// this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub accelerator_type: std::option::Option<std::string::String>,

    /// Optional. The number of the guest accelerator cards exposed to this
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub accelerator_count: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_count = v.into();
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AcceleratorConfig"
    }
}

/// A customer-supplied encryption key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerEncryptionKey {
    /// Optional. The service account being used for the encryption request for the
    /// given KMS key. If absent, the Compute Engine default service account is
    /// used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kms_key_service_account: std::option::Option<std::string::String>,

    /// The key to use for encryption.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub key: std::option::Option<crate::model::customer_encryption_key::Key>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerEncryptionKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_kms_key_service_account<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_service_account = v.into();
        self
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key].
    ///
    /// Note that all the setters affecting `key` are mutually
    /// exclusive.
    pub fn set_key<
        T: std::convert::Into<std::option::Option<crate::model::customer_encryption_key::Key>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key = v.into();
        self
    }

    /// The value of [key][crate::model::CustomerEncryptionKey::key]
    /// if it holds a `RawKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn raw_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key.as_ref().and_then(|v| match v {
            crate::model::customer_encryption_key::Key::RawKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key]
    /// to hold a `RawKey`.
    ///
    /// Note that all the setters affecting `key` are
    /// mutually exclusive.
    pub fn set_raw_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key =
            std::option::Option::Some(crate::model::customer_encryption_key::Key::RawKey(v.into()));
        self
    }

    /// The value of [key][crate::model::CustomerEncryptionKey::key]
    /// if it holds a `RsaEncryptedKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rsa_encrypted_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key.as_ref().and_then(|v| match v {
            crate::model::customer_encryption_key::Key::RsaEncryptedKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key]
    /// to hold a `RsaEncryptedKey`.
    ///
    /// Note that all the setters affecting `key` are
    /// mutually exclusive.
    pub fn set_rsa_encrypted_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key = std::option::Option::Some(
            crate::model::customer_encryption_key::Key::RsaEncryptedKey(v.into()),
        );
        self
    }

    /// The value of [key][crate::model::CustomerEncryptionKey::key]
    /// if it holds a `KmsKeyName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kms_key_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.key.as_ref().and_then(|v| match v {
            crate::model::customer_encryption_key::Key::KmsKeyName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [key][crate::model::CustomerEncryptionKey::key]
    /// to hold a `KmsKeyName`.
    ///
    /// Note that all the setters affecting `key` are
    /// mutually exclusive.
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = std::option::Option::Some(
            crate::model::customer_encryption_key::Key::KmsKeyName(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CustomerEncryptionKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.CustomerEncryptionKey"
    }
}

/// Defines additional types related to [CustomerEncryptionKey].
pub mod customer_encryption_key {
    #[allow(unused_imports)]
    use super::*;

    /// The key to use for encryption.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Key {
        /// Optional. Specifies a 256-bit customer-supplied
        /// encryption key.
        RawKey(std::string::String),
        /// Optional. RSA-wrapped 2048-bit
        /// customer-supplied encryption key to either encrypt or decrypt this
        /// resource.
        RsaEncryptedKey(std::string::String),
        /// Optional. The name of the encryption key that is stored in Google Cloud
        /// KMS.
        KmsKeyName(std::string::String),
    }
}

/// A key/value pair to be used for storing metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entry {
    /// Optional. Key for the metadata entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key: std::option::Option<std::string::String>,

    /// Optional. Value for the metadata entry. These are free-form strings, and
    /// only have meaning as interpreted by the image running in the instance. The
    /// only restriction placed on values is that their size must be less than
    /// or equal to 262144 bytes (256 KiB).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::Entry::key].
    pub fn set_key<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Entry::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Entry"
    }
}

/// A metadata key/value entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Metadata {
    /// Optional. Array of key/value pairs. The total size of all keys and values
    /// must be less than 512 KB.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Entry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::Metadata::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Metadata"
    }
}

/// A network interface resource attached to an instance.
/// s
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkInterface {
    /// Optional. URL of the VPC network resource for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<std::string::String>,

    /// Optional. The URL of the Subnetwork resource for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub subnetwork: std::option::Option<std::string::String>,

    /// Optional. An IPv4 internal IP address to assign to the instance for this
    /// network interface. If not specified by the user, an unused internal IP is
    /// assigned by the system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_address: std::option::Option<std::string::String>,

    /// Optional. An IPv6 internal network address for this network interface. To
    /// use a static internal IP address, it must be unused and in the same region
    /// as the instance's zone. If not specified, Google Cloud will automatically
    /// assign an internal IPv6 address from the instance's subnetwork.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ipv6_address: std::option::Option<std::string::String>,

    /// Optional. The prefix length of the primary internal IPv6 range.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub internal_ipv6_prefix_length: std::option::Option<i32>,

    /// Output only. [Output Only] The name of the network interface, which is
    /// generated by the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// Optional. An array of configurations for this interface. Currently, only
    /// one access config,ONE_TO_ONE_NAT is supported. If there are no
    /// accessConfigs specified, then this instance will have
    /// no external internet access.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// Optional. An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there
    /// is no ipv6AccessConfig specified, then this instance will
    /// have no external IPv6 Internet access.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ipv6_access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// Optional. An array of alias IP ranges for this network interface.
    /// You can only specify this field for network interfaces in VPC networks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alias_ip_ranges: std::vec::Vec<crate::model::AliasIpRange>,

    /// The stack type for this network interface.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stack_type: std::option::Option<crate::model::network_interface::StackType>,

    /// Optional. [Output Only] One of EXTERNAL, INTERNAL to indicate whether the
    /// IP can be accessed from the Internet. This field is always inherited from
    /// its subnetwork.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ipv6_access_type: std::option::Option<crate::model::network_interface::Ipv6AccessType>,

    /// Optional. The networking queue count that's specified by users for the
    /// network interface. Both Rx and Tx queues will be set to this number. It'll
    /// be empty if not specified by the users.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queue_count: std::option::Option<i32>,

    /// Optional. The type of vNIC to be used on this interface. This may be gVNIC
    /// or VirtioNet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nic_type: std::option::Option<crate::model::network_interface::NicType>,

    /// Optional. The URL of the network attachment that this interface should
    /// connect to in the following format:
    /// projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_attachment: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::NetworkInterface::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [ipv6_address][crate::model::NetworkInterface::ipv6_address].
    pub fn set_ipv6_address<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ipv6_address = v.into();
        self
    }

    /// Sets the value of [internal_ipv6_prefix_length][crate::model::NetworkInterface::internal_ipv6_prefix_length].
    pub fn set_internal_ipv6_prefix_length<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.internal_ipv6_prefix_length = v.into();
        self
    }

    /// Sets the value of [name][crate::model::NetworkInterface::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [access_configs][crate::model::NetworkInterface::access_configs].
    pub fn set_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ipv6_access_configs][crate::model::NetworkInterface::ipv6_access_configs].
    pub fn set_ipv6_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.ipv6_access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [alias_ip_ranges][crate::model::NetworkInterface::alias_ip_ranges].
    pub fn set_alias_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AliasIpRange>,
    {
        use std::iter::Iterator;
        self.alias_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_stack_type<
        T: std::convert::Into<std::option::Option<crate::model::network_interface::StackType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stack_type = v.into();
        self
    }

    /// Sets the value of [ipv6_access_type][crate::model::NetworkInterface::ipv6_access_type].
    pub fn set_ipv6_access_type<
        T: std::convert::Into<std::option::Option<crate::model::network_interface::Ipv6AccessType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ipv6_access_type = v.into();
        self
    }

    /// Sets the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_queue_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queue_count = v.into();
        self
    }

    /// Sets the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_nic_type<
        T: std::convert::Into<std::option::Option<crate::model::network_interface::NicType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.nic_type = v.into();
        self
    }

    /// Sets the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_network_attachment<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_attachment = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.NetworkInterface"
    }
}

/// Defines additional types related to [NetworkInterface].
pub mod network_interface {
    #[allow(unused_imports)]
    use super::*;

    /// Stack type for this network interface.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StackType {
        /// Default should be STACK_TYPE_UNSPECIFIED.
        Unspecified,
        /// The network interface will be assigned IPv4 address.
        Ipv4Only,
        /// The network interface can have both IPv4 and IPv6 addresses.
        Ipv4Ipv6,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StackType::value] or
        /// [StackType::name].
        UnknownValue(stack_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stack_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ipv4Only => std::option::Option::Some(1),
                Self::Ipv4Ipv6 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STACK_TYPE_UNSPECIFIED"),
                Self::Ipv4Only => std::option::Option::Some("IPV4_ONLY"),
                Self::Ipv4Ipv6 => std::option::Option::Some("IPV4_IPV6"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ipv4Only,
                2 => Self::Ipv4Ipv6,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STACK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IPV4_ONLY" => Self::Ipv4Only,
                "IPV4_IPV6" => Self::Ipv4Ipv6,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ipv4Only => serializer.serialize_i32(1),
                Self::Ipv4Ipv6 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StackType>::new(
                ".google.cloud.backupdr.v1.NetworkInterface.StackType",
            ))
        }
    }

    /// IPv6 access type for this network interface.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Ipv6AccessType {
        /// IPv6 access type not set. Means this network interface hasn't been
        /// turned on IPv6 yet.
        UnspecifiedIpv6AccessType,
        /// This network interface can have internal IPv6.
        Internal,
        /// This network interface can have external IPv6.
        External,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Ipv6AccessType::value] or
        /// [Ipv6AccessType::name].
        UnknownValue(ipv_6_access_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ipv_6_access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Ipv6AccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::UnspecifiedIpv6AccessType => std::option::Option::Some(0),
                Self::Internal => std::option::Option::Some(1),
                Self::External => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::UnspecifiedIpv6AccessType => {
                    std::option::Option::Some("UNSPECIFIED_IPV6_ACCESS_TYPE")
                }
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Ipv6AccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Ipv6AccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Ipv6AccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::UnspecifiedIpv6AccessType,
                1 => Self::Internal,
                2 => Self::External,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Ipv6AccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED_IPV6_ACCESS_TYPE" => Self::UnspecifiedIpv6AccessType,
                "INTERNAL" => Self::Internal,
                "EXTERNAL" => Self::External,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Ipv6AccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::UnspecifiedIpv6AccessType => serializer.serialize_i32(0),
                Self::Internal => serializer.serialize_i32(1),
                Self::External => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Ipv6AccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Ipv6AccessType>::new(
                ".google.cloud.backupdr.v1.NetworkInterface.Ipv6AccessType",
            ))
        }
    }

    /// Nic type for this network interface.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NicType {
        /// Default should be NIC_TYPE_UNSPECIFIED.
        Unspecified,
        /// VIRTIO
        VirtioNet,
        /// GVNIC
        Gvnic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NicType::value] or
        /// [NicType::name].
        UnknownValue(nic_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod nic_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NicType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtioNet => std::option::Option::Some(1),
                Self::Gvnic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NIC_TYPE_UNSPECIFIED"),
                Self::VirtioNet => std::option::Option::Some("VIRTIO_NET"),
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NicType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NicType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NicType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtioNet,
                2 => Self::Gvnic,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NicType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NIC_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VIRTIO_NET" => Self::VirtioNet,
                "GVNIC" => Self::Gvnic,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NicType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtioNet => serializer.serialize_i32(1),
                Self::Gvnic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NicType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NicType>::new(
                ".google.cloud.backupdr.v1.NetworkInterface.NicType",
            ))
        }
    }
}

/// Network performance configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkPerformanceConfig {
    /// Optional. The tier of the total egress bandwidth.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_egress_bandwidth_tier:
        std::option::Option<crate::model::network_performance_config::Tier>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPerformanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_total_egress_bandwidth_tier<
        T: std::convert::Into<std::option::Option<crate::model::network_performance_config::Tier>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.total_egress_bandwidth_tier = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPerformanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.NetworkPerformanceConfig"
    }
}

/// Defines additional types related to [NetworkPerformanceConfig].
pub mod network_performance_config {
    #[allow(unused_imports)]
    use super::*;

    /// Network performance tier.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tier {
        /// This value is unused.
        Unspecified,
        /// Default network performance config.
        Default,
        /// Tier 1 network performance config.
        _1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tier::value] or
        /// [Tier::name].
        UnknownValue(tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Tier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::_1 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::_1 => std::option::Option::Some("TIER_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Tier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::_1,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Tier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "TIER_1" => Self::_1,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::_1 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                ".google.cloud.backupdr.v1.NetworkPerformanceConfig.Tier",
            ))
        }
    }
}

/// An access configuration attached to an instance's network interface.
/// Only one access config per instance is supported.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessConfig {
    /// Optional. In accessConfigs (IPv4), the
    /// default and only option is ONE_TO_ONE_NAT. In
    /// ipv6AccessConfigs, the default and only option is
    /// DIRECT_IPV6.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::access_config::AccessType>,

    /// Optional. The name of this access configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// Optional. The external IP address of this access configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_ip: std::option::Option<std::string::String>,

    /// Optional. The external IPv6 address of this access configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_ipv6: std::option::Option<std::string::String>,

    /// Optional. The prefix length of the external IPv6 range.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_ipv6_prefix_length: std::option::Option<i32>,

    /// Optional. Specifies whether a public DNS 'PTR' record should be created to
    /// map the external IP address of the instance to a DNS domain name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub set_public_ptr: std::option::Option<bool>,

    /// Optional. The DNS domain name for the public PTR record.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub public_ptr_domain_name: std::option::Option<std::string::String>,

    /// Optional. This signifies the networking tier used for configuring this
    /// access
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_tier: std::option::Option<crate::model::access_config::NetworkTier>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::access_config::AccessType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AccessConfig::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::AccessConfig::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [external_ipv6][crate::model::AccessConfig::external_ipv6].
    pub fn set_external_ipv6<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_ipv6 = v.into();
        self
    }

    /// Sets the value of [external_ipv6_prefix_length][crate::model::AccessConfig::external_ipv6_prefix_length].
    pub fn set_external_ipv6_prefix_length<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_ipv6_prefix_length = v.into();
        self
    }

    /// Sets the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_set_public_ptr<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.set_public_ptr = v.into();
        self
    }

    /// Sets the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_public_ptr_domain_name<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.public_ptr_domain_name = v.into();
        self
    }

    /// Sets the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_network_tier<
        T: std::convert::Into<std::option::Option<crate::model::access_config::NetworkTier>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_tier = v.into();
        self
    }
}

impl wkt::message::Message for AccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AccessConfig"
    }
}

/// Defines additional types related to [AccessConfig].
pub mod access_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessType {
        /// Default value. This value is unused.
        Unspecified,
        /// ONE_TO_ONE_NAT
        OneToOneNat,
        /// Direct IPv6 access.
        DirectIpv6,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccessType::value] or
        /// [AccessType::name].
        UnknownValue(access_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OneToOneNat => std::option::Option::Some(1),
                Self::DirectIpv6 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCESS_TYPE_UNSPECIFIED"),
                Self::OneToOneNat => std::option::Option::Some("ONE_TO_ONE_NAT"),
                Self::DirectIpv6 => std::option::Option::Some("DIRECT_IPV6"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OneToOneNat,
                2 => Self::DirectIpv6,
                _ => Self::UnknownValue(access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCESS_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ONE_TO_ONE_NAT" => Self::OneToOneNat,
                "DIRECT_IPV6" => Self::DirectIpv6,
                _ => Self::UnknownValue(access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OneToOneNat => serializer.serialize_i32(1),
                Self::DirectIpv6 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessType>::new(
                ".google.cloud.backupdr.v1.AccessConfig.AccessType",
            ))
        }
    }

    /// Network tier property used by addresses, instances and forwarding rules.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkTier {
        /// Default value. This value is unused.
        Unspecified,
        /// High quality, Google-grade network tier, support for all networking
        /// products.
        Premium,
        /// Public internet quality, only limited support for other networking
        /// products.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkTier::value] or
        /// [NetworkTier::name].
        UnknownValue(network_tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Premium => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NETWORK_TIER_UNSPECIFIED"),
                Self::Premium => std::option::Option::Some("PREMIUM"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Premium,
                2 => Self::Standard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORK_TIER_UNSPECIFIED" => Self::Unspecified,
                "PREMIUM" => Self::Premium,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Premium => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkTier>::new(
                ".google.cloud.backupdr.v1.AccessConfig.NetworkTier",
            ))
        }
    }
}

/// An alias IP range attached to an instance's network interface.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AliasIpRange {
    /// Optional. The IP alias ranges to allocate for this interface.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_cidr_range: std::option::Option<std::string::String>,

    /// Optional. The name of a subnetwork secondary IP range from which to
    /// allocate an IP alias range. If not specified, the primary range of the
    /// subnetwork is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub subnetwork_range_name: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AliasIpRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_ip_cidr_range<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ip_cidr_range = v.into();
        self
    }

    /// Sets the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_subnetwork_range_name<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.subnetwork_range_name = v.into();
        self
    }
}

impl wkt::message::Message for AliasIpRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AliasIpRange"
    }
}

/// Additional instance params.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceParams {
    /// Optional. Resource manager tags to be bound to the instance.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_manager_tags][crate::model::InstanceParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InstanceParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.InstanceParams"
    }
}

/// Specifies the reservations that this instance can consume from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllocationAffinity {
    /// Optional. Specifies the type of reservation from which this instance can
    /// consume
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub consume_allocation_type: std::option::Option<crate::model::allocation_affinity::Type>,

    /// Optional. Corresponds to the label key of a reservation resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key: std::option::Option<std::string::String>,

    /// Optional. Corresponds to the label values of a reservation resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllocationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_allocation_type][crate::model::AllocationAffinity::consume_allocation_type].
    pub fn set_consume_allocation_type<
        T: std::convert::Into<std::option::Option<crate::model::allocation_affinity::Type>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consume_allocation_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::AllocationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::AllocationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AllocationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AllocationAffinity"
    }
}

/// Defines additional types related to [AllocationAffinity].
pub mod allocation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether to consume from a reservation or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This value is unused.
        Unspecified,
        /// Do not consume from any allocated capacity.
        NoReservation,
        /// Consume any allocation available.
        AnyReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.backupdr.v1.AllocationAffinity.Type",
            ))
        }
    }
}

/// Sets the scheduling options for an Instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Scheduling {
    /// Optional. Defines the maintenance behavior for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub on_host_maintenance: std::option::Option<crate::model::scheduling::OnHostMaintenance>,

    /// Optional. Specifies whether the instance should be automatically restarted
    /// if it is terminated by Compute Engine (not terminated by a user).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automatic_restart: std::option::Option<bool>,

    /// Optional. Defines whether the instance is preemptible.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preemptible: std::option::Option<bool>,

    /// Optional. A set of node affinity and anti-affinity configurations.
    /// Overrides reservationAffinity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_affinities: std::vec::Vec<crate::model::scheduling::NodeAffinity>,

    /// Optional. The minimum number of virtual CPUs this instance will consume
    /// when running on a sole-tenant node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_node_cpus: std::option::Option<i32>,

    /// Optional. Specifies the provisioning model of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provisioning_model: std::option::Option<crate::model::scheduling::ProvisioningModel>,

    /// Optional. Specifies the termination action for the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_termination_action:
        std::option::Option<crate::model::scheduling::InstanceTerminationAction>,

    /// Optional. Specifies the maximum amount of time a Local Ssd Vm should wait
    /// while recovery of the Local Ssd state is attempted. Its value should be in
    /// between 0 and 168 hours with hour granularity and the default value being 1
    /// hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub local_ssd_recovery_timeout: std::option::Option<crate::model::SchedulingDuration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Scheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<
        T: std::convert::Into<std::option::Option<crate::model::scheduling::OnHostMaintenance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.on_host_maintenance = v.into();
        self
    }

    /// Sets the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_automatic_restart<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.automatic_restart = v.into();
        self
    }

    /// Sets the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_preemptible<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.preemptible = v.into();
        self
    }

    /// Sets the value of [node_affinities][crate::model::Scheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::scheduling::NodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_min_node_cpus<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_node_cpus = v.into();
        self
    }

    /// Sets the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_provisioning_model<
        T: std::convert::Into<std::option::Option<crate::model::scheduling::ProvisioningModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_model = v.into();
        self
    }

    /// Sets the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_instance_termination_action<
        T: std::convert::Into<
                std::option::Option<crate::model::scheduling::InstanceTerminationAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_termination_action = v.into();
        self
    }

    /// Sets the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_local_ssd_recovery_timeout<
        T: std::convert::Into<std::option::Option<crate::model::SchedulingDuration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_ssd_recovery_timeout = v.into();
        self
    }
}

impl wkt::message::Message for Scheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Scheduling"
    }
}

/// Defines additional types related to [Scheduling].
pub mod scheduling {
    #[allow(unused_imports)]
    use super::*;

    /// Node Affinity: the configuration of desired nodes onto which this Instance
    /// could be scheduled.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NodeAffinity {
        /// Optional. Corresponds to the label key of Node resource.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub key: std::option::Option<std::string::String>,

        /// Optional. Defines the operation of node selection.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub operator: std::option::Option<crate::model::scheduling::node_affinity::Operator>,

        /// Optional. Corresponds to the label values of Node resource.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodeAffinity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::scheduling::NodeAffinity::key].
        pub fn set_key<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [operator][crate::model::scheduling::NodeAffinity::operator].
        pub fn set_operator<
            T: std::convert::Into<
                    std::option::Option<crate::model::scheduling::node_affinity::Operator>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operator = v.into();
            self
        }

        /// Sets the value of [values][crate::model::scheduling::NodeAffinity::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NodeAffinity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.backupdr.v1.Scheduling.NodeAffinity"
        }
    }

    /// Defines additional types related to [NodeAffinity].
    pub mod node_affinity {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the type of node selections.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operator {
            /// Default value. This value is unused.
            Unspecified,
            /// Requires Compute Engine to seek for matched nodes.
            In,
            /// Requires Compute Engine to avoid certain nodes.
            NotIn,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Operator::value] or
            /// [Operator::name].
            UnknownValue(operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Operator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::NotIn => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::NotIn => std::option::Option::Some("NOT_IN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Operator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Operator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Operator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Operator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "NOT_IN" => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Operator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::NotIn => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Operator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                    ".google.cloud.backupdr.v1.Scheduling.NodeAffinity.Operator",
                ))
            }
        }
    }

    /// Defines the maintenance behavior for this instance=
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// Default value. This value is unused.
        Unspecified,
        /// Tells Compute Engine to terminate and (optionally) restart the instance
        /// away from the maintenance activity.
        Terminate,
        /// Default, Allows Compute Engine to automatically migrate instances
        /// out of the way of maintenance events.
        Migrate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::Migrate => std::option::Option::Some(1000),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ON_HOST_MAINTENANCE_UNSPECIFIED"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Terminate,
                1000 => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Self::Unspecified,
                "TERMINATE" => Self::Terminate,
                "MIGRATE" => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Terminate => serializer.serialize_i32(1),
                Self::Migrate => serializer.serialize_i32(1000),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.backupdr.v1.Scheduling.OnHostMaintenance",
            ))
        }
    }

    /// Defines the provisioning model for an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProvisioningModel {
        /// Default value. This value is not used.
        Unspecified,
        /// Standard provisioning with user controlled runtime, no discounts.
        Standard,
        /// Heavily discounted, no guaranteed runtime.
        Spot,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProvisioningModel::value] or
        /// [ProvisioningModel::name].
        UnknownValue(provisioning_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provisioning_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProvisioningModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Spot => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVISIONING_MODEL_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProvisioningModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProvisioningModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProvisioningModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Spot,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProvisioningModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVISIONING_MODEL_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "SPOT" => Self::Spot,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProvisioningModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Spot => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProvisioningModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProvisioningModel>::new(
                ".google.cloud.backupdr.v1.Scheduling.ProvisioningModel",
            ))
        }
    }

    /// Defines the supported termination actions for an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceTerminationAction {
        /// Default value. This value is unused.
        Unspecified,
        /// Delete the VM.
        Delete,
        /// Stop the VM without storing in-memory content. default action.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceTerminationAction::value] or
        /// [InstanceTerminationAction::name].
        UnknownValue(instance_termination_action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_termination_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceTerminationAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Delete => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")
                }
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceTerminationAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceTerminationAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceTerminationAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Delete,
                2 => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceTerminationAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" => Self::Unspecified,
                "DELETE" => Self::Delete,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceTerminationAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Delete => serializer.serialize_i32(1),
                Self::Stop => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceTerminationAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<InstanceTerminationAction>::new(
                    ".google.cloud.backupdr.v1.Scheduling.InstanceTerminationAction",
                ),
            )
        }
    }
}

/// A SchedulingDuration represents a fixed-length span of time represented
/// as a count of seconds and fractions of seconds at nanosecond
/// resolution. It is independent of any calendar and concepts like "day"
/// or "month". Range is approximately 10,000 years.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SchedulingDuration {
    /// Optional. Span of time at a resolution of a second.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub seconds: std::option::Option<i64>,

    /// Optional. Span of time that's a fraction of a second at nanosecond
    /// resolution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nanos: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulingDuration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [seconds][crate::model::SchedulingDuration::seconds].
    pub fn set_seconds<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.seconds = v.into();
        self
    }

    /// Sets the value of [nanos][crate::model::SchedulingDuration::nanos].
    pub fn set_nanos<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.nanos = v.into();
        self
    }
}

impl wkt::message::Message for SchedulingDuration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.SchedulingDuration"
    }
}

/// A service account.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Optional. Email address of the service account.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub email: std::option::Option<std::string::String>,

    /// Optional. The list of scopes to be made available for this service account.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scopes: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.ServiceAccount"
    }
}

/// A set of instance tags.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tags {
    /// Optional. An array of tags. Each tag must be 1-63 characters long, and
    /// comply with RFC1035.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::Tags::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Tags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.Tags"
    }
}

/// An instance-attached disk resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedDisk {
    /// Optional. Specifies the parameters to initialize this disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initialize_params: std::option::Option<crate::model::attached_disk::InitializeParams>,

    /// Optional. This is used as an identifier for the disks. This is the unique
    /// name has to provided to modify disk parameters like disk_name and
    /// replica_zones (in case of RePDs)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub device_name: std::option::Option<std::string::String>,

    /// Optional. Type of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<std::string::String>,

    /// Specifies the type of the disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub disk_type_deprecated: std::option::Option<crate::model::attached_disk::DiskType>,

    /// Optional. The mode in which to attach this disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::attached_disk::DiskMode>,

    /// Optional. Specifies a valid partial or full URL to an existing Persistent
    /// Disk resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<std::string::String>,

    /// Optional. A zero-based index to this disk, where 0 is reserved for the
    /// boot disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub index: std::option::Option<i64>,

    /// Optional. Indicates that this is a boot disk. The virtual machine will use
    /// the first partition of the disk for its root filesystem.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub boot: std::option::Option<bool>,

    /// Optional. Specifies whether the disk will be auto-deleted when the instance
    /// is deleted (but not when the disk is detached from the instance).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auto_delete: std::option::Option<bool>,

    /// Optional. Any valid publicly visible licenses.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub license: std::vec::Vec<std::string::String>,

    /// Optional. Specifies the disk interface to use for attaching this disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_interface: std::option::Option<crate::model::attached_disk::DiskInterface>,

    /// Optional. A list of features to enable on the guest operating system.
    /// Applicable only for bootable images.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub guest_os_feature: std::vec::Vec<crate::model::GuestOsFeature>,

    /// Optional. Encrypts or decrypts a disk using a customer-supplied
    /// encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// Optional. The size of the disk in GB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub disk_size_gb: std::option::Option<i64>,

    /// Optional. Output only. The state of the disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub saved_state: std::option::Option<crate::model::attached_disk::DiskSavedState>,

    /// Optional. Output only. The URI of the disk type resource. For example:
    /// projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_type: std::option::Option<std::string::String>,

    /// Optional. Specifies the type of the disk.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::attached_disk::DiskType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_initialize_params<
        T: std::convert::Into<std::option::Option<crate::model::attached_disk::InitializeParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initialize_params = v.into();
        self
    }

    /// Sets the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_device_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.device_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_kind<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [disk_type_deprecated][crate::model::AttachedDisk::disk_type_deprecated].
    #[deprecated]
    pub fn set_disk_type_deprecated<
        T: std::convert::Into<std::option::Option<crate::model::attached_disk::DiskType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type_deprecated = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::attached_disk::DiskMode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [source][crate::model::AttachedDisk::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [index][crate::model::AttachedDisk::index].
    pub fn set_index<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_boot<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.boot = v.into();
        self
    }

    /// Sets the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_auto_delete<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.auto_delete = v.into();
        self
    }

    /// Sets the value of [license][crate::model::AttachedDisk::license].
    pub fn set_license<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.license = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_interface][crate::model::AttachedDisk::disk_interface].
    pub fn set_disk_interface<
        T: std::convert::Into<std::option::Option<crate::model::attached_disk::DiskInterface>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_interface = v.into();
        self
    }

    /// Sets the value of [guest_os_feature][crate::model::AttachedDisk::guest_os_feature].
    pub fn set_guest_os_feature<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestOsFeature>,
    {
        use std::iter::Iterator;
        self.guest_os_feature = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_disk_encryption_key<
        T: std::convert::Into<std::option::Option<crate::model::CustomerEncryptionKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disk_encryption_key = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_saved_state<
        T: std::convert::Into<std::option::Option<crate::model::attached_disk::DiskSavedState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.saved_state = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::AttachedDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::attached_disk::DiskType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for AttachedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.AttachedDisk"
    }
}

/// Defines additional types related to [AttachedDisk].
pub mod attached_disk {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the parameters to initialize this disk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InitializeParams {
        /// Optional. Specifies the disk name. If not specified, the default is to
        /// use the name of the instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub disk_name: std::option::Option<std::string::String>,

        /// Optional. URL of the zone where the disk should be created.
        /// Required for each regional disk associated with the instance.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub replica_zones: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InitializeParams {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_name][crate::model::attached_disk::InitializeParams::disk_name].
        pub fn set_disk_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.disk_name = v.into();
            self
        }

        /// Sets the value of [replica_zones][crate::model::attached_disk::InitializeParams::replica_zones].
        pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.replica_zones = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InitializeParams {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.backupdr.v1.AttachedDisk.InitializeParams"
        }
    }

    /// List of the Disk Types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskType {
        /// Default value, which is unused.
        Unspecified,
        /// A scratch disk type.
        Scratch,
        /// A persistent disk type.
        Persistent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskType::value] or
        /// [DiskType::name].
        UnknownValue(disk_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scratch => std::option::Option::Some(1),
                Self::Persistent => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_TYPE_UNSPECIFIED"),
                Self::Scratch => std::option::Option::Some("SCRATCH"),
                Self::Persistent => std::option::Option::Some("PERSISTENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scratch,
                2 => Self::Persistent,
                _ => Self::UnknownValue(disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCRATCH" => Self::Scratch,
                "PERSISTENT" => Self::Persistent,
                _ => Self::UnknownValue(disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scratch => serializer.serialize_i32(1),
                Self::Persistent => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskType>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskType",
            ))
        }
    }

    /// List of the Disk Modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskMode {
        /// Default value, which is unused.
        Unspecified,
        /// Attaches this disk in read-write mode. Only one
        /// virtual machine at a time can be attached to a disk in read-write mode.
        ReadWrite,
        /// Attaches this disk in read-only mode. Multiple virtual machines can use
        /// a disk in read-only mode at a time.
        ReadOnly,
        /// The disk is locked for administrative reasons. Nobody else
        /// can use the disk. This mode is used (for example) when taking
        /// a snapshot of a disk to prevent mounting the disk while it is
        /// being snapshotted.
        Locked,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskMode::value] or
        /// [DiskMode::name].
        UnknownValue(disk_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::ReadOnly => std::option::Option::Some(2),
                Self::Locked => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_MODE_UNSPECIFIED"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::Locked => std::option::Option::Some("LOCKED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ReadWrite,
                2 => Self::ReadOnly,
                3 => Self::Locked,
                _ => Self::UnknownValue(disk_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_MODE_UNSPECIFIED" => Self::Unspecified,
                "READ_WRITE" => Self::ReadWrite,
                "READ_ONLY" => Self::ReadOnly,
                "LOCKED" => Self::Locked,
                _ => Self::UnknownValue(disk_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ReadWrite => serializer.serialize_i32(1),
                Self::ReadOnly => serializer.serialize_i32(2),
                Self::Locked => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskMode>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskMode",
            ))
        }
    }

    /// List of the Disk Interfaces.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskInterface {
        /// Default value, which is unused.
        Unspecified,
        /// SCSI Disk Interface.
        Scsi,
        /// NVME Disk Interface.
        Nvme,
        /// NVDIMM Disk Interface.
        Nvdimm,
        /// ISCSI Disk Interface.
        Iscsi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskInterface::value] or
        /// [DiskInterface::name].
        UnknownValue(disk_interface::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_interface {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskInterface {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scsi => std::option::Option::Some(1),
                Self::Nvme => std::option::Option::Some(2),
                Self::Nvdimm => std::option::Option::Some(3),
                Self::Iscsi => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_INTERFACE_UNSPECIFIED"),
                Self::Scsi => std::option::Option::Some("SCSI"),
                Self::Nvme => std::option::Option::Some("NVME"),
                Self::Nvdimm => std::option::Option::Some("NVDIMM"),
                Self::Iscsi => std::option::Option::Some("ISCSI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskInterface {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskInterface {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskInterface {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scsi,
                2 => Self::Nvme,
                3 => Self::Nvdimm,
                4 => Self::Iscsi,
                _ => Self::UnknownValue(disk_interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskInterface {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_INTERFACE_UNSPECIFIED" => Self::Unspecified,
                "SCSI" => Self::Scsi,
                "NVME" => Self::Nvme,
                "NVDIMM" => Self::Nvdimm,
                "ISCSI" => Self::Iscsi,
                _ => Self::UnknownValue(disk_interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskInterface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scsi => serializer.serialize_i32(1),
                Self::Nvme => serializer.serialize_i32(2),
                Self::Nvdimm => serializer.serialize_i32(3),
                Self::Iscsi => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskInterface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskInterface>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskInterface",
            ))
        }
    }

    /// List of the states of the Disk.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiskSavedState {
        /// Default Disk state has not been preserved.
        Unspecified,
        /// Disk state has been preserved.
        Preserved,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiskSavedState::value] or
        /// [DiskSavedState::name].
        UnknownValue(disk_saved_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod disk_saved_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiskSavedState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Preserved => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISK_SAVED_STATE_UNSPECIFIED"),
                Self::Preserved => std::option::Option::Some("PRESERVED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiskSavedState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiskSavedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiskSavedState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Preserved,
                _ => Self::UnknownValue(disk_saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiskSavedState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_SAVED_STATE_UNSPECIFIED" => Self::Unspecified,
                "PRESERVED" => Self::Preserved,
                _ => Self::UnknownValue(disk_saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiskSavedState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Preserved => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiskSavedState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskSavedState>::new(
                ".google.cloud.backupdr.v1.AttachedDisk.DiskSavedState",
            ))
        }
    }
}

/// Feature type of the Guest OS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GuestOsFeature {
    /// The ID of a supported feature.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::guest_os_feature::FeatureType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GuestOsFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::guest_os_feature::FeatureType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for GuestOsFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.backupdr.v1.GuestOsFeature"
    }
}

/// Defines additional types related to [GuestOsFeature].
pub mod guest_os_feature {
    #[allow(unused_imports)]
    use super::*;

    /// List of the Feature Types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FeatureType {
        /// Default value, which is unused.
        Unspecified,
        /// VIRTIO_SCSI_MULTIQUEUE feature type.
        VirtioScsiMultiqueue,
        /// WINDOWS feature type.
        Windows,
        /// MULTI_IP_SUBNET feature type.
        MultiIpSubnet,
        /// UEFI_COMPATIBLE feature type.
        UefiCompatible,
        /// SECURE_BOOT feature type.
        SecureBoot,
        /// GVNIC feature type.
        Gvnic,
        /// SEV_CAPABLE feature type.
        SevCapable,
        /// BARE_METAL_LINUX_COMPATIBLE feature type.
        BareMetalLinuxCompatible,
        /// SUSPEND_RESUME_COMPATIBLE feature type.
        SuspendResumeCompatible,
        /// SEV_LIVE_MIGRATABLE feature type.
        SevLiveMigratable,
        /// SEV_SNP_CAPABLE feature type.
        SevSnpCapable,
        /// TDX_CAPABLE feature type.
        TdxCapable,
        /// IDPF feature type.
        Idpf,
        /// SEV_LIVE_MIGRATABLE_V2 feature type.
        SevLiveMigratableV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FeatureType::value] or
        /// [FeatureType::name].
        UnknownValue(feature_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod feature_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FeatureType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtioScsiMultiqueue => std::option::Option::Some(1),
                Self::Windows => std::option::Option::Some(2),
                Self::MultiIpSubnet => std::option::Option::Some(3),
                Self::UefiCompatible => std::option::Option::Some(4),
                Self::SecureBoot => std::option::Option::Some(5),
                Self::Gvnic => std::option::Option::Some(6),
                Self::SevCapable => std::option::Option::Some(7),
                Self::BareMetalLinuxCompatible => std::option::Option::Some(8),
                Self::SuspendResumeCompatible => std::option::Option::Some(9),
                Self::SevLiveMigratable => std::option::Option::Some(10),
                Self::SevSnpCapable => std::option::Option::Some(11),
                Self::TdxCapable => std::option::Option::Some(12),
                Self::Idpf => std::option::Option::Some(13),
                Self::SevLiveMigratableV2 => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FEATURE_TYPE_UNSPECIFIED"),
                Self::VirtioScsiMultiqueue => std::option::Option::Some("VIRTIO_SCSI_MULTIQUEUE"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::MultiIpSubnet => std::option::Option::Some("MULTI_IP_SUBNET"),
                Self::UefiCompatible => std::option::Option::Some("UEFI_COMPATIBLE"),
                Self::SecureBoot => std::option::Option::Some("SECURE_BOOT"),
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::SevCapable => std::option::Option::Some("SEV_CAPABLE"),
                Self::BareMetalLinuxCompatible => {
                    std::option::Option::Some("BARE_METAL_LINUX_COMPATIBLE")
                }
                Self::SuspendResumeCompatible => {
                    std::option::Option::Some("SUSPEND_RESUME_COMPATIBLE")
                }
                Self::SevLiveMigratable => std::option::Option::Some("SEV_LIVE_MIGRATABLE"),
                Self::SevSnpCapable => std::option::Option::Some("SEV_SNP_CAPABLE"),
                Self::TdxCapable => std::option::Option::Some("TDX_CAPABLE"),
                Self::Idpf => std::option::Option::Some("IDPF"),
                Self::SevLiveMigratableV2 => std::option::Option::Some("SEV_LIVE_MIGRATABLE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FeatureType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FeatureType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FeatureType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtioScsiMultiqueue,
                2 => Self::Windows,
                3 => Self::MultiIpSubnet,
                4 => Self::UefiCompatible,
                5 => Self::SecureBoot,
                6 => Self::Gvnic,
                7 => Self::SevCapable,
                8 => Self::BareMetalLinuxCompatible,
                9 => Self::SuspendResumeCompatible,
                10 => Self::SevLiveMigratable,
                11 => Self::SevSnpCapable,
                12 => Self::TdxCapable,
                13 => Self::Idpf,
                14 => Self::SevLiveMigratableV2,
                _ => Self::UnknownValue(feature_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FeatureType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FEATURE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VIRTIO_SCSI_MULTIQUEUE" => Self::VirtioScsiMultiqueue,
                "WINDOWS" => Self::Windows,
                "MULTI_IP_SUBNET" => Self::MultiIpSubnet,
                "UEFI_COMPATIBLE" => Self::UefiCompatible,
                "SECURE_BOOT" => Self::SecureBoot,
                "GVNIC" => Self::Gvnic,
                "SEV_CAPABLE" => Self::SevCapable,
                "BARE_METAL_LINUX_COMPATIBLE" => Self::BareMetalLinuxCompatible,
                "SUSPEND_RESUME_COMPATIBLE" => Self::SuspendResumeCompatible,
                "SEV_LIVE_MIGRATABLE" => Self::SevLiveMigratable,
                "SEV_SNP_CAPABLE" => Self::SevSnpCapable,
                "TDX_CAPABLE" => Self::TdxCapable,
                "IDPF" => Self::Idpf,
                "SEV_LIVE_MIGRATABLE_V2" => Self::SevLiveMigratableV2,
                _ => Self::UnknownValue(feature_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FeatureType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtioScsiMultiqueue => serializer.serialize_i32(1),
                Self::Windows => serializer.serialize_i32(2),
                Self::MultiIpSubnet => serializer.serialize_i32(3),
                Self::UefiCompatible => serializer.serialize_i32(4),
                Self::SecureBoot => serializer.serialize_i32(5),
                Self::Gvnic => serializer.serialize_i32(6),
                Self::SevCapable => serializer.serialize_i32(7),
                Self::BareMetalLinuxCompatible => serializer.serialize_i32(8),
                Self::SuspendResumeCompatible => serializer.serialize_i32(9),
                Self::SevLiveMigratable => serializer.serialize_i32(10),
                Self::SevSnpCapable => serializer.serialize_i32(11),
                Self::TdxCapable => serializer.serialize_i32(12),
                Self::Idpf => serializer.serialize_i32(13),
                Self::SevLiveMigratableV2 => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FeatureType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FeatureType>::new(
                ".google.cloud.backupdr.v1.GuestOsFeature.FeatureType",
            ))
        }
    }
}

/// Backup configuration state. Is the resource configured for backup?
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackupConfigState {
    /// The possible states of backup configuration.
    /// Status not set.
    Unspecified,
    /// The data source is actively protected (i.e. there is a
    /// BackupPlanAssociation or Appliance SLA pointing to it)
    Active,
    /// The data source is no longer protected (but may have backups under it)
    Passive,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackupConfigState::value] or
    /// [BackupConfigState::name].
    UnknownValue(backup_config_state::UnknownValue),
}

#[doc(hidden)]
pub mod backup_config_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackupConfigState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::Passive => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKUP_CONFIG_STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::Passive => std::option::Option::Some("PASSIVE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackupConfigState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackupConfigState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackupConfigState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::Passive,
            _ => Self::UnknownValue(backup_config_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackupConfigState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKUP_CONFIG_STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "PASSIVE" => Self::Passive,
            _ => Self::UnknownValue(backup_config_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackupConfigState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::Passive => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackupConfigState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupConfigState>::new(
            ".google.cloud.backupdr.v1.BackupConfigState",
        ))
    }
}

/// BackupView contains enum options for Partial and Full view.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackupView {
    /// If the value is not set, the default 'FULL' view is used.
    Unspecified,
    /// Includes basic data about the Backup, but not the full contents.
    Basic,
    /// Includes all data about the Backup.
    /// This is the default value (for both ListBackups and GetBackup).
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackupView::value] or
    /// [BackupView::name].
    UnknownValue(backup_view::UnknownValue),
}

#[doc(hidden)]
pub mod backup_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackupView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKUP_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BACKUP_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("BACKUP_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackupView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackupView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackupView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(backup_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackupView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKUP_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BACKUP_VIEW_BASIC" => Self::Basic,
            "BACKUP_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(backup_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackupView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackupView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupView>::new(
            ".google.cloud.backupdr.v1.BackupView",
        ))
    }
}

/// BackupVaultView contains enum options for Partial and Full view.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackupVaultView {
    /// If the value is not set, the default 'FULL' view is used.
    Unspecified,
    /// Includes basic data about the Backup Vault, but not the full contents.
    Basic,
    /// Includes all data about the Backup Vault.
    /// This is the default value (for both ListBackupVaults and GetBackupVault).
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackupVaultView::value] or
    /// [BackupVaultView::name].
    UnknownValue(backup_vault_view::UnknownValue),
}

#[doc(hidden)]
pub mod backup_vault_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackupVaultView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKUP_VAULT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BACKUP_VAULT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("BACKUP_VAULT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackupVaultView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackupVaultView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackupVaultView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(backup_vault_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackupVaultView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKUP_VAULT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BACKUP_VAULT_VIEW_BASIC" => Self::Basic,
            "BACKUP_VAULT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(backup_vault_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackupVaultView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackupVaultView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupVaultView>::new(
            ".google.cloud.backupdr.v1.BackupVaultView",
        ))
    }
}

/// Specifies whether the virtual machine instance will be shut down on key
/// revocation. It is currently used in instance, instance properties and GMI
/// protos
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum KeyRevocationActionType {
    /// Default value. This value is unused.
    Unspecified,
    /// Indicates user chose no operation.
    None,
    /// Indicates user chose to opt for VM shutdown on key revocation.
    Stop,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [KeyRevocationActionType::value] or
    /// [KeyRevocationActionType::name].
    UnknownValue(key_revocation_action_type::UnknownValue),
}

#[doc(hidden)]
pub mod key_revocation_action_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl KeyRevocationActionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::None => std::option::Option::Some(1),
            Self::Stop => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
            }
            Self::None => std::option::Option::Some("NONE"),
            Self::Stop => std::option::Option::Some("STOP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for KeyRevocationActionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for KeyRevocationActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for KeyRevocationActionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::None,
            2 => Self::Stop,
            _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for KeyRevocationActionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NONE" => Self::None,
            "STOP" => Self::Stop,
            _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for KeyRevocationActionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::None => serializer.serialize_i32(1),
            Self::Stop => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for KeyRevocationActionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<KeyRevocationActionType>::new(
            ".google.cloud.backupdr.v1.KeyRevocationActionType",
        ))
    }
}
